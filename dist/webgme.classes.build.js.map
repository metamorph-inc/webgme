{
  "version": 3,
  "file": "webgme.classes.build.js",
  "sources": [
    "client/lib/debug/debug.js",
    "client/js/logger.js",
    "common/storage/constants.js",
    "common/storage/storageclasses/watchers.js",
    "common/storage/storageclasses/simpleapi.js",
    "common/storage/storageclasses/objectloaders.js",
    "common/util/assert.js",
    "common/storage/project/cache.js",
    "common/storage/project/interface.js",
    "common/storage/project/branch.js",
    "client/lib/q/q.js",
    "common/storage/project/project.js",
    "common/util/sha1.js",
    "common/util/canon.js",
    "common/util/key.js",
    "common/storage/storageclasses/editorstorage.js",
    "common/storage/socketio/browserclient.js",
    "common/EventDispatcher.js",
    "common/storage/socketio/websocket.js",
    "common/storage/browserstorage.js",
    "common/core/tasync.js",
    "common/core/coretree.js",
    "common/core/corerel.js",
    "common/core/setcore.js",
    "common/util/guid.js",
    "common/regexp.js",
    "common/core/guidcore.js",
    "common/core/nullpointercore.js",
    "common/core/coreunwrap.js",
    "common/core/coretype.js",
    "common/core/constraintcore.js",
    "common/core/metacore.js",
    "common/core/coretreeloader.js",
    "common/core/corediff.js",
    "common/core/metacachecore.js",
    "common/core/core.js",
    "client/js/client/constants.js",
    "common/core/users/meta.js",
    "common/util/url.js",
    "client/js/RegistryKeys.js",
    "client/js/client/gmeNodeGetter.js",
    "client/js/client/gmeNodeSetter.js",
    "common/core/users/serialization.js",
    "common/blob/BlobConfig.js",
    "common/blob/BlobMetadata.js",
    "common/blob/Artifact.js",
    "client/lib/superagent/superagent.js",
    "common/blob/BlobClient.js",
    "client/js/client.js",
    "common/executor/ExecutorClient.js",
    "plugin/PluginConfig.js",
    "plugin/PluginNodeDescription.js",
    "plugin/PluginMessage.js",
    "plugin/PluginResult.js",
    "plugin/PluginBase.js",
    "plugin/PluginContext.js",
    "common/storage/util.js",
    "plugin/PluginManagerBase.js",
    "../utils/build/empty/empty.js",
    "client/js/Utils/InterpreterManager.js",
    "../teststorage/teststorage.js",
    "../utils/build/webgme.classes/webgme.classes.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxfA,ADyfA;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA,AD+HA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnNA,ADoNA;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA,AD2BA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrOA,ADsOA;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpOA,ADqOA;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjgEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnFA;AACA;AACA;AACA;AACA;AACA;ACLA,ADMA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA,ADuCA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3sBA,AD4sBA;AC3sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA,ADqCA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvOA,ADwOA;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA,AD8CA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjvBA,ADkvBA;ACjvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5+BA,AD6+BA;AC5+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACx2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA,ADqBA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA,AD8DA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA,ADwFA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACr1BA,ADs1BA;ACr1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpkBA,ADqkBA;ACpkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA,ADyDA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9xEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzWA,AD0WA;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACl5CA,ADm5CA;ACl5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA,ADwCA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACxWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACt5BA,ADu5BA;ACt5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA,ADkGA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3SA,AD4SA;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzWA,AD0WA;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACp7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA,ADoDA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtNA,ADuNA;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9BA,AD+BA;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvUA,ADwUA;ACvUA;AACA;AACA;AACA;AACA,ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,Ab3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AcpzCA,AdqzCA;AcpzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nwindow.debug = exports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Use chrome.storage.local if we are in an app\n */\n\nvar storage;\n\nif (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')\n  storage = chrome.storage.local;\nelse\n  storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      storage.removeItem('debug');\n    } else {\n      storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n},{\"./debug\":2}],2:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":3}],3:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}]},{},[1]);\n\ndefine(\"debug\", function(){});\n\n",
    "/*globals define, debug*/\n/*jshint node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/logger',['debug'], function (_debug) {\n    'use strict';\n    // Separate namespaces using ',' a leading '-' will disable the namespace.\n    // Each part takes a regex.\n    //      ex: localStorage.debug = '*,-socket\\.io*,-engine\\.io*'\n    //      will log all but socket.io and engine.io\n    function createLogger(name, options) {\n        var log = typeof debug === 'undefined' ? _debug(name) : debug(name),\n            level,\n            levels = {\n                silly: 0,\n                input: 1,\n                verbose: 2,\n                prompt: 3,\n                debug: 4,\n                info: 5,\n                data: 6,\n                help: 7,\n                warn: 8,\n                error: 9\n            };\n        if (!options) {\n            throw new Error('options required in logger');\n        }\n        if (options.hasOwnProperty('level') === false) {\n            throw new Error('options.level required in logger');\n        }\n        level = levels[options.level];\n        if (typeof level === 'undefined') {\n            level = levels.info;\n        }\n\n        log.debug = function () {\n            if (log.enabled && level <= levels.debug) {\n                if (console.debug) {\n                    log.log = console.debug.bind(console);\n                } else {\n                    log.log = console.log.bind(console);\n                }\n                log.apply(this, arguments);\n            }\n        };\n        log.info = function () {\n            if (log.enabled && level <= levels.info) {\n                log.log = console.info.bind(console);\n                log.apply(this, arguments);\n            }\n        };\n        log.warn = function () {\n            if (log.enabled && level <= levels.warn) {\n                log.log = console.warn.bind(console);\n                log.apply(this, arguments);\n            }\n        };\n        log.error = function () {\n            if (log.enabled && level <= levels.error) {\n                log.log = console.error.bind(console);\n                log.apply(this, arguments);\n            } else {\n                console.error.apply(console, arguments);\n            }\n        };\n\n        log.fork = function (forkName, useForkName) {\n            forkName = useForkName ? forkName : name + ':' + forkName;\n            return createLogger(forkName, options);\n        };\n\n        log.forkWithOptions = function (_name, _options) {\n            return createLogger(_name, _options);\n        };\n\n        return log;\n    }\n\n    function createWithGmeConfig(name, gmeConfig) {\n        return createLogger(name, gmeConfig.client.log);\n    }\n\n    return {\n        create: createLogger,\n        createWithGmeConfig: createWithGmeConfig\n    };\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n * @module Storage\n */\n\n/**\n * @typedef {string} CommitHash - Unique SHA-1 hash for commit object.\n * @example\n * '#5496cf226542fcceccf89056f0d27564abc88c99'\n */\n\n/**\n * @typedef {object} CommitResult\n * @prop {module:Storage~CommitHash} hash - The commitHash for the commit.\n * @prop {string} status - 'SYNCED', 'FORKED', 'CANCELED', undefined\n *\n * @example\n * {\n *   status: 'SYNCED',\n *   hash: '#someHash'\n * }\n * @example\n * {\n         *   hash: '<hash from makeCommit with no branch provided>'\n         * }\n */\n\n/**\n * @typedef {object} CommitObject\n * @prop {module:Storage~CommitHash} _id - Hash of the commit object, a.k.a commitHash.\n * @prop {module:Core~ObjectHash} root - Hash of the associated root object, a.k.a. rootHash.\n * @prop {module:Storage~CommitHash[]} parents - Commits from where this commit evolved.\n * @prop {number} time - When the commit object was created (new Date()).getTime().\n * @prop {string} message - Commit message.\n * @prop {string[]} updater - Commit message.\n * @prop {string} type - 'commit'\n *\n * @example\n * {\n *   _id: '#5496cf226542fcceccf89056f0d27564abc88c99',\n *   root: '#04009ecd1e68117cd3e9d39c87aadd9ed1ee5cb3',\n *   parents: ['#87d9fd309ec6a5d84776d7731ce1f1ab2790aac2']\n *   updater: ['guest'],\n *   time: 1430169614741,\n *   message: \"createChildren({\\\"/1008889918/1998840078\\\":\\\"/1182870936/737997118/1736829087/1966323860\\\"})\",\n *   type: 'commit'\n *}\n */\ndefine('common/storage/constants',[], function () {\n    'use strict';\n\n    return {\n        // Database related\n        MONGO_ID: '_id',\n        PROJECT_INFO_ID: '*info*',\n        EMPTY_PROJECT_DATA: 'empty',\n        PROJECT_ID_SEP: '+',\n        PROJECT_DISPLAYED_NAME_SEP: '/',\n\n        // Socket IO\n        DATABASE_ROOM: 'database',\n        ROOM_DIVIDER: '%',\n        CONNECTED: 'CONNECTED',\n        DISCONNECTED: 'DISCONNECTED',\n        RECONNECTED: 'RECONNECTED',\n\n        // Branch commit status - this is the status returned after setting the hash of a branch\n        SYNCED: 'SYNCED', // The commitData was inserted in the database and the branchHash updated.\n        FORKED: 'FORKED', // The commitData was inserted in the database, but the branchHash NOT updated.\n        CANCELED: 'CANCELED', // The commitData was never inserted to the database.\n        MERGED: 'MERGED', // This is currently not used\n\n        BRANCH_STATUS: {\n            SYNC: 'SYNC',\n            AHEAD_SYNC: 'AHEAD_SYNC',\n            AHEAD_NOT_SYNC: 'AHEAD_NOT_SYNC',\n            PULLING: 'PULLING'\n        },\n\n        // Events\n        PROJECT_DELETED: 'PROJECT_DELETED',\n        PROJECT_CREATED: 'PROJECT_CREATED',\n\n        BRANCH_DELETED: 'BRANCH_DELETED',\n        BRANCH_CREATED: 'BRANCH_CREATED',\n        BRANCH_HASH_UPDATED: 'BRANCH_HASH_UPDATED',\n\n        BRANCH_UPDATED: 'BRANCH_UPDATED',\n\n        BRANCH_ROOM_SOCKETS: 'BRANCH_ROOM_SOCKETS'\n    };\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * Provides watching-functionality of the database and specific projects.\n * Keeps a state of the registered watchers.\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/watchers',['common/storage/constants'], function (CONSTANTS) {\n    'use strict';\n\n    function StorageWatcher(webSocket, logger, gmeConfig) {\n        // watcher counters determining when to join/leave a room on the sever\n        this.watchers = {\n            database: 0,\n            projects: {}\n        };\n        this.webSocket = webSocket;\n        this.logger = this.logger || logger.fork('storage');\n        this.gmeConfig = gmeConfig;\n        this.logger.debug('StorageWatcher ctor');\n        this.connected = false;\n    }\n\n    StorageWatcher.prototype.watchDatabase = function (eventHandler, callback) {\n        this.logger.debug('watchDatabase - handler added');\n        this.webSocket.addEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);\n        this.webSocket.addEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);\n        this.watchers.database += 1;\n        this.logger.debug('Nbr of database watchers:', this.watchers.database);\n        if (this.watchers.database === 1) {\n            this.logger.debug('First watcher will enter database room.');\n            this.webSocket.watchDatabase({join: true}, callback);\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype.unwatchDatabase = function (eventHandler, callback) {\n        this.logger.debug('unwatchDatabase - handler will be removed');\n        this.logger.debug('Nbr of database watchers (before removal):', this.watchers.database);\n        this.webSocket.removeEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);\n        this.webSocket.removeEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);\n        this.watchers.database -= 1;\n        if (this.watchers.database === 0) {\n            this.logger.debug('No more watchers will exit database room.');\n            if (this.connected) {\n                this.webSocket.watchDatabase({join: false}, callback);\n            } else {\n                callback(null);\n            }\n        } else if (this.watchers.database < 0) {\n            this.logger.error('Number of database watchers became negative!');\n            callback(new Error('Number of database watchers became negative!'));\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype.watchProject = function (projectId, eventHandler, callback) {\n        this.logger.debug('watchProject - handler added for project', projectId);\n        this.webSocket.addEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);\n        this.webSocket.addEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);\n        this.webSocket.addEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);\n\n        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?\n        this.watchers.projects[projectId] + 1 : 1;\n        this.logger.debug('Nbr of watchers for project:', projectId, this.watchers.projects[projectId]);\n        if (this.watchers.projects[projectId] === 1) {\n            this.logger.debug('First watcher will enter project room:', projectId);\n            this.webSocket.watchProject({projectId: projectId, join: true}, callback);\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype.unwatchProject = function (projectId, eventHandler, callback) {\n        this.logger.debug('unwatchProject - handler will be removed', projectId);\n        this.logger.debug('Nbr of database watchers (before removal):', projectId,\n            this.watchers.projects[projectId]);\n        this.webSocket.removeEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);\n        this.webSocket.removeEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);\n        this.webSocket.removeEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);\n\n        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?\n        this.watchers.projects[projectId] - 1 : -1;\n        if (this.watchers.projects[projectId] === 0) {\n            this.logger.debug('No more watchers will exit project room:', projectId);\n            delete this.watchers.projects[projectId];\n            if (this.connected) {\n                this.webSocket.watchProject({projectId: projectId, join: false}, callback);\n            } else {\n                callback(null);\n            }\n        } else if (this.watchers.projects[projectId] < 0) {\n            this.logger.error('Number of project watchers became negative!:', projectId);\n            callback(new Error('Number of project watchers became negative!'));\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype._rejoinWatcherRooms = function () {\n        var self = this,\n            projectId,\n            callback = function (err) {\n                //TODO: Add a callback here too.\n                if (err) {\n                    self.logger.error('problems rejoining watcher rooms', err);\n                }\n            };\n        this.logger.debug('rejoinWatcherRooms');\n        if (this.watchers.database > 0) {\n            this.logger.debug('Rejoining database room.');\n            this.webSocket.watchDatabase({join: true}, callback);\n        }\n        for (projectId in this.watchers.projects) {\n            if (this.watchers.projects.hasOwnProperty(projectId) && this.watchers.projects[projectId] > 0) {\n                this.logger.debug('Rejoining project room', projectId, this.watchers.projects[projectId]);\n                this.webSocket.watchProject({projectId: projectId, join: true}, callback);\n            }\n        }\n    };\n\n    return StorageWatcher;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * TODO: Come up with an appropriate name for this.\n * TODO: Proper implementation needed, e.g. error handling.\n *\n * Provides REST-like functionality of the database.\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/simpleapi',['common/storage/storageclasses/watchers'], function (StorageWatcher) {\n    'use strict';\n\n    /**\n     *\n     * @param webSocket\n     * @param logger\n     * @param gmeConfig\n     * @constructor\n     * @class\n     */\n    function StorageSimpleAPI(webSocket, logger, gmeConfig) {\n        // watcher counters determining when to join/leave a room on the sever\n        this.logger = this.logger || logger.fork('storage');\n        StorageWatcher.call(this, webSocket, logger, gmeConfig);\n        this.webSocket = webSocket;\n        this.gmeConfig = gmeConfig;\n        this.logger.debug('StorageSimpleAPI ctor');\n    }\n\n    StorageSimpleAPI.prototype = Object.create(StorageWatcher.prototype);\n    StorageSimpleAPI.prototype.constructor = StorageSimpleAPI;\n\n    /**\n     * Callback for getProjects.\n     *\n     * @callback StorageSimpleAPI~getProjectsCallback\n     * @param {string} err - error string.\n     * @param {{object[]} projects - All projects in the database.\n     * @example\n     * // projects is of the form\n     * // [{ name: 'projectId', read: true, write: false, delete: false} ]\n     */\n\n    /**\n     * Retrieves all the access info for all projects.\n     *\n     * @param {StorageSimpleAPI~getProjectsCallback} callback\n     */\n    StorageSimpleAPI.prototype.getProjects = function (options, callback) {\n        this.logger.debug('invoking getProjects', {metadata: options});\n        this.webSocket.getProjects(options, callback);\n    };\n\n    /**\n     * Callback for getProjectsAndBranches.\n     *\n     * @callback StorageSimpleAPI~getProjectsAndBranches\n     * @param {string} err - error string.\n     * @param {{object[]} projectsWithBranches - Projects the user has at least read-access to.\n     * @example\n     * // projectsWithBranches is of the form\n     * // [{\n     * //    name: 'projectId',\n     * //    read: true, //will always be true\n     * //    write: false,\n     * //    delete: false\n     * //    branches: {\n     * //      master: '#validHash',\n     * //      b1: '#validHashtoo'\n     * //    }\n     * // }]\n     */\n\n\n    StorageSimpleAPI.prototype.getBranches = function (projectId, callback) {\n        var data = {\n            projectId: projectId\n        };\n        this.logger.debug('invoking getBranches', {metadata: data});\n        this.webSocket.getBranches(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getCommits = function (projectId, before, number, callback) {\n        var data = {\n            projectId: projectId,\n            before: before,\n            number: number\n        };\n        this.logger.debug('invoking getCommits', {metadata: data});\n        this.webSocket.getCommits(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getBranchHash = function (projectId, branchName, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName\n        };\n        this.logger.debug('invoking getBranchHash', {metadata: data});\n        this.webSocket.getBranchHash(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getLatestCommitData = function (projectId, branchName, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName\n        };\n        this.logger.debug('invoking getLatestCommitData', {metadata: data});\n        this.webSocket.getLatestCommitData(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getCommonAncestorCommit = function (projectId, commitA, commitB, callback) {\n        var data = {\n            commitA: commitA,\n            commitB: commitB,\n            projectId: projectId\n        };\n        this.logger.debug('invoking getCommonAncestorCommit', {metadata: data});\n        this.webSocket.getCommonAncestorCommit(data, callback);\n    };\n\n    // Setters\n    StorageSimpleAPI.prototype.createProject = function (projectName, ownerId, callback) {\n        var self = this,\n            data = {\n                projectName: projectName,\n                ownerId: ownerId\n            };\n\n        if (callback === undefined && typeof ownerId === 'function') {\n            callback = ownerId;\n            data.ownerId = undefined;\n        }\n\n        this.logger.debug('invoking createProject', {metadata: data});\n\n        this.webSocket.createProject(data, function (err, projectId) {\n            if (err) {\n                self.logger.error('cannot create project ', projectName, err);\n                callback(err);\n                return;\n            }\n            self.logger.debug('Project created, projectId', projectId);\n\n            callback(err, projectId);\n        });\n    };\n\n    StorageSimpleAPI.prototype.deleteProject = function (projectId, callback) {\n        var data = {\n            projectId: projectId\n        };\n        this.logger.debug('invoking deleteProject', {metadata: data});\n        this.webSocket.deleteProject(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.transferProject = function (projectId, newOwnerId, callback) {\n        var data = {\n            projectId: projectId,\n            newOwnerId: newOwnerId\n        };\n        this.logger.debug('invoking transferProject', {metadata: data});\n        this.webSocket.transferProject(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName,\n            newHash: newHash,\n            oldHash: oldHash\n        };\n        this.logger.debug('invoking setBranchHash', {metadata: data});\n        this.webSocket.setBranchHash(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.createBranch = function (projectId, branchName, newHash, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName,\n            newHash: newHash,\n            oldHash: ''\n        };\n        this.logger.debug('invoking createBranch', {metadata: data});\n        this.webSocket.setBranchHash(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.deleteBranch = function (projectId, branchName, oldHash, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName,\n            newHash: '',\n            oldHash: oldHash\n        };\n        this.logger.debug('invoking deleteBranch', {metadata: data});\n        this.webSocket.setBranchHash(data, callback);\n    };\n\n    //temporary simple request and result functions\n    StorageSimpleAPI.prototype.simpleRequest = function (parameters, callback) {\n        this.logger.debug('invoking simpleRequest', {metadata: parameters});\n        this.webSocket.simpleRequest(parameters, callback);\n    };\n\n    StorageSimpleAPI.prototype.simpleQuery = function (workerId, parameters, callback) {\n        this.logger.debug('invoking simpleQuery; workerId, parameters', workerId, {metadata: parameters});\n        this.webSocket.simpleQuery(workerId, parameters, callback);\n    };\n\n    return StorageSimpleAPI;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * Provides functionality (used by the project-cache) for loading objects.\n *\n * To avoid multiple round-trips to the server the loadObject requests are put in a bucket\n * that is loaded when the bucket is full (gmeConfig.storage.loadBucketSize) or when a\n * timeout is triggered (gmeConfig.storage.loadBucketTimer).\n *\n * N.B. when used directly, the user need to make sure that the same object (by hash) is not loaded within in the\n * same bucket, (see the project-cache for example).\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/objectloaders',['common/storage/storageclasses/simpleapi'], function (SimpleAPI) {\n    'use strict';\n\n    function StorageObjectLoaders(webSocket, logger, gmeConfig) {\n        // watcher counters determining when to join/leave a room on the sever\n        this.logger = this.logger || logger.fork('storage');\n        SimpleAPI.call(this, webSocket, logger, gmeConfig);\n        this.webSocket = webSocket;\n        this.gmeConfig = gmeConfig;\n        // Bucket for loading objects\n        this.loadBucket = [];\n        this.loadBucketSize = 0;\n        this.loadBucketTimer = null;\n        this.logger.debug('StorageObjectLoaders ctor');\n    }\n\n    StorageObjectLoaders.prototype = Object.create(SimpleAPI.prototype);\n    StorageObjectLoaders.prototype.constructor = StorageObjectLoaders;\n\n    // Getters\n    StorageObjectLoaders.prototype.loadObject = function (projectId, hash, callback) {\n        var self = this;\n        this.logger.debug('loadObject', projectId, hash);\n\n        self.loadBucket.push({projectId: projectId, hash: hash, cb: callback});\n        self.loadBucketSize += 1;\n\n        function resetBucketAndLoadObjects() {\n            var myBucket = self.loadBucket;\n            self.loadBucket = [];\n            self.loadBucketTimer = null;\n            self.loadBucketSize = 0;\n            self.loadObjects(projectId, myBucket);\n        }\n\n        if (self.loadBucketSize === 1) {\n            self.logger.debug('loadBucket was empty starting timer [ms]', self.gmeConfig.storage.loadBucketTimer);\n            self.loadBucketTimer = setTimeout(function () {\n                self.logger.debug('loadBucketTimer triggered, bucketSize:', self.loadBucketSize);\n                resetBucketAndLoadObjects();\n            }, self.gmeConfig.storage.loadBucketTimer);\n        }\n        \n        if (self.loadBucketSize === self.gmeConfig.storage.loadBucketSize) {\n            self.logger.debug('loadBuckSize reached will loadObjects, bucketSize:', self.loadBucketSize);\n            clearTimeout(self.loadBucketTimer);\n            resetBucketAndLoadObjects();\n        }\n    };\n\n    StorageObjectLoaders.prototype.loadObjects = function (projectId, hashedObjects) {\n        var self = this,\n            hashes = {},\n            data,\n            i;\n        for (i = 0; i < hashedObjects.length; i++) {\n            hashes[hashedObjects[i].hash] = true;\n        }\n        hashes = Object.keys(hashes);\n        data = {\n            hashes: hashes,\n            projectId: projectId\n        };\n\n        this.webSocket.loadObjects(data, function (err, result) {\n            //if (err) {\n            //    throw new Error(err);\n            //}\n            self.logger.debug('loadObjects returned', {metadata: result});\n            for (i = 0; i < hashedObjects.length; i++) {\n                if (err) {\n                    hashedObjects[i].cb(err);\n                } else if (typeof result[hashedObjects[i].hash] === 'string') {\n                    self.logger.error(result[hashedObjects[i].hash]);\n                    hashedObjects[i].cb(new Error(result[hashedObjects[i].hash]));\n                } else {\n                    hashedObjects[i].cb(err, result[hashedObjects[i].hash]);\n                }\n            }\n        });\n    };\n\n    return StorageObjectLoaders;\n});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author mmaroti / https://github.com/mmaroti\r\n */\r\n\r\n\r\ndefine('common/util/assert',[],function () {\r\n    'use strict';\r\n\r\n    var assert = function (cond, msg) {\r\n        if (!cond) {\r\n            var error = new Error(msg || 'ASSERT failed');\r\n\r\n            if (typeof TESTING === 'undefined') {\r\n                console.log('Throwing', error.stack);\r\n                console.log();\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    return assert;\r\n});\r\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * This class (extracted functionality from cache implemented by mmaroti) caches objects associated\n * with a project.\n *\n * @author pmeijer / https://github.com/pmeijer\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/storage/project/cache',['common/util/assert', 'common/storage/constants'], function (ASSERT, CONSTANTS) {\n    'use strict';\n    function ProjectCache(storage, projectId, mainLogger, gmeConfig) {\n        var self = this,\n            missing = {},\n            backup = {},\n            cache = {},\n            logger = mainLogger.fork('ProjectCache'),\n            cacheSize = 0;\n\n        logger.debug('ctor', projectId);\n\n        this.queuedPersists = {};\n\n        function cacheInsert(key, obj) {\n            ASSERT(typeof cache[key] === 'undefined' && obj[CONSTANTS.MONGO_ID] === key);\n            logger.debug('cacheInsert', key);\n\n            //deepFreeze(obj);\n            cache[key] = obj;\n\n            if (++cacheSize >= gmeConfig.storage.cache) {\n                backup = cache;\n                cache = {};\n                cacheSize = 0;\n            }\n        }\n\n        this.loadObject = function (key, callback) {\n            var commitId;\n            ASSERT(typeof key === 'string' && typeof callback === 'function');\n            logger.debug('loadObject', {metadata: key});\n\n            var obj = cache[key];\n            if (typeof obj === 'undefined') {\n                obj = backup[key];\n                if (typeof obj === 'undefined') {\n                    for (commitId in self.queuedPersists) {\n                        if (self.queuedPersists.hasOwnProperty(commitId) && self.queuedPersists[commitId][key]) {\n                            obj = self.queuedPersists[commitId][key];\n                            break;\n                        }\n                    }\n                    if (typeof obj === 'undefined') {\n                        obj = missing[key];\n                        if (typeof obj === 'undefined') {\n                            obj = [callback];\n                            missing[key] = obj;\n                            logger.debug('object set to be loaded from storage');\n                            storage.loadObject(projectId, key, function (err, obj2) {\n                                ASSERT(typeof obj2 === 'object' || typeof obj2 === 'undefined');\n\n                                if (obj.length !== 0) {\n                                    ASSERT(missing[key] === obj);\n\n                                    delete missing[key];\n                                    if (!err && obj2) {\n                                        cacheInsert(key, obj2);\n                                    }\n\n                                    var cb;\n                                    while ((cb = obj.pop())) {\n                                        cb(err, obj2);\n                                    }\n                                }\n                            });\n                        } else {\n                            logger.debug('object was already queued to be loaded');\n                            obj.push(callback);\n                        }\n                        return;\n                    } else {\n                        logger.debug('object was erased from cache and backup but present in queuedPersists');\n                        cacheInsert(key, obj);\n                    }\n                } else {\n                    logger.debug('object was in backup');\n                    cacheInsert(key, obj);\n                }\n            } else {\n                logger.debug('object was in cache');\n            }\n\n            ASSERT(typeof obj === 'object' && obj !== null && obj[CONSTANTS.MONGO_ID] === key);\n            callback(null, obj);\n        };\n\n        this.insertObject = function (obj, stackedObjects) {\n            ASSERT(typeof obj === 'object' && obj !== null);\n\n            var key = obj[CONSTANTS.MONGO_ID];\n            logger.debug('insertObject', {metadata: key});\n            ASSERT(typeof key === 'string');\n\n            if (typeof cache[key] !== 'undefined') {\n                logger.warn('object inserted was already in cache');\n            } else {\n                var item = backup[key];\n                cacheInsert(key, obj);\n\n                if (typeof item !== 'undefined') {\n                    logger.warn('object inserted was already in back-up');\n                } else {\n                    item = missing[key];\n                    if (typeof item !== 'undefined') {\n                        delete missing[key];\n\n                        var cb;\n                        while ((cb = item.pop())) {\n                            cb(null, obj);\n                        }\n                    }\n                }\n            }\n            if (stackedObjects) {\n                stackedObjects[key] = obj;\n            }\n        };\n    }\n\n    return ProjectCache;\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * This class defines the common interface for a storage-project.\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/project/interface',[\n    'common/storage/project/cache',\n    'common/storage/constants',\n], function (ProjectCache, CONSTANTS) {\n    'use strict';\n\n    /**\n     *\n     * @param {string} projectId - Id of project to be opened.\n     * @param {object} storageObjectsAccessor - Exposes loadObject towards the database.\n     * @param {GmeLogger} mainLogger - Logger instance from instantiator.\n     * @param {GmeConfig} gmeConfig\n     * @alias ProjectInterface\n     * @constructor\n     */\n    function ProjectInterface(projectId, storageObjectsAccessor, mainLogger, gmeConfig) {\n\n        /**\n         * Unique ID of project, built up by the ownerId and projectName.\n         *\n         * @example\n         * 'guest+TestProject', 'organization+TestProject2'\n         * @type {string}\n         */\n        this.projectId = projectId;\n\n        this.CONSTANTS = CONSTANTS;\n\n        this.ID_NAME = CONSTANTS.MONGO_ID;\n        this.logger = mainLogger.fork('Project:' + this.projectId);\n\n        this.logger.debug('ctor', projectId);\n        this.projectCache = new ProjectCache(storageObjectsAccessor, this.projectId, this.logger, gmeConfig);\n\n        // Functions forwarded to project cache.\n        /**\n         * Inserts the given object to project-cache.\n         *\n         * @param {module:Storage~CommitObject|module:Core~ObjectData} obj - Object to be inserted in database.\n         * @param {Object.<module:Core~ObjectHash, module:Core~ObjectData>} [stackedObjects] - When used by the core, inserts between persists are stored here.\n         * @func\n         * @private\n         */\n        this.insertObject = this.projectCache.insertObject;\n\n        /**\n         * Callback for loadObject.\n         *\n         * @callback ProjectInterface~loadObjectCallback\n         * @param {Error} err - If error occurred.\n         * @param {module:Storage~CommitObject|module:Core~ObjectData} object - Object loaded from database, e.g. a commit object.\n         */\n\n        /**\n         * Attempts to load the object with hash key from the database or\n         * directly from the cache if recently loaded.\n         *\n         * @param {string} key - Hash of object to load.\n         * @param {ProjectInterface~loadObjectCallback} callback - Invoked when object is loaded.\n         * @func\n         */\n        this.loadObject = this.projectCache.loadObject;\n\n        /**\n         * Makes a commit to data base. Based on the root hash and commit message a new\n         * {@link module:Storage.CommitObject} (with returned hash)\n         * is generated and insert together with the core objects to the database on the server.\n         *\n         * @example\n         * var persisted = core.persist(rootNode);\n         *\n         * project.makeCommit('master', ['#thePreviousCommitHash'], persisted.rootHash, persisted.objects, 'new commit')\n         *   .then(function (result) {\n         *     // result = {\n         *     //   status: 'SYNCED',\n         *     //   hash: '#thisCommitHash'\n         *     // }\n         *   })\n         *   .catch(function (error) {\n         *     // error.message = 'Not authorized to read project: guest+project'\n         *   });\n         * @example\n         * project.makeCommit('master', ['#notPreviousCommitHash'], persisted.rootHash, persisted.objects, 'new commit')\n         *   .then(function (result) {\n         *     // result = {\n         *     //   status: 'FORKED',\n         *     //   hash: '#thisCommitHash'\n         *     // }\n         *   })...\n         * @example\n         * project.makeCommit(null, ['#anExistingCommitHash'], persisted.rootHash, persisted.objects, 'new commit')\n         *   .then(function (result) {\n         *     // result = {\n         *     //   hash: '#thisCommitHash'\n         *     // }\n         *   })...\n         * @example\n         * project.makeCommit('master', ['#aPreviousCommitHash'], previousRootHash, {}, 'just adding a commit to master')\n         *   .then(function (result) {\n         *     // result = {\n         *     //   status: 'SYNCED',\n         *     //   hash: '#thisCommitHash'\n         *     // }\n         *   })...\n         * @param {string} branchName - Name of branch to update (none if null).\n         * @param {module:Storage~CommitHash[]} parents - Parent commit hashes.\n         * @param {module:Core~ObjectHash} rootHash - Hash of root object.\n         * @param {module:Core~DataObject} coreObjects - Core objects associated with the commit.\n         * @param {string} msg='n/a' - Commit message.\n         * @param {function} [callback] - If provided no promise will be returned.\n         * @async\n         * @return {external:Promise}  On success the promise will be resolved with\n         * {@link module:Storage~CommitResult} <b>result</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {\n            throw new Error('makeCommit must be overridden in derived class');\n        };\n\n        /**\n         * Attempts to update the head of the branch.\n         * @param {string} branchName - Name of branch to update.\n         * @param {module:Storage~CommitHash} newHash - New commit hash for branch head.\n         * @param {module:Storage~CommitHash} oldHash - Current state of the branch head inside the database.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * {@link module:Storage~CommitResult} <b>result</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.setBranchHash = function (branchName, newHash, oldHash, callback) {\n            throw new Error('setBranchHash must be overridden in derived class');\n        };\n\n        /**\n         * Retrieves the commit hash for the head of the branch.\n         * @param {string} branchName - Name of branch.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * {module:Storage~CommitHash} <b>branchHash</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.getBranchHash = function (branchName, callback) {\n            throw new Error('getBranchHash must be overridden in derived class');\n        };\n\n        /**\n         * Attempts to create a new branch with head pointing to the provided commit hash.\n         * @param {string} branchName - Name of branch to create.\n         * @param {module:Storage~CommitHash} newHash - New commit hash for branch head.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * {@link module:Storage~CommitResult} <b>result</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.createBranch = function (branchName, newHash, callback) {\n            throw new Error('createBranch must be overridden in derived class');\n        };\n\n        /**\n         * Attempts to delete the branch.\n         * @param {string} branchName - Name of branch to create.\n         * @param {module:Storage~CommitHash} oldHash - Previous commit hash for branch head.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * {@link module:Storage~~CommitResult} <b>result</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.deleteBranch = function (branchName, oldHash, callback) {\n            throw new Error('deleteBranch must be overridden in derived class');\n        };\n\n        /**\n         * Retrieves all branches and their current heads within the project.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * Object.<string, {@link module:Storage~CommitHash}> <b>result</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.getBranches = function (callback) {\n            throw new Error('getBranches must be overridden in derived class');\n        };\n\n        /**\n         * Retrieves and array of the latest (sorted by timestamp) commits for the project.\n         * If timestamp is given it will get <b>number</b> of commits strictly before <b>before</b>.\n         * If commit hash is specified that commit will be included too.\n         * @param {number|module:Storage~CommitHash} before - Timestamp or commitHash to load history from.\n         * @param {number} number - Number of commits to load.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * Array.<{@link module:Storage~CommitObject}> <b>result</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.getCommits = function (before, number, callback) {\n            throw new Error('getCommits must be overridden in derived class');\n        };\n\n        /**\n         * Attempts to retrieve the common ancestor of two commits. If no ancestor exists it will result in an error.\n         *\n         * @param {string} commitA - Commit hash.\n         * @param {string} commitB - Commit hash.\n         * @param {function} [callback] - if provided no promise will be returned.\n         *\n         * @return {external:Promise}  On success the promise will be resolved with\n         * {@link module:Storage~CommitHash} <b>commonCommitHash</b>.<br>\n         * On error the promise will be rejected with {Error} <b>error</b>.\n         */\n        this.getCommonAncestorCommit = function (commitA, commitB, callback) {\n            throw new Error('getCommonAncestorCommit must be overridden in derived class');\n        };\n    }\n\n    return ProjectInterface;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/project/branch',['common/storage/constants'], function (CONSTANTS) {\n    'use strict';\n\n    function Branch(name, mainLogger) {\n        var self = this,\n            logger = mainLogger.fork('Branch:' + name),\n            originHash = '',\n            localHash = '',\n            commitQueue = [],\n            updateQueue = [],\n            branchStatus = CONSTANTS.BRANCH_STATUS.SYNC;\n\n        logger.debug('ctor');\n        this.name = name;\n        this.isOpen = true;\n        this.inSync = true;\n\n        this.branchStatusHandlers = [];\n        this.hashUpdateHandlers = [];\n        this.callbackQueue = [];\n\n        this._remoteUpdateHandler = null;\n\n        this.cleanUp = function () {\n            var i,\n                commitResult;\n            self.isOpen = false;\n            self.branchStatusHandlers = [];\n            self.hashUpdateHandlers = [];\n\n            self._remoteUpdateHandler = null;\n            for (i = 0; i < self.callbackQueue.length; i += 1) {\n                // Make sure there are no pending callbacks, invoke with status CANCELED.\n                commitResult = {\n                    status: CONSTANTS.CANCELED,\n                    hash: commitQueue[i].commitObject[CONSTANTS.MONGO_ID]\n                };\n                self.callbackQueue[i](null, commitResult);\n            }\n            self.callbackQueue = [];\n            commitQueue = [];\n            updateQueue = [];\n        };\n\n        // Hash related functions\n        this.getLocalHash = function () {\n            return localHash;\n        };\n\n        this.getOriginHash = function () {\n            return originHash;\n        };\n\n        this.updateHashes = function (newLocal, newOrigin) {\n            logger.debug('updatingHashes');\n            if (newLocal !== null) {\n                logger.debug('localHash: old, new', localHash, newLocal);\n                localHash = newLocal;\n            }\n            if (newOrigin !== null) {\n                logger.debug('originHash: old, new', originHash, newOrigin);\n                originHash = newOrigin;\n            }\n        };\n\n        // Queue related functions\n        this.queueCommit = function (commitData, commitCallback) {\n            commitQueue.push(commitData);\n            self.callbackQueue.push(commitCallback);\n            logger.debug('Adding new commit to queue', commitQueue.length);\n        };\n\n        this.getFirstCommit = function (shift) {\n            var commitData;\n            if (shift) {\n                commitData = commitQueue.shift();\n                self.callbackQueue.shift();\n                logger.debug('Removed commit from queue', commitQueue.length);\n            } else {\n                commitData = commitQueue[0];\n            }\n\n            return commitData;\n        };\n\n        this.getCommitQueue = function () {\n            return commitQueue;\n        };\n\n        this.getCommitsForNewFork = function (upTillCommitHash) {\n            var i,\n                commitData,\n                commitHash,\n                commitHashExisted = false,\n                subQueue = [];\n\n            logger.debug('getCommitsForNewFork', upTillCommitHash);\n\n            if (commitQueue.length === 0) {\n                commitHash = localHash;\n\n                logger.debug('No commits queued will fork from', commitHash);\n                upTillCommitHash = upTillCommitHash || commitHash;\n                commitHashExisted = upTillCommitHash === commitHash;\n            } else {\n                upTillCommitHash = upTillCommitHash ||\n                    commitQueue[commitQueue.length - 1].commitObject[CONSTANTS.MONGO_ID];\n            }\n\n            logger.debug('Will fork up to commitHash', upTillCommitHash);\n\n            // Move over all commit-data up till the chosen commitHash to the fork's queue,\n            // except the commit that caused the fork (all its objects are already in the database).\n            for (i = 0; i < commitQueue.length; i += 1) {\n                commitData = commitQueue[i];\n                commitHash = commitData.commitObject[CONSTANTS.MONGO_ID];\n                if (i !== 0) {\n                    subQueue.push(commitData);\n                }\n                if (commitData.commitObject[CONSTANTS.MONGO_ID] === upTillCommitHash) {\n                    // The commitHash from where to fork has been reached.\n                    // If any, the rest of the 'pending' commits will not be used.\n                    commitHashExisted = true;\n                    break;\n                }\n            }\n\n            if (commitHashExisted === false) {\n                logger.error('Could not find the specified commitHash', upTillCommitHash);\n                return false;\n            }\n\n            return {commitHash: commitHash, queue: subQueue};\n        };\n\n        this.queueUpdate = function (updateData) {\n            updateQueue.push(updateData);\n            logger.debug('Adding new update to queue', updateQueue.length);\n        };\n\n        this.getUpdateQueue = function () {\n            return updateQueue;\n        };\n\n        this.getFirstUpdate = function (shift) {\n            var updateData;\n            if (shift) {\n                updateData = updateQueue.shift();\n                logger.debug('Removed update from queue', updateQueue.length);\n            } else {\n                updateData = updateQueue[0];\n            }\n\n            return updateData;\n        };\n\n        // Event related functions\n        this.addBranchStatusHandler = function (fn) {\n            self.branchStatusHandlers.push(fn);\n        };\n\n        this.removeBranchStatusHandler = function (fn) {\n            var i;\n\n            for (i = 0; i < self.branchStatusHandlers.length; i += 1) {\n                if (self.branchStatusHandlers[i] === fn) {\n                    self.branchStatusHandlers.splice(i, 1);\n                    return true;\n                }\n            }\n\n            return false;\n        };\n\n        this.dispatchBranchStatus = function (newStatus) {\n            var i;\n\n            logger.debug('dispatchBranchStatus old, new', branchStatus, newStatus);\n            branchStatus = newStatus;\n            for (i = 0; i < self.branchStatusHandlers.length; i += 1) {\n                self.branchStatusHandlers[i](newStatus, commitQueue, updateQueue);\n            }\n        };\n\n        this.addHashUpdateHandler = function (fn) {\n            self.hashUpdateHandlers.push(fn);\n        };\n\n        this.removeHashUpdateHandler = function (fn) {\n            var i;\n\n            for (i = 0; i < self.hashUpdateHandlers.length; i += 1) {\n                if (self.hashUpdateHandlers[i] === fn) {\n                    self.hashUpdateHandlers.splice(i, 1);\n                    return true;\n                }\n            }\n\n            return false;\n        };\n\n        this.dispatchHashUpdate = function (data, callback) {\n            var i,\n                error = null,\n                counter = self.hashUpdateHandlers.length,\n                allProceed = true,\n                counterCallback = function (err, proceed) {\n                    error = error || err; // Use the latest error\n                    allProceed = allProceed && proceed === true;\n                    counter -= 1;\n                    if (counter === 0) {\n                        callback(error, allProceed);\n                    }\n                };\n\n            for (i = 0; i < self.hashUpdateHandlers.length; i += 1) {\n                self.hashUpdateHandlers[i](data, commitQueue, updateQueue, counterCallback);\n            }\n        };\n    }\n\n    return Branch;\n});\n",
    "// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define('q',definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n\n *\n * Storage.openProject resolves with an instance of this classes.\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/project/project',[\n    'common/storage/project/interface',\n    'common/storage/project/branch',\n    'q'\n], function (ProjectInterface, Branch, Q) {\n    'use strict';\n\n    /**\n     * This project uses a common storage to connect to the database on the server via web-sockets.\n     * It can run under both nodeJS and in the browser.\n     *\n     *\n     * @param {string} projectId - Id of project to be opened.\n     * @param {object} storage - Storage connected to the server and database.\n     * @param {object} mainLogger - Logger instance.\n     * @param {GmeConfig} gmeConfig\n     * @alias Project\n     * @constructor\n     * @augments ProjectInterface\n     */\n    function Project(projectId, storage, mainLogger, gmeConfig) {\n        var self = this;\n        this.branches = {};\n\n        ProjectInterface.call(this, projectId, storage, mainLogger, gmeConfig);\n\n        // Functions defined in ProjectInterface\n        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {\n            return Q.ninvoke(storage, 'makeCommit', self.projectId, branchName, parents, rootHash, coreObjects, msg)\n                .nodeify(callback);\n        };\n\n        this.setBranchHash = function (branchName, newHash, oldHash, callback) {\n            return Q.ninvoke(storage, 'setBranchHash', self.projectId, branchName, newHash, oldHash)\n                .nodeify(callback);\n        };\n\n        this.getBranchHash = function (branchName, callback) {\n            return Q.ninvoke(storage, 'getBranchHash', self.projectId, branchName)\n                .nodeify(callback);\n        };\n\n        this.createBranch = function (branchName, newHash, callback) {\n            return Q.ninvoke(storage, 'createBranch', self.projectId, branchName, newHash)\n                .nodeify(callback);\n        };\n\n        this.deleteBranch = function (branchName, oldHash, callback) {\n            return Q.ninvoke(storage, 'deleteBranch', self.projectId, branchName, oldHash)\n                .nodeify(callback);\n        };\n\n        this.getBranches = function (callback) {\n            return Q.ninvoke(storage, 'getBranches', self.projectId)\n                .nodeify(callback);\n        };\n\n        this.getCommits = function (before, number, callback) {\n            return Q.ninvoke(storage, 'getCommits', self.projectId, before, number)\n                .nodeify(callback);\n        };\n\n        this.getCommonAncestorCommit = function (commitA, commitB, callback) {\n            return Q.ninvoke(storage, 'getCommonAncestorCommit', self.projectId, commitA, commitB)\n                .nodeify(callback);\n        };\n    }\n\n    Project.prototype = Object.create(ProjectInterface.prototype);\n    Project.prototype.constructor = Project;\n\n    return Project;\n});\n",
    "//jshint ignore: start\n//SHA1 in Javascript 862 bytes, MIT License, http://antimatter15.com/\ndefine('common/util/sha1',[],function() {\nreturn function(l){function p(b,a){return b<<a|b>>>32-a}l+=\"\";for(var n=Math,c=[1518500249,1859775393,2400959708,3395469782,1732584193,4023233417,2562383102,271733878,3285377520,4294967295],s=n.ceil(l.length/4)+2,q=n.ceil(s/16),g=[],a=0,h=[],j,d,e,f,m,i,b,k;a<q;a++){g[a]=[];for(k=0;k<16;k++){function o(b,c){return l.charCodeAt(a*64+k*4+b)<<c}g[a][k]=o(0,24)|o(1,16)|o(2,8)|o(3,0)}}i=l.length*8-8;a=q-1;g[a][14]=i/(c[9]+1);g[a][14]=n.floor(g[a][14]);g[a][15]=i&c[9];for(a=0;a<q;a++){for(b=0;b<16;b++)h[b]=g[a][b];for(b=16;b<80;b++)h[b]=p(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);j=c[4];d=c[5];e=c[6];f=c[7];m=c[8];for(b=0;b<80;b++){var r=n.floor(b/20),t=p(j,5)+(r<1?d&e^~d&f:r==2?d&e^d&f^e&f:d^e^f)+m+c[r]+h[b]&c[9];m=f;f=e;e=p(d,30);d=j;j=t}c[4]+=j;c[5]+=d;c[6]+=e;c[7]+=f;c[8]+=m}i=\"\";for(z=4;z<9;z++)for(a=7;a>=0;a--)i+=((c[z]&c[9])>>>a*4&15).toString(16);return i};\n});\n\n",
    "//jshint ignore: start\n/* 2012 David Chambers <dc@hashify.me>  */\ndefine('common/util/canon',[], function() {\n    var CANON = {},\n        keys, map, nativeMap, pad,\n        __slice = [].slice,\n        __hasProp = {}.hasOwnProperty;\n\n\n    CANON.stringify = (function() {\n        var canonicalize;\n        canonicalize = function(value) {\n            var pair, _ref;\n            switch (Object.prototype.toString.call(value)) {\n                case '[object Array]':\n                    return ['Array'].concat(__slice.call(map(value, canonicalize)));\n                case '[object Date]':\n                    return ['Date'].concat(isFinite(+value) ? value.getUTCFullYear() + '-' + pad(value.getUTCMonth() + 1) + '-' + pad(value.getUTCDate()) + 'T' + pad(value.getUTCHours()) + ':' + pad(value.getUTCMinutes()) + ':' + pad(value.getUTCSeconds()) + '.' + pad(value.getUTCMilliseconds(), 3) + 'Z' : null);\n                case '[object Function]':\n                    throw new TypeError('functions cannot be serialized');\n                    break;\n                case '[object Number]':\n                    if (isFinite(value)) {\n                        return value;\n                    } else {\n                        return ['Number', \"\" + value];\n                    }\n                    break;\n                case '[object Object]':\n                    pair = function(key) {\n                        return [key, canonicalize(value[key])];\n                    };\n                    return (_ref = ['Object']).concat.apply(_ref, map(keys(value).sort(), pair));\n                case '[object RegExp]':\n                    return ['RegExp', \"\" + value];\n                case '[object Undefined]':\n                    return ['Undefined'];\n                default:\n                    return value;\n            }\n        };\n        return function(value) {\n            return JSON.stringify(canonicalize(value));\n        };\n    })();\n\n    CANON.parse = (function() {\n        var canonicalize;\n        canonicalize = function(value) {\n            var element, elements, idx, object, what, _i, _ref;\n            if (Object.prototype.toString.call(value) !== '[object Array]') {\n                return value;\n            }\n            what = value[0], elements = 2 <= value.length ? __slice.call(value, 1) : [];\n            element = elements[0];\n            switch (what) {\n                case 'Array':\n                    return map(elements, canonicalize);\n                case 'Date':\n                    return new Date(element);\n                case 'Number':\n                    return +element;\n                case 'Object':\n                    object = {};\n                    for (idx = _i = 0, _ref = elements.length; _i < _ref; idx = _i += 2) {\n                        object[elements[idx]] = canonicalize(elements[idx + 1]);\n                    }\n                    return object;\n                case 'RegExp':\n                    return (function(func, args, ctor) {\n                        ctor.prototype = func.prototype;\n                        var child = new ctor, result = func.apply(child, args);\n                        return Object(result) === result ? result : child;\n                    })(RegExp, /^[/](.+)[/]([gimy]*)$/.exec(element).slice(1), function(){});\n                case 'Undefined':\n                    return void 0;\n                default:\n                    throw new Error('invalid input');\n            }\n        };\n        return function(string) {\n            return canonicalize(JSON.parse(string));\n        };\n    })();\n\n    nativeMap = Array.prototype.map;\n\n    map = function(array, iterator) {\n        var el, _i, _len, _results;\n        if (nativeMap && array.map === nativeMap) {\n            return array.map(iterator);\n        } else {\n            _results = [];\n            for (_i = 0, _len = array.length; _i < _len; _i++) {\n                el = array[_i];\n                _results.push(iterator(el));\n            }\n            return _results;\n        }\n    };\n\n    keys = Object.keys || function(object) {\n        var key, _results;\n        _results = [];\n        for (key in object) {\n            if (!__hasProp.call(object, key)) continue;\n            _results.push(key);\n        }\n        return _results;\n    };\n\n    pad = function(n, min) {\n        if (min == null) {\n            min = 2;\n        }\n        return (\"\" + (1000 + n)).substr(4 - min);\n    };\n\n    return CANON;\n\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/util/key',[\n    'common/util/sha1',\n    'common/util/assert',\n    'common/util/canon'\n], function (SHA1, ASSERT, CANON) {\n    'use strict';\n\n    var keyType = null;\n\n    function rand160Bits() {\n        var result = '',\n            i, code;\n        for (i = 0; i < 40; i++) {\n            code = Math.floor(Math.random() * 16);\n            code = code > 9 ? code + 87 : code + 48;\n            result += String.fromCharCode(code);\n        }\n        return result;\n    }\n\n    return function KeyGenerator(object, gmeConfig) {\n        keyType = gmeConfig.storage.keyType;\n        ASSERT(typeof keyType === 'string');\n\n        switch (keyType) {\n            case 'rand160Bits':\n                return rand160Bits();\n            default: //plainSHA1\n                return SHA1(CANON.stringify(object));\n        }\n    };\n});\n",
    "/*globals define*/\n/*jshint node:true*/\n/**\n * This class implements the functionality needed to edit a model in a specific project and branch in a\n * collaborative fashion.\n *\n * It keeps a state of the open projects which in turn keeps track of the open branches.\n *\n * Each project is associated with a project-cache which is shared amongst the branches. So switching\n * between branches is (potentially) an operation that does not require lots of server round-trips.\n *\n * It is possible to have multiple projects open and multiple branches within each project. However\n * one instance of a storage can only hold a single instance of a project (or branch within a project).\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/editorstorage',[\n    'common/storage/storageclasses/objectloaders',\n    'common/storage/constants',\n    'common/storage/project/project',\n    'common/storage/project/branch',\n    'common/util/assert',\n    'common/util/key'\n], function (StorageObjectLoaders, CONSTANTS, Project, Branch, ASSERT, GENKEY) {\n    'use strict';\n\n    /**\n     *\n     * @param webSocket\n     * @param mainLogger\n     * @param gmeConfig\n     * @constructor\n     */\n    function EditorStorage(webSocket, mainLogger, gmeConfig) {\n        var self = this,\n            logger = mainLogger.fork('storage'),\n            projects = {};\n\n        self.logger = logger;\n        self.userId = null;\n\n        StorageObjectLoaders.call(this, webSocket, mainLogger, gmeConfig);\n\n        this.open = function (networkHandler) {\n            webSocket.connect(function (err, connectionState) {\n                if (err) {\n                    logger.error(err);\n                    networkHandler(CONSTANTS.ERROR);\n                } else if (connectionState === CONSTANTS.CONNECTED) {\n                    self.connected = true;\n                    self.userId = webSocket.userId;\n                    networkHandler(connectionState);\n                } else if (connectionState === CONSTANTS.RECONNECTED) {\n                    self._rejoinWatcherRooms();\n                    self._rejoinBranchRooms();\n                    self.connected = true;\n                    networkHandler(connectionState);\n                } else if (connectionState === CONSTANTS.DISCONNECTED) {\n                    self.connected = false;\n                    networkHandler(connectionState);\n                } else {\n                    logger.error('unexpected connection state');\n                    networkHandler(CONSTANTS.ERROR);\n                }\n            });\n        };\n\n        this.close = function (callback) {\n            var error = null,\n                openProjects = Object.keys(projects),\n                projectCnt = openProjects.length;\n\n            logger.debug('Closing storage, openProjects', openProjects);\n\n            function afterProjectClosed(err) {\n                if (err) {\n                    logger.error(err.message);\n                    error = err;\n                }\n                logger.debug('inside afterProjectClosed projectCnt', projectCnt);\n                if (projectCnt === 0) {\n                    // Remove the handler for the socket.io events 'connect' and 'disconnect'.\n                    logger.debug('Removing connect and disconnect events');\n                    webSocket.socket.removeAllListeners('connect');\n                    webSocket.socket.removeAllListeners('disconnect');\n                    // Disconnect from the server.\n                    logger.debug('Disconnecting web-socket');\n                    webSocket.disconnect();\n                    self.connected = false;\n                    // Remove all local event-listeners.\n                    webSocket.clearAllEvents();\n                    callback(error);\n                }\n            }\n\n            if (projectCnt > 0) {\n                while (projectCnt) {\n                    projectCnt -= 1;\n                    this.closeProject(openProjects[projectCnt], afterProjectClosed);\n                }\n            } else {\n                logger.debug('No projects were open, will disconnect directly');\n                afterProjectClosed(null);\n            }\n        };\n\n        /**\n         * Callback for openProject.\n         *\n         * @callback EditorStorage~openProjectCallback\n         * @param {string} err - error string.\n         * @param {Project} project - the newly opened project.\n         * @param {object} branches - the newly opened project.\n         * @example\n         * // branches is of the form\n         * // { master: '#somevalidhash', b1: '#someothervalidhash' }\n         */\n\n        /**\n         *\n         * @param {string} projectId - name of project to open.\n         * @param {EditorStorage~openProjectCallback} - callback\n         */\n        this.openProject = function (projectId, callback) {\n            var data = {\n                projectId: projectId\n            };\n            if (projects[projectId]) {\n                logger.error('project is already open', projectId);\n                callback(new Error('project is already open'));\n            }\n            webSocket.openProject(data, function (err, branches, access) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                var project = new Project(projectId, self, logger, gmeConfig);\n                projects[projectId] = project;\n                callback(null, project, branches, access);\n            });\n        };\n\n        this.closeProject = function (projectId, callback) {\n            var project = projects[projectId],\n                error = null,\n                branchCnt,\n                branchNames;\n            logger.debug('closeProject', projectId);\n\n            function closeAndDelete(err) {\n                if (err) {\n                    logger.error(err.message);\n                    error = err;\n                }\n                logger.debug('inside closeAndDelete branchCnt', branchCnt);\n                if (branchCnt === 0) {\n                    webSocket.closeProject({projectId: projectId}, function (err) {\n                        logger.debug('project closed on server.');\n                        delete projects[projectId];\n                        callback(err || error);\n                    });\n                }\n            }\n\n            if (project) {\n                branchNames = Object.keys(project.branches);\n                branchCnt = branchNames.length;\n                if (branchCnt > 0) {\n                    logger.warn('Branches still open for project, will be closed.', projectId, branchNames);\n                    while (branchCnt) {\n                        branchCnt -= 1;\n                        this.closeBranch(projectId, branchNames[branchCnt], closeAndDelete);\n                    }\n                } else {\n                    closeAndDelete(null);\n                }\n            } else {\n                logger.warn('Project is not open ', projectId);\n                callback(null);\n            }\n\n        };\n\n        this.openBranch = function (projectId, branchName, hashUpdateHandler, branchStatusHandler, callback) {\n            var project = projects[projectId],\n                data = {\n                    projectId: projectId,\n                    branchName: branchName\n                },\n                branch;\n\n            if (!project) {\n                callback(new Error('Cannot open branch, ' + branchName + ', project ' + projectId + ' is not opened.'));\n                return;\n            }\n\n            if (project.branches[branchName]) {\n                callback(new Error('Branch is already open ' + branchName + ', project: ' + projectId));\n                return;\n            }\n\n            logger.debug('openBranch, calling webSocket openBranch', projectId, branchName);\n\n            webSocket.openBranch(data, function (err, latestCommit) {\n                var branchHash;\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                branch = new Branch(branchName, project.logger);\n                project.branches[branchName] = branch;\n\n                // Update state of branch\n                branch.latestCommitData = latestCommit;\n                branchHash = latestCommit.commitObject[CONSTANTS.MONGO_ID];\n                branch.updateHashes(branchHash, branchHash);\n\n                // Add handlers to branch and set the remote update handler for the web-socket.\n                branch.addHashUpdateHandler(hashUpdateHandler);\n                branch.addBranchStatusHandler(branchStatusHandler);\n\n                branch._remoteUpdateHandler = function (_ws, updateData, initCallback) {\n                    var j,\n                        originHash = updateData.commitObject[CONSTANTS.MONGO_ID];\n                    logger.debug('_remoteUpdateHandler invoked for project, branch', projectId, branchName);\n                    for (j = 0; j < updateData.coreObjects.length; j += 1) {\n                        project.insertObject(updateData.coreObjects[j]);\n                    }\n\n                    branch.queueUpdate(updateData);\n                    branch.updateHashes(null, originHash);\n\n                    if (branch.getCommitQueue().length === 0) {\n                        if (branch.getUpdateQueue().length === 1) {\n                            self._pullNextQueuedCommit(projectId, branchName, initCallback); // hashUpdateHandlers\n                        }\n                    } else {\n                        logger.debug('commitQueue is not empty, only updating originHash.');\n                    }\n                };\n\n                branch._remoteUpdateHandler(null, latestCommit, function (err) {\n                    webSocket.addEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),\n                        branch._remoteUpdateHandler);\n                    callback(err, latestCommit);\n                });\n            });\n        };\n\n        this.closeBranch = function (projectId, branchName, callback) {\n            var project = projects[projectId],\n                branch;\n\n            logger.debug('closeBranch', projectId, branchName);\n\n            if (!project) {\n                callback(new Error('Cannot close branch, ' + branchName + ', project ' + projectId +\n                    ' is not opened.'));\n                return;\n            }\n\n            branch = project.branches[branchName];\n\n            if (!branch) {\n                logger.warn('Project does not have given branch.', projectId, branchName);\n                callback(null);\n                return;\n            }\n\n            // This will prevent memory leaks and expose if a commit is being\n            // processed at the server this time (see last error in _pushNextQueuedCommit).\n            branch.dispatchBranchStatus(null);\n\n            // Stop listening to events from the server\n            webSocket.removeEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),\n                branch._remoteUpdateHandler);\n\n            branch.cleanUp();\n\n            webSocket.closeBranch({projectId: projectId, branchName: branchName}, function (err) {\n                delete project.branches[branchName];\n                callback(err);\n            });\n        };\n\n        this.forkBranch = function (projectId, branchName, forkName, commitHash, callback) {\n            var project = projects[projectId],\n                branch,\n                forkData;\n\n            this.logger.debug('forkBranch', projectId, branchName, forkName, commitHash);\n\n            if (!project) {\n                callback(new Error('Cannot fork branch, ' + branchName + ', project ' + projectId + ' is not opened.'));\n                return;\n            }\n\n            branch = project.branches[branchName];\n\n            if (!branch) {\n                callback(new Error('Cannot fork branch, branch is not open ' + branchName + ', project: ' + projectId));\n                return;\n            }\n\n            forkData = branch.getCommitsForNewFork(commitHash, forkName); // commitHash = null defaults to latest commit\n            self.logger.debug('forkBranch - forkData', forkData);\n            if (forkData === false) {\n                callback(new Error('Could not find specified commitHash'));\n                return;\n            }\n\n            function commitNext() {\n                var currentCommitData = forkData.queue.shift();\n\n                logger.debug('forkBranch - commitNext, currentCommitData', currentCommitData);\n                if (currentCommitData) {\n                    delete currentCommitData.branchName;\n\n                    webSocket.makeCommit(currentCommitData, function (err, result) {\n                        if (err) {\n                            logger.error('forkBranch - failed committing', err);\n                            callback(err);\n                            return;\n                        }\n                        logger.debug('forkBranch - commit successful, hash', result);\n                        commitNext();\n                    });\n                } else {\n                    self.createBranch(projectId, forkName, forkData.commitHash, function (err) {\n                        if (err) {\n                            logger.error('forkBranch - failed creating new branch', err);\n                            callback(err);\n                            return;\n                        }\n                        callback(null, forkData.commitHash);\n                    });\n                }\n            }\n\n            commitNext();\n        };\n\n        this.makeCommit = function (projectId, branchName, parents, rootHash, coreObjects, msg, callback) {\n            var project = projects[projectId],\n                branch,\n                commitId,\n                commitCallback,\n                commitData = {\n                    projectId: projectId,\n                    commitObject: null,\n                    coreObjects: null\n                };\n\n            commitData.commitObject = self._getCommitObject(projectId, parents, rootHash, msg);\n            commitData.coreObjects = coreObjects;\n\n            if (project) {\n                project.insertObject(commitData.commitObject);\n                commitId = commitData.commitObject[CONSTANTS.MONGO_ID];\n\n                commitCallback = function commitCallback() {\n                    delete project.projectCache.queuedPersists[commitId];\n                    self.logger.debug('Removed now persisted core-objects from cache: ',\n                        Object.keys(project.projectCache.queuedPersists).length);\n                    callback.apply(null, arguments);\n                };\n\n                project.projectCache.queuedPersists[commitId] = coreObjects;\n                logger.debug('Queued non-persisted core-objects in cache: ',\n                    Object.keys(project.projectCache.queuedPersists).length);\n            } else {\n                commitCallback = callback;\n            }\n\n            if (typeof branchName === 'string') {\n                commitData.branchName = branchName;\n                branch = project ? project.branches[branchName] : null;\n            }\n\n            logger.debug('makeCommit', commitData);\n            if (branch) {\n                logger.debug('makeCommit, branch is open will commit using commitQueue. branchName:', branchName);\n                self._commitToBranch(projectId, branchName, commitData, parents[0], commitCallback);\n            } else {\n                webSocket.makeCommit(commitData, commitCallback);\n            }\n        };\n\n        this.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {\n            var project = projects[projectId],\n                branch;\n\n            logger.debug('setBranchHash', projectId, branchName, newHash, oldHash);\n            if (project && project.branches[branchName]) {\n                branch = project.branches[branchName];\n                logger.debug('setBranchHash, branch is open, will notify other local users about change');\n                project.loadObject(newHash, function (err, commitObject) {\n                    var commitData;\n                    if (err) {\n                        logger.error('setBranchHash, faild to load in commitObject');\n                        callback(err);\n                        return;\n                    }\n                    logger.debug('setBranchHash, loaded commitObject');\n                    commitData = {\n                        projectId: projectId,\n                        branchName: branchName,\n                        coreObjects: [],\n                        commitObject: commitObject,\n                        oldHash: oldHash\n                    };\n                    self._commitToBranch(projectId, branchName, commitData, oldHash, callback);\n                });\n            } else {\n                StorageObjectLoaders.prototype.setBranchHash.call(self,\n                    projectId, branchName, newHash, oldHash, callback);\n            }\n        };\n\n        this._commitToBranch = function (projectId, branchName, commitData, oldCommitHash, callback) {\n            var project = projects[projectId],\n                newCommitHash = commitData.commitObject._id,\n                branch = project.branches[branchName],\n                wasFirstInQueue,\n                eventData = {\n                    commitData: commitData,\n                    local: true\n                };\n\n            logger.debug('_commitToBranch, [oldCommitHash, localHash]', oldCommitHash, branch.getLocalHash());\n\n            if (oldCommitHash === branch.getLocalHash()) {\n                branch.updateHashes(newCommitHash, null);\n                branch.queueCommit(commitData, callback);\n\n                if (branch.inSync === false) {\n                    branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);\n                } else {\n                    branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);\n                }\n\n                // Get the queue length before dispatching because within the asynchrony,\n                // the queue may get longer and we end up never pushing any commit.\n                wasFirstInQueue = branch.getCommitQueue().length === 1;\n\n                branch.dispatchHashUpdate(eventData, function (err, proceed) {\n                    logger.debug('_commitToBranch, dispatchHashUpdate done. [err, proceed]', err, proceed);\n\n                    if (err) {\n                        callback(new Error('Commit failed being loaded in users: ' + err));\n                    } else if (proceed === true) {\n                        if (wasFirstInQueue) {\n                            logger.debug('_commitToBranch, commit was first in queue - will start pushing commit');\n                            self._pushNextQueuedCommit(projectId, branchName);\n                        } else {\n                            logger.debug('_commitToBranch, commit was NOT first in queue');\n                        }\n                    } else {\n                        callback(new Error('Commit halted when loaded in users: ' + err));\n                    }\n                });\n            } else {\n                // The current user is behind the local branch, e.g. plugin trying to save after client changes.\n                logger.warn('_commitToBranch, incoming commit parent was not the same as the localHash ' +\n                    'for the branch, commit will be canceled!');\n                callback(null, {status: CONSTANTS.CANCELED, hash: newCommitHash});\n            }\n        };\n\n        this._pushNextQueuedCommit = function (projectId, branchName) {\n            var project = projects[projectId],\n                branch = project.branches[branchName],\n                commitData;\n\n            logger.debug('_pushNextQueuedCommit, length=', branch.getCommitQueue().length);\n\n            commitData = branch.getFirstCommit();\n\n            logger.debug('_pushNextQueuedCommit, makeCommit [from# -> to#]',\n                commitData.commitObject.parents[0], commitData.commitObject._id);\n\n            webSocket.makeCommit(commitData, function (err, result) {\n                if (err) {\n                    logger.error('makeCommit failed', err);\n                }\n\n                if (branch.isOpen) {\n                    branch.callbackQueue[0](err, result);\n                    if (!err && result) {\n                        if (result.status === CONSTANTS.SYNCED) {\n                            branch.inSync = true;\n                            branch.updateHashes(null, result.hash);\n                            branch.getFirstCommit(true);\n                            if (branch.getCommitQueue().length === 0) {\n                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);\n                            } else {\n                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);\n                                self._pushNextQueuedCommit(projectId, branchName);\n                            }\n                        } else if (result.status === CONSTANTS.FORKED) {\n                            branch.inSync = false;\n                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);\n                        } else {\n                            logger.error('Unsupported commit status ' + result.status);\n                        }\n                    }\n                } else {\n                    logger.error('_pushNextQueuedCommit returned from server but the branch was closed, ' +\n                        'the branch has probably been closed while waiting for the response.', projectId, branchName);\n                }\n            });\n        };\n\n        this._pullNextQueuedCommit = function (projectId, branchName, callback) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            var project = projects[projectId],\n                branch = project.branches[branchName],\n                error,\n                updateData;\n\n            if (!branch) {\n                error = new Error('Branch, ' + branchName + ', not in project ' + projectId + '.');\n                if (callback) {\n                    callback(error);\n                } else {\n                    throw error;\n                }\n            }\n\n            logger.debug('About to update, updateQueue', {metadata: branch.getUpdateQueue()});\n            if (branch.getUpdateQueue().length === 0) {\n                logger.debug('No queued updates, returns');\n                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);\n                if (callback) {\n                    callback(null);\n                }\n                return;\n            }\n\n            updateData = branch.getFirstUpdate();\n\n            if (branch.isOpen) {\n                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.PULLING);\n                branch.dispatchHashUpdate({commitData: updateData, local: false}, function (err, proceed) {\n                    var originHash = updateData.commitObject[CONSTANTS.MONGO_ID];\n                    if (err) {\n                        logger.error('Loading of update commit failed with error', err, {metadata: updateData});\n                    } else if (proceed === true) {\n                        logger.debug('New commit was successfully loaded, updating localHash.');\n                        branch.updateHashes(originHash, null);\n                        branch.getFirstUpdate(true);\n                        if (branch.getCommitQueue().length === 0) {\n                            self._pullNextQueuedCommit(projectId, branchName, callback);\n                        }\n                        return;\n                    } else {\n                        logger.warn('Loading of update commit was aborted', {metadata: updateData});\n                    }\n                    if (callback) {\n                        callback(new Error('Loading the first commit was aborted'));\n                    }\n                });\n            } else {\n                logger.error('_pullNextQueuedCommit returned from server but the branch was closed.',\n                    projectId, branchName);\n            }\n        };\n\n        this._getCommitObject = function (projectId, parents, rootHash, msg) {\n            msg = msg || 'n/a';\n            var commitObj = {\n                    root: rootHash,\n                    parents: parents,\n                    updater: [self.userId],\n                    time: (new Date()).getTime(),\n                    message: msg,\n                    type: 'commit'\n                },\n                commitHash = '#' + GENKEY(commitObj, gmeConfig);\n\n            commitObj[CONSTANTS.MONGO_ID] = commitHash;\n\n            return commitObj;\n        };\n\n        this._rejoinBranchRooms = function () {\n            var projectId,\n                project,\n                branchName;\n            logger.debug('_rejoinBranchRooms');\n            function afterRejoinFn(projectId, branchName) {\n                return function (err) {\n                    var project = projects[projectId];\n                    if (err) {\n                        logger.error('_rejoinBranchRooms, could not rejoin branch room', projectId, branchName);\n                        logger.error(err);\n                        return;\n                    }\n                    logger.debug('_rejoinBranchRooms, rejoined branch room', projectId, branchName);\n\n                    if (!project) {\n                        logger.error('_rejoinBranchRooms, project has been closed after disconnect',\n                            projectId, branchName);\n                        return;\n                    }\n                    project.getBranchHash(branchName)\n                        .then(function (branchHash) {\n                            var branch = project.branches[branchName],\n                                queuedCommitHash;\n                            logger.debug('_rejoinBranchRooms received branchHash', projectId, branchName, branchHash);\n                            if (!branch) {\n                                logger.error('_rejoinBranchRooms, branch had been closed disconnect',\n                                    projectId, branchName);\n                                return;\n                            }\n\n                            if (branch.getCommitQueue().length > 0) {\n                                queuedCommitHash = branch.getFirstCommit().commitObject._id;\n                                logger.debug('_rejoinBranchRooms, commits were queued length=, firstQueuedCommitHash',\n                                    branch.getCommitQueue().length, queuedCommitHash);\n\n                                project.getCommonAncestorCommit(branchHash, queuedCommitHash)\n                                    .then(function (commonCommitHash) {\n                                        var result,\n                                            branch = project.branches[branchName];\n\n                                        logger.debug('_rejoinBranchRooms getCommonAncestorCommit',\n                                            projectId, branchName, commonCommitHash);\n                                        if (!branch) {\n                                            logger.error('_rejoinBranchRooms, branch had been closed after disconnect',\n                                                projectId, branchName);\n                                            return;\n                                        }\n                                        function dispatchSynced() {\n                                            result = {status: CONSTANTS.SYNCED, hash: branchHash};\n\n                                            branch.callbackQueue[0](null, result);\n                                            branch.inSync = true;\n                                            branch.updateHashes(null, branchHash);\n                                            branch.getFirstCommit(true);\n                                            if (branch.getCommitQueue().length === 0) {\n                                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);\n                                            } else {\n                                                branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC);\n                                                self._pushNextQueuedCommit(projectId, branchName);\n                                            }\n                                        }\n\n                                        function dispatchForked() {\n                                            result = {status: CONSTANTS.FORKED, hash: branchHash};\n\n                                            branch.callbackQueue[0](null, result);\n                                            branch.inSync = false;\n                                            branch.dispatchBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC);\n                                        }\n\n                                        // The commit was inserted.\n                                        if (commonCommitHash === queuedCommitHash) {\n                                            // The commit is (or was) in sync with the branch.\n                                            dispatchSynced();\n                                        } else if (commonCommitHash === branchHash) {\n                                            // The branch has moved back since the commit was made.\n                                            // Treat it like the commit was forked.\n                                            dispatchForked();\n                                        } else {\n                                            // The branch has moved forward and the commit was forked.\n                                            dispatchForked();\n                                        }\n                                    })\n                                    .catch(function (err) {\n                                        if (err.message.indexOf('Commit object does not exist [' +\n                                                queuedCommitHash) > -1) {\n                                            // Commit never made it to the server - push it.\n                                            logger.debug('First queued commit never made it to the server. push...');\n                                            self._pushNextQueuedCommit(projectId, branchName);\n                                        } else {\n                                            logger.error(err);\n                                        }\n                                    })\n                                    .done();\n                            } else {\n                                logger.debug('_rejoinBranchRooms, no commits were queued during disconnect.');\n                            }\n                        })\n                        .catch(function (err) {\n                            logger.error(err);\n                        });\n                };\n            }\n\n            for (projectId in projects) {\n                if (projects.hasOwnProperty(projectId)) {\n                    project = projects[projectId];\n                    logger.debug('_rejoinBranchRooms found project', projectId);\n                    for (branchName in project.branches) {\n                        if (project.branches.hasOwnProperty(branchName)) {\n                            logger.debug('_rejoinBranchRooms joining branch', projectId, branchName);\n                            webSocket.watchBranch({\n                                projectId: projectId,\n                                branchName: branchName,\n                                join: true\n                            }, afterRejoinFn(projectId, branchName));\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    EditorStorage.prototype = Object.create(StorageObjectLoaders.prototype);\n    EditorStorage.prototype.constructor = EditorStorage;\n\n    return EditorStorage;\n});\n",
    "/*globals define, require*/\n/*jshint browser:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/socketio/browserclient',[], function () {\n    'use strict';\n\n    function IoClient (mainLogger, gmeConfig) {\n        var logger = mainLogger.fork('socketio-browserclient');\n\n        this.connect = function (callback) {\n            var hostAddress = window.location.protocol + '//' + window.location.host,\n                socketIoUrl;\n\n            if (window.__karma__) {\n                // TRICKY: karma uses web sockets too, we need to use the gme server's port\n                hostAddress = window.location.protocol + '//localhost:' + gmeConfig.server.port;\n            }\n\n            socketIoUrl = hostAddress + '/socket.io/socket.io.js';\n            logger.debug('Will require socketIO from', socketIoUrl);\n\n            require([socketIoUrl], function (io_) {\n                var io = io_ || window.io,\n                    socket;\n\n                logger.debug('Connecting to \"' + hostAddress + '\" with options', gmeConfig.socketIO.clientOptions);\n                socket = io.connect(hostAddress, gmeConfig.socketIO.clientOptions);\n                callback(null, socket);\n            });\n        };\n    }\n\n    return IoClient;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author rkereskenyi / https://github.com/rkereskenyi\n */\n\ndefine('common/EventDispatcher',[], function () {\n    'use strict';\n\n    var EventDispatcher = function () {\n        this._eventList = {};\n    };\n\n    EventDispatcher.prototype = {\n        _eventList: null,\n        _getEvent: function (eventName, create) {\n            // Check if Array of Event Handlers has been created\n            if (!this._eventList[eventName]) {\n\n                // Check if the calling method wants to create the Array\n                // if not created. This reduces unneeded memory usage.\n                if (!create) {\n                    return null;\n                }\n\n                // Create the Array of Event Handlers\n                this._eventList[eventName] = [];\n                // new Array\n            }\n\n            // return the Array of Event Handlers already added\n            return this._eventList[eventName];\n        },\n        addEventListener: function (eventName, handler) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName, true);\n\n            // Add the new Event Handler to the Array\n            evt.push(handler);\n        },\n        removeEventListener: function (eventName, handler) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName);\n\n            if (!evt) {\n                return;\n            }\n\n            // Helper Method - an Array.indexOf equivalent\n            var getArrayIndex = function (array, item) {\n                for (var i = 0; i < array.length; i++) {\n                    if (array[i] === item) {\n                        return i;\n                    }\n                }\n                return -1;\n            };\n\n            // Get the Array index of the Event Handler\n            var index = getArrayIndex(evt, handler);\n\n            if (index > -1) {\n                // Remove Event Handler from Array\n                evt.splice(index, 1);\n            }\n        },\n        removeAllEventListeners: function (eventName) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName);\n\n            if (!evt) {\n                return;\n            }\n\n            evt.splice(0, evt.length);\n        },\n        dispatchEvent: function (eventName, eventArgs) {\n            // Get a function that will call all the Event Handlers internally\n            var handler = this._getEventHandler(eventName);\n            if (handler) {\n                // call the handler function\n                // Pass in \"sender\" and \"eventArgs\" parameters\n                handler(this, eventArgs);\n            }\n        },\n        clearAllEvents: function () {\n            this._eventList = {};\n        },\n        _getEventHandler: function (eventName) {\n            // Get Event Handler Array for this Event\n            var evt = this._getEvent(eventName, false);\n            if (!evt || evt.length === 0) {\n                return null;\n            }\n\n            // Create the Handler method that will use currying to\n            // call all the Events Handlers internally\n            var h = function (sender, args) {\n                for (var i = 0; i < evt.length; i++) {\n                    evt[i](sender, args);\n                }\n            };\n\n            // Return this new Handler method\n            return h;\n        }\n    };\n\n    return EventDispatcher;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\n// socket.io-client\n//\ndefine('common/storage/socketio/websocket',[\n    'common/EventDispatcher',\n    'common/storage/constants'\n], function (EventDispatcher, CONSTANTS) {\n\n    'use strict';\n\n    function WebSocket(ioClient, mainLogger, gmeConfig) {\n        var self = this,\n            logger = mainLogger.fork('WebSocket'),\n            beenConnected = false;\n\n        self.socket = null;\n        self.userId = null;\n\n        logger.debug('ctor');\n        EventDispatcher.call(this);\n\n        function wrapError(callback) {\n            return function () {\n                if (typeof arguments[0] === 'string') {\n                    callback(new Error(arguments[0]), arguments[1]); // Add second argument for e.g. pluginResults\n                } else {\n                    callback.apply(null, arguments);\n                }\n            };\n        }\n\n        this.connect = function (networkHandler) {\n            logger.debug('Connecting via ioClient.');\n            ioClient.connect(function (err, socket_) {\n                if (err) {\n                    networkHandler(err);\n                    return;\n                }\n                self.socket = socket_;\n\n                self.socket.on('connect', function () {\n                    var i,\n                        sendBufferSave = [];\n                    if (beenConnected) {\n                        logger.debug('Socket got reconnected.');\n\n                        // #368\n                        for (i = 0; i < self.socket.sendBuffer.length; i += 1) {\n                            // Clear all makeCommits. If pushed - they would be broadcasted back to the socket.\n                            if (self.socket.sendBuffer[i].data[0] === 'makeCommit') {\n                                logger.debug('Removed makeCommit from sendBuffer...');\n                            } else {\n                                sendBufferSave.push(self.socket.sendBuffer[i]);\n                            }\n                        }\n                        if (self.socket.receiveBuffer.length > 0) {\n                            // TODO: In which cases is this applicable??\n                            logger.debug('receiveBuffer not empty after reconnect');\n                        }\n                        self.socket.sendBuffer = sendBufferSave;\n                        networkHandler(null, CONSTANTS.RECONNECTED);\n                    } else {\n                        logger.debug('Socket got connected for the first time.');\n                        beenConnected = true;\n                        self.socket.emit('getUserId', function (err, userId) {\n                            if (err) {\n                                self.userId = gmeConfig.authentication.guestAccount;\n                                logger.error('Error getting user id setting to default', err, self.userId);\n                            } else {\n                                self.userId = userId;\n                            }\n                            networkHandler(null, CONSTANTS.CONNECTED);\n                        });\n                    }\n                });\n\n                self.socket.on('disconnect', function () {\n                    logger.debug('Socket got disconnected!');\n                    networkHandler(null, CONSTANTS.DISCONNECTED);\n                });\n\n                self.socket.on(CONSTANTS.PROJECT_DELETED, function (data) {\n                    data.etype = CONSTANTS.PROJECT_DELETED;\n                    logger.debug('PROJECT_DELETED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.PROJECT_DELETED, data);\n                });\n\n                self.socket.on(CONSTANTS.PROJECT_CREATED, function (data) {\n                    data.etype = CONSTANTS.PROJECT_CREATED;\n                    logger.debug('PROJECT_CREATED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.PROJECT_CREATED, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_CREATED, function (data) {\n                    data.etype = CONSTANTS.BRANCH_CREATED;\n                    logger.debug('BRANCH_CREATED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_CREATED + data.projectId, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_DELETED, function (data) {\n                    data.etype = CONSTANTS.BRANCH_DELETED;\n                    logger.debug('BRANCH_DELETED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_DELETED + data.projectId, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_HASH_UPDATED, function (data) {\n                    data.etype = CONSTANTS.BRANCH_HASH_UPDATED;\n                    logger.debug('BRANCH_HASH_UPDATED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_HASH_UPDATED + data.projectId, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_UPDATED, function (data) {\n                    logger.debug('BRANCH_UPDATED event', {metadata: data});\n                    self.dispatchEvent(self.getBranchUpdateEventName(data.projectId, data.branchName), data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_ROOM_SOCKETS, function (data) {\n                    logger.debug('BRANCH_ROOM_SOCKETS event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_ROOM_SOCKETS, data);\n                });\n            });\n        };\n\n        this.disconnect = function () {\n            self.socket.disconnect();\n            beenConnected = false; //This is a forced disconnect from the storage and all listeners are removed\n        };\n\n        // watcher functions\n        this.watchDatabase = function (data, callback) {\n            self.socket.emit('watchDatabase', data, wrapError(callback));\n        };\n\n        this.watchProject = function (data, callback) {\n            self.socket.emit('watchProject', data, wrapError(callback));\n        };\n\n        this.watchBranch = function (data, callback) {\n            self.socket.emit('watchBranch', data, wrapError(callback));\n        };\n\n        // model editing functions\n        this.openProject = function (data, callback) {\n            self.socket.emit('openProject', data, wrapError(callback));\n        };\n\n        this.closeProject = function (data, callback) {\n            self.socket.emit('closeProject', data, wrapError(callback));\n        };\n\n        this.openBranch = function (data, callback) {\n            self.socket.emit('openBranch', data, wrapError(callback));\n        };\n\n        this.closeBranch = function (data, callback) {\n            self.socket.emit('closeBranch', data, wrapError(callback));\n        };\n\n        this.makeCommit = function (data, callback) {\n            self.socket.emit('makeCommit', data, wrapError(callback));\n        };\n\n        this.loadObjects = function (data, callback) {\n            self.socket.emit('loadObjects', data, wrapError(callback));\n        };\n\n        this.setBranchHash = function (data, callback) {\n            self.socket.emit('setBranchHash', data, wrapError(callback));\n        };\n\n        this.getBranchHash = function (data, callback) {\n            self.socket.emit('getBranchHash', data, wrapError(callback));\n        };\n\n        // REST like functions\n        this.getProjects = function (data, callback) {\n            self.socket.emit('getProjects', data, wrapError(callback));\n        };\n\n        this.deleteProject = function (data, callback) {\n            self.socket.emit('deleteProject', data, wrapError(callback));\n        };\n\n        this.createProject = function (data, callback) {\n            self.socket.emit('createProject', data, wrapError(callback));\n        };\n\n        this.transferProject = function (data, callback) {\n            self.socket.emit('transferProject', data, wrapError(callback));\n        };\n\n        this.getBranches = function (data, callback) {\n            self.socket.emit('getBranches', data, wrapError(callback));\n        };\n\n        this.getCommits = function (data, callback) {\n            self.socket.emit('getCommits', data, wrapError(callback));\n        };\n\n        this.getLatestCommitData = function (data, callback) {\n            self.socket.emit('getLatestCommitData', data, wrapError(callback));\n        };\n\n        this.getCommonAncestorCommit = function (data, callback) {\n            self.socket.emit('getCommonAncestorCommit', data, wrapError(callback));\n        };\n\n        //temporary simple request / result functions\n        this.simpleRequest = function (data, callback) {\n            self.socket.emit('simpleRequest', data, wrapError(callback));\n        };\n\n        this.simpleQuery = function (workerId, data, callback) {\n            self.socket.emit('simpleQuery', workerId, data, wrapError(callback));\n        };\n\n        // Helper functions\n        this.getBranchUpdateEventName = function (projectId, branchName) {\n            return CONSTANTS.BRANCH_UPDATED + projectId + CONSTANTS.ROOM_DIVIDER + branchName;\n        };\n    }\n\n    WebSocket.prototype = Object.create(EventDispatcher.prototype);\n    WebSocket.prototype.constructor = WebSocket;\n\n    return WebSocket;\n});\n",
    "/*globals define*/\n/*jshint browser:true*/\n/**\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/browserstorage',[\n    'common/storage/storageclasses/editorstorage',\n    'common/storage/socketio/browserclient',\n    'common/storage/socketio/websocket',\n], function (EditorStorage, BrowserIoClient, WebSocket) {\n    'use strict';\n\n    var _storage;\n\n    function _createStorage(logger, gmeConfig) {\n        var ioClient = new BrowserIoClient(logger, gmeConfig),\n            webSocket = new WebSocket(ioClient, logger, gmeConfig),\n            storage = new EditorStorage(webSocket, logger, gmeConfig);\n\n        return storage;\n    }\n\n    function getStorage (logger, gmeConfig, forceNew) {\n        logger.debug('getStorage');\n\n        if (!_storage) {\n            logger.debug('No storage existed, will create new one..');\n            _storage = _createStorage(logger, gmeConfig);\n        } else {\n            logger.debug('Storage existed...');\n\n            if (forceNew === true) {\n                logger.debug('Force new set to true, will create new one.');\n                _storage = _createStorage(logger, gmeConfig);\n            }\n        }\n\n        return _storage;\n    }\n\n    return {\n        getStorage: getStorage\n    };\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true, camelcase: false*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\n(function () {\n    'use strict';\n\n    // ------- assert -------\n\n    var TASYNC_TRACE_ENABLE = true;\n\n    function setTrace(value) {\n        TASYNC_TRACE_ENABLE = value;\n    }\n\n    function assert(cond) {\n        if (!cond) {\n            throw new Error('tasync internal error');\n        }\n    }\n\n    // ------- Future -------\n\n    var STATE_LISTEN = 0;\n    var STATE_REJECTED = 1;\n    var STATE_RESOLVED = 2;\n\n    var Future = function () {\n        this.state = STATE_LISTEN;\n        this.value = [];\n    };\n\n    Future.prototype.register = function (target) {\n        assert(this.state === STATE_LISTEN);\n        assert(typeof target === 'object' && target !== null);\n\n        this.value.push(target);\n    };\n\n    Future.prototype.resolve = function (value) {\n        assert(this.state === STATE_LISTEN && !(value instanceof Future));\n\n        var listeners = this.value;\n\n        this.state = STATE_RESOLVED;\n        this.value = value;\n\n        var i;\n        for (i = 0; i < listeners.length; ++i) {\n            listeners[i].onResolved(value);\n        }\n    };\n\n    Future.prototype.reject = function (error) {\n        assert(this.state === STATE_LISTEN && error instanceof Error);\n\n        var listeners = this.value;\n\n        this.state = STATE_REJECTED;\n        this.value = error;\n\n        var i;\n        for (i = 0; i < listeners.length; ++i) {\n            listeners[i].onRejected(error);\n        }\n    };\n\n    // ------- Delay -------\n\n    function delay(timeout, value) {\n        if (timeout < 0) {\n            return value;\n        }\n\n        var future = new Future();\n        setTimeout(function () {\n            future.resolve(value);\n        }, timeout);\n        return future;\n    }\n\n    // ------- Lift -------\n\n    var FutureLift = function (array, index) {\n        Future.call(this);\n\n        this.array = array;\n        this.index = index;\n    };\n\n    FutureLift.prototype = Object.create(Future.prototype);\n\n    FutureLift.prototype.onResolved = function (value) {\n        assert(this.state === STATE_LISTEN);\n\n        var array = this.array;\n        array[this.index] = value;\n\n        while (++this.index < array.length) {\n            value = array[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    array[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        this.array = null;\n        this.resolve(array);\n    };\n\n    FutureLift.prototype.onRejected = function (error) {\n        this.array = null;\n        this.reject(error);\n    };\n\n    var lift = function (array) {\n        if (!(array instanceof Array)) {\n            throw new Error('array argument is expected');\n        }\n\n        var index;\n        for (index = 0; index < array.length; ++index) {\n            var value = array[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    array[index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    var future = new FutureLift(array, index);\n                    value.register(future);\n                    return future;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        return array;\n    };\n\n    // ------- Apply -------\n\n    var ROOT = {\n        subframes: 0\n    };\n\n    var FRAME = ROOT;\n\n    var FutureApply = function tasync_trace_end(func, that, args, index) {\n        Future.call(this);\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n        this.subframes = 0;\n\n        if (TASYNC_TRACE_ENABLE) {\n            this.trace = new Error();\n        }\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n        this.index = index;\n    };\n\n    FutureApply.prototype = Object.create(Future.prototype);\n\n    FutureApply.prototype.getPath = function () {\n        var future = this.caller,\n            path = [this.position];\n\n        while (future !== ROOT) {\n            path.push(future.position);\n            future = future.caller;\n        }\n\n        return path;\n    };\n\n    function getSlice(trace) {\n        assert(typeof trace === 'string');\n\n        var end = trace.indexOf('tasync_trace_start');\n        if (end >= 0) {\n            end = trace.lastIndexOf('\\n', end) + 1;\n        } else {\n            if (trace.charAt(trace.length - 1) !== '\\n') {\n                // trace += '\\n';\n            }\n            end = undefined;\n        }\n\n        var start = trace.indexOf('tasync_trace_end');\n        if (start >= 0) {\n            start = trace.indexOf('\\n', start) + 1;\n            if (start >= 0) {\n                start = trace.indexOf('\\n', start) + 1;\n            }\n        } else {\n            start = 0;\n        }\n\n        return trace.substring(start, end);\n    }\n\n    function createError(error, future) {\n        if (!(error instanceof Error)) {\n            error = new Error(error);\n        }\n\n        if (TASYNC_TRACE_ENABLE) {\n            error.trace = getSlice(error.stack);\n            do {\n                error.trace += '*** callback ***\\n';\n                error.trace += getSlice(future.trace.stack);\n                future = future.caller;\n            } while (future !== ROOT);\n        }\n\n        return error;\n    }\n\n    FutureApply.prototype.onRejected = function (error) {\n        this.args = null;\n        this.reject(error);\n    };\n\n    FutureApply.prototype.onResolved = function tasync_trace_start(value) {\n        assert(this.state === STATE_LISTEN);\n\n        var args = this.args;\n        args[this.index] = value;\n\n        while (--this.index >= 0) {\n            value = args[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    args[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        assert(FRAME === ROOT);\n        FRAME = this;\n\n        this.args = null;\n        try {\n            value = this.func.apply(this.that, args);\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(createError(error, this));\n            return;\n        }\n\n        FRAME = ROOT;\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n\n            this.onResolved = this.resolve;\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    var apply = function (func, args, that) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        } else if (!(args instanceof Array)) {\n            throw new Error('array argument is expected');\n        }\n\n        var index = args.length;\n        while (--index >= 0) {\n            var value = args[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_LISTEN) {\n                    var future = new FutureApply(func, that, args, index);\n                    value.register(future);\n                    return future;\n                } else if (value.state === STATE_RESOLVED) {\n                    args[index] = value.value;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        return func.apply(that, args);\n    };\n\n    // ------- Call -------\n\n    var FutureCall = function tasync_trace_end(args, index) {\n        Future.call(this);\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n        this.subframes = 0;\n\n        if (TASYNC_TRACE_ENABLE) {\n            this.trace = new Error();\n        }\n\n        this.args = args;\n        this.index = index;\n    };\n\n    FutureCall.prototype = Object.create(Future.prototype);\n\n    FutureCall.prototype.getPath = FutureApply.prototype.getPath;\n    FutureCall.prototype.onRejected = FutureApply.prototype.onRejected;\n\n    var FUNCTION_CALL = Function.call;\n\n    FutureCall.prototype.onResolved = function tasync_trace_start(value) {\n        assert(this.state === STATE_LISTEN);\n\n        var args = this.args;\n        args[this.index] = value;\n\n        while (--this.index >= 0) {\n            value = args[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    args[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        assert(FRAME === ROOT);\n        FRAME = this;\n\n        this.args = null;\n        try {\n            var func = args[0];\n            args[0] = null;\n            value = FUNCTION_CALL.apply(func, args);\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(createError(error, this));\n            return;\n        }\n\n        FRAME = ROOT;\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n\n            this.onResolved = this.resolve;\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    var call = function () {\n        var index = arguments.length;\n        while (--index >= 0) {\n            var value = arguments[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_LISTEN) {\n                    var future = new FutureCall(arguments, index);\n                    value.register(future);\n                    return future;\n                } else if (value.state === STATE_RESOLVED) {\n                    arguments[index] = value.value;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        var func = arguments[0];\n        return FUNCTION_CALL.apply(func, arguments);\n    };\n\n    // ------- TryCatch -------\n\n    function FutureTryCatch(handler) {\n        Future.call(this);\n\n        this.handler = handler;\n    }\n\n    FutureTryCatch.prototype = Object.create(Future.prototype);\n\n    FutureTryCatch.prototype.onRejected = function (error) {\n        try {\n            var value = this.handler(error);\n\n            if (value instanceof Future) {\n                this.onRejected = Future.prorotype.reject;\n                value.register(this);\n            } else {\n                this.resolve(value);\n            }\n        } catch (err) {\n            this.reject(err);\n        }\n    };\n\n    FutureTryCatch.prototype.onResolved = Future.prototype.resolve;\n\n    function trycatch(func, handler) {\n        if (typeof func !== 'function' || typeof handler !== 'function') {\n            throw new Error('function arguments are expected');\n        }\n\n        try {\n            var value = func();\n\n            if (value instanceof Future) {\n                var future = new FutureTryCatch(handler);\n                value.register(future);\n\n                return future;\n            } else {\n                return value;\n            }\n        } catch (error) {\n            return handler(error);\n        }\n    }\n\n    // ------- Wrap -------\n\n    function wrap(func) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        }\n\n        if (typeof func.tasync_wraped === 'undefined') {\n            func.tasync_wraped = function () {\n                var args = arguments;\n                var future = new Future();\n\n                args[args.length++] = function (error, value) {\n                    if (error) {\n                        future.reject(error instanceof Error ? error : new Error(error));\n                    } else {\n                        future.resolve(value);\n                    }\n                };\n\n                func.apply(this, args);\n\n                if (future.state === STATE_LISTEN) {\n                    return future;\n                } else if (future.state === STATE_RESOLVED) {\n                    return future.value;\n                } else {\n                    assert(future.state === STATE_REJECTED);\n                    throw future.value;\n                }\n            };\n\n            func.tasync_wraped.tasync_unwraped = func;\n        }\n\n        return func.tasync_wraped;\n    }\n\n    // ------- Unwrap -------\n\n    function UnwrapListener(callback) {\n        this.callback = callback;\n    }\n\n    UnwrapListener.prototype.onRejected = function (error) {\n        this.callback(error);\n    };\n\n    UnwrapListener.prototype.onResolved = function (value) {\n        this.callback(null, value);\n    };\n\n    function unwrap(func) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        }\n\n        if (typeof func.tasync_unwraped === 'undefined') {\n            func.tasync_unwraped = function () {\n                var args = arguments;\n\n                var callback = args[--args.length];\n                assert(typeof callback === 'function');\n\n                var value;\n                try {\n                    value = func.apply(this, args);\n                } catch (error) {\n                    callback(error);\n                    return;\n                }\n\n                if (value instanceof Future) {\n                    assert(value.state === STATE_LISTEN);\n\n                    var listener = new UnwrapListener(callback);\n                    value.register(listener);\n                } else {\n                    callback(null, value);\n                }\n            };\n\n            func.tasync_unwraped.tasync_wraped = func;\n        }\n\n        return func.tasync_unwraped;\n    }\n\n    // ------- Throttle -------\n\n    function FutureThrottle(func, that, args) {\n        Future.call(this);\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n\n        this.path = this.getPath();\n    }\n\n    FutureThrottle.prototype = Object.create(Future.prototype);\n\n    FutureThrottle.prototype.execute = function () {\n        var value;\n        try {\n            assert(FRAME === ROOT);\n            FRAME = this;\n\n            value = this.func.apply(this.that, this.args);\n\n            FRAME = ROOT;\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(error);\n            return;\n        }\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    FutureThrottle.prototype.getPath = FutureApply.prototype.getPath;\n    FutureThrottle.prototype.onResolved = Future.prototype.resolve;\n    FutureThrottle.prototype.onRejected = Future.prototype.reject;\n\n    FutureThrottle.prototype.compare = function (second) {\n        var first = this.path;\n        second = second.path;\n\n        var i, limit = first.length < second.length ? first.length : second.length;\n        for (i = 0; i < limit; ++i) {\n            if (first[i] !== second[i]) {\n                return first[i] - second[i];\n            }\n        }\n\n        return first.length - second.length;\n    };\n\n    function ThrottleListener(limit) {\n        this.running = 0;\n        this.limit = limit;\n        this.queue = [];\n    }\n\n    function priorityQueueInsert(queue, elem) {\n        var low = 0;\n        var high = queue.length;\n\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            assert(low <= mid && mid < high);\n\n            if (elem.compare(queue[mid]) < 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        queue.splice(low, 0, elem);\n    }\n\n    ThrottleListener.prototype.execute = function (func, that, args) {\n        if (this.running < this.limit) {\n            var value = func.apply(that, args);\n\n            if (value instanceof Future) {\n                assert(value.state === STATE_LISTEN);\n\n                ++this.running;\n                value.register(this);\n            }\n\n            return value;\n        } else {\n            var future = new FutureThrottle(func, that, args);\n            priorityQueueInsert(this.queue, future);\n\n            return future;\n        }\n    };\n\n    ThrottleListener.prototype.onResolved = function () {\n        if (this.queue.length > 0) {\n            var future = this.queue.pop();\n            future.register(this);\n\n            future.execute();\n        } else {\n            --this.running;\n        }\n    };\n\n    ThrottleListener.prototype.onRejected = ThrottleListener.prototype.onResolved;\n\n    // TODO: prevent recursion, otheriwise throttle will not work\n    function throttle(func, limit) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        } else if (typeof limit !== 'number') {\n            throw new Error('number argument is expected');\n        }\n\n        var listener = new ThrottleListener(limit);\n\n        return function () {\n            return listener.execute(func, this, arguments);\n        };\n    }\n\n    // ------- Join -------\n\n    function FutureJoin(first) {\n        Future.call(this);\n\n        this.first = first;\n        this.missing = first instanceof Future && first.state === STATE_LISTEN ? 1 : 0;\n    }\n\n    FutureJoin.prototype = Object.create(Future.prototype);\n\n    FutureJoin.prototype.onResolved = function (/*value*/) {\n        if (--this.missing === 0) {\n            assert(this.state !== STATE_RESOLVED);\n\n            if (this.state === STATE_LISTEN) {\n                if (this.first instanceof Future) {\n                    assert(this.first.state === STATE_RESOLVED);\n\n                    this.resolve(this.first.value);\n                } else {\n                    this.resolve(this.first);\n                }\n            }\n        }\n    };\n\n    FutureJoin.prototype.onRejected = function (error) {\n        if (this.state === STATE_LISTEN) {\n            this.reject(error);\n        }\n    };\n\n    function join(first, second) {\n        if (first instanceof Future && first.state === STATE_REJECTED) {\n            return first;\n        } else if (second instanceof Future) {\n            if (second.state === STATE_RESOLVED) {\n                return first;\n            } else if (second.state === STATE_REJECTED) {\n                return second;\n            }\n        } else {\n            return first;\n        }\n\n        if (!(first instanceof FutureJoin)) {\n            first = new FutureJoin(first);\n        }\n\n        first.missing += 1;\n        second.register(first);\n\n        return first;\n    }\n\n    // ------- TASYNC -------\n\n    var TASYNC = {\n        setTrace: setTrace,\n        delay: delay,\n        lift: lift,\n        apply: apply,\n        call: call,\n        trycatch: trycatch,\n        wrap: wrap,\n        unwrap: unwrap,\n        throttle: throttle,\n        join: join\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('common/core/tasync',[], function () {\n            return TASYNC;\n        });\n    } else {\n        module.exports = TASYNC;\n    }\n}());\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/coretree',[\n    'common/util/assert',\n    'common/util/key',\n    'common/core/tasync'\n], function (ASSERT, GENKEY, TASYNC) {\n\n    'use strict';\n\n    var HASH_REGEXP = new RegExp('#[0-9a-f]{40}');\n    var isValidHash = function (key) {\n        return typeof key === 'string' && key.length === 41 && HASH_REGEXP.test(key);\n    };\n\n    var MAX_RELID = Math.pow(2, 31);\n    var createRelid = function (data) {\n        ASSERT(data && typeof data === 'object');\n\n        var relid;\n        do {\n            relid = Math.floor(Math.random() * MAX_RELID);\n            // relid = relid.toString();\n        } while (data[relid] !== undefined);\n\n        return '' + relid;\n    };\n\n    //// make relids deterministic\n    //if (false) {\n    //    var nextRelid = 0;\n    //    createRelid = function (data) {\n    //        ASSERT(data && typeof data === 'object');\n    //\n    //        var relid;\n    //        do {\n    //            relid = (nextRelid += -1);\n    //        } while (data[relid] !== undefined);\n    //\n    //        return '' + relid;\n    //    };\n    //}\n\n    var rootCounter = 0;\n\n    return function (storage, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n\n        var gmeConfig = options.globConf,\n            logger = options.logger.fork('coretree'),\n            MAX_AGE = 3, // MAGIC NUMBER\n            MAX_TICKS = 2000, // MAGIC NUMBER\n            MAX_MUTATE = 30000, // MAGIC NUMBER\n\n            ID_NAME = storage.ID_NAME,\n            __getEmptyData = function () {\n                return {};\n            },\n            roots = [],\n            ticks = 0,\n            stackedObjects = {};\n\n        storage.loadObject = TASYNC.wrap(storage.loadObject);\n\n        // ------- static methods\n\n        var getParent = function (node) {\n            ASSERT(typeof node.parent === 'object');\n\n            return node.parent;\n        };\n\n        var getRelid = function (node) {\n            ASSERT(node.relid === null || typeof node.relid === 'string');\n\n            return node.relid;\n        };\n\n        var getLevel = function (node) {\n            var level = 0;\n            while (node.parent !== null) {\n                ++level;\n                node = node.parent;\n            }\n            return level;\n        };\n\n        var getRoot = function (node) {\n            while (node.parent !== null) {\n                node = node.parent;\n            }\n            return node;\n        };\n\n        var getPath = function (node, base) {\n            if (node === null) {\n                return null;\n            }\n\n            var path = '';\n            while (node.relid !== null && node !== base) {\n                path = '/' + node.relid + path;\n                node = node.parent;\n            }\n            return path;\n        };\n\n        var isValidPath = function (path) {\n            return typeof path === 'string' && (path === '' || path.charAt(0) === '/');\n        };\n\n        var splitPath = function (path) {\n            ASSERT(isValidPath(path));\n\n            path = path.split('/');\n            path.splice(0, 1);\n\n            return path;\n        };\n\n        var buildPath = function (path) {\n            ASSERT(path instanceof Array);\n\n            return path.length === 0 ? '' : '/' + path.join('/');\n        };\n\n        var joinPaths = function (first, second) {\n            ASSERT(isValidPath(first) && isValidPath(second));\n\n            return first + second;\n        };\n\n        var getCommonPathPrefixData = function (first, second) {\n            ASSERT(typeof first === 'string' && typeof second === 'string');\n\n            first = splitPath(first);\n            second = splitPath(second);\n\n            var common = [];\n            for (var i = 0; first[i] === second[i] && i < first.length; ++i) {\n                common.push(first[i]);\n            }\n\n            return {\n                common: buildPath(common),\n                first: buildPath(first.slice(i)),\n                firstLength: first.length - i,\n                second: buildPath(second.slice(i)),\n                secondLength: second.length - i\n            };\n        };\n\n        // ------- memory management\n\n        var __detachChildren = function (node) {\n            ASSERT(node.children instanceof Array && node.age >= MAX_AGE - 1);\n\n            var children = node.children;\n            node.children = null;\n            node.age = MAX_AGE;\n\n            for (var i = 0; i < children.length; ++i) {\n                __detachChildren(children[i]);\n            }\n        };\n\n        var __ageNodes = function (nodes) {\n            ASSERT(nodes instanceof Array);\n\n            var i = nodes.length;\n            while (--i >= 0) {\n                var node = nodes[i];\n\n                ASSERT(node.age < MAX_AGE);\n                if (++node.age >= MAX_AGE) {\n                    nodes.splice(i, 1);\n                    __detachChildren(node);\n                } else {\n                    __ageNodes(node.children);\n                }\n            }\n        };\n\n        var __ageRoots = function () {\n            if (++ticks >= MAX_TICKS) {\n                ticks = 0;\n                __ageNodes(roots);\n            }\n        };\n\n        var __getChildNode = function (children, relid) {\n            ASSERT(children instanceof Array && typeof relid === 'string');\n\n            for (var i = 0; i < children.length; ++i) {\n                var child = children[i];\n                if (child.relid === relid) {\n                    ASSERT(child.parent.age === 0);\n\n                    child.age = 0;\n                    return child;\n                }\n            }\n\n            return null;\n        };\n\n        var __getChildData = function (data, relid) {\n            ASSERT(typeof relid === 'string');\n\n            if (typeof data === 'object' && data !== null) {\n                data = data[relid];\n                return typeof data === 'undefined' ? __getEmptyData() : data;\n            } else {\n                return null;\n            }\n        };\n\n        var normalize = function (node) {\n            ASSERT(isValidNode(node));\n            // console.log('normalize start', printNode(getRoot(node)));\n\n            var parent;\n\n            if (node.children === null) {\n                ASSERT(node.age === MAX_AGE);\n\n                if (node.parent !== null) {\n                    parent = normalize(node.parent);\n\n                    var temp = __getChildNode(parent.children, node.relid);\n                    if (temp !== null) {\n                        // TODO: make the current node close to the returned one\n\n                        // console.log('normalize end1',\n                        // printNode(getRoot(temp)));\n                        return temp;\n                    }\n\n                    ASSERT(node.parent.children === null || __getChildNode(node.parent.children, node.relid) === null);\n                    ASSERT(__getChildNode(parent.children, node.relid) === null);\n\n                    node.parent = parent;\n                    parent.children.push(node);\n\n                    temp = __getChildData(parent.data, node.relid);\n                    if (!isValidHash(temp) || temp !== __getChildData(node.data, ID_NAME)) {\n                        node.data = temp;\n                    }\n                } else {\n                    roots.push(node);\n                }\n\n                node.age = 0;\n                node.children = [];\n            } else if (node.age !== 0) {\n                parent = node;\n                do {\n                    parent.age = 0;\n                    parent = parent.parent;\n                } while (parent !== null && parent.age !== 0);\n            }\n\n            // console.log('normalize end2', printNode(getRoot(node)));\n            return node;\n        };\n\n        // ------- hierarchy\n\n        var getAncestor = function (first, second) {\n            ASSERT(getRoot(first) === getRoot(second));\n\n            first = normalize(first);\n            second = normalize(second);\n\n            var a = [];\n            do {\n                a.push(first);\n                first = first.parent;\n            } while (first !== null);\n\n            var b = [];\n            do {\n                b.push(second);\n                second = second.parent;\n            } while (second !== null);\n\n            var i = a.length - 1;\n            var j = b.length - 1;\n            while (i !== 0 && j !== 0 && a[i - 1] === b[j - 1]) {\n                --i;\n                --j;\n            }\n\n            ASSERT(a[i] === b[j]);\n            return a[i];\n        };\n\n        var isAncestor = function (node, ancestor) {\n            ASSERT(getRoot(node) === getRoot(ancestor));\n\n            node = normalize(node);\n            ancestor = normalize(ancestor);\n\n            do {\n                if (node === ancestor) {\n                    return true;\n                }\n\n                node = node.parent;\n            } while (node !== null);\n\n            return false;\n        };\n\n        var createRoot = function () {\n            var root = {\n                parent: null,\n                relid: null,\n                age: 0,\n                children: [],\n                data: {\n                    _mutable: true\n                },\n                rootid: ++rootCounter\n            };\n            root.data[ID_NAME] = '';\n            roots.push(root);\n\n            __ageRoots();\n            return root;\n        };\n\n        var getChild = function (node, relid) {\n            ASSERT(typeof relid === 'string' && relid !== ID_NAME);\n\n            node = normalize(node);\n\n            var child = __getChildNode(node.children, relid);\n            if (child !== null) {\n                return child;\n            }\n\n            child = {\n                parent: node,\n                relid: relid,\n                age: 0,\n                children: [],\n                data: __getChildData(node.data, relid)\n            };\n            node.children.push(child);\n\n            __ageRoots();\n            return child;\n        };\n\n        var createChild = function (node) {\n            node = normalize(node);\n\n            if (typeof node.data !== 'object' || node.data === null) {\n                throw new Error('invalid node data');\n            }\n\n            var relid = createRelid(node.data);\n            var child = {\n                parent: node,\n                relid: relid,\n                age: 0,\n                children: [],\n                data: __getEmptyData()\n            };\n\n            // TODO: make sure that it is not on the list\n            node.children.push(child);\n\n            __ageRoots();\n            return child;\n        };\n\n        var getDescendant = function (node, head, base) {\n            ASSERT(typeof base === 'undefined' || isAncestor(head, base));\n\n            node = normalize(node);\n            head = normalize(head);\n            base = typeof base === 'undefined' ? null : normalize(base.parent);\n\n            var path = [];\n            while (head.parent !== base) {\n                path.push(head.relid);\n                head = head.parent;\n            }\n\n            var i = path.length;\n            while (--i >= 0) {\n                node = getChild(node, path[i]);\n            }\n\n            return node;\n        };\n\n        var getDescendantByPath = function (node, path) {\n            ASSERT(path === '' || path.charAt(0) === '/');\n\n            path = path.split('/');\n\n            for (var i = 1; i < path.length; ++i) {\n                node = getChild(node, path[i]);\n            }\n\n            return node;\n        };\n\n        // ------- data manipulation\n\n        var __isMutableData = function (data) {\n            return typeof data === 'object' && data !== null && data._mutable === true;\n        };\n\n        var isMutable = function (node) {\n            node = normalize(node);\n            return __isMutableData(node.data);\n        };\n\n        var isObject = function (node) {\n            node = normalize(node);\n            return typeof node.data === 'object' && node.data !== null;\n        };\n\n        var isEmpty = function (node) {\n            node = normalize(node);\n            if (typeof node.data !== 'object' || node.data === null) {\n                return false;\n            } else if (node.data === __getEmptyData()) {\n                return true;\n            }\n\n            return __isEmptyData(node.data);\n        };\n\n        var __isEmptyData = function (data) {\n            if (typeof data === 'string') {\n                return false;\n            } else if (typeof data === 'object' && Object.keys(data).length === 0) {\n                return true;\n            } else {\n                return false;\n            }\n        };\n\n        var __areEquivalent = function (data1, data2) {\n            return data1 === data2 || (typeof data1 === 'string' && data1 === __getChildData(data2, ID_NAME)) ||\n                (__isEmptyData(data1) && __isEmptyData(data2));\n        };\n\n        var mutateCount = 0;\n        var mutate = function (node) {\n            ASSERT(isValidNode(node));\n\n            node = normalize(node);\n            var data = node.data;\n\n            if (typeof data !== 'object' || data === null) {\n                return false;\n            } else if (data._mutable === true) {\n                return true;\n            }\n\n            // TODO: infinite cycle if MAX_MUTATE is smaller than depth!\n            // gmeConfig.storage.autoPersist is removed and always false\n            if (false && ++mutateCount > MAX_MUTATE) {\n                mutateCount = 0;\n\n                for (var i = 0; i < roots.length; ++i) {\n                    if (__isMutableData(roots[i].data)) {\n                        __saveData(roots[i].data);\n                    }\n                }\n            }\n\n            if (node.parent !== null && !mutate(node.parent)) {\n                // this should never happen\n                return false;\n            }\n\n            var copy = {\n                _mutable: true\n            };\n\n            for (var key in data) {\n                copy[key] = data[key];\n            }\n\n            ASSERT(copy._mutable === true);\n\n            if (typeof data[ID_NAME] === 'string') {\n                copy[ID_NAME] = '';\n            }\n\n            if (node.parent !== null) {\n                //inherited child doesn't have an entry in the parent as long as it has not been modified\n                ASSERT(node.parent.data[node.relid] === undefined ||\n                    __areEquivalent(__getChildData(node.parent.data, node.relid), node.data));\n                node.parent.data[node.relid] = copy;\n            }\n\n            node.data = copy;\n            return true;\n        };\n\n        var getData = function (node) {\n            node = normalize(node);\n\n            ASSERT(!__isMutableData(node.data));\n            return node.data;\n        };\n\n        var __reloadChildrenData = function (node) {\n            for (var i = 0; i < node.children.length; ++i) {\n                var child = node.children[i];\n\n                var data = __getChildData(node.data, child.relid);\n                if (!isValidHash(data) || data !== __getChildData(child.data, ID_NAME)) {\n                    child.data = data;\n                    __reloadChildrenData(child);\n                }\n            }\n        };\n\n        var setData = function (node, data) {\n            ASSERT(data !== null && typeof data !== 'undefined');\n\n            node = normalize(node);\n            if (node.parent !== null) {\n                if (!mutate(node.parent)) {\n                    throw new Error('incorrect node data');\n                }\n\n                node.parent.data[node.relid] = data;\n            }\n\n            node.data = data;\n            __reloadChildrenData(node);\n        };\n\n        var deleteData = function (node) {\n            node = normalize(node);\n\n            if (node.parent !== null) {\n                if (!mutate(node.parent)) {\n                    throw new Error('incorrect node data');\n                }\n\n                delete node.parent.data[node.relid];\n            }\n\n            var data = node.data;\n\n            node.data = __getEmptyData();\n            __reloadChildrenData(node);\n\n            return data;\n        };\n\n        var copyData = function (node) {\n            node = normalize(node);\n\n            if (typeof node.data !== 'object' || node.data === null) {\n                return node.data;\n            }\n\n            // TODO: return immutable data without coping\n            return JSON.parse(JSON.stringify(node.data));\n        };\n\n        var getProperty = function (node, name) {\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\n\n            var data;\n            node = normalize(node);\n\n            if (typeof node.data === 'object' && node.data !== null) {\n                data = node.data[name];\n            }\n\n            // TODO: corerel uses getProperty to get the overlay content which can get mutable\n            // ASSERT(!__isMutableData(data));\n            return data;\n        };\n\n        var setProperty = function (node, name, data) {\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\n            ASSERT(!__isMutableData(data) /*&& data !== null*/ && data !== undefined);\n            //TODO is the 'null' really can be a value of a property???\n\n            node = normalize(node);\n            if (!mutate(node)) {\n                throw new Error('incorrect node data');\n            }\n\n            node.data[name] = data;\n\n            var child = __getChildNode(node.children, name);\n            if (child !== null) {\n                child.data = data;\n                __reloadChildrenData(child);\n            }\n        };\n\n        var deleteProperty = function (node, name) {\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\n\n            node = normalize(node);\n            if (!mutate(node)) {\n                throw new Error('incorrect node data');\n            }\n\n            delete node.data[name];\n\n            var child = __getChildNode(node.children, name);\n            if (child !== null) {\n                child.data = __getEmptyData();\n                __reloadChildrenData(child);\n            }\n        };\n\n        var noUnderscore = function (relid) {\n            ASSERT(typeof relid === 'string');\n            return relid.charAt(0) !== '_';\n        };\n\n        var getKeys = function (node, predicate) {\n            ASSERT(typeof predicate === 'undefined' || typeof predicate === 'function');\n\n            node = normalize(node);\n            predicate = predicate || noUnderscore;\n\n            if (typeof node.data !== 'object' || node.data === null) {\n                return null;\n            }\n\n            var keys = Object.keys(node.data);\n\n            var i = keys.length;\n            while (--i >= 0 && !predicate(keys[i])) {\n                keys.pop();\n            }\n\n            while (--i >= 0) {\n                if (!predicate(keys[i])) {\n                    keys[i] = keys.pop();\n                }\n            }\n\n            return keys;\n        };\n\n        var getRawKeys = function (object, predicate) {\n            ASSERT(typeof predicate === 'undefined' || typeof predicate === 'function');\n            predicate = predicate || noUnderscore;\n\n            var keys = Object.keys(object);\n\n            var i = keys.length;\n            while (--i >= 0 && !predicate(keys[i])) {\n                keys.pop();\n            }\n\n            while (--i >= 0) {\n                if (!predicate(keys[i])) {\n                    keys[i] = keys.pop();\n                }\n            }\n\n            return keys;\n        };\n\n        // ------- persistence\n\n        var getHash = function (node) {\n            if (node === null) {\n                return null;\n            }\n\n            var hash;\n            node = normalize(node);\n            if (typeof node.data === 'object' && node.data !== null) {\n                hash = node.data[ID_NAME];\n            }\n\n            ASSERT(typeof hash === 'string' || typeof hash === 'undefined');\n            return hash;\n        };\n\n        var isHashed = function (node) {\n            node = normalize(node);\n            return typeof node.data === 'object' && node.data !== null && typeof node.data[ID_NAME] === 'string';\n        };\n\n        var setHashed = function (node, hashed, noMutate) {\n            ASSERT(typeof hashed === 'boolean');\n\n            node = normalize(node);\n            if (!noMutate) {\n                if (!mutate(node)) {\n                    throw new Error('incorrect node data');\n                }\n            }\n\n            if (hashed) {\n                node.data[ID_NAME] = '';\n            } else {\n                delete node.data[ID_NAME];\n            }\n\n            ASSERT(typeof node.children[ID_NAME] === 'undefined');\n        };\n\n        var __saveData = function (data) {\n            ASSERT(__isMutableData(data));\n\n            var done = __getEmptyData(),\n                keys = Object.keys(data),\n                i, child, sub, hash;\n\n            delete data._mutable;\n\n            for (i = 0; i < keys.length; i++) {\n                child = data[keys[i]];\n                if (__isMutableData(child)) {\n                    sub = __saveData(child);\n                    if (sub === __getEmptyData()) {\n                        delete data[keys[i]];\n                    } else {\n                        done = sub;\n                        if (typeof child[ID_NAME] === 'string') {\n                            data[keys[i]] = child[ID_NAME];\n                        }\n                    }\n                } else {\n                    done = undefined;\n                }\n            }\n\n\n            if (done !== __getEmptyData()) {\n                hash = data[ID_NAME];\n                ASSERT(hash === '' || typeof hash === 'undefined');\n\n                if (hash === '') {\n                    hash = '#' + GENKEY(data, gmeConfig);\n                    data[ID_NAME] = hash;\n\n                    done = data;\n                    storage.insertObject(data, stackedObjects);\n                    //stackedObjects[hash] = data;\n                }\n            }\n\n            return done;\n        };\n\n        var persist = function (node) {\n            var updated = false,\n                result;\n\n            node = normalize(node);\n\n            if (!__isMutableData(node.data)) {\n                return {rootHash: node.data[ID_NAME], objects: {}};\n            }\n\n            updated = __saveData(node.data);\n            if (updated !== __getEmptyData()) {\n                result = {};\n                result.objects = stackedObjects;\n                stackedObjects = {};\n                result.rootHash = node.data[ID_NAME];\n            } else {\n                result = {rootHash: node.data[ID_NAME], objects: {}};\n            }\n\n            return result;\n        };\n\n        var loadRoot = function (hash) {\n            ASSERT(isValidHash(hash));\n\n            return TASYNC.call(__loadRoot2, storage.loadObject(hash));\n        };\n\n        var __loadRoot2 = function (data) {\n            var root = {\n                parent: null,\n                relid: null,\n                age: 0,\n                children: [],\n                data: data,\n                rootid: ++rootCounter\n            };\n            roots.push(root);\n\n            __ageRoots();\n            return root;\n        };\n\n        var loadChild = function (node, relid) {\n            ASSERT(isValidNode(node));\n\n            node = getChild(node, relid);\n\n            if (isValidHash(node.data)) {\n                // TODO: this is a hack, we should avoid loading it multiple\n                // times\n                return TASYNC.call(__loadChild2, node, storage.loadObject(node.data));\n            } else {\n                return typeof node.data === 'object' && node.data !== null ? node : null;\n            }\n        };\n\n        var getChildHash = function (node, relid) {\n            ASSERT(isValidNode(node));\n\n            node = getChild(node, relid);\n\n            if (isValidHash(node.data)) {\n                // TODO: this is a hack, we should avoid loading it multiple\n                // times\n                return node.data;\n            } else {\n                return typeof node.data === 'object' && node.data !== null ? getHash(node) : null;\n            }\n        };\n\n\n        var __loadChild2 = function (node, newdata) {\n            node = normalize(node);\n\n            // TODO: this is a hack, we should avoid loading it multiple times\n            if (isValidHash(node.data)) {\n                ASSERT(node.data === newdata[ID_NAME]);\n\n                node.data = newdata;\n                __reloadChildrenData(node);\n            } else {\n                // TODO: if this bites you, use the Cache\n                /*if(node.data !== newdata){\n                 console.log('kecso',node);\n                 }\n                 ASSERT(node.data === newdata);*/\n            }\n\n            return node;\n        };\n\n        var loadByPath = function (node, path) {\n            ASSERT(isValidNode(node));\n            ASSERT(path === '' || path.charAt(0) === '/');\n\n            path = path.split('/');\n            return __loadDescendantByPath2(node, path, 1);\n        };\n\n        var __loadDescendantByPath2 = function (node, path, index) {\n            if (node === null || index === path.length) {\n                return node;\n            }\n\n            var child = loadChild(node, path[index]);\n            return TASYNC.call(__loadDescendantByPath2, child, path, index + 1);\n        };\n\n        // ------- valid -------\n\n        var printNode = function (node) {\n            var str = '{';\n            str += 'age:' + node.age;\n\n            if (typeof node.relid === 'string') {\n                str += ', relid: \"' + node.relid + '\"';\n            }\n\n            str += ', children:';\n            if (node.children === null) {\n                str += 'null';\n            } else {\n                str += '[';\n                for (var i = 0; i < node.children.length; ++i) {\n                    if (i !== 0) {\n                        str += ', ';\n                    }\n                    str += printNode(node.children[i]);\n                }\n                str += ']';\n            }\n\n            str += '}';\n            return str;\n        };\n\n        var __test = function (text, cond) {\n            if (!cond) {\n                throw new Error(text);\n            }\n        };\n\n        var checkValidTree = function (node) {\n            if (isValidNode(node)) {\n                if (node.children instanceof Array) {\n                    for (var i = 0; i < node.children.length; ++i) {\n                        checkValidTree(node.children[i]);\n                    }\n                }\n            }\n        };\n\n        // disable checking for now\n        var checkValidTreeRunning = true;\n\n        var isValidNode = function (node) {\n            try {\n                __test('object', typeof node === 'object' && node !== null);\n                __test('object 2', node.hasOwnProperty('parent') && node.hasOwnProperty('relid'));\n                __test('parent', typeof node.parent === 'object');\n                __test('relid', typeof node.relid === 'string' || node.relid === null);\n                __test('parent 2', (node.parent === null) === (node.relid === null));\n                __test('age', node.age >= 0 && node.age <= MAX_AGE);\n                __test('children', node.children === null || node.children instanceof Array);\n                __test('children 2', (node.age === MAX_AGE) === (node.children === null));\n                __test('data', typeof node.data === 'object' || typeof node.data === 'string' ||\n                    typeof node.data === 'number');\n\n                if (node.parent !== null) {\n                    __test('age 2', node.age >= node.parent.age);\n                    __test('mutable', !__isMutableData(node.data) || __isMutableData(node.parent.data));\n                }\n\n                if (!checkValidTreeRunning) {\n                    checkValidTreeRunning = true;\n                    checkValidTree(getRoot(node));\n                    checkValidTreeRunning = false;\n                }\n\n                return true;\n            } catch (error) {\n                logger.error(error.message, {stack: error.stack, node: node});\n                return false;\n            }\n        };\n\n        return {\n            getParent: getParent,\n            getRelid: getRelid,\n            getLevel: getLevel,\n            getRoot: getRoot,\n            getPath: getPath,\n            isValidPath: isValidPath,\n            splitPath: splitPath,\n            buildPath: buildPath,\n            joinPaths: joinPaths,\n            getCommonPathPrefixData: getCommonPathPrefixData,\n\n            normalize: normalize,\n            getAncestor: getAncestor,\n            isAncestor: isAncestor,\n            createRoot: createRoot,\n            createChild: createChild,\n            getChild: getChild,\n            getDescendant: getDescendant,\n            getDescendantByPath: getDescendantByPath,\n\n            isMutable: isMutable,\n            isObject: isObject,\n            isEmpty: isEmpty,\n            mutate: mutate,\n            getData: getData,\n            setData: setData,\n            deleteData: deleteData,\n            copyData: copyData,\n            getProperty: getProperty,\n            setProperty: setProperty,\n            deleteProperty: deleteProperty,\n            getKeys: getKeys,\n            getRawKeys: getRawKeys,\n\n            isHashed: isHashed,\n            setHashed: setHashed,\n            getHash: getHash,\n            persist: persist,\n            loadRoot: loadRoot,\n            loadChild: loadChild,\n            loadByPath: loadByPath,\n\n            isValidNode: isValidNode,\n\n            getChildHash: getChildHash\n        };\n    };\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/corerel',['common/util/assert', 'common/core/coretree', 'common/core/tasync'], function (ASSERT, CoreTree, TASYNC) {\n\n    'use strict';\n\n    // ----------------- RELID -----------------\n\n    var ATTRIBUTES = 'atr';\n    var REGISTRY = 'reg';\n    var OVERLAYS = 'ovr';\n    var COLLSUFFIX = '-inv';\n\n    function isPointerName(name) {\n        ASSERT(typeof name === 'string');\n        //TODO this is needed as now we work with modified data as well\n        if (name === '_mutable') {\n            return false;\n        }\n        return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\n    }\n\n    function isValidRelid(relid) {\n        return typeof relid === 'string' && parseInt(relid, 10).toString() === relid;\n    }\n\n    function __test(text, cond) {\n        if (!cond) {\n            throw new Error(text);\n        }\n    }\n\n    // ----------------- Core -----------------\n\n    function CoreRel(coretree, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        ASSERT(typeof coretree === 'object');\n\n        var logger = options.logger.fork('corerel');\n\n        logger.debug('initialized');\n\n        function isValidNode(node) {\n            try {\n                __test('coretree', coretree.isValidNode(node));\n                __test('isobject', coretree.isObject(node));\n\n                return true;\n            } catch (error) {\n                logger.error(error.message, {metadata: {stack: error.stack, node: node}});\n                return false;\n            }\n        }\n\n        function getAttributeNames(node) {\n            ASSERT(isValidNode(node));\n\n            node = (coretree.getProperty(node, ATTRIBUTES) || {});\n            var keys = coretree.getRawKeys(node);\n            var i = keys.length;\n            while (--i >= 0) {\n                if (keys[i].charAt(0) === '') {\n                    console.log('***** This happens?');\n                    keys.splice(i, 1);\n                }\n            }\n\n            return keys;\n        }\n\n        function getRegistryNames(node) {\n            ASSERT(isValidNode(node));\n\n            node = (coretree.getProperty(node, REGISTRY) || {});\n            var keys = coretree.getRawKeys(node);\n            var i = keys.length;\n            while (--i >= 0) {\n                if (keys[i].charAt(0) === '') {\n                    console.log('***** This happens?');\n                    keys.splice(i, 1);\n                }\n            }\n\n            return keys;\n        }\n\n        function getAttribute(node, name) {\n            /*node = coretree.getChild(node, ATTRIBUTES);\n             return coretree.getProperty(node, name);*/\n            return (coretree.getProperty(node, ATTRIBUTES) || {})[name];\n        }\n\n        function delAttribute(node, name) {\n            node = coretree.getChild(node, ATTRIBUTES);\n            coretree.deleteProperty(node, name);\n        }\n\n        function setAttribute(node, name, value) {\n            node = coretree.getChild(node, ATTRIBUTES);\n            coretree.setProperty(node, name, value);\n        }\n\n        function getRegistry(node, name) {\n            /*node = coretree.getChild(node, REGISTRY);\n             return coretree.getProperty(node, name);*/\n            return (coretree.getProperty(node, REGISTRY) || {})[name];\n        }\n\n        function delRegistry(node, name) {\n            node = coretree.getChild(node, REGISTRY);\n            coretree.deleteProperty(node, name);\n        }\n\n        function setRegistry(node, name, value) {\n            node = coretree.getChild(node, REGISTRY);\n            coretree.setProperty(node, name, value);\n        }\n\n        function overlayInsert(overlays, source, name, target) {\n            ASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\n            ASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\n            ASSERT(coretree.getCommonPathPrefixData(source, target).common === '');\n\n            // console.log('insert', overlays.parent.data.atr.name, source, name, target);\n\n            var node = coretree.getChild(overlays, source);\n\n            ASSERT(coretree.getProperty(node, name) === undefined);\n            coretree.setProperty(node, name, target);\n\n            node = coretree.getChild(overlays, target);\n            name = name + COLLSUFFIX;\n\n            var array = coretree.getProperty(node, name);\n            if (array) {\n                ASSERT(array.indexOf(source) < 0);\n\n                array = array.slice(0);\n                array.push(source);\n            } else {\n                array = [source];\n            }\n\n            coretree.setProperty(node, name, array);\n        }\n\n        function overlayRemove(overlays, source, name, target) {\n            ASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\n            ASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\n            ASSERT(coretree.getCommonPathPrefixData(source, target).common === '');\n\n            // console.log('remove', overlays.parent.data.atr.name, source, name, target);\n\n            var node = coretree.getChild(overlays, source);\n            ASSERT(node && coretree.getProperty(node, name) === target);\n            coretree.deleteProperty(node, name);\n\n            if (coretree.getKeys(node).length === 0) {\n                coretree.deleteProperty(overlays, source);\n            }\n\n            node = coretree.getChild(overlays, target);\n            ASSERT(node);\n\n            name = name + COLLSUFFIX;\n\n            var array = coretree.getProperty(node, name);\n            ASSERT(Array.isArray(array) && array.length >= 1);\n\n            if (array.length === 1) {\n                ASSERT(array[0] === source);\n\n                coretree.deleteProperty(node, name);\n            } else {\n                var index = array.indexOf(source);\n                ASSERT(index >= 0);\n\n                array = array.slice(0);\n                array.splice(index, 1);\n\n                coretree.setProperty(node, name, array);\n            }\n\n            if (coretree.getKeys(node).length === 0) {\n                coretree.deleteProperty(overlays, target);\n            }\n        }\n\n        function overlayQuery(overlays, prefix) {\n            ASSERT(isValidNode(overlays) && coretree.isValidPath(prefix));\n\n            var prefix2 = prefix + '/';\n            var list = [];\n            var paths = coretree.getKeys(overlays);\n\n            for (var i = 0; i < paths.length; ++i) {\n                var path = paths[i];\n                if (path === prefix || path.substr(0, prefix2.length) === prefix2) {\n                    var node = coretree.getChild(overlays, path);\n                    var names = coretree.getKeys(node);\n\n                    for (var j = 0; j < names.length; ++j) {\n                        var name = names[j];\n                        if (isPointerName(name)) {\n                            list.push({\n                                s: path,\n                                n: name,\n                                t: coretree.getProperty(node, name),\n                                p: true\n                            });\n                        } else {\n                            var array = coretree.getProperty(node, name);\n                            ASSERT(Array.isArray(array));\n                            name = name.slice(0, -COLLSUFFIX.length);\n                            for (var k = 0; k < array.length; ++k) {\n                                list.push({\n                                    s: array[k],\n                                    n: name,\n                                    t: path,\n                                    p: false\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n\n            // console.log('query', overlays.parent.data.atr.name, prefix, list);\n\n            return list;\n        }\n\n        function createNode(parameters) {\n            parameters = parameters || {};\n            var relid = parameters.relid,\n                parent = parameters.parent;\n\n            ASSERT(!parent || isValidNode(parent));\n            ASSERT(!relid || typeof relid === 'string');\n\n            var node;\n            if (parent) {\n                if (relid) {\n                    node = coretree.getChild(parent, relid);\n                } else {\n                    node = coretree.createChild(parent);\n                }\n                coretree.setHashed(node, true);\n            } else {\n                node = coretree.createRoot();\n            }\n\n            return node;\n        }\n\n        function deleteNode(node) {\n            ASSERT(isValidNode(node));\n\n            var parent = coretree.getParent(node);\n            var prefix = '/' + coretree.getRelid(node);\n            ASSERT(parent !== null);\n\n            coretree.deleteProperty(parent, coretree.getRelid(node));\n\n            while (parent) {\n                var overlays = coretree.getChild(parent, OVERLAYS);\n\n                var list = overlayQuery(overlays, prefix);\n                for (var i = 0; i < list.length; ++i) {\n                    var entry = list[i];\n                    overlayRemove(overlays, entry.s, entry.n, entry.t);\n                }\n\n                prefix = '/' + coretree.getRelid(parent) + prefix;\n                parent = coretree.getParent(parent);\n            }\n        }\n\n        function copyNode(node, parent) {\n            ASSERT(isValidNode(node));\n            ASSERT(!parent || isValidNode(parent));\n\n            node = coretree.normalize(node);\n            var newNode;\n\n            if (parent) {\n                var ancestor = coretree.getAncestor(node, parent);\n\n                // cannot copy inside of itself\n                if (ancestor === node) {\n                    return null;\n                }\n\n                newNode = coretree.createChild(parent);\n                coretree.setHashed(newNode, true);\n                coretree.setData(newNode, coretree.copyData(node));\n\n                var ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\n                var ancestorNewPath = coretree.getPath(newNode, ancestor);\n\n                var base = coretree.getParent(node);\n                var baseOldPath = '/' + coretree.getRelid(node);\n                var aboveAncestor = 1;\n\n                while (base) {\n                    var baseOverlays = coretree.getChild(base, OVERLAYS);\n                    var list = overlayQuery(baseOverlays, baseOldPath);\n                    var tempAncestor = coretree.getAncestor(base, ancestor);\n\n                    aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\n\n                    var relativePath = aboveAncestor < 0 ?\n                        coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\n\n                    for (var i = 0; i < list.length; ++i) {\n                        var entry = list[i];\n\n                        if (entry.p) {\n                            ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n                            ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');\n\n                            var source, target, overlays;\n\n                            if (aboveAncestor < 0) {\n                                //below ancestor node - further from root\n                                source = ancestorNewPath + entry.s.substr(baseOldPath.length);\n                                target = coretree.joinPaths(relativePath, entry.t);\n                                overlays = ancestorOverlays;\n                            } else if (aboveAncestor === 0) {\n                                //at ancestor node\n                                var data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\n\n                                overlays = newNode;\n                                while (data.firstLength-- > 0) {\n                                    overlays = coretree.getParent(overlays);\n                                }\n                                overlays = coretree.getChild(overlays, OVERLAYS);\n\n                                source = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\n                                target = data.second;\n                            } else {\n                                //above ancestor node - closer to root\n                                ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n\n                                source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\n                                target = entry.t;\n                                overlays = baseOverlays;\n                            }\n\n                            overlayInsert(overlays, source, entry.n, target);\n                        }\n                    }\n\n                    baseOldPath = '/' + coretree.getRelid(base) + baseOldPath;\n                    base = coretree.getParent(base);\n                }\n            } else {\n                newNode = coretree.createRoot();\n                coretree.setData(newNode, coretree.copyData(node));\n            }\n\n            return newNode;\n        }\n\n        //kecso\n        function copyNodes(nodes, parent) {\n            //copying multiple nodes at once for keeping their internal relations\n            var paths = [],\n                i, j, index, names, pointer,\n                copiedNodes = [],\n                internalRelationPaths = []; // Every single element will be an object with the\n                                            // internally pointing relations and the index of the target.\n\n            for (i = 0; i < nodes.length; i++) {\n                paths.push(coretree.getPath(nodes[i]));\n            }\n\n            for (i = 0; i < nodes.length; i++) {\n                names = getPointerNames(nodes[i]);\n                pointer = {};\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(getPointerPath(nodes[i], names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                internalRelationPaths.push(pointer);\n            }\n\n            //now we use our simple copy\n            for (i = 0; i < nodes.length; i++) {\n                copiedNodes.push(copyNode(nodes[i], parent));\n            }\n\n            //and now back to the relations\n            for (i = 0; i < internalRelationPaths.length; i++) {\n                names = Object.keys(internalRelationPaths[i]);\n                for (j = 0; j < names.length; j++) {\n                    setPointer(copiedNodes[i], names[j], copiedNodes[internalRelationPaths[i][names[j]]]);\n                }\n            }\n\n            return copiedNodes;\n        }\n\n        function moveNode(node, parent) {\n            ASSERT(isValidNode(node) && isValidNode(parent));\n\n            node = coretree.normalize(node);\n            var ancestor = coretree.getAncestor(node, parent);\n\n            // cannot move inside of itself\n            if (ancestor === node) {\n                return null;\n            }\n\n            var base = coretree.getParent(node);\n            var baseOldPath = '/' + coretree.getRelid(node);\n            var aboveAncestor = 1;\n\n            var oldNode = node;\n            node = coretree.getChild(parent, coretree.getRelid(oldNode));\n            if (!coretree.isEmpty(node)) {\n                // we have to change the relid of the node, to fit into its new\n                // place...\n                node = coretree.createChild(parent);\n            }\n            coretree.setHashed(node, true);\n            coretree.setData(node, coretree.copyData(oldNode));\n\n            var ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\n            var ancestorNewPath = coretree.getPath(node, ancestor);\n\n            while (base) {\n                var baseOverlays = coretree.getChild(base, OVERLAYS);\n                var list = overlayQuery(baseOverlays, baseOldPath);\n                var tempAncestor = coretree.getAncestor(base, ancestor);\n\n                aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\n\n                var relativePath = aboveAncestor < 0 ?\n                    coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\n\n                for (var i = 0; i < list.length; ++i) {\n                    var entry = list[i];\n\n                    overlayRemove(baseOverlays, entry.s, entry.n, entry.t);\n\n                    var tmp;\n                    if (!entry.p) {\n                        tmp = entry.s;\n                        entry.s = entry.t;\n                        entry.t = tmp;\n                    }\n\n                    ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n                    ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');\n\n                    var source, target, overlays;\n\n                    if (aboveAncestor < 0) {\n                        //below ancestor node\n                        source = ancestorNewPath + entry.s.substr(baseOldPath.length);\n                        target = coretree.joinPaths(relativePath, entry.t);\n                        overlays = ancestorOverlays;\n                    } else if (aboveAncestor === 0) {\n                        //at ancestor node\n                        var data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\n\n                        overlays = node;\n                        while (data.firstLength-- > 0) {\n                            overlays = coretree.getParent(overlays);\n                        }\n                        overlays = coretree.getChild(overlays, OVERLAYS);\n\n                        source = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\n                        target = data.second;\n                    } else {\n                        //above ancestor node\n                        ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n\n                        source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\n                        target = entry.t;\n                        overlays = baseOverlays;\n                    }\n\n                    if (!entry.p) {\n                        tmp = entry.s;\n                        entry.s = entry.t;\n                        entry.t = tmp;\n\n                        tmp = source;\n                        source = target;\n                        target = tmp;\n                    }\n\n                    //console.log(source, target);\n                    overlayInsert(overlays, source, entry.n, target);\n                }\n\n                baseOldPath = '/' + coretree.getRelid(base) + baseOldPath;\n                base = coretree.getParent(base);\n            }\n\n            deleteNode(oldNode);\n\n            return node;\n        }\n\n        function getChildrenRelids(node) {\n            ASSERT(isValidNode(node));\n\n            return coretree.getKeys(node, isValidRelid);\n        }\n\n        function getChildrenPaths(node) {\n            var path = coretree.getPath(node);\n\n            var relids = getChildrenRelids(node);\n            for (var i = 0; i < relids.length; ++i) {\n                relids[i] = path + '/' + relids[i];\n            }\n\n            return relids;\n        }\n\n        function loadChildren(node) {\n            ASSERT(isValidNode(node));\n\n            var children = coretree.getKeys(node, isValidRelid);\n            for (var i = 0; i < children.length; ++i) {\n                children[i] = coretree.loadChild(node, children[i]);\n            }\n\n            return TASYNC.lift(children);\n        }\n\n        function getPointerNames(node) {\n            ASSERT(isValidNode(node));\n\n            var source = '';\n            var names = [];\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    for (var name in child) {\n                        ASSERT(names.indexOf(name) === -1);\n                        if (isPointerName(name)) {\n                            names.push(name);\n                        }\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return names;\n        }\n\n        function getPointerPath(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(coretree.getPath(node), target);\n            }\n\n            return target;\n        }\n\n        function hasPointer(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child && child[name] !== undefined) {\n                    return true;\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return false;\n        }\n\n        function getOutsidePointerPath(node, name, source) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n            ASSERT(typeof source === 'string');\n\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(coretree.getPath(node), target);\n            }\n\n            return target;\n        }\n\n        function loadPointer(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            var source = '';\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(typeof target === 'string' && node);\n                return coretree.loadByPath(node, target);\n            } else {\n                return null;\n            }\n        }\n\n        function getCollectionNames(node) {\n            ASSERT(isValidNode(node));\n\n            var target = '';\n            var names = [];\n\n            do {\n                var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\n                if (child) {\n                    for (var name in child) {\n                        if (!isPointerName(name) && name !== '_mutable') {\n                            name = name.slice(0, -COLLSUFFIX.length);\n                            if (isPointerName(name) && names.indexOf(name) < 0) {\n                                names.push(name);\n                            }\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return names;\n        }\n\n        function loadCollection(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            name += COLLSUFFIX;\n\n            var collection = [];\n            var target = '';\n\n            do {\n                var child = coretree.getChild(node, OVERLAYS);\n\n                child = coretree.getChild(child, target);\n                if (child) {\n                    var sources = coretree.getProperty(child, name);\n                    if (sources) {\n                        ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                        for (var i = 0; i < sources.length; ++i) {\n                            collection.push(coretree.loadByPath(node, sources[i]));\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return TASYNC.lift(collection);\n        }\n\n        function getCollectionPaths(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            name += COLLSUFFIX;\n\n            var result = [];\n            var target = '';\n\n            do {\n                var child = coretree.getChild(node, OVERLAYS);\n\n                child = coretree.getChild(child, target);\n                if (child) {\n                    var sources = coretree.getProperty(child, name);\n                    if (sources) {\n                        ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                        var prefix = coretree.getPath(node);\n\n                        for (var i = 0; i < sources.length; ++i) {\n                            result.push(coretree.joinPaths(prefix, sources[i]));\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return result;\n        }\n\n        function deletePointer(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n\n            do {\n                var overlays = coretree.getChild(node, OVERLAYS);\n                ASSERT(overlays);\n\n                var target = coretree.getProperty(coretree.getChild(overlays, source), name);\n                if (target !== undefined) {\n                    overlayRemove(overlays, source, name, target);\n                    return true;\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return false;\n        }\n\n        function setPointer(node, name, target) {\n            ASSERT(isValidNode(node) && typeof name === 'string' && (!target || isValidNode(target)));\n\n            deletePointer(node, name);\n\n            if (target) {\n                var ancestor = coretree.getAncestor(node, target);\n\n                var overlays = coretree.getChild(ancestor, OVERLAYS);\n                var sourcePath = coretree.getPath(node, ancestor);\n                var targetPath = coretree.getPath(target, ancestor);\n\n                overlayInsert(overlays, sourcePath, name, targetPath);\n            }\n        }\n\n        function getChildrenHashes(node) {\n            var keys = getChildrenRelids(node),\n                i, hashes = {};\n\n            for (i = 0; i < keys.length; i++) {\n                hashes[keys[i]] = coretree.getChildHash(node, keys[i]);\n            }\n\n            return hashes;\n        }\n\n        // copy everything from coretree\n        var corerel = {};\n        for (var key in coretree) {\n            corerel[key] = coretree[key];\n        }\n\n        corerel.isValidNode = isValidNode;\n        corerel.isValidRelid = isValidRelid;\n\n        corerel.getChildrenRelids = getChildrenRelids;\n        corerel.getChildrenPaths = getChildrenPaths;\n\n        corerel.loadChildren = loadChildren;\n        corerel.createNode = createNode;\n        corerel.deleteNode = deleteNode;\n        corerel.copyNode = copyNode;\n        corerel.copyNodes = copyNodes;\n        corerel.moveNode = moveNode;\n\n        corerel.getAttributeNames = getAttributeNames;\n        corerel.getAttribute = getAttribute;\n        corerel.setAttribute = setAttribute;\n        corerel.delAttribute = delAttribute;\n\n        corerel.getRegistryNames = getRegistryNames;\n        corerel.getRegistry = getRegistry;\n        corerel.setRegistry = setRegistry;\n        corerel.delRegistry = delRegistry;\n\n        corerel.getPointerNames = getPointerNames;\n        corerel.getPointerPath = getPointerPath;\n        corerel.hasPointer = hasPointer;\n        corerel.getOutsidePointerPath = getOutsidePointerPath;\n        corerel.loadPointer = loadPointer;\n        corerel.deletePointer = deletePointer;\n        corerel.setPointer = setPointer;\n        corerel.getCollectionNames = getCollectionNames;\n        corerel.getCollectionPaths = getCollectionPaths;\n        corerel.loadCollection = loadCollection;\n\n        corerel.getCoreTree = function () {\n            return coretree;\n        };\n\n        corerel.getChildrenHashes = getChildrenHashes;\n\n        corerel.overlayInsert = overlayInsert;\n\n        corerel.isContainerPath = function (path, parentPath) {\n            var pathArray = (path || '').split('/'),\n                parentArray = (parentPath || '').split('/'),\n                i;\n\n            for (i = 0; i < parentArray.length; i += 1) {\n                if (parentArray[i] !== pathArray[i]) {\n                    return false;\n                }\n            }\n\n            return true;\n        };\n\n        return corerel;\n    }\n\n    return CoreRel;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/setcore',['common/util/assert'], function (ASSERT) {\n    'use strict';\n\n    var SETS_ID = '_sets';\n    var REL_ID = 'member';\n\n    function SetCore(innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n\n        var logger = options.logger.fork('setcore'),\n            setCore = {};\n        for (var i in innerCore) {\n            setCore[i] = innerCore[i];\n        }\n        logger.debug('initialized');\n\n        //help functions\n        function setModified(node) {\n            innerCore.setRegistry(node, '_sets_', (innerCore.getRegistry(node, '_sets_') || 0) + 1);\n        }\n\n        function getMemberPath(node, setElementNode) {\n            var ownPath = innerCore.getPath(node),\n                memberPath = innerCore.getPointerPath(setElementNode, REL_ID);\n\n            //TODO this is a hack and should be solved some other way if possible\n            ownPath = ownPath.substring(0, ownPath.indexOf('/_'));\n\n            if (ownPath !== memberPath) {\n                return memberPath;\n            }\n\n            //now we should check who really set this member as its own\n            while (innerCore.getBase(node) !== null && innerCore.getBase(setElementNode) !== null &&\n            innerCore.getRegistry(innerCore.getBase(setElementNode), '_') === '_') {\n\n                node = innerCore.getBase(node);\n                setElementNode = innerCore.getBase(setElementNode);\n                ownPath = innerCore.getPath(node);\n\n                //TODO this is a hack and should be solved some other way if possible\n                ownPath = ownPath.substring(0, ownPath.indexOf('/_'));\n            }\n            memberPath = innerCore.getPointerPath(setElementNode, REL_ID);\n\n\n            return memberPath;\n\n        }\n\n        function getMemberRelId(node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName);\n            var elements = innerCore.getChildrenRelids(setNode);\n\n            for (var i = 0; i < elements.length; i++) {\n                if (getMemberPath(node, innerCore.getChild(setNode, elements[i])) === memberPath) {\n                    return elements[i];\n                }\n            }\n            return null;\n        }\n\n        function createNewMemberRelid(setNode) {\n            var MAX_RELID = Math.pow(2, 31);\n            var existingRelIds = innerCore.getChildrenRelids(setNode);\n            var relid;\n            do {\n                relid = Math.floor(Math.random() * MAX_RELID);\n            } while (existingRelIds.indexOf(relid) !== -1);\n            return '' + relid;\n        }\n\n        function harmonizeMemberData(node, setName) {\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName),\n                base = innerCore.getBase(setNode),\n                allMembers = innerCore.getChildrenRelids(setNode),\n                ownMembers, inheritedMembers, i, j, path, names, ownMember, inheritedMember, k;\n            if (base) {\n                harmonizeMemberData(base, setName); //recursively harmonize base members first\n                inheritedMembers = innerCore.getChildrenRelids(base);\n                ownMembers = [];\n                for (i = 0; i < allMembers.length; i++) {\n                    if (inheritedMembers.indexOf(allMembers[i]) === -1) {\n                        ownMembers.push(allMembers[i]);\n                    }\n                }\n\n                for (i = 0; i < ownMembers.length; i++) {\n                    ownMember = innerCore.getChild(setNode, ownMembers[i]);\n                    path = innerCore.getPointerPath(ownMember, 'member');\n                    if (path === undefined) {\n                        innerCore.deleteNode(innerCore.getChild(setNode, ownMembers[i]), true);\n                    } else {\n                        for (j = 0; j < inheritedMembers.length; j++) {\n                            inheritedMember = innerCore.getChild(setNode, inheritedMembers[j]);\n                            if (getMemberPath(node, inheritedMember) === path) {\n                                //redundancy...\n                                names = innerCore.getAttributeNames(ownMember);\n                                for (k = 0; k < names.length; k++) {\n                                    if (innerCore.getAttribute(ownMember, names[k]) !==\n                                        innerCore.getAttribute(inheritedMember, names[k])) {\n\n                                        innerCore.setAttribute(inheritedMember, names[k],\n                                            innerCore.getAttribute(ownMember, names[k]));\n                                    }\n                                }\n                                names = innerCore.getRegistryNames(ownMember);\n                                for (k = 0; k < names.length; k++) {\n                                    if (innerCore.getRegistry(ownMember, names[k]) !==\n                                        innerCore.getRegistry(inheritedMember, names[k])) {\n\n                                        innerCore.setRegistry(inheritedMember, names[k],\n                                            innerCore.getRegistry(ownMember, names[k]));\n                                    }\n                                }\n                                innerCore.deleteNode(innerCore.getChild(setNode, ownMembers[i]), true);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n\n        //adding new functions\n        setCore.getSetNumbers = function (node) {\n            return this.getSetNames(node).length;\n        };\n\n        setCore.getSetNames = function (node) {\n            return innerCore.getPointerNames(innerCore.getChild(node, SETS_ID)) || [];\n        };\n\n        setCore.getPointerNames = function (node) {\n            var sorted = [],\n                raw = innerCore.getPointerNames(node);\n            for (var i = 0; i < raw.length; i++) {\n                if (raw[i].indexOf(REL_ID) === -1) {\n                    sorted.push(raw[i]);\n                }\n            }\n            return sorted;\n        };\n\n        setCore.getCollectionNames = function (node) {\n            var sorted = [],\n                raw = innerCore.getCollectionNames(node);\n            for (var i = 0; i < raw.length; i++) {\n                if (raw[i].indexOf(REL_ID) === -1) {\n                    sorted.push(raw[i]);\n                }\n            }\n            return sorted;\n        };\n\n        setCore.getMemberPaths = function (node, setName) {\n            harmonizeMemberData(node, setName);\n            ASSERT(typeof setName === 'string');\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName);\n            var members = [];\n            var elements = innerCore.getChildrenRelids(setNode);\n            elements = elements.sort(); //TODO this should be removed at some point\n            for (var i = 0; i < elements.length; i++) {\n                var path = getMemberPath(node, innerCore.getChild(setNode, elements[i]));\n                if (path) {\n                    members.push(path);\n                }\n            }\n            return members;\n        };\n\n        setCore.delMember = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            //we only need the path of the member so we allow to enter only it\n            if (typeof memberPath !== 'string') {\n                memberPath = innerCore.getPath(memberPath);\n            }\n\n            var setMemberRelId = getMemberRelId(node, setName, memberPath);\n            if (setMemberRelId) {\n                var setMemberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), setMemberRelId);\n\n                innerCore.deleteNode(setMemberNode, true);\n                setModified(node);\n            }\n        };\n\n        setCore.addMember = function (node, setName, member) {\n            ASSERT(typeof setName === 'string');\n            var setsNode = innerCore.getChild(node, SETS_ID),\n                setNode = innerCore.getChild(setsNode, setName),\n                setMemberRelId = getMemberRelId(node, setName, setCore.getPath(member));\n            if (setMemberRelId === null) {\n                createSetOnDemand(node, setName);\n                var setMember = innerCore.getChild(setNode, createNewMemberRelid(setNode));\n                innerCore.setPointer(setMember, 'member', member);\n\n                //TODO hack, somehow the empty children have been removed during persist\n                innerCore.setRegistry(setMember, '_', '_');\n                setModified(node);\n            }\n        };\n\n        //TODO: Refactor out getMemberNode:\n        //TODO: var memberNode = innerCore.getChild(\n        //TODO: innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n        setCore.getMemberAttributeNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getAttributeNames(memberNode);\n            }\n            return [];\n        };\n\n        setCore.getMemberOwnAttributeNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getOwnAttributeNames(memberNode);\n            }\n            return [];\n        };\n\n        setCore.getMemberAttribute = function (node, setName, memberPath, attrName) {\n            harmonizeMemberData(node, setName);\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getAttribute(memberNode, attrName);\n            }\n        };\n\n        setCore.setMemberAttribute = function (node, setName, memberPath, attrName, attrValue) {\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string' && attrValue !== undefined);\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.setAttribute(memberNode, attrName, attrValue);\n                setModified(node);\n            }\n        };\n\n        setCore.delMemberAttribute = function (node, setName, memberPath, attrName) {\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.delAttribute(memberNode, attrName);\n                setModified(node);\n            }\n        };\n\n        setCore.getMemberRegistryNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getRegistryNames(memberNode);\n            }\n            return [];\n        };\n        setCore.getMemberOwnRegistryNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getOwnRegistryNames(memberNode);\n            }\n            return [];\n        };\n        setCore.getMemberRegistry = function (node, setName, memberPath, regName) {\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getRegistry(memberNode, regName);\n            }\n        };\n        setCore.setMemberRegistry = function (node, setName, memberPath, regName, regValue) {\n            ASSERT(typeof setName === 'string' && typeof regName === 'string' && regValue !== undefined);\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.setRegistry(memberNode, regName, regValue);\n                setModified(node);\n            }\n        };\n        setCore.delMemberRegistry = function (node, setName, memberPath, regName) {\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.delRegistry(memberNode, regName);\n                setModified(node);\n            }\n        };\n\n        function createSetOnDemand(node, setName) {\n            //the function checks if there is no set defined on the node's level and create it\n            var setsNode = innerCore.getChild(node, SETS_ID);\n            if (innerCore.getOwnPointerPath(setsNode, setName) === undefined) {\n                setCore.createSet(node, setName);\n            }\n        }\n\n\n        setCore.createSet = function (node, setName) {\n            ASSERT(typeof setName === 'string');\n            var setsNode = innerCore.getChild(node, SETS_ID),\n                setNode = innerCore.getChild(setsNode, setName);\n\n            //FIXME: hack, somehow the empty children have been removed during persist\n            innerCore.setRegistry(setNode, '_', '_');\n\n            innerCore.setPointer(innerCore.getChild(node, SETS_ID), setName, null);\n            setModified(node);\n        };\n        setCore.deleteSet = function (node, setName) {\n            ASSERT(typeof setName === 'string');\n            var setsNode = innerCore.getChild(node, SETS_ID),\n                setNode = innerCore.getChild(setsNode, setName);\n            innerCore.deletePointer(setsNode, setName);\n            innerCore.deleteNode(setNode, true);\n            setModified(node);\n        };\n\n        setCore.isMemberOf = function (node) {\n            //TODO we should find a proper way to do this - or at least some support from lower layers would be fine\n            var coll = setCore.getCollectionPaths(node, REL_ID);\n            var sets = {};\n            for (var i = 0; i < coll.length; i++) {\n                var pathArray = coll[i].split('/');\n                if (pathArray.indexOf('_meta') === -1) {\n                    //now we simply skip META sets...\n                    var index = pathArray.indexOf(SETS_ID);\n                    if (index > 0 && pathArray.length > index + 1) {\n                        //otherwise it is not a real set\n                        var ownerPath = pathArray.slice(0, index).join('/');\n                        if (sets[ownerPath] === undefined) {\n                            sets[ownerPath] = [];\n                        }\n                        sets[ownerPath].push(pathArray[index + 1]);\n                    }\n                }\n            }\n            return sets;\n        };\n\n        /*setcore.getDataForSingleHash = function(node){\n         ASSERT(setcore.isValidNode(node));\n         var datas = innerCore.getDataForSingleHash(node);\n\n         //now we should stir all the sets hashes into the node's hash to get changes deep inside\n         var names = setcore.getSetNames(node);\n         for(var i=0;i<names.length;i++){\n         var setNode = setcore.getChild(setcore.getChild(node,SETS_ID),names[i]);\n         var memberRelids = setcore.getChildrenRelids(setNode);\n         for(var j=0;j<memberRelids.length;j++){\n         datas = datas.concat(innerCore.getDataForSingleHash(setcore.getChild(setNode,memberRelids[j])));\n         }\n         }\n\n         return datas;\n         };*/\n\n        return setCore;\n\n    }\n\n    return SetCore;\n});\n\n\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true, bitwise: false*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/util/guid',[],function () {\n    'use strict';\n\n    var guid = function () {\n        var S4 = function () {\n            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n        };\n\n        //return GUID\n        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());\n    };\n\n    return guid;\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/regexp',[], function () {\n    'use strict';\n    var HASH = new RegExp('^#[0-9a-zA-Z_]*$'),\n        BRANCH = new RegExp('^[0-9a-zA-Z_]*$'),\n        RAW_BRANCH = new RegExp('^\\\\*[0-9a-zA-Z_]*$'),// This is how it's stored in mongodb, i.e. with a prefixed *.\n        PROJECT = new RegExp('^(?!system\\\\.)(?!_)[0-9a-zA-Z_+]*$'), // project name may not start with system. or _\n\n        GUID = new RegExp('[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}', 'i');\n\n    return {\n        HASH: HASH,\n        BRANCH: BRANCH,\n        RAW_BRANCH: RAW_BRANCH,\n        PROJECT: PROJECT,\n        GUID: GUID\n    };\n});\n\n",
    "/*globals define*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/guidcore',[\n    'common/util/assert',\n    'common/util/guid',\n    'common/core/tasync',\n    'common/regexp'\n], function (ASSERT, GUID, TASYNC, REGEXP) {\n\n    'use strict';\n\n    var OWN_GUID = '_relguid';\n\n    function guidCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var logger = options.logger.fork('guidCore');\n        //helper functions\n        function toInternalGuid(myGuid) {\n            return myGuid.replace(/-/g, '');\n        }\n\n        function toExternalGuid(myGuid) {\n            var out = myGuid.substr(0, 8) + '-' + myGuid.substr(8, 4) + '-' +\n                myGuid.substr(12, 4) + '-' + myGuid.substr(16, 4) + '-' + myGuid.substr(20);\n            return out;\n        }\n\n        function guidToArray(guid) {\n            if (guid === null || guid === undefined) {\n                return [0, 0, 0, 0, 0, 0, 0, 0];\n            }\n            var array = [];\n            for (var i = 0; i < guid.length / 4; i++) {\n                array.push(parseInt(guid.substr(4 * i, 4), 16));\n            }\n            return array;\n        }\n\n        function getRelidGuid(node) {\n            //TODO we always should know what structure we should expect as a relid -\n            // now we think it is a number so it can be converted to 0xsomething\n            var relid = _core.getRelid(node);\n            relid = Number(relid);\n            if (relid === 'NaN') {\n                return null;\n            }\n            if (relid < 0) {\n                relid = relid * (-1);\n            }\n\n            relid = relid.toString(16);\n\n            //now we should fill up with 0's in the beggining\n            while (relid.length < 32) {\n                relid = relid + '0'; //TODO we pad to the end so the final result will be more visible during debug\n            }\n            return relid;\n        }\n\n        function xorGuids(a, b) {\n            var arrayA = guidToArray(a);\n            var arrayB = guidToArray(b);\n\n            ASSERT(arrayA.length === arrayB.length);\n\n            var arrayOut = [];\n            for (var i = 0; i < arrayA.length; i++) {\n                /*jshint bitwise: false*/\n                arrayOut.push(arrayA[i] ^ arrayB[i]);\n            }\n            for (i = 0; i < arrayOut.length; i++) {\n                arrayOut[i] = Number(arrayOut[i]).toString(16);\n                var difi = 4 - arrayOut[i].length;\n                while (difi > 0) {\n                    arrayOut[i] = '0' + arrayOut[i];\n                    difi--;\n                }\n            }\n            return arrayOut.join('');\n        }\n\n        var _core = {};\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n        logger.debug('initialized');\n        //new functions\n        _core.getMiddleGuid = function (node) {\n            var outGuid = _core.getAttribute(node, OWN_GUID);\n            var tempnode = _core.getParent(node);\n            while (tempnode) {\n                outGuid = xorGuids(outGuid, _core.getAttribute(tempnode, OWN_GUID));\n                tempnode = _core.getParent(tempnode);\n            }\n            return outGuid;\n        };\n\n        _core.getGuid = function (node) {\n            var middle = _core.getMiddleGuid(node),\n                relid = getRelidGuid(node),\n                guid = xorGuids(middle, relid);\n            return toExternalGuid(guid);\n        };\n\n        _core.setGuid = function (node, guid) {\n            ASSERT(REGEXP.GUID.test(guid));\n            var children = _core.loadChildren(node);\n            return TASYNC.call(function (nodeArray) {\n                var newGuid = toInternalGuid(guid);\n                //first setting the node's OWN_GUID\n                var oldOwn = _core.getAttribute(node, OWN_GUID);\n                var parent = _core.getParent(node);\n                if (parent) {\n                    _core.setAttribute(node, OWN_GUID,\n                        xorGuids(newGuid, xorGuids(_core.getMiddleGuid(parent), getRelidGuid(node))));\n                } else {\n                    _core.setAttribute(node, OWN_GUID, xorGuids(newGuid, getRelidGuid(node)));\n                }\n                var newOwn = _core.getAttribute(node, OWN_GUID);\n                //now modify its children's\n                for (var i = 0; i < nodeArray.length; i++) {\n                    var oldGuid = _core.getAttribute(nodeArray[i], OWN_GUID);\n                    _core.setAttribute(nodeArray[i], OWN_GUID, xorGuids(oldGuid, xorGuids(oldOwn, newOwn)));\n                }\n\n                return;\n            }, children);\n        };\n\n        //modified functions\n        _core.createNode = function (parameters) {\n            parameters = parameters || {};\n            var guid = parameters.guid || GUID(),\n                parent = parameters.parent;\n\n            ASSERT(REGEXP.GUID.test(guid));\n\n            var node = _innerCore.createNode(parameters);\n            guid = toInternalGuid(guid);\n\n            var relguid = '';\n            if (parent) {\n                relguid = xorGuids(toInternalGuid(_core.getMiddleGuid(_core.getParent(node))),\n                    xorGuids(guid, getRelidGuid(node)));\n            } else {\n                relguid = xorGuids(guid, getRelidGuid(node));\n            }\n            _innerCore.setAttribute(node, OWN_GUID, relguid);\n\n            return node;\n        };\n\n        _core.moveNode = function (node, parent) {\n            var oldGuid = toInternalGuid(_core.getGuid(node)),\n                newNode = _innerCore.moveNode(node, parent);\n\n            _core.setAttribute(newNode, OWN_GUID, xorGuids(_core.getMiddleGuid(parent),\n                xorGuids(oldGuid, getRelidGuid(newNode))));\n\n            return newNode;\n        };\n\n        _core.copyNode = function (node, parent) {\n            var newNode = _innerCore.copyNode(node, parent);\n            _core.setAttribute(newNode, OWN_GUID, toInternalGuid(GUID()));\n            return newNode;\n        };\n\n        _core.copyNodes = function (nodes, parent) {\n            var copiedNodes = _innerCore.copyNodes(nodes, parent),\n                i;\n            for (i = 0; i < copiedNodes.length; i++) {\n                _core.setAttribute(copiedNodes[i], OWN_GUID, toInternalGuid(GUID()));\n            }\n\n            return copiedNodes;\n        };\n\n        return _core;\n    }\n\n    return guidCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/nullpointercore',['common/util/assert'], function (ASSERT) {\n    'use strict';\n\n    var NULLPTR_NAME = '_null_pointer';\n    var NULLPTR_RELID = '_nullptr';\n\n\n    function nullPointerCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('nullpointercore');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n        logger.debug('initialized');\n\n        //extra functions\n        _core.setPointer = function (node, name, target) {\n            if (target === null) {\n                var nullChild = _innerCore.getChild(node, NULLPTR_RELID);\n                _innerCore.setAttribute(nullChild, 'name', NULLPTR_NAME);\n                _innerCore.setPointer(node, name, nullChild);\n            } else {\n                _innerCore.setPointer(node, name, target);\n            }\n        };\n\n        _core.getPointerPath = function (node, name) {\n            var path = _innerCore.getPointerPath(node, name);\n            if (path && path.indexOf(NULLPTR_RELID) !== -1) {\n                return null;\n            } else {\n                return path;\n            }\n        };\n\n        _core.loadPointer = function (node, name) {\n            var path = _core.getPointerPath(node, name);\n            if (path === null) {\n                return null;\n            } else {\n                return _innerCore.loadPointer(node, name);\n            }\n        };\n\n        return _core;\n    }\n\n    return nullPointerCore;\n});\n\n\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/coreunwrap',['common/util/assert', 'common/core/tasync'], function (ASSERT, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreUnwrap -----------------\n\n    var CoreUnwrap = function (oldcore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var logger = options.logger.fork('coreunwrap');\n\n        function checkNode(node) {\n            if (node === null || oldcore.isValidNode(node)) {\n                return node;\n            } else {\n                throw new Error('Invalid result node');\n            }\n        }\n\n        function checkNodes(nodes) {\n            ASSERT(nodes instanceof Array);\n\n            var i;\n            for (i = 0; i < nodes.length; ++i) {\n                if (!oldcore.isValidNode(nodes[i])) {\n                    throw new Error('Invalid result node array');\n                }\n            }\n\n            return nodes;\n        }\n\n        // copy all operations\n        var core = {};\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        core.loadRoot = TASYNC.unwrap(oldcore.loadRoot);\n        //core.persist = TASYNC.unwrap(oldcore.persist);\n\n        // core.loadChild = TASYNC.unwrap(oldcore.loadChild);\n        core.loadChild = TASYNC.unwrap(function (node, relid) {\n            return TASYNC.call(checkNode, oldcore.loadChild(node, relid));\n        });\n\n        // core.loadByPath = TASYNC.unwrap(oldcore.loadByPath);\n        core.loadByPath = TASYNC.unwrap(function (node, path) {\n            return TASYNC.call(checkNode, oldcore.loadByPath(node, path));\n        });\n\n        // core.loadChildren = TASYNC.unwrap(oldcore.loadChildren);\n        core.loadChildren = TASYNC.unwrap(function (node) {\n            return TASYNC.call(checkNodes, oldcore.loadChildren(node));\n        });\n\n        core.loadPointer = TASYNC.unwrap(oldcore.loadPointer);\n        core.loadCollection = TASYNC.unwrap(oldcore.loadCollection);\n\n        core.loadSubTree = TASYNC.unwrap(oldcore.loadSubTree);\n        core.loadTree = TASYNC.unwrap(oldcore.loadTree);\n\n        //core diff async functions\n        if (typeof oldcore.generateTreeDiff === 'function') {\n            core.generateTreeDiff = TASYNC.unwrap(oldcore.generateTreeDiff);\n        }\n\n        if (typeof oldcore.generateLightTreeDiff === 'function') {\n            core.generateLightTreeDiff = TASYNC.unwrap(oldcore.generateLightTreeDiff);\n        }\n\n        if (typeof oldcore.applyTreeDiff === 'function') {\n            core.applyTreeDiff = TASYNC.unwrap(oldcore.applyTreeDiff);\n        }\n\n        return core;\n    };\n\n    return CoreUnwrap;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/coretype',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreType -----------------\n\n    //FIXME TODO these stuff have been simply copied from lower layer, probably it should be put to some constant place\n    var OVERLAYS = 'ovr';\n    var COLLSUFFIX = '-inv';\n\n    var CoreType = function (oldcore, options) {\n        // copy all operations\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var core = {},\n            logger = options.logger.fork('coretype');\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        // ----- validity\n\n        function __test(text, cond) {\n            if (!cond) {\n                throw new Error(text);\n            }\n        }\n\n        function isValidNode(node) {\n            try {\n                __test('core', oldcore.isValidNode(node));\n                __test('base', typeof node.base === 'object');\n                return true;\n            } catch (error) {\n                logger.error(error.message, {stack: error.stack, node: node});\n                return false;\n            }\n        }\n\n        function isFalseNode(node) {\n            //TODO this hack should be removed, but now it seems just fine :)\n            if (typeof oldcore.getPointerPath(node, 'base') === 'undefined') {\n                return true;\n            }\n            return false;\n        }\n\n        core.isValidNode = isValidNode;\n\n        //check of inheritance chain and containment hierarchy collision\n        core.isInheritanceContainmentCollision = function (node, parent) {\n            var parentPath = core.getPath(parent),\n                bases = [];\n\n            while (node) {\n                bases.push(core.getPath(node));\n                node = core.getBase(node);\n            }\n\n            while (parent) {\n                if (bases.indexOf(core.getPath(parent)) !== -1) {\n                    return true;\n                }\n                parent = core.getParent(parent);\n            }\n            return false;\n        };\n\n        // ----- navigation\n\n        core.getBase = function (node) {\n            ASSERT(isValidNode(node));\n\n            // TODO: check if base has moved\n            return node.base;\n        };\n\n        core.getBaseRoot = function (node) {\n            ASSERT(isValidNode(node));\n            while (node.base !== null) {\n                node = node.base;\n            }\n\n            return node;\n        };\n\n        core.loadRoot = function (hash) {\n            return TASYNC.call(__loadRoot2, oldcore.loadRoot(hash));\n        };\n\n        function __loadRoot2(node) {\n            ASSERT(typeof node.base === 'undefined' || node.base === null);\n            //kecso - TODO it should be undefined, but maybe because of the cache it can be null\n\n            node.base = null;\n            return node;\n        }\n\n        function _loadChild(node, relid) {\n            var child = null,\n                base = core.getBase(node),\n                basechild = null;\n            if (base) {\n                //the parent is inherited\n                if (core.getChildrenRelids(base).indexOf(relid) !== -1) {\n                    //inherited child\n                    if (oldcore.getChildrenRelids(node).indexOf(relid) !== -1) {\n                        //but it is overwritten so we should load it\n                        child = oldcore.loadChild(node, relid);\n                    }\n                    basechild = core.loadChild(base, relid);\n                    return TASYNC.call(function (b, c, n, r) {\n                        if (c) {\n                            child = c;\n                            child.base = b;\n                            return child;\n                        } else {\n                            child = oldcore.getChild(n, r);\n                            core.setHashed(child, true, true);\n                            child.base = b;\n\n                            return child;\n                        }\n                    }, basechild, child, node, relid);\n                }\n            }\n            //normal child\n            return TASYNC.call(__loadBase, oldcore.loadChild(node, relid));\n        }\n\n        core.loadChild = function (node, relid) {\n            return TASYNC.call(function (child) {\n                if (child && core.isInheritanceContainmentCollision(child, core.getParent(child))) {\n                    logger.error('node[' + core.getPath(child) + '] was deleted due to inheritance-containment collision');\n                    core.deleteNode(child);\n                    //core.persist(core.getRoot(child));\n                    return null;\n                } else {\n                    return child;\n                }\n            }, _loadChild(node, relid));\n        };\n\n        core.loadByPath = function (node, path) {\n            ASSERT(isValidNode(node));\n            ASSERT(path === '' || path.charAt(0) === '/');\n            path = path.split('/');\n            return loadDescendantByPath(node, path, 1);\n        };\n\n        var loadDescendantByPath = function (node, pathArray, index) {\n            if (node === null || index === pathArray.length) {\n                return node;\n            }\n\n            var child = core.loadChild(node, pathArray[index]);\n            return TASYNC.call(loadDescendantByPath, child, pathArray, index + 1);\n        };\n\n        //TODO the pointer loading is totally based upon the loadByPath...\n        core.loadPointer = function (node, name) {\n            var pointerPath = core.getPointerPath(node, name);\n            if (pointerPath === undefined) {\n                return undefined;\n            }\n            if (pointerPath === null) {\n                return null;\n            }\n            return TASYNC.call(core.loadByPath, core.getRoot(node), pointerPath);\n        };\n\n        function __loadBase(node) {\n            var path = oldcore.getPath(node);\n            ASSERT(node === null || typeof node.base === 'undefined' || typeof node.base === 'object');\n\n            if (typeof node.base === 'undefined') {\n                if (core.isEmpty(node)) {\n                    //empty nodes do not have a base\n                    node.base = null;\n                    return node;\n                } else if (isFalseNode(node)) {\n                    oldcore.deleteNode(node);\n                    //core.persist(core.getRoot(node));\n                    //TODO a notification should be generated towards the user\n                    logger.warn('node [' + path + '] removed due to missing base'); //TODO check if some identification can be passed\n                    return null;\n                } else {\n                    var basePath = oldcore.getPointerPath(node, 'base');\n                    ASSERT(basePath !== undefined);\n                    if (basePath === null) {\n                        node.base = null;\n                        return node;\n                    } else if (core.isContainerPath(basePath, path)) {\n                        //contained base error\n                        logger.error('node [' + path + '] contains its own base!');\n                        oldcore.deleteNode(node);\n                        //core.persist(core.getRoot(node));\n                        return null;\n                    } else {\n                        return TASYNC.call(__loadBase2, node, core.loadByPath(core.getRoot(node), basePath));\n                    }\n                }\n            } else {\n                //TODO can the base change at this point???\n                return node;\n            }\n        }\n\n        function __loadBase2(node, target) {\n            if (typeof node.base !== null && typeof node.base === 'object' &&\n                (oldcore.getPath(node.base) === oldcore.getPath(target))) {\n                //TODO somehow the object already loaded properly and we do no know about it!!!\n                return node;\n            } else {\n                ASSERT(typeof node.base === 'undefined' || node.base === null); //kecso\n\n                if (target === null) {\n                    node.base = null;\n                    return node;\n                } else {\n                    return TASYNC.call(function (n, b) {\n                        n.base = b;\n                        return n;\n                    }, node, __loadBase(target));\n                }\n            }\n        }\n\n        core.getChildrenRelids = function (node) {\n            var inheritRelIds = node.base === null ? [] : core.getChildrenRelids(core.getBase(node));\n            var ownRelIds = oldcore.getChildrenRelids(node);\n            for (var i = 0; i < inheritRelIds.length; i++) {\n                if (ownRelIds.indexOf(inheritRelIds[i]) === -1) {\n                    ownRelIds.push(inheritRelIds[i]);\n                }\n            }\n            return ownRelIds;\n        };\n\n        core.loadChildren = function (node) {\n            ASSERT(isValidNode(node));\n            var relids = core.getChildrenRelids(node);\n            relids = relids.sort(); //TODO this should be temporary\n            var children = [];\n            for (var i = 0; i < relids.length; i++) {\n                children[i] = core.loadChild(node, relids[i]);\n            }\n            return TASYNC.call(function (n) {\n                var newn = [];\n                for (var i = 0; i < n.length; i++) {\n                    if (n[i] !== null) {\n                        newn.push(n[i]);\n                    }\n                }\n                return newn;\n            }, TASYNC.lift(children));\n        };\n\n        //collection handling and needed functions\n        function _isInheritedChild(node) {\n            var parent = core.getParent(node),\n                base = core.getBase(node),\n                parentBase = parent ? core.getBase(parent) : null,\n                baseParent = base ? core.getParent(base) : null;\n\n            if (baseParent && parentBase && core.getPath(baseParent) === core.getPath(parentBase)) {\n                return true;\n            }\n            return false;\n        }\n\n        function _getInstanceRoot(node) {\n\n            while (_isInheritedChild(node)) {\n                node = core.getParent(node);\n            }\n\n            return node;\n        }\n\n        //TODO copied function from corerel\n        function isPointerName(name) {\n            ASSERT(typeof name === 'string');\n\n            return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\n        }\n\n        function _getInheritedCollectionNames(node) {\n            var target = '',\n                names = [],\n                coretree = core.getCoreTree(),\n                startNode = node,\n                endNode = _getInstanceRoot(node),\n                exit;\n\n            if (core.getPath(startNode) === core.getPath(endNode)) {\n                return names;\n            }\n\n            do {\n                startNode = core.getBase(startNode);\n                endNode = core.getBase(endNode);\n                node = startNode;\n                exit = false;\n                target = '';\n                do {\n                    if (core.getPath(node) === core.getPath(endNode)) {\n                        exit = true;\n                    }\n                    var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\n                    if (child) {\n                        for (var name in child) {\n                            if (!isPointerName(name)) {\n                                name = name.slice(0, -COLLSUFFIX.length);\n                                if (names.indexOf(name) < 0) {\n                                    names.push(name);\n                                }\n                            }\n                        }\n                    }\n\n                    target = '/' + coretree.getRelid(node) + target;\n                    node = coretree.getParent(node);\n                } while (!exit);\n            } while (_isInheritedChild(startNode));\n\n            return names;\n        }\n\n        function _getInheritedCollectionPaths(node, name) {\n            var target = '',\n                result = [],\n                coretree = core.getCoreTree(),\n                startNode = node,\n                endNode = _getInstanceRoot(node),\n                prefixStart = startNode,\n                prefixNode = prefixStart,\n                exit,\n                collName = name + COLLSUFFIX,\n                notOverwritten = function (sNode, eNode, source) {\n                    var result = true,\n                        tNode = sNode,\n                        child, target;\n\n                    while (core.getPath(tNode) !== core.getPath(eNode)) {\n                        child = coretree.getChild(tNode, OVERLAYS);\n                        child = coretree.getChild(child, source);\n                        if (child) {\n                            target = coretree.getProperty(child, name);\n                            if (target) {\n                                return false;\n                            }\n                        }\n                        tNode = core.getBase(tNode);\n                    }\n\n                    return result;\n                };\n\n            if (core.getPath(startNode) === core.getPath(endNode)) {\n                return result;\n            }\n\n            do {\n                startNode = core.getBase(startNode);\n                endNode = core.getBase(endNode);\n                node = startNode;\n                prefixNode = prefixStart;\n                exit = false;\n                target = '';\n                do {\n                    if (core.getPath(node) === core.getPath(endNode)) {\n                        exit = true;\n                    }\n                    var child = coretree.getChild(node, OVERLAYS);\n                    child = coretree.getChild(child, target);\n                    if (child) {\n                        var sources = coretree.getProperty(child, collName);\n                        if (sources) {\n                            ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                            var prefix = coretree.getPath(prefixNode);\n\n                            for (var i = 0; i < sources.length; ++i) {\n                                if (notOverwritten(prefixNode, node, sources[i])) {\n                                    result.push(coretree.joinPaths(prefix, sources[i]));\n                                }\n                            }\n                        }\n                    }\n\n                    target = '/' + coretree.getRelid(node) + target;\n                    node = coretree.getParent(node);\n                    prefixNode = core.getParent(prefixNode);\n                } while (!exit);\n            } while (_isInheritedChild(startNode));\n\n            return result;\n        }\n\n        core.getCollectionNames = function (node) {\n            ASSERT(isValidNode(node));\n            var checkCollNames = function (draft) {\n                    var filtered = [],\n                        i, sources;\n                    for (i = 0; i < draft.length; i++) {\n                        sources = core.getCollectionPaths(node, draft[i]);\n                        if (sources.length > 0) {\n                            filtered.push(draft[i]);\n                        }\n                    }\n                    return filtered;\n                },\n                ownNames = oldcore.getCollectionNames(node),\n                inhNames = checkCollNames(_getInheritedCollectionNames(node)),\n                i;\n            for (i = 0; i < ownNames.length; i++) {\n                if (inhNames.indexOf(ownNames[i]) < 0) {\n                    inhNames.push(ownNames[i]);\n                }\n            }\n\n            return inhNames;\n        };\n\n        core.getCollectionPaths = function (node, name) {\n            ASSERT(isValidNode(node) && name);\n            var ownPaths = oldcore.getCollectionPaths(node, name),\n                inhPaths = _getInheritedCollectionPaths(node, name);\n\n            inhPaths = inhPaths.concat(ownPaths);\n\n            return inhPaths;\n        };\n\n        core.loadCollection = function (node, name) {\n            var root = core.getRoot(node);\n            var paths = core.getCollectionPaths(node, name);\n\n            var nodes = [];\n            for (var i = 0; i < paths.length; i++) {\n                nodes[i] = core.loadByPath(root, paths[i]);\n            }\n\n            return TASYNC.lift(nodes);\n        };\n\n        // ----- creation\n\n        core.createNode = function (parameters) {\n            parameters = parameters || {};\n            var base = parameters.base || null,\n                parent = parameters.parent;\n\n\n            ASSERT(!parent || isValidNode(parent));\n            ASSERT(!base || isValidNode(base));\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\n\n            var node = oldcore.createNode(parameters);\n            node.base = base;\n            oldcore.setPointer(node, 'base', base);\n\n            return node;\n        };\n\n        // ----- properties\n\n        core.getAttributeNames = function (node) {\n            ASSERT(isValidNode(node));\n\n            var merged = {};\n            do {\n                var names = oldcore.getAttributeNames(node);\n                for (var i = 0; i < names.length; ++i) {\n                    if (!(names[i] in merged)) {\n                        merged[names[i]] = true;\n                    }\n                }\n\n                node = node.base;\n            } while (node);\n\n            return Object.keys(merged);\n        };\n        core.getOwnAttributeNames = function (node) {\n            return oldcore.getAttributeNames(node);\n        };\n\n        core.getRegistryNames = function (node) {\n            ASSERT(isValidNode(node));\n\n            var merged = {};\n            do {\n                var names = oldcore.getRegistryNames(node);\n                for (var i = 0; i < names.length; ++i) {\n                    if (!(names[i] in merged)) {\n                        merged[names[i]] = true;\n                    }\n                }\n\n                node = node.base;\n            } while (node);\n\n            return Object.keys(merged);\n        };\n        core.getOwnRegistryNames = function (node) {\n            return oldcore.getRegistryNames(node);\n        };\n\n        core.getAttribute = function (node, name) {\n            ASSERT(isValidNode(node));\n            var value;\n            do {\n                value = oldcore.getAttribute(node, name);\n                node = node.base;\n            } while (typeof value === 'undefined' && node !== null);\n\n            return value;\n        };\n        core.getOwnAttribute = function (node, name) {\n            return oldcore.getAttribute(node, name);\n        };\n\n        core.getRegistry = function (node, name) {\n            ASSERT(isValidNode(node));\n            var value;\n            do {\n                value = oldcore.getRegistry(node, name);\n                node = node.base;\n            } while (typeof value === 'undefined' && node !== null);\n\n            return value;\n        };\n        core.getOwnRegistry = function (node, name) {\n            return oldcore.getRegistry(node, name);\n        };\n\n\n        // ----- pointers\n\n        core.getPointerNames = function (node) {\n            ASSERT(isValidNode(node));\n\n            var merged = {};\n            do {\n                var names = oldcore.getPointerNames(node);\n                for (var i = 0; i < names.length; ++i) {\n                    if (!(names[i] in merged)) {\n                        merged[names[i]] = true;\n                    }\n                }\n\n                node = node.base;\n            } while (node);\n\n            return Object.keys(merged);\n        };\n        core.getOwnPointerNames = function (node) {\n            ASSERT(isValidNode(node));\n            return oldcore.getPointerNames(node);\n        };\n\n        core.getPointerPath = function (node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var ownPointerPath = oldcore.getPointerPath(node, name);\n            if (ownPointerPath !== undefined) {\n                return ownPointerPath;\n            }\n            var source = '',\n                target,\n                coretree = core.getCoreTree(),\n                basePath,\n                hasNullTarget = false,\n                getProperty = function (node, name) {\n                    var property;\n                    while (property === undefined && node !== null) {\n                        property = coretree.getProperty(node, name);\n                        node = core.getBase(node);\n                    }\n                    return property;\n                },\n                getSimpleBasePath = function (node) {\n                    var path = oldcore.getPointerPath(node, name);\n                    if (path === undefined) {\n                        if (node.base !== null && node.base !== undefined) {\n                            return getSimpleBasePath(node.base);\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return path;\n                    }\n                },\n                getParentOfBasePath = function (node) {\n                    if (node.base) {\n                        var parent = core.getParent(node.base);\n                        if (parent) {\n                            return core.getPath(parent);\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return undefined;\n                    }\n                },\n                getBaseOfParentPath = function (node) {\n                    var parent = core.getParent(node);\n                    if (parent) {\n                        if (parent.base) {\n                            return core.getPath(parent.base);\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return undefined;\n                    }\n                },\n                getTargetRelPath = function (node, relSource, name) {\n                    var ovr = core.getChild(node, 'ovr');\n                    var source = core.getChild(ovr, relSource);\n                    return getProperty(source, name);\n                };\n\n            basePath = node.base ? getSimpleBasePath(node.base) : undefined;\n\n            while (node) {\n                target = getTargetRelPath(node, source, name);\n                if (target !== undefined) {\n                    if (target.indexOf('_nullptr') !== -1) {\n                        hasNullTarget = true;\n                        target = undefined;\n                    } else {\n                        break;\n                    }\n                }\n\n                source = '/' + core.getRelid(node) + source;\n                if (getParentOfBasePath(node) === getBaseOfParentPath(node)) {\n                    node = core.getParent(node);\n                } else {\n                    node = null;\n                }\n            }\n\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(oldcore.getPath(node), target);\n            }\n\n            if (typeof target === 'string') {\n                return target;\n            }\n            if (typeof basePath === 'string') {\n                return basePath;\n            }\n            if (hasNullTarget === true) {\n                return null;\n            }\n            return undefined;\n\n        };\n        core.getOwnPointerPath = function (node, name) {\n            oldcore.getPointerPath(node, name);\n        };\n\n        core.setBase = function (node, base) {\n            ASSERT(isValidNode(node) && (base === undefined || base === null || isValidNode(base)));\n            ASSERT(!base || core.getPath(core.getParent(node)) !== core.getPath(base));\n            ASSERT(!base || core.getPath(node) !== core.getPath(base));\n\n            var oldBase = core.getBase(node);\n\n            //TODO this restriction should be removed after clarification of the different scenarios and outcomes\n            //changing base from or to a node which has children is not allowed currently\n            ASSERT((base === null || oldBase === null) ||\n                (core.getChildrenRelids(base).length === 0 && core.getChildrenRelids(oldBase).length === 0));\n\n\n            if (!!base) {\n                //TODO maybe this is not the best way, needs to be double checked\n                node.base = base;\n                var parent = core.getParent(node),\n                    parentBase, baseParent;\n                if (parent) {\n                    parentBase = core.getBase(parent);\n                    baseParent = core.getParent(base);\n                    if (core.getPath(parentBase) !== core.getPath(baseParent)) {\n                        //we have to set an exact pointer only if it is not inherited child\n                        oldcore.setPointer(node, 'base', base);\n                    } else {\n                        oldcore.deletePointer(node, 'base'); //we remove the pointer just in case\n                    }\n                } else {\n                    //if for some reason the node doesn't have a parent it is surely not an inherited child\n                    oldcore.setPointer(node, 'base', base);\n                }\n            } else {\n                oldcore.setPointer(node, 'base', null);\n                node.base = null;\n            }\n        };\n\n        core.getChild = function (node, relid) {\n            ASSERT(isValidNode(node) && (typeof node.base === 'undefined' || typeof node.base === 'object'));\n            var child = oldcore.getChild(node, relid);\n            if (node.base !== null && node.base !== undefined) {\n                if (child.base === null || child.base === undefined) {\n                    child.base = core.getChild(node.base, relid);\n                }\n            } else {\n                child.base = null;\n            }\n            return child;\n        };\n        core.moveNode = function (node, parent) {\n            //TODO we have to check if the move is really allowed!!!\n            ASSERT(isValidNode(node) && isValidNode(parent));\n            var base = node.base,\n                parentBase = parent.base;\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\n            ASSERT(!parentBase || core.getPath(parentBase) !== core.getPath(node));\n\n            var moved = oldcore.moveNode(node, parent);\n            moved.base = base;\n            return moved;\n        };\n        core.copyNode = function (node, parent) {\n            var base = node.base;\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\n\n            var newnode = oldcore.copyNode(node, parent);\n            newnode.base = base;\n            oldcore.setPointer(newnode, 'base', base);\n            return newnode;\n        };\n        function _inheritedPointerNames(node) {\n            var allNames = core.getPointerNames(node),\n                ownNames = core.getOwnPointerNames(node),\n                names = [],\n                i;\n\n            for (i = 0; i < allNames.length; i++) {\n                if (ownNames.indexOf(allNames[i]) === -1) {\n                    names.push(allNames[i]);\n                }\n            }\n\n            return names;\n        }\n\n        core.copyNodes = function (nodes, parent) {\n            var copiedNodes,\n                i, j, index, base,\n                relations = [],\n                names, pointer,\n                paths = [];\n\n            //here we also have to copy the inherited relations which points inside the copy area\n            for (i = 0; i < nodes.length; i++) {\n                paths.push(core.getPath(nodes[i]));\n            }\n\n            for (i = 0; i < nodes.length; i++) {\n                names = _inheritedPointerNames(nodes[i]);\n                pointer = {};\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(core.getPointerPath(nodes[i], names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                relations.push(pointer);\n            }\n\n            //making the actual copy\n            copiedNodes = oldcore.copyNodes(nodes, parent);\n\n            //setting internal-inherited relations\n            for (i = 0; i < nodes.length; i++) {\n                names = Object.keys(relations[i]);\n                for (j = 0; j < names.length; j++) {\n                    core.setPointer(copiedNodes[i], names[j], copiedNodes[relations[i][names[j]]]);\n                }\n            }\n\n            //setting base relation\n            for (i = 0; i < nodes.length; i++) {\n                base = nodes[i].base;\n                copiedNodes[i].base = base;\n                oldcore.setPointer(copiedNodes[i], 'base', base);\n            }\n\n\n            return copiedNodes;\n        };\n\n        core.getChildrenPaths = function (node) {\n            var path = core.getPath(node);\n\n            var relids = core.getChildrenRelids(node);\n            for (var i = 0; i < relids.length; ++i) {\n                relids[i] = path + '/' + relids[i];\n            }\n\n            return relids;\n        };\n\n        core.deleteNode = function (node, technical) {\n            //currently we only check if the node is inherited from its parents children\n            if (node && (node.base !== null || technical === true)) {\n                var parent = core.getParent(node),\n                    parentsBase = parent ? core.getBase(node) : null,\n                    base = core.getBase(node),\n                    basesParent = base ? core.getParent(node) : null;\n\n                if (parent && parentsBase && base && basesParent) {\n                    if (core.getPath(parentsBase) !== core.getPath(basesParent)) {\n                        oldcore.deleteNode(node);\n                    }\n                } else {\n                    oldcore.deleteNode(node);\n                }\n            }\n        };\n\n        core.getTypeRoot = function (node) {\n            if (node.base) {\n                while (node.base !== null) {\n                    node = core.getBase(node);\n                }\n                return node;\n            } else {\n                return null;\n            }\n        };\n\n        // -------- kecso\n\n        return core;\n    };\n\n    return CoreType;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n *\n * example constraint structure for the outside world:\n * {\n *  script:string,\n *  priority:integer,\n *  name:string,\n *  message:string\n * }\n * provided API:\n * getConstraint(node,name) -> constraintObj\n * setConstraint(node,constraintObj)\n * getConstraintNames(node)\n * delConstraint(node,name)\n */\n\ndefine('common/core/constraintcore',['common/util/assert'], function (ASSERT) {\n    'use strict';\n    var CONSTRAINTS_RELID = '_constraints';\n    var C_DEF_PRIORITY = 1;\n\n    function constraintCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('constraintcore');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n        logger.debug('initialized');\n        var createNewConstraintRelId = function (constraintsNode) {\n            var max = Math.pow(2, 31);\n            var existingRelIds = _innerCore.getChildrenRelids(constraintsNode);\n            var relId;\n            do {\n                relId = Math.floor(Math.random() * max);\n            } while (existingRelIds.indexOf(relId) !== -1);\n            return '' + relId;\n        };\n\n        var getConstraintRelId = function (constraintsNode, name) {\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\n            var relId;\n            for (var i = 0; i < relIds.length; i++) {\n                if (name === _innerCore.getAttribute(_innerCore.getChild(constraintsNode, relIds[i]), 'name')) {\n                    relId = relIds[i];\n                    break;\n                }\n            }\n            return relId;\n        };\n        var getRegConstName = function (name) {\n            return '_ch#_' + name;\n        };\n\n        _core.getConstraint = function (node, name) {\n            ASSERT(_innerCore.isValidNode(node));\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var constRelId = getConstraintRelId(constraintsNode, name);\n            if (constRelId) {\n                var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\n                return {\n                    script: _innerCore.getAttribute(constraintNode, 'script'),\n                    priority: _innerCore.getAttribute(constraintNode, 'priority'),\n                    info: _innerCore.getAttribute(constraintNode, 'info')\n                };\n            } else {\n                return null;\n            }\n        };\n\n        _core.setConstraint = function (node, name, constraintObj) {\n            ASSERT(_innerCore.isValidNode(node));\n            ASSERT(typeof constraintObj === 'object' && typeof name === 'string');\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var constRelId = getConstraintRelId(constraintsNode, name);\n            if (!constRelId) {\n                //we should create a new one\n                constRelId = createNewConstraintRelId(constraintsNode);\n            }\n\n            var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\n            constraintObj.priority = constraintObj.priority || C_DEF_PRIORITY;\n            constraintObj.script = constraintObj.script || 'console.log(\"empty constraint\");';\n            constraintObj.info = constraintObj.info || '';\n            _innerCore.setAttribute(constraintNode, 'name', name);\n            _innerCore.setAttribute(constraintNode, 'script', constraintObj.script);\n            _innerCore.setAttribute(constraintNode, 'priority', constraintObj.priority);\n            _innerCore.setAttribute(constraintNode, 'info', constraintObj.info);\n            _innerCore.setRegistry(node, getRegConstName(name),\n                (_innerCore.getRegistry(node, getRegConstName(name)) || 0) + 1);\n        };\n\n        _core.delConstraint = function (node, name) {\n            ASSERT(_innerCore.isValidNode(node));\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var constRelId = getConstraintRelId(constraintsNode, name);\n            if (constRelId) {\n                var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\n                _innerCore.deleteNode(constraintNode, true);\n            }\n            _innerCore.delRegistry(node, getRegConstName(name));\n        };\n\n        _core.getConstraintNames = function (node) {\n            ASSERT(_innerCore.isValidNode(node));\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\n            var names = [];\n            for (var i = 0; i < relIds.length; i++) {\n                names.push(_innerCore.getAttribute(_innerCore.getChild(constraintsNode, relIds[i]), 'name'));\n            }\n            return names;\n        };\n\n        //TODO this means we always have to have this layer above type/inheritance layer\n        _core.getOwnConstraintNames = function (node) {\n            ASSERT(_innerCore.isValidNode(node));\n            var names = _core.getConstraintNames(node),\n                base = _core.getBase(node),\n                baseNames = [],\n                i, index;\n\n            if (base) {\n                baseNames = _core.getConstraintNames(base);\n            }\n\n            for (i = 0; i < baseNames.length; i++) {\n                index = names.indexOf(baseNames[i]);\n                if (index !== -1) {\n                    names.splice(index, 1);\n                }\n            }\n\n            return names;\n        };\n\n        return _core;\n    }\n\n    return constraintCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/metacore',[\n    'common/util/assert',\n    'common/core/core',\n    'common/core/tasync',\n    'common/util/canon'\n], function (ASSERT, Core, TASYNC, CANON) {\n    'use strict';\n\n    // ----------------- CoreType -----------------\n\n    var MetaCore = function (oldcore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        // copy all operations\n        var core = {},\n            logger = options.logger.fork('metacore');\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        var sameNode = function (nodeA, nodeB) {\n            if (core.getPath(nodeA) === core.getPath(nodeB)) {\n                return true;\n            }\n            return false;\n        };\n\n        var realNode = function (node) { //TODO we have to make some more sophisticated distinction\n            if (core.getPath(node).indexOf('_') !== -1) {\n                return false;\n            }\n            return true;\n        };\n\n        var getMetaNode = function (node) {\n            return core.getChild(node, '_meta');\n        };\n        var getMetaChildrenNode = function (node) {\n            return core.getChild(getMetaNode(node), 'children');\n        };\n        var getMetaPointerNode = function (node, name) {\n            var meta = getMetaNode(node),\n                pointerNames = core.getPointerNames(meta) || [];\n            if (pointerNames.indexOf(name) !== -1) {\n                return core.getChild(meta, '_p_' + name);\n            }\n            return null;\n        };\n        var _MetaPointerNode = function (node, name) {\n            //this function always gives back a node, use this if you just want to create the node as well\n            core.setPointer(getMetaNode(node), name, null);\n            return core.getChild(getMetaNode(node), '_p_' + name);\n        };\n\n        var getMetaAspectsNode = function (node) {\n            return core.getChild(getMetaNode(node), 'aspects');\n        };\n        var getMetaAspectNode = function (node, name) {\n            var aspectNode = getMetaAspectsNode(node),\n                names = core.getPointerNames(aspectNode) || [];\n            if (names.indexOf(name) !== -1) {\n                return core.getChild(aspectNode, '_a_' + name);\n            }\n            return null;\n        };\n\n        var _MetaAspectNode = function (node, name) {\n            //this function always gives back a node, use this if you just want to create the node as well\n            var aspectNode = core.getChild(getMetaNode(node), 'aspects');\n\n            core.setPointer(aspectNode, name, null);\n            return core.getChild(aspectNode, '_a_' + name);\n        };\n        //now the additional functions\n        core.isTypeOf = function (node, typeNode) {\n            if (!realNode(node)) {\n                return false;\n            }\n            while (node) {\n                if (sameNode(node, typeNode)) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n            return false;\n        };\n\n        core.isValidChildOf = function (node, parentNode) {\n            if (!realNode(node)) {\n                return true;\n            }\n            var validChildTypePaths = core.getMemberPaths(getMetaChildrenNode(parentNode), 'items') || [];\n            while (node) {\n                if (validChildTypePaths.indexOf(core.getPath(node)) !== -1) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n            return false;\n        };\n\n        core.getValidPointerNames = function (node) {\n            var validNames = core.getPointerNames(getMetaNode(node)) || [],\n                i,\n                validPointerNames = [],\n                metaPointerNode, max;\n            for (i = 0; i < validNames.length; i++) {\n                metaPointerNode = getMetaPointerNode(node, validNames[i]);\n                max = core.getAttribute(metaPointerNode, 'max');\n                if (max === 1) {\n                    //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\n                    validPointerNames.push(validNames[i]);\n                }\n            }\n\n            return validPointerNames;\n        };\n\n        core.getValidSetNames = function (node) {\n            var validNames = core.getPointerNames(getMetaNode(node)) || [],\n                i,\n                validSetNames = [],\n                metaPointerNode, max;\n\n            for (i = 0; i < validNames.length; i++) {\n                metaPointerNode = getMetaPointerNode(node, validNames[i]);\n                max = core.getAttribute(metaPointerNode, 'max');\n                if (max === undefined || max === -1 || max > 1) {\n                    //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\n                    validSetNames.push(validNames[i]);\n                }\n            }\n\n            return validSetNames;\n        };\n\n        core.isValidTargetOf = function (node, source, name) {\n            if (!realNode(source) || node === null) { //we position ourselves over the null-pointer layer\n                return true;\n            }\n            var pointerMetaNode = getMetaPointerNode(source, name);\n            if (pointerMetaNode) {\n                var validTargetTypePaths = core.getMemberPaths(pointerMetaNode, 'items') || [];\n                while (node) {\n                    if (validTargetTypePaths.indexOf(core.getPath(node)) !== -1) {\n                        return true;\n                    }\n                    node = core.getBase(node);\n                }\n            }\n            return false;\n        };\n\n        core.getValidAttributeNames = function (node) {\n            var names = [];\n            if (realNode(node)) {\n                names = core.getAttributeNames(getMetaNode(node)) || [];\n            }\n            return names;\n        };\n\n        core.isValidAttributeValueOf = function (node, name, value) {\n            //currently it only checks the name and the type\n            if (!realNode(node)) {\n                return true;\n            }\n            if (core.getValidAttributeNames(node).indexOf(name) === -1) {\n                return false;\n            }\n            var meta = core.getAttribute(getMetaNode(node), name);\n            switch (meta.type) {\n                case 'boolean':\n                    if (value === true || value === false) {\n                        return true;\n                    }\n                    break;\n                case 'string':\n                case 'asset':\n                    if (typeof value === 'string') {\n                        return true;\n                    }\n                    break;\n                case 'integer':\n                    if (!isNaN(parseInt(value)) && parseFloat(value) === parseInt(value)) {\n                        return true;\n                    }\n                    break;\n                case 'float':\n                    if (!isNaN(parseFloat(value))) {\n                        return true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            return false;\n        };\n\n\n        core.getValidAspectNames = function (node) {\n            return core.getPointerNames(getMetaAspectsNode(node)) || [];\n        };\n\n        core.getAspectMeta = function (node, name) {\n            return core.getMemberPaths(getMetaAspectNode(node, name), 'items');\n        };\n\n        //additional meta functions for getting meta definitions\n        core.getJsonMeta = function (node) {\n            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},\n                tempNode,\n                names,\n                pointer,\n                i, j;\n\n            //fill children part\n            tempNode = getMetaChildrenNode(node);\n\n            meta.children.minItems = [];\n            meta.children.maxItems = [];\n            meta.children.items = core.getMemberPaths(tempNode, 'items');\n            for (i = 0; i < meta.children.items.length; i++) {\n                meta.children.minItems.push(\n                    core.getMemberAttribute(tempNode, 'items', meta.children.items[i], 'min') || -1);\n\n                meta.children.maxItems.push(\n                    core.getMemberAttribute(tempNode, 'items', meta.children.items[i], 'max') || -1);\n            }\n            meta.children.min = core.getAttribute(tempNode, 'min');\n            meta.children.max = core.getAttribute(tempNode, 'max');\n\n            //attributes\n            names = core.getValidAttributeNames(node);\n            for (i = 0; i < names.length; i++) {\n                meta.attributes[names[i]] = core.getAttribute(getMetaNode(node), names[i]);\n            }\n\n            //pointers\n            names = core.getPointerNames(getMetaNode(node));\n            for (i = 0; i < names.length; i++) {\n                tempNode = getMetaPointerNode(node, names[i]);\n                pointer = {};\n\n                pointer.items = core.getMemberPaths(tempNode, 'items');\n                pointer.min = core.getAttribute(tempNode, 'min');\n                pointer.max = core.getAttribute(tempNode, 'max');\n                pointer.minItems = [];\n                pointer.maxItems = [];\n\n                for (j = 0; j < pointer.items.length; j++) {\n                    pointer.minItems.push(core.getMemberAttribute(tempNode, 'items', pointer.items[j], 'min') || -1);\n                    pointer.maxItems.push(core.getMemberAttribute(tempNode, 'items', pointer.items[j], 'max') || -1);\n\n                }\n\n                meta.pointers[names[i]] = pointer;\n            }\n\n            //aspects\n            names = core.getValidAspectNames(node);\n\n            for (i = 0; i < names.length; i++) {\n                tempNode = getMetaAspectNode(node, names[i]);\n                meta.aspects[names[i]] = core.getMemberPaths(tempNode, 'items') || [];\n            }\n\n            //constraints\n            names = core.getConstraintNames(node);\n            for (i = 0; i < names.length; i++) {\n                meta.constraints[names[i]] = core.getConstraint(node, names[i]);\n            }\n\n            return meta;\n        };\n\n        var getMetaObjectDiff = function (bigger, smaller) {\n            //TODO this is a specific diff calculation for META rule JSONs\n            var diff = {},\n                names, i,\n                itemedElementDiff = function (bigItem, smallItem) {\n                    var diffItems = {},\n                        diff, i, index, names;\n                    for (i = 0; i < bigItem.items.length; i++) {\n                        if (smallItem.items.indexOf(bigItem.items[i]) === -1) {\n                            diffItems[bigItem.items[i]] = true;\n                        }\n                    }\n                    names = Object.keys(diffItems);\n                    for (i = 0; i < names.length; i++) {\n                        diff = diff || {items: [], minItems: [], maxItems: []};\n                        index = bigItem.items.indexOf(names[i]);\n                        diff.items.push(bigItem.items[index]);\n                        diff.minItems.push(bigItem.minItems[index]);\n                        diff.maxItems.push(bigItem.maxItems[index]);\n\n                    }\n                    if (bigItem.min && ((smallItem.min && bigItem.min !== smallItem.min) || !smallItem.min)) {\n                        diff = diff || {};\n                        diff.min = bigItem.min;\n                    }\n                    if (bigItem.max && ((smallItem.max && bigItem.max !== smallItem.max) || !smallItem.max)) {\n                        diff = diff || {};\n                        diff.max = bigItem.max;\n                    }\n                    return diff || {};\n                };\n            //attributes\n            if (smaller.attributes) {\n                names = Object.keys(bigger.attributes);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.attributes[names[i]]) {\n                        //they both have the attribute - if it differs we keep the whole of the bigger\n                        if (CANON.stringify(smaller.attributes[names[i]]) !==\n                            CANON.stringify(bigger.attributes[names[i]])) {\n\n                            diff.attributes = diff.attributes || {};\n                            diff.attributes[names[i]] = bigger.attributes[names[i]];\n                        }\n                    } else {\n                        diff.attributes = diff.attributes || {};\n                        diff.attributes[names[i]] = bigger.attributes[names[i]];\n                    }\n                }\n            } else if (bigger.attributes) {\n                diff.attributes = bigger.attributes;\n            }\n            //children\n            if (smaller.children) {\n                diff.children = itemedElementDiff(bigger.children, smaller.children);\n                if (Object.keys(diff.children).length < 1) {\n                    delete diff.children;\n                }\n            } else if (bigger.children) {\n                diff.children = bigger.children;\n            }\n            //pointers\n            if (smaller.pointers) {\n                diff.pointers = {};\n                names = Object.keys(bigger.pointers);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.pointers[names[i]]) {\n                        diff.pointers[names[i]] = itemedElementDiff(bigger.pointers[names[i]],\n                            smaller.pointers[names[i]]);\n                        if (Object.keys(diff.pointers[names[i]]).length < 1) {\n                            delete diff.pointers[names[i]];\n                        }\n                    } else {\n                        diff.pointers[names[i]] = bigger.pointers[names[i]];\n                    }\n                }\n            } else if (bigger.pointers) {\n                diff.pointers = bigger.pointers;\n            }\n            if (Object.keys(diff.pointers).length < 1) {\n                delete diff.pointers;\n            }\n            //aspects\n            if (smaller.aspects) {\n                diff.aspects = {};\n                names = Object.keys(bigger.aspects);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.aspects[names[i]]) {\n                        smaller.aspects[names[i]] = smaller.aspects[names[i]].sort();\n                        bigger.aspects[names[i]] = bigger.aspects[names[i]].sort();\n                        if (bigger.aspects[names[i]].length > smaller.aspects[names[i]].length) {\n                            diff.aspects[names[i]] = bigger.aspects[names[i]].slice(smaller.aspects[names[i]].length);\n                        }\n                    } else {\n                        diff.aspects[names[i]] = bigger.aspects[names[i]];\n                    }\n                }\n            } else if (bigger.aspects) {\n                diff.aspects = bigger.aspects;\n            }\n\n            if (Object.keys(diff.aspects).length < 1) {\n                delete diff.aspects;\n            }\n            return diff;\n        };\n\n        core.getOwnJsonMeta = function (node) {\n            var base = core.getBase(node),\n                baseMeta = base ? core.getJsonMeta(base) : {},\n                meta = core.getJsonMeta(node);\n\n            return getMetaObjectDiff(meta, baseMeta);\n        };\n\n        core.clearMetaRules = function (node) {\n            core.deleteNode(getMetaNode(node), true);\n        };\n\n        core.setAttributeMeta = function (node, name, value) {\n            ASSERT(typeof value === 'object' && typeof name === 'string' && name);\n\n            core.setAttribute(getMetaNode(node), name, value);\n        };\n        core.delAttributeMeta = function (node, name) {\n            core.delAttribute(getMetaNode(node), name);\n        };\n        core.getAttributeMeta = function (node, name) {\n            return core.getAttribute(getMetaNode(node), name);\n        };\n\n        core.getValidChildrenPaths = function (node) {\n            return core.getMemberPaths(getMetaChildrenNode(node), 'items');\n        };\n\n        core.getChildrenMeta = function (node) {\n            var cMetaNode = getMetaChildrenNode(node),\n                childrenMeta = {\n                    min: core.getAttribute(cMetaNode, 'min'),\n                    max: core.getAttribute(cMetaNode, 'max')\n                },\n                paths = core.getMemberPaths(cMetaNode, 'items'),\n                i;\n\n            for (i = 0; i < paths.length; i += 1) {\n                childrenMeta[paths[i]] = {\n                    min: core.getMemberAttribute(cMetaNode, 'items', paths[i], 'min'),\n                    max: core.getMemberAttribute(cMetaNode, 'items', paths[i], 'max')\n                };\n            }\n\n            if(paths.length > 0){\n                return childrenMeta;\n            }\n\n            return null;\n        };\n\n        core.setChildMeta = function (node, child, min, max) {\n            core.addMember(getMetaChildrenNode(node), 'items', child);\n            min = min || -1;\n            max = max || -1;\n            core.setMemberAttribute(getMetaChildrenNode(node), 'items', core.getPath(child), 'min', min);\n            core.setMemberAttribute(getMetaChildrenNode(node), 'items', core.getPath(child), 'max', max);\n        };\n        core.delChildMeta = function (node, childPath) {\n            core.delMember(getMetaChildrenNode(node), 'items', childPath);\n        };\n        core.setChildrenMetaLimits = function (node, min, max) {\n            if (min) {\n                core.setAttribute(getMetaChildrenNode(node), 'min', min);\n            }\n            if (max) {\n                core.setAttribute(getMetaChildrenNode(node), 'max', max);\n            }\n        };\n\n        core.setPointerMetaTarget = function (node, name, target, min, max) {\n            core.addMember(_MetaPointerNode(node, name), 'items', target);\n            min = min || -1;\n            core.setMemberAttribute(_MetaPointerNode(node, name), 'items', core.getPath(target), 'min', min);\n            max = max || -1;\n            core.setMemberAttribute(_MetaPointerNode(node, name), 'items', core.getPath(target), 'max', max);\n        };\n        core.delPointerMetaTarget = function (node, name, targetPath) {\n            var metaNode = getMetaPointerNode(node, name);\n            if (metaNode) {\n                core.delMember(metaNode, 'items', targetPath);\n            }\n        };\n        core.setPointerMetaLimits = function (node, name, min, max) {\n            if (min) {\n                core.setAttribute(_MetaPointerNode(node, name), 'min', min);\n            }\n            if (max) {\n                core.setAttribute(_MetaPointerNode(node, name), 'max', max);\n            }\n        };\n        core.delPointerMeta = function (node, name) {\n            core.deleteNode(_MetaPointerNode(node, name), true);\n            core.deletePointer(getMetaNode(node), name);\n        };\n\n        core.getPointerMeta = function (node, name) {\n            var pointerMeta = {},\n                members,\n                member,\n                i,\n                pointerMetaNode = getMetaPointerNode(node, name);\n\n            if (pointerMetaNode === null) {\n                return null;\n            }\n\n            //min\n            pointerMeta.min = core.getAttribute(pointerMetaNode, 'min');\n            if (pointerMeta.min === undefined) {\n                pointerMeta.min = -1;\n            }\n\n            //max\n            pointerMeta.max = core.getAttribute(pointerMetaNode, 'max');\n            if (pointerMeta.max === undefined) {\n                pointerMeta.max = -1;\n            }\n\n            members = core.getMemberPaths(pointerMetaNode, 'items');\n            for (i = 0; i < members.length; i++) {\n                member = {\n                    min: core.getMemberAttribute(pointerMetaNode, 'items', members[i], 'min'),\n                    max: core.getMemberAttribute(pointerMetaNode, 'items', members[i], 'max')\n                };\n                if (member.min === undefined) {\n                    member.min = -1;\n                }\n                if (member.max === undefined) {\n                    member.max = -1;\n                }\n\n                pointerMeta[members[i]] = member;\n            }\n\n            return pointerMeta;\n        };\n\n        core.setAspectMetaTarget = function (node, name, target) {\n            core.addMember(_MetaAspectNode(node, name), 'items', target);\n        };\n        core.delAspectMetaTarget = function (node, name, targetPath) {\n            var metaNode = getMetaAspectNode(node, name);\n            if (metaNode) {\n                core.delMember(metaNode, 'items', targetPath);\n            }\n        };\n        core.delAspectMeta = function (node, name) {\n            core.deleteNode(_MetaAspectNode(node, name), true);\n            core.deletePointer(getMetaAspectsNode(node), name);\n        };\n\n        //type related extra query functions\n        var isOnMetaSheet = function (node) {\n            //MetaAspectSet\n            var sets = core.isMemberOf(node);\n\n            if (sets && sets[''] && sets[''].indexOf('MetaAspectSet') !== -1) {\n                //TODO this is all should be global constant values\n                return true;\n            }\n            return false;\n        };\n        core.getBaseType = function (node) {\n            //TODO this functions now uses the fact that we think of META as the MetaSetContainer of the ROOT\n            while (node) {\n                if (isOnMetaSheet(node)) {\n                    return node;\n                }\n                node = core.getBase(node);\n            }\n            return null;\n        };\n        core.isInstanceOf = function (node, name) {\n            //TODO this is name based query - doesn't check the node's own name\n            node = core.getBase(node);\n            while (node) {\n                if (core.getAttribute(node, 'name') === name) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n\n            return false;\n        };\n\n        return core;\n    };\n\n    return MetaCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/coretreeloader',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreTreeLoader -----------------\n\n    var MetaCore = function (innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var core = {},\n            key,\n            logger = options.logger.fork('coretreeloader');\n        for (key in innerCore) {\n            core[key] = innerCore[key];\n        }\n        logger.debug('initialized');\n        //adding load functions\n        core.loadSubTree = function (root) {\n            var loadSubTrees = function (nodes) {\n                for (var i = 0; i < nodes.length; i++) {\n                    nodes[i] = core.loadSubTree(nodes[i]);\n                }\n                return TASYNC.lift(nodes);\n\n            };\n            return TASYNC.call(function (children) {\n                if (children.length < 1) {\n                    return [root];\n                } else {\n                    return TASYNC.call(function (subArrays) {\n                        var nodes = [],\n                            i;\n                        for (i = 0; i < subArrays.length; i++) {\n                            nodes = nodes.concat(subArrays[i]);\n                        }\n                        nodes.unshift(root);\n                        return nodes;\n                    }, loadSubTrees(children));\n                }\n            }, core.loadChildren(root));\n        };\n        core.loadTree = function (rootHash) {\n            return TASYNC.call(core.loadSubTree, core.loadRoot(rootHash));\n        };\n\n        return core;\n    };\n    return MetaCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n// TODO: This files needs refactoring\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/corediff',['common/util/canon',\n    'common/core/tasync',\n    'common/util/assert',\n    'common/regexp'\n], function (CANON, TASYNC, ASSERT, REGEXP) {\n    'use strict';\n\n    function diffCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('corediff'),\n            _yetToCompute = {},\n            _DIFF = {},\n            _needChecking = true,\n            _rounds = 0,\n            TODELETESTRING = '*to*delete*',\n            toFrom = {}, //TODO should not be global\n            fromTo = {}, //TODO should not be global\n            _concatResult,\n            _diffMoves = {},\n            _conflictItems = [],\n            _conflictMine,\n            _conflictTheirs,\n            _concatBase,\n            _concatExtension,\n            _concatBaseRemovals,\n            _concatMoves;\n\n        logger.debug('initialized');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n\n        function normalize(obj) {\n            if (!obj) {\n                return obj;\n            }\n            var keys = Object.keys(obj),\n                i;\n            if (JSON.stringify(obj.set) === JSON.stringify({})) {\n                delete obj.set;\n            }\n\n            for (i = 0; i < keys.length; i++) {\n                /*if (Array.isArray(obj[keys[i]])) {\n                 if (obj[keys[i]].length === 0) {\n                 delete obj[keys[i]];\n                 }*/\n                if (Array.isArray(obj[keys[i]])) {\n                    //do nothing, leave the array as is\n                } else if (obj[keys[i]] === undefined) {\n                    delete obj[keys[i]]; //there cannot be undefined in the object\n                } else if (keys[i] === 'set') {\n                    //do nothing with set as it can include empty set's as well\n                } else if (typeof obj[keys[i]] === 'object') {\n                    normalize(obj[keys[i]]);\n                    if (obj[keys[i]] && Object.keys(obj[keys[i]]).length === 0) {\n                        delete obj[keys[i]];\n                    }\n                }\n            }\n            keys = Object.keys(obj);\n            if (keys.length === 1) {\n                //it only has the GUID, so the node doesn't changed at all\n                delete obj.guid;\n            }\n        }\n\n        function attrDiff(source, target) {\n            var sNames = _core.getOwnAttributeNames(source),\n                tNames = _core.getOwnAttributeNames(target),\n                i,\n                diff = {};\n\n            for (i = 0; i < sNames.length; i++) {\n                if (tNames.indexOf(sNames[i]) === -1) {\n                    diff[sNames[i]] = TODELETESTRING;\n                }\n            }\n\n            for (i = 0; i < tNames.length; i++) {\n                if (_core.getAttribute(source, tNames[i]) === undefined) {\n                    diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\n                } else {\n                    if (CANON.stringify(_core.getAttribute(source, tNames[i])) !==\n                        CANON.stringify(_core.getAttribute(target, tNames[i]))) {\n\n                        diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        function regDiff(source, target) {\n            var sNames = _core.getOwnRegistryNames(source),\n                tNames = _core.getOwnRegistryNames(target),\n                i,\n                diff = {};\n\n            for (i = 0; i < sNames.length; i++) {\n                if (tNames.indexOf(sNames[i]) === -1) {\n                    diff[sNames[i]] = TODELETESTRING;\n                }\n            }\n\n            for (i = 0; i < tNames.length; i++) {\n                if (_core.getRegistry(source, tNames[i]) === undefined) {\n                    diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\n                } else {\n                    if (CANON.stringify(_core.getRegistry(source, tNames[i])) !==\n                        CANON.stringify(_core.getRegistry(target, tNames[i]))) {\n\n                        diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        function childrenDiff(source, target) {\n            var sRelids = _core.getChildrenRelids(source),\n                tRelids = _core.getChildrenRelids(target),\n                tHashes = _core.getChildrenHashes(target),\n                sHashes = _core.getChildrenHashes(source),\n                i,\n                diff = {added: [], removed: []};\n\n            for (i = 0; i < sRelids.length; i++) {\n                if (tRelids.indexOf(sRelids[i]) === -1) {\n                    diff.removed.push({relid: sRelids[i], hash: sHashes[sRelids[i]]});\n                }\n            }\n\n            for (i = 0; i < tRelids.length; i++) {\n                if (sRelids.indexOf(tRelids[i]) === -1) {\n                    diff.added.push({relid: tRelids[i], hash: tHashes[tRelids[i]]});\n                }\n            }\n\n            return diff;\n\n        }\n\n        function pointerDiff(source, target) {\n            var getPointerData = function (node) {\n                    var data = {},\n                        names = _core.getPointerNames(node),\n                        i;\n                    for (i = 0; i < names.length; i++) {\n                        data[names[i]] = _core.getPointerPath(node, names[i]);\n                    }\n                    return data;\n                },\n                sPointer = getPointerData(source),\n                tPointer = getPointerData(target);\n\n            if (CANON.stringify(sPointer) !== CANON.stringify(tPointer)) {\n                return {source: sPointer, target: tPointer};\n            }\n            return {};\n        }\n\n        function setDiff(source, target) {\n            var getSetData = function (node) {\n                    var data = {},\n                        names, targets, keys, i, j, k;\n\n                    names = _core.getSetNames(node);\n                    for (i = 0; i < names.length; i++) {\n                        data[names[i]] = {};\n                        targets = _core.getMemberPaths(node, names[i]);\n                        for (j = 0; j < targets.length; j++) {\n                            data[names[i]][targets[j]] = {attr: {}, reg: {}};\n                            keys = _core.getMemberOwnAttributeNames(node, names[i], targets[j]);\n                            for (k = 0; k < keys.length; k++) {\n                                data[names[i]][targets[j]].attr[keys[k]] = _core.getMemberAttribute(node,\n                                    names[i], targets[j], keys[k]);\n                            }\n                            keys = _core.getMemberRegistryNames(node, names[i], targets[j]);\n                            for (k = 0; k < keys.length; k++) {\n                                data[names[i]][targets[j]].reg[keys[k]] = _core.getMemberRegistry(node,\n                                    names[i], targets[j], keys[k]);\n                            }\n                        }\n                    }\n\n                    return data;\n\n                },\n                sSet = getSetData(source),\n                tSet = getSetData(target);\n\n            if (CANON.stringify(sSet) !== CANON.stringify(tSet)) {\n                return {source: sSet, target: tSet};\n            }\n            return {};\n        }\n\n        function ovrDiff(source, target) {\n            var getOvrData = function (node) {\n                    var paths, names, i, j,\n                        ovr = _core.getProperty(node, 'ovr') || {},\n                        data = {},\n                        base = _core.getPath(node);\n\n                    paths = Object.keys(ovr);\n                    for (i = 0; i < paths.length; i++) {\n                        if (paths[i].indexOf('_') === -1) {\n                            data[paths[i]] = {};\n                            names = Object.keys(ovr[paths[i]]);\n                            for (j = 0; j < names.length; j++) {\n                                if (ovr[paths[i]][names[j]] === '/_nullptr') {\n                                    data[paths[i]][names[j]] = null;\n                                } else if (names[j].slice(-4) !== '-inv' && names[j].indexOf('_') === -1 &&\n                                    ovr[paths[i]][names[j]].indexOf('_') === -1) {\n\n                                    data[paths[i]][names[j]] = _core.joinPaths(base, ovr[paths[i]][names[j]]);\n                                }\n                            }\n                        }\n                    }\n                    return data;\n                },\n                sOvr = getOvrData(source),\n                tOvr = getOvrData(target);\n\n            if (CANON.stringify(sOvr) !== CANON.stringify(tOvr)) {\n                return {source: sOvr, target: tOvr};\n            }\n            return {};\n        }\n\n        function metaDiff(source, target) {\n            //TODO jsonMeta format should be changed in all places!!!\n            var convertJsonMeta = function (jsonMeta) {\n                    var i, j, names, itemsObject;\n                    //children\n                    if (jsonMeta.children) {\n                        itemsObject = jsonMeta.children;\n                        for (i = 0; i < itemsObject.items.length; i += 1) {\n                            itemsObject[itemsObject.items[i]] = {\n                                min: itemsObject.minItems[i],\n                                max: itemsObject.maxItems[i]\n                            };\n                        }\n                        delete itemsObject.items;\n                        delete itemsObject.minItems;\n                        delete itemsObject.maxItems;\n                    }\n                    //ptr\n                    if (jsonMeta.pointers) {\n                        names = Object.keys(jsonMeta.pointers);\n\n                        for (j = 0; j < names.length; j += 1) {\n                            itemsObject = jsonMeta.pointers[names[j]];\n                            for (i = 0; i < itemsObject.items.length; i += 1) {\n                                itemsObject[itemsObject.items[i]] = {\n                                    min: itemsObject.minItems[i],\n                                    max: itemsObject.maxItems[i]\n                                };\n                            }\n                            delete itemsObject.items;\n                            delete itemsObject.minItems;\n                            delete itemsObject.maxItems;\n                        }\n                    }\n                    return jsonMeta;\n                },\n                sMeta = convertJsonMeta(_core.getOwnJsonMeta(source)),\n                tMeta = convertJsonMeta(_core.getOwnJsonMeta(target));\n            if (CANON.stringify(sMeta) !== CANON.stringify(tMeta)) {\n                return {source: sMeta, target: tMeta};\n            }\n            return {};\n        }\n\n        function combineMoveIntoMetaDiff(diff) {\n            var keys = Object.keys(diff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (_diffMoves[keys[i]]) {\n                    diff[_diffMoves[keys[i]]] = diff[keys[i]];\n                    delete diff[keys[i]];\n                } else if (typeof diff[keys[i]] === 'object') {\n                    combineMoveIntoMetaDiff(diff[keys[i]]);\n                }\n            }\n        }\n\n        function combineMoveIntoPointerDiff(diff) {\n            var keys = Object.keys(diff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (_diffMoves[diff[keys[i]]]) {\n                    diff[keys[i]] = _diffMoves[diff[keys[i]]];\n                }\n            }\n        }\n\n        function finalizeDiff() {\n            finalizeMetaDiff(_DIFF);\n            finalizePointerDiff(_DIFF);\n            finalizeSetDiff(_DIFF);\n            normalize(_DIFF);\n        }\n\n        function finalizeMetaDiff(diff) {\n            //at this point _DIFF is ready and the _diffMoves is complete...\n            var relids = getDiffChildrenRelids(diff),\n                i, sMeta, tMeta;\n            if (diff.meta) {\n                sMeta = diff.meta.source || {};\n                tMeta = diff.meta.target || {};\n                combineMoveIntoMetaDiff(sMeta);\n                diff.meta = diffObjects(sMeta, tMeta);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizeMetaDiff(diff[relids[i]]);\n            }\n        }\n\n        function finalizePointerDiff(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, sPointer, tPointer;\n            if (diff.pointer) {\n                sPointer = diff.pointer.source || {};\n                tPointer = diff.pointer.target || {};\n                /*if(diff.movedFrom && !sPointer.base && tPointer.base){\n                 delete tPointer.base;\n                 }*/\n                combineMoveIntoPointerDiff(sPointer);\n                diff.pointer = diffObjects(sPointer, tPointer);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizePointerDiff(diff[relids[i]]);\n            }\n        }\n\n        function finalizeSetDiff(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, sSet, tSet;\n            if (diff.set) {\n                sSet = diff.set.source || {};\n                tSet = diff.set.target || {};\n                combineMoveIntoMetaDiff(sSet);\n                diff.set = diffObjects(sSet, tSet);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizeSetDiff(diff[relids[i]]);\n            }\n        }\n\n        function isEmptyNodeDiff(diff) {\n            if (\n                Object.keys(diff.children || {}).length > 0 ||\n                Object.keys(diff.attr || {}).length > 0 ||\n                Object.keys(diff.reg || {}).length > 0 ||\n                Object.keys(diff.pointer || {}).length > 0 ||\n                Object.keys(diff.set || {}).length > 0 ||\n                diff.meta\n            ) {\n                return false;\n            }\n            return true;\n        }\n\n        function getPathOfDiff(diff, path) {\n            var pathArray = path.split('/'),\n                i;\n            pathArray.shift();\n            for (i = 0; i < pathArray.length; i++) {\n                diff[pathArray[i]] = diff[pathArray[i]] || {};\n                diff = diff[pathArray[i]];\n            }\n\n            return diff;\n        }\n\n        function extendDiffWithOvr(diff, oDiff) {\n            var i, paths, names, j, tDiff;\n            //first extend sources\n            paths = Object.keys(oDiff.source || {});\n            for (i = 0; i < paths.length; i++) {\n                tDiff = getPathOfDiff(diff, paths[i]);\n                if (tDiff.removed !== true) {\n                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};\n                    names = Object.keys(oDiff.source[paths[i]]);\n                    for (j = 0; j < names.length; j++) {\n                        tDiff.pointer.source[names[j]] = oDiff.source[paths[i]][names[j]];\n                    }\n                }\n            }\n            //then targets\n            paths = Object.keys(oDiff.target || {});\n            for (i = 0; i < paths.length; i++) {\n                tDiff = getPathOfDiff(diff, paths[i]);\n                if (tDiff.removed !== true) {\n                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};\n                    names = Object.keys(oDiff.target[paths[i]]);\n                    for (j = 0; j < names.length; j++) {\n                        tDiff.pointer.target[names[j]] = oDiff.target[paths[i]][names[j]];\n                    }\n                }\n            }\n        }\n\n        function updateDiff(sourceRoot, targetRoot) {\n            var diff = _core.nodeDiff(sourceRoot, targetRoot) || {},\n                oDiff = ovrDiff(sourceRoot, targetRoot),\n                getChild = function (childArray, relid) {\n                    for (var i = 0; i < childArray.length; i++) {\n                        if (_core.getRelid(childArray[i]) === relid) {\n                            return childArray[i];\n                        }\n                    }\n                    return null;\n                };\n            return TASYNC.call(function (sChildren, tChildren) {\n                ASSERT(sChildren.length >= 0 && tChildren.length >= 0);\n\n                var i, child, done, tDiff, guid, base,\n                    childComputationFinished = function (cDiff, relid/*, d*/) {\n                        diff[relid] = cDiff;\n                        return null;\n                    };\n\n                tDiff = diff.children ? diff.children.removed || [] : [];\n                for (i = 0; i < tDiff.length; i++) {\n                    diff.childrenListChanged = true;\n                    child = getChild(sChildren, tDiff[i].relid);\n                    if (child) {\n                        guid = _core.getGuid(child);\n                        diff[tDiff[i].relid] = {guid: guid, removed: true, hash: _core.getHash(child)};\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].from = child;\n                        _yetToCompute[guid].fromExpanded = false;\n                    }\n                }\n\n                tDiff = diff.children ? diff.children.added || [] : [];\n                for (i = 0; i < tDiff.length; i++) {\n                    diff.childrenListChanged = true;\n                    child = getChild(tChildren, tDiff[i].relid);\n                    if (child) {\n                        guid = _core.getGuid(child);\n                        base = _core.getBase(child);\n                        diff[tDiff[i].relid] = {\n                            guid: guid,\n                            removed: false,\n                            hash: _core.getHash(child),\n                            pointer: {source: {}, target: {base: base === null ? null : _core.getPath(base)}}\n                        };\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].to = child;\n                        _yetToCompute[guid].toExpanded = false;\n                    }\n                }\n\n                for (i = 0; i < tChildren.length; i++) {\n                    child = getChild(sChildren, _core.getRelid(tChildren[i]));\n                    if (child && _core.getHash(tChildren[i]) !== _core.getHash(child)) {\n                        done = TASYNC.call(childComputationFinished,\n                            updateDiff(child, tChildren[i]), _core.getRelid(child), done);\n                    }\n                }\n                return TASYNC.call(function () {\n                    delete diff.children;\n                    extendDiffWithOvr(diff, oDiff);\n                    normalize(diff);\n                    if (Object.keys(diff).length > 0) {\n                        diff.guid = _core.getGuid(targetRoot);\n                        diff.hash = _core.getHash(targetRoot);\n                        diff.oGuids = gatherObstructiveGuids(targetRoot);\n                        return TASYNC.call(function (finalDiff) {\n                            return finalDiff;\n                        }, fillMissingGuid(targetRoot, '', diff));\n                    } else {\n                        return diff;\n                    }\n\n                }, done);\n            }, _core.loadChildren(sourceRoot), _core.loadChildren(targetRoot));\n        }\n\n        function gatherObstructiveGuids(node) {\n            var result = {},\n                putParents = function (n) {\n                    while (n) {\n                        result[_core.getGuid(n)] = true;\n                        n = _core.getParent(n);\n                    }\n                };\n            while (node) {\n                putParents(node);\n                node = _core.getBase(node);\n            }\n            return result;\n        }\n\n        function fillMissingGuid(root, path, diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i,\n                done,\n                subComputationFinished = function (cDiff, relid) {\n                    diff[relid] = cDiff;\n                    return null;\n                };\n\n            for (i = 0; i < relids.length; i++) {\n                done = TASYNC.call(subComputationFinished,\n                    fillMissingGuid(root, path + '/' + relids[i], diff[relids[i]]), relids[i]);\n            }\n\n            return TASYNC.call(function () {\n                if (diff.guid) {\n                    return diff;\n                } else {\n                    return TASYNC.call(function (child) {\n                        diff.guid = _core.getGuid(child);\n                        diff.hash = _core.getHash(child);\n                        diff.oGuids = gatherObstructiveGuids(child);\n                        return diff;\n                    }, _core.loadByPath(root, path));\n                }\n            }, done);\n        }\n\n        function expandDiff(root, isDeleted) {\n            var diff = {\n                guid: _core.getGuid(root),\n                hash: _core.getHash(root),\n                removed: isDeleted === true\n            };\n            return TASYNC.call(function (children) {\n                var guid;\n                for (var i = 0; i < children.length; i++) {\n                    guid = _core.getGuid(children[i]);\n                    diff[_core.getRelid(children[i])] = {\n                        guid: guid,\n                        hash: _core.getHash(children[i]),\n                        removed: isDeleted === true\n                    };\n\n                    if (isDeleted) {\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].from = children[i];\n                        _yetToCompute[guid].fromExpanded = false;\n                    } else {\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].to = children[i];\n                        _yetToCompute[guid].toExpanded = false;\n                    }\n                }\n                return diff;\n            }, _core.loadChildren(root));\n        }\n\n        function insertIntoDiff(path, diff) {\n            var pathArray = path.split('/'),\n                relid = pathArray.pop(),\n                sDiff = _DIFF,\n                i;\n            pathArray.shift();\n            for (i = 0; i < pathArray.length; i++) {\n                sDiff = sDiff[pathArray[i]];\n            }\n            //sDiff[relid] = diff;\n            sDiff[relid] = mergeObjects(sDiff[relid], diff);\n        }\n\n        function diffObjects(source, target) {\n            var diff = {},\n                sKeys = Object.keys(source),\n                tKeys = Object.keys(target),\n                tDiff, i;\n            for (i = 0; i < sKeys.length; i++) {\n                if (tKeys.indexOf(sKeys[i]) === -1) {\n                    diff[sKeys[i]] = TODELETESTRING;\n                }\n            }\n            for (i = 0; i < tKeys.length; i++) {\n                if (sKeys.indexOf(tKeys[i]) === -1) {\n                    diff[tKeys[i]] = target[tKeys[i]];\n                } else {\n                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\n                        typeof target[tKeys[i]] === 'object' &&\n                        (target[tKeys[i]] !== null && source[tKeys[i]] !== null)) {\n                        tDiff = diffObjects(source[tKeys[i]], target[tKeys[i]]);\n                        if (Object.keys(tDiff).length > 0) {\n                            diff[tKeys[i]] = tDiff;\n                        }\n                    } else if (source[tKeys[i]] !== target[tKeys[i]]) {\n                        diff[tKeys[i]] = target[tKeys[i]];\n                    }\n                }\n            }\n            return diff;\n        }\n\n        function mergeObjects(source, target) {\n            var merged = {},\n                sKeys = Object.keys(source),\n                tKeys = Object.keys(target),\n                i;\n            for (i = 0; i < sKeys.length; i++) {\n                merged[sKeys[i]] = source[sKeys[i]];\n            }\n            for (i = 0; i < tKeys.length; i++) {\n                if (sKeys.indexOf(tKeys[i]) === -1) {\n                    merged[tKeys[i]] = target[tKeys[i]];\n                } else {\n                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\n                        typeof target[tKeys[i]] === 'object' && !(target instanceof Array)) {\n                        merged[tKeys[i]] = mergeObjects(source[tKeys[i]], target[tKeys[i]]);\n                    } else {\n                        merged[tKeys[i]] = target[tKeys[i]];\n                    }\n                }\n            }\n\n            return merged;\n        }\n\n        function removePathFromDiff(diff, path) {\n            var relId, i, pathArray;\n            if (path === '') {\n                diff = null;\n            } else {\n                pathArray = path.split('/');\n                pathArray.shift();\n                relId = pathArray.pop();\n                for (i = 0; i < pathArray.length; i++) {\n                    diff = diff[pathArray[i]];\n                }\n                delete diff[relId];\n            }\n        }\n\n        function shrinkDiff(rootDiff) {\n            var _shrink = function (diff) {\n                if (diff) {\n                    var keys = getDiffChildrenRelids(diff),\n                        i;\n                    if (typeof diff.movedFrom === 'string') {\n                        removePathFromDiff(rootDiff, diff.movedFrom);\n                    }\n\n                    if (diff.removed !== false || typeof diff.movedFrom === 'string') {\n                        delete diff.hash;\n                    }\n\n                    if (diff.removed === true) {\n                        for (i = 0; i < keys.length; i++) {\n                            delete diff[keys[i]];\n                        }\n                    } else {\n\n                        for (i = 0; i < keys.length; i++) {\n                            _shrink(diff[keys[i]]);\n                        }\n                    }\n                }\n            };\n            _shrink(rootDiff);\n        }\n\n        function checkRound() {\n            var guids = Object.keys(_yetToCompute),\n                done, ytc,\n                i,\n                computingMove = function (mDiff, info) {\n                    mDiff.guid = _core.getGuid(info.from);\n                    mDiff.movedFrom = _core.getPath(info.from);\n                    mDiff.ooGuids = gatherObstructiveGuids(info.from);\n                    _diffMoves[_core.getPath(info.from)] = _core.getPath(info.to);\n                    insertAtPath(_DIFF, _core.getPath(info.to), mDiff);\n                    return null;\n                },\n                expandFrom = function (mDiff, info) {\n                    mDiff.hash = _core.getHash(info.from);\n                    mDiff.removed = true;\n                    insertIntoDiff(_core.getPath(info.from), mDiff);\n                    return null;\n                },\n                expandTo = function (mDiff, info) {\n                    if (!mDiff.hash) {\n                        mDiff.hash = _core.getHash(info.to);\n                    }\n                    mDiff.removed = false;\n                    insertIntoDiff(_core.getPath(info.to), mDiff);\n                    return null;\n                };\n\n            if (_needChecking !== true || guids.length < 1) {\n                shrinkDiff(_DIFF);\n                finalizeDiff();\n                return JSON.parse(JSON.stringify(_DIFF));\n            }\n\n            _needChecking = false;\n            for (i = 0; i < guids.length; i++) {\n                ytc = _yetToCompute[guids[i]];\n                if (ytc.from && ytc.to) {\n                    //move\n                    _needChecking = true;\n                    delete _yetToCompute[guids[i]];\n                    done = TASYNC.call(computingMove, updateDiff(ytc.from, ytc.to), ytc);\n                } else {\n                    if (ytc.from && ytc.fromExpanded === false) {\n                        //expand from\n                        ytc.fromExpanded = true;\n                        _needChecking = true;\n                        done = TASYNC.call(expandFrom, expandDiff(ytc.from, true), ytc);\n                    } else if (ytc.to && ytc.toExpanded === false) {\n                        //expand to\n                        ytc.toExpanded = true;\n                        _needChecking = true;\n                        done = TASYNC.call(expandTo, expandDiff(ytc.to, false), ytc);\n                    }\n                }\n            }\n            return TASYNC.call(checkRound, done);\n        }\n\n        _core.nodeDiff = function (source, target) {\n            var diff = {\n                children: childrenDiff(source, target),\n                attr: attrDiff(source, target),\n                reg: regDiff(source, target),\n                pointer: pointerDiff(source, target),\n                set: setDiff(source, target),\n                meta: metaDiff(source, target)\n            };\n\n            normalize(diff);\n            return isEmptyNodeDiff(diff) ? null : diff;\n        };\n\n        _core.generateTreeDiff = function (sRoot, tRoot) {\n            _yetToCompute = {};\n            _DIFF = {};\n            _diffMoves = {};\n            _needChecking = true;\n            _rounds = 0;\n            return TASYNC.call(function (d) {\n                _DIFF = d;\n                return checkRound();\n            }, updateDiff(sRoot, tRoot));\n        };\n\n        _core.generateLightTreeDiff = function (sRoot, tRoot) {\n            return updateDiff(sRoot, tRoot);\n        };\n\n        function getDiffChildrenRelids(diff) {\n            var keys = Object.keys(diff || {}),\n                i,\n                filteredKeys = [],\n                forbiddenWords = {\n                    guid: true,\n                    hash: true,\n                    attr: true,\n                    reg: true,\n                    pointer: true,\n                    set: true,\n                    meta: true,\n                    removed: true,\n                    movedFrom: true,\n                    childrenListChanged: true,\n                    oGuids: true,\n                    ooGuids: true,\n                    min: true,\n                    max: true\n                };\n            for (i = 0; i < keys.length; i++) {\n                if (!forbiddenWords[keys[i]]) {\n                    filteredKeys.push(keys[i]);\n                }\n            }\n            return filteredKeys;\n        }\n\n        function getMoveSources(diff, path, toFrom, fromTo) {\n            var relids = getDiffChildrenRelids(diff),\n                i;\n\n            for (i = 0; i < relids.length; i++) {\n                getMoveSources(diff[relids[i]], path + '/' + relids[i], toFrom, fromTo);\n            }\n\n            if (typeof diff.movedFrom === 'string') {\n                toFrom[path] = diff.movedFrom;\n                fromTo[diff.movedFrom] = path;\n            }\n        }\n\n        function getAncestor(node, path) {\n            var ownPath = _core.getPath(node),\n                ancestorPath = '',\n                i, ownPathArray, pathArray;\n            pathArray = path.split('/');\n            ownPathArray = ownPath.split('/');\n            ownPathArray.shift();\n            pathArray.shift();\n            for (i = 0; i < ownPathArray.length; i++) {\n                if (ownPathArray[i] === pathArray[i]) {\n                    ancestorPath = ancestorPath + '/' + ownPathArray[i];\n                } else {\n                    break;\n                }\n            }\n            while (ownPath !== ancestorPath) {\n                node = _core.getParent(node);\n                ownPath = _core.getPath(node);\n            }\n            return node;\n        }\n\n        function setBaseOfNewNode(node, relid, basePath) {\n            //TODO this is a kind of low level hack so maybe there should be another way to do this\n            var ancestor = getAncestor(node, basePath),\n                sourcePath = _core.getPath(node).substr(_core.getPath(ancestor).length),\n                targetPath = basePath.substr(_core.getPath(ancestor).length);\n            sourcePath = sourcePath + '/' + relid;\n            _innerCore.overlayInsert(_core.getChild(ancestor, 'ovr'), sourcePath, 'base', targetPath);\n        }\n\n        function makeInitialContainmentChanges(node, diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, done, child, moved,\n                moving = function (n, di, p, m/*, d*/) {\n                    if (m === true) {\n                        n = _core.moveNode(n, p);\n                    }\n                    return makeInitialContainmentChanges(n, di);\n                };\n\n            for (i = 0; i < relids.length; i++) {\n                moved = false;\n                if (diff[relids[i]].movedFrom) {\n                    //moved node\n                    moved = true;\n                    child = _core.loadByPath(_core.getRoot(node), diff[relids[i]].movedFrom);\n                } else if (diff[relids[i]].removed === false) {\n                    //added node\n                    //first we hack the pointer, then we create the node\n                    if (diff[relids[i]].pointer && diff[relids[i]].pointer.base) {\n                        //we can set base if the node has one, otherwise it is 'inheritance internal' node\n                        setBaseOfNewNode(node, relids[i], diff[relids[i]].pointer.base);\n                    }\n                    if (diff[relids[i]].hash) {\n                        _core.setProperty(node, relids[i], diff[relids[i]].hash);\n                        child = _core.loadChild(node, relids[i]);\n                    } else {\n                        child = _core.getChild(node, relids[i]);\n                        _core.setHashed(child, true);\n                    }\n                } else {\n                    //simple node\n                    child = _core.loadChild(node, relids[i]);\n                }\n\n                done = TASYNC.call(moving, child, diff[relids[i]], node, moved, done);\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyNodeChange(root, path, nodeDiff) {\n            //check for move\n            var node;\n            node = _core.loadByPath(root, path);\n\n            return TASYNC.call(function (n) {\n                var done,\n                    relids = getDiffChildrenRelids(nodeDiff),\n                    i;\n                if (nodeDiff.removed === true) {\n                    _core.deleteNode(n);\n                    return;\n                }\n                applyAttributeChanges(n, nodeDiff.attr || {});\n                applyRegistryChanges(n, nodeDiff.reg || {});\n                done = applyPointerChanges(n, nodeDiff);\n                done = TASYNC.call(applySetChanges, n, nodeDiff.set || {}, done);\n                if (nodeDiff.meta) {\n                    delete nodeDiff.meta.empty;\n                    done = TASYNC.call(applyMetaChanges, n, nodeDiff.meta, done);\n                }\n                for (i = 0; i < relids.length; i++) {\n                    /*done = TASYNC.call(function () {\n                     return null;\n                     }, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]), done);*/\n                    done = TASYNC.join(done, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]));\n                }\n                /*TASYNC.call(function (d) {\n                 return done;\n                 }, done);*/\n                return done;\n            }, node);\n        }\n\n        function applyAttributeChanges(node, attrDiff) {\n            var i, keys;\n            keys = Object.keys(attrDiff);\n            for (i = 0; i < keys.length; i++) {\n                if (attrDiff[keys[i]] === TODELETESTRING) {\n                    _core.delAttribute(node, keys[i]);\n                } else {\n                    _core.setAttribute(node, keys[i], attrDiff[keys[i]]);\n                }\n            }\n        }\n\n        function applyRegistryChanges(node, regDiff) {\n            var i, keys;\n            keys = Object.keys(regDiff);\n            for (i = 0; i < keys.length; i++) {\n                if (regDiff[keys[i]] === TODELETESTRING) {\n                    _core.delRegistry(node, keys[i]);\n                } else {\n                    _core.setRegistry(node, keys[i], regDiff[keys[i]]);\n                }\n            }\n        }\n\n        function setPointer(node, name, target) {\n            var targetNode;\n            if (target === null) {\n                targetNode = null;\n            } else {\n                if (fromTo[target]) {\n                    target = fromTo[target];\n                }\n                targetNode = _core.loadByPath(_core.getRoot(node), target);\n            }\n            return TASYNC.call(function (t) {\n                //TODO watch if handling of base changes!!!\n                _core.setPointer(node, name, t);\n                return;\n            }, targetNode);\n        }\n\n        function applyPointerChanges(node, diff) {\n            var done,\n                pointerDiff = diff.pointer || {},\n                keys = Object.keys(pointerDiff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (pointerDiff[keys[i]] === TODELETESTRING) {\n                    _core.deletePointer(node, keys[i]);\n                } else if (diff.removed !== false || keys[i] !== 'base') {\n                    done = setPointer(node, keys[i], pointerDiff[keys[i]]);\n                }\n            }\n\n            return TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n\n        }\n\n        function addMember(node, name, target, data) {\n            var memberAttrSetting = function (diff) {\n                    var keys = _core.getMemberOwnAttributeNames(node, name, target),\n                        i;\n                    for (i = 0; i < keys.length; i++) {\n                        _core.delMemberAttribute(node, name, target, keys[i]);\n                    }\n\n                    keys = Object.keys(diff);\n                    for (i = 0; i < keys.length; i++) {\n                        _core.setMemberAttribute(node, name, target, keys[i], diff[keys[i]]);\n                    }\n                },\n                memberRegSetting = function (diff) {\n                    var keys = _core.getMemberOwnRegistryNames(node, name, target),\n                        i;\n                    for (i = 0; i < keys.length; i++) {\n                        _core.delMemberRegistry(node, name, target, keys[i]);\n                    }\n\n                    keys = Object.keys(diff);\n                    for (i = 0; i < keys.length; i++) {\n                        _core.setMemberRegistry(node, name, target, keys[i], diff[keys[i]]);\n                    }\n                };\n            return TASYNC.call(function (t) {\n                _core.addMember(node, name, t);\n                memberAttrSetting(data.attr || {});\n                memberRegSetting(data.reg || {});\n                return;\n            }, _core.loadByPath(_core.getRoot(node), target));\n        }\n\n        function applySetChanges(node, setDiff) {\n            var done,\n                setNames = Object.keys(setDiff),\n                elements, i, j;\n            for (i = 0; i < setNames.length; i++) {\n                if (setDiff[setNames[i]] === TODELETESTRING) {\n                    _core.deleteSet(node, setNames[i]);\n                } else {\n                    _core.createSet(node, setNames[i]);\n                    elements = Object.keys(setDiff[setNames[i]]);\n                    for (j = 0; j < elements.length; j++) {\n                        if (setDiff[setNames[i]][elements[j]] === TODELETESTRING) {\n                            _core.delMember(node, setNames[i], elements[j]);\n                        } else {\n                            done = addMember(node, setNames[i], elements[j], setDiff[setNames[i]][elements[j]]);\n                        }\n                    }\n                }\n            }\n\n            return TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n\n        }\n\n        function applyMetaAttributes(node, metaAttrDiff) {\n            var i, keys, newValue;\n            if (metaAttrDiff === TODELETESTRING) {\n                //we should delete all MetaAttributes\n                keys = _core.getValidAttributeNames(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delAttributeMeta(node, keys[i]);\n                }\n            } else {\n                keys = Object.keys(metaAttrDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaAttrDiff[keys[i]] === TODELETESTRING) {\n                        _core.delAttributeMeta(node, keys[i]);\n                    } else {\n                        newValue = jsonConcat(_core.getAttributeMeta(node, keys[i]) || {}, metaAttrDiff[keys[i]]);\n                        _core.setAttributeMeta(node, keys[i], newValue);\n                    }\n                }\n            }\n        }\n\n        function applyMetaConstraints(node, metaConDiff) {\n            var keys, i;\n            if (metaConDiff === TODELETESTRING) {\n                //remove all constraints\n                keys = _core.getConstraintNames(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delConstraint(node, keys[i]);\n                }\n            } else {\n                keys = Object.keys(metaConDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaConDiff[keys[i]] === TODELETESTRING) {\n                        _core.delConstraint(node, keys[i]);\n                    } else {\n                        _core.setConstraint(node, keys[i], jsonConcat(_core.getConstraint(node, keys[i]) || {},\n                            metaConDiff[keys[i]]));\n                    }\n                }\n            }\n        }\n\n        function applyMetaChildren(node, metaChildrenDiff) {\n            var keys, i, done,\n                setChild = function (target, data/*, d*/) {\n                    _core.setChildMeta(node, target, data.min, data.max);\n                };\n            if (metaChildrenDiff === TODELETESTRING) {\n                //remove all valid child\n                keys = _core.getValidChildrenPaths(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delChildMeta(node, keys[i]);\n                }\n            } else {\n                _core.setChildrenMetaLimits(node, metaChildrenDiff.min, metaChildrenDiff.max);\n                delete metaChildrenDiff.max; //TODO we do not need it anymore, but maybe there is a better way\n                delete metaChildrenDiff.min;\n                keys = Object.keys(metaChildrenDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaChildrenDiff[keys[i]] === TODELETESTRING) {\n                        _core.delChildMeta(node, keys[i]);\n                    } else {\n                        done = TASYNC.call(setChild, _core.loadByPath(_core.getRoot(node), keys[i]),\n                            metaChildrenDiff[keys[i]], done);\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaPointers(node, metaPointerDiff) {\n            var names, targets, i, j, done,\n                setPointer = function (name, target, data/*, d*/) {\n                    _core.setPointerMetaTarget(node, name, target, data.min, data.max);\n                };\n            if (metaPointerDiff === TODELETESTRING) {\n                //remove all pointers,sets and their targets\n                names = _core.getValidPointerNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delPointerMeta(node, names[i]);\n                }\n\n                names = _core.getValidSetNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delPointerMeta(node, names[i]);\n                }\n                return;\n            }\n\n            names = Object.keys(metaPointerDiff);\n            for (i = 0; i < names.length; i++) {\n                if (metaPointerDiff[names[i]] === TODELETESTRING) {\n                    _core.delPointerMeta(node, names[i]);\n                } else {\n                    _core.setPointerMetaLimits(node, names[i], metaPointerDiff[names[i]].min,\n                        metaPointerDiff[names[i]].max);\n                    //TODO we do not need it anymore, but maybe there is a better way\n                    delete metaPointerDiff[names[i]].max;\n                    delete metaPointerDiff[names[i]].min;\n                    targets = Object.keys(metaPointerDiff[names[i]]);\n                    for (j = 0; j < targets.length; j++) {\n                        if (metaPointerDiff[names[i]][targets[j]] === TODELETESTRING) {\n                            _core.delPointerMetaTarget(node, names[i], targets[j]);\n                        } else {\n                            done = TASYNC.call(setPointer, names[i], _core.loadByPath(_core.getRoot(node), targets[j]),\n                                metaPointerDiff[names[i]][targets[j]], done);\n                        }\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaAspects(node, metaAspectsDiff) {\n            var names, targets, i, j, done,\n                setAspect = function (name, target/*, d*/) {\n                    _core.setAspectMetaTarget(node, name, target);\n                };\n            if (metaAspectsDiff === TODELETESTRING) {\n                //remove all aspects\n                names = _core.getValidAspectNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delAspectMeta(node, names[i]);\n                }\n                return;\n            }\n\n            names = Object.keys(metaAspectsDiff);\n            for (i = 0; i < names.length; i++) {\n                if (metaAspectsDiff[names[i]] === TODELETESTRING) {\n                    _core.delAspectMeta(node, names[i]);\n                } else {\n                    targets = metaAspectsDiff[names[i]];\n                    for (j = 0; j < targets.length; j++) {\n                        if (metaAspectsDiff[names[i]][targets[j]] === TODELETESTRING) {\n                            _core.delAspectMetaTarget(node, names[i], targets[j]);\n                        } else {\n                            done = TASYNC.call(setAspect, names[i], _core.loadByPath(_core.getRoot(node), targets[j]),\n                                done);\n                        }\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaChanges(node, metaDiff) {\n            var done;\n            applyMetaAttributes(node, metaDiff.attributes || TODELETESTRING);\n            applyMetaConstraints(node, metaDiff.constraints || TODELETESTRING);\n            done = applyMetaChildren(node, metaDiff.children || TODELETESTRING);\n            done = TASYNC.call(applyMetaPointers, node, metaDiff.pointers || TODELETESTRING, done);\n            done = TASYNC.call(applyMetaAspects, node, metaDiff.aspects || TODELETESTRING, done);\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        _core.applyTreeDiff = function (root, diff) {\n            toFrom = {};\n            fromTo = {};\n            getMoveSources(diff, '', toFrom, fromTo);\n\n            return TASYNC.join(makeInitialContainmentChanges(root, diff), applyNodeChange(root, '', diff));\n        };\n\n        function getNodeByGuid(diff, guid) {\n            var relids, i, node;\n\n            if (REGEXP.GUID.test(guid) !== true) {\n                return null;\n            }\n\n            if (diff.guid === guid) {\n                return diff;\n            }\n\n            relids = getDiffChildrenRelids(diff);\n            for (i = 0; i < relids.length; i++) {\n                node = getNodeByGuid(diff[relids[i]], guid);\n                if (node) {\n                    return node;\n                }\n            }\n            return null;\n        }\n\n        function insertAtPath(diff, path, object) {\n            ASSERT(typeof path === 'string');\n            var i, base, relid, nodepath;\n\n            if (path === '') {\n                _concatResult = JSON.parse(JSON.stringify(object));\n                return;\n            }\n            nodepath = path.match(/\\/\\/.*\\/\\//) || [];\n            nodepath = nodepath[0] || 'there is no nodepath in the path';\n            path = path.replace(nodepath, '/*nodepath*/');\n            nodepath = nodepath.replace(/\\/\\//g, '/');\n            nodepath = nodepath.slice(0, -1);\n            path = path.split('/');\n            path.shift();\n            if (path.indexOf('*nodepath*') !== -1) {\n                path[path.indexOf('*nodepath*')] = nodepath;\n            }\n            relid = path.pop();\n            base = diff;\n            for (i = 0; i < path.length; i++) {\n                base[path[i]] = base[path[i]] || {};\n                base = base[path[i]];\n            }\n            base[relid] = JSON.parse(JSON.stringify(object));\n            return;\n        }\n\n        //FIXME check if it is really depreciated\n        //function changeMovedPaths(singleNode) {\n        //    var keys, i;\n        //    keys = Object.keys(singleNode);\n        //    for (i = 0; i < keys.length; i++) {\n        //        if (_concatMoves.fromTo[keys[i]]) {\n        //            singleNode[_concatMoves.fromTo[keys[i]]] = singleNode[keys[i]];\n        //            delete singleNode[keys[i]];\n        //            if (typeof singleNode[_concatMoves.fromTo[keys[i]]] === 'object' &&\n        //                singleNode[_concatMoves.fromTo[keys[i]]] !== null) {\n        //\n        //                changeMovedPaths(singleNode[_concatMoves.fromTo[keys[i]]]);\n        //            }\n        //        } else {\n        //            if (typeof singleNode[keys[i]] === 'string' && keys[i] !== 'movedFrom' &&\n        //                _concatMoves.fromTo[singleNode[keys[i]]]) {\n        //\n        //                singleNode[keys[i]] = _concatMoves.fromTo[keys[i]];\n        //            }\n        //\n        //            if (typeof singleNode[keys[i]] === 'object' && singleNode[keys[i]] !== null) {\n        //                changeMovedPaths(singleNode[keys[i]]);\n        //            }\n        //        }\n        //\n        //    }\n        //    if (typeof singleNode === 'object' && singleNode !== null) {\n        //        keys = Object.keys(singleNode);\n        //        for (i = 0; i < keys.length; i++) {\n        //            if (_concatMoves.fromTo[keys[i]]) {\n        //                singleNode[_concatMoves.fromTo[keys[i]]] = singleNode[keys[i]];\n        //                delete singleNode[keys[i]];\n        //            }\n        //        }\n        //    } else if (typeof singleNode === 'string') {\n        //\n        //    }\n        //\n        //}\n\n        function getSingleNode(node) {\n            //removes the children from the node\n            var result = JSON.parse(JSON.stringify(node)),\n                keys = getDiffChildrenRelids(result),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                delete result[keys[i]];\n            }\n            //changeMovedPaths(result);\n            return result;\n        }\n\n        function jsonConcat(base, extension) {\n            var baseKeys = Object.keys(base),\n                extKeys = Object.keys(extension),\n                concat = JSON.parse(JSON.stringify(base)),\n                i;\n            for (i = 0; i < extKeys.length; i++) {\n                if (baseKeys.indexOf(extKeys[i]) === -1) {\n                    concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\n                } else {\n                    if (typeof base[extKeys[i]] === 'object' && typeof extension[extKeys[i]] === 'object') {\n                        concat[extKeys[i]] = jsonConcat(base[extKeys[i]], extension[extKeys[i]]);\n                    } else { //either from value to object or object from value we go with the extension\n                        concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\n                    }\n                }\n            }\n            return concat;\n        }\n\n        //FIXME are we going to use this function\n        //function getConflictByGuid(conflict, guid) {\n        //    var relids, i, result;\n        //    if (conflict.guid === guid) {\n        //        return conflict;\n        //    }\n        //    relids = getDiffChildrenRelids(conflict);\n        //    for (i = 0; i < relids.length; i++) {\n        //        result = getConflictByGuid(conflict[relids[i]], guid);\n        //        if (result) {\n        //            return result;\n        //        }\n        //    }\n        //    return null;\n        //}\n\n        function getPathByGuid(conflict, guid, path) {\n            var relids, i, result;\n\n            if (REGEXP.GUID.test(guid) !== true) {\n                return null;\n            }\n\n            if (conflict.guid === guid) {\n                return path;\n            }\n            relids = getDiffChildrenRelids(conflict);\n            for (i = 0; i < relids.length; i++) {\n                result = getPathByGuid(conflict[relids[i]], guid, path + '/' + relids[i]);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        }\n\n        //now we try a different approach, which maybe more simple\n        function getCommonPathForConcat(path) {\n            if (_concatMoves.getExtensionSourceFromDestination[path]) {\n                path = _concatMoves.getExtensionSourceFromDestination[path];\n            }\n            if (_concatMoves.getBaseDestinationFromSource[path]) {\n                path = _concatMoves.getBaseDestinationFromSource[path];\n            }\n            return path;\n        }\n\n        function getConcatBaseRemovals(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i;\n            if (diff.removed !== true) {\n                if (diff.movedFrom) {\n                    if (_concatBaseRemovals[diff.guid] !== undefined) {\n                        delete _concatBaseRemovals[diff.guid];\n                    } else {\n                        _concatBaseRemovals[diff.guid] = false;\n                    }\n                }\n                for (i = 0; i < relids.length; i++) {\n                    getConcatBaseRemovals(diff[relids[i]]);\n                }\n            } else {\n                if (_concatBaseRemovals[diff.guid] === false) {\n                    delete _concatBaseRemovals[diff.guid];\n                } else {\n                    _concatBaseRemovals[diff.guid] = true;\n                }\n            }\n        }\n\n        function getObstructiveGuids(diffNode) {\n            var result = [],\n                keys, i;\n            keys = Object.keys(diffNode.oGuids || {});\n            for (i = 0; i < keys.length; i++) {\n                if (_concatBaseRemovals[keys[i]]) {\n                    result.push(keys[i]);\n                }\n            }\n            keys = Object.keys(diffNode.ooGuids || {});\n            for (i = 0; i < keys.length; i++) {\n                if (_concatBaseRemovals[keys[i]]) {\n                    result.push(keys[i]);\n                }\n            }\n            return result;\n        }\n\n        function getWhomIObstructGuids(guid) {\n            //this function is needed when the extension contains a deletion where the base did not delete the node\n            var guids = [],\n                checkNode = function (diffNode) {\n                    var relids, i;\n                    if ((diffNode.oGuids && diffNode.oGuids[guid]) || (diffNode.ooGuids && diffNode.ooGuids[guid])) {\n                        guids.push(diffNode.guid);\n                    }\n\n                    relids = getDiffChildrenRelids(diffNode);\n                    for (i = 0; i < relids.length; i++) {\n                        checkNode(diffNode[relids[i]]);\n                    }\n                };\n            checkNode(_concatBase);\n            return guids;\n        }\n\n        function gatherFullNodeConflicts(diffNode, mine, path, opposingPath) {\n            var conflict,\n                opposingConflict,\n                keys, i,\n                createSingleKeyValuePairConflicts = function (pathBase, data) {\n                    var keys, i;\n                    keys = Object.keys(data);\n                    for (i = 0; i < keys.length; i++) {\n                        conflict[pathBase + '/' + keys[i]] = conflict[pathBase + '/' + keys[i]] || {\n                                value: data[keys[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[pathBase + '/' + keys[i]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[pathBase + '/' + keys[i]] = true;\n                    }\n                };\n\n            //setting the conflicts\n            if (mine === true) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n            ASSERT(opposingConflict);\n            //if the node was moved we should make a conflict for the whole node as well\n            if (diffNode.movedFrom) {\n                conflict[path] = conflict[path] || {value: path, conflictingPaths: {}};\n                conflict[path].conflictingPaths[opposingPath] = true;\n                opposingConflict.conflictingPaths[path] = true;\n            }\n            createSingleKeyValuePairConflicts(path + '/attr', diffNode.attr || {});\n            createSingleKeyValuePairConflicts(path + '/reg', diffNode.reg || {});\n            createSingleKeyValuePairConflicts(path + '/pointer', diffNode.pointer || {});\n\n            if (diffNode.set) {\n                if (diffNode.set === TODELETESTRING) {\n                    conflict[path + '/set'] = conflict[path + '/set'] || {value: TODELETESTRING, conflictingPaths: {}};\n                    conflict[path + '/set'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/set'] = true;\n                } else {\n                    keys = Object.keys(diffNode.set);\n                    for (i = 0; i < keys.length; i++) {\n                        if (diffNode.set[keys[i]] === TODELETESTRING) {\n                            conflict[path + '/set/' + keys[i]] = conflict[path + '/set/' + keys[i]] || {\n                                    value: TODELETESTRING,\n                                    conflictingPaths: {}\n                                };\n                            conflict[path + '/set/' + keys[i]].conflictingPaths[opposingPath] = true;\n                            opposingConflict.conflictingPaths[path + '/set/' + keys[i]] = true;\n                        } else {\n                            gatherFullSetConflicts(diffNode.set[keys[i]], mine, path + '/set/' + keys[i], opposingPath);\n                        }\n                    }\n                }\n            }\n\n            if (diffNode.meta) {\n                gatherFullMetaConflicts(diffNode.meta, mine, path + '/meta', opposingPath);\n            }\n\n            //if the opposing item is theirs, we have to recursively go down in our changes\n            if (mine) {\n                keys = getDiffChildrenRelids(diffNode);\n                for (i = 0; i < keys.length; i++) {\n                    gatherFullNodeConflicts(diffNode[keys[i]], true, path + '/' + keys[i], opposingPath);\n                }\n            }\n\n        }\n\n        function gatherFullSetConflicts(diffSet, mine, path, opposingPath) {\n            var relids = getDiffChildrenRelids(diffSet),\n                i, keys, j, conflict, opposingConflict;\n\n            //setting the conflicts\n            if (mine === true) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n            for (i = 0; i < relids.length; i++) {\n                if (diffSet[relids[i]] === TODELETESTRING) {\n                    //single conflict as the element was removed\n                    conflict[path + '/' + relids[i] + '/'] = conflict[path + '/' + relids[i] + '/'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/' + relids[i] + '/'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/' + relids[i] + '/'] = true;\n                } else {\n                    keys = Object.keys(diffSet[relids[i]].attr || {});\n                    for (j = 0; j < keys.length; j++) {\n                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]] =\n                            conflict[path + '/' + relids[i] + '//attr/' + keys[j]] || {\n                                value: diffSet[relids[i]].attr[keys[j]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//attr/' + keys[j]] = true;\n                    }\n                    keys = Object.keys(diffSet[relids[i]].reg || {});\n                    for (j = 0; j < keys.length; j++) {\n                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]] =\n                            conflict[path + '/' + relids[i] + '//reg/' + keys[j]] || {\n                                value: diffSet[relids[i]].reg[keys[j]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//reg/' + keys[j]] = true;\n                    }\n                }\n            }\n        }\n\n        function concatSingleKeyValuePairs(path, base, extension) {\n            var keys, i, temp;\n            keys = Object.keys(extension);\n            for (i = 0; i < keys.length; i++) {\n                temp = extension[keys[i]];\n                if (typeof temp === 'string' && temp !== TODELETESTRING) {\n                    temp = getCommonPathForConcat(temp);\n                }\n                if (base[keys[i]] !== undefined && CANON.stringify(base[keys[i]]) !== CANON.stringify(temp)) {\n                    //conflict\n                    _conflictMine[path + '/' + keys[i]] = {value: base[keys[i]], conflictingPaths: {}};\n                    _conflictTheirs[path + '/' + keys[i]] = {value: extension[keys[i]], conflictingPaths: {}};\n                    _conflictMine[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;\n                    _conflictTheirs[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;\n                } else {\n                    base[keys[i]] = extension[keys[i]];\n                }\n            }\n        }\n\n        function concatSet(path, base, extension) {\n            var names = Object.keys(extension),\n                members, i, j, memberPath;\n\n            for (i = 0; i < names.length; i++) {\n                if (base[names[i]]) {\n                    if (base[names[i]] === TODELETESTRING) {\n                        if (extension[names[i]] !== TODELETESTRING) {\n                            //whole set conflict\n                            _conflictMine[path + '/' + names[i]] = {value: TODELETESTRING, conflictingPaths: {}};\n                            gatherFullSetConflicts(extension[names[i]],\n                                false, path + '/' + names[i], path + '/' + names[i]);\n                        }\n                    } else {\n                        if (extension[names[i]] === TODELETESTRING) {\n                            //whole set conflict\n                            _conflictTheirs[path + '/' + names[i]] = {value: TODELETESTRING, conflictingPaths: {}};\n                            gatherFullSetConflicts(base[names[i]], true, path + '/' + names[i], path + '/' + names[i]);\n                        } else {\n                            //now we can only have member or sub-member conflicts...\n                            members = getDiffChildrenRelids(extension[names[i]]);\n                            for (j = 0; j < members.length; j++) {\n                                memberPath = getCommonPathForConcat(members[j]);\n                                if (base[names[i]][memberPath]) {\n                                    if (base[names[i]][memberPath] === TODELETESTRING) {\n                                        if (extension[names[i]][members[j]] !== TODELETESTRING) {\n                                            //whole member conflict\n                                            _conflictMine[path + '/' + names[i] + '/' + memberPath + '//'] = {\n                                                value: TODELETESTRING,\n                                                conflictingPaths: {}\n                                            };\n                                            gatherFullNodeConflicts(extension[names[i]][members[j]],\n                                                false,\n                                                path + '/' + names[i] + '/' + memberPath + '//', path +\n                                                '/' + names[i] + '/' + memberPath + '//');\n                                        }\n                                    } else {\n                                        if (extension[names[i]][members[j]] === TODELETESTRING) {\n                                            //whole member conflict\n                                            _conflictTheirs[path + '/' + names[i] + '/' + memberPath + '//'] = {\n                                                value: TODELETESTRING,\n                                                conflictingPaths: {}\n                                            };\n                                            gatherFullNodeConflicts(base[names[i]][memberPath],\n                                                true,\n                                                path + '/' + names[i] + '/' + memberPath + '//', path +\n                                                '/' + names[i] + '/' + memberPath + '//');\n                                        } else {\n                                            if (extension[names[i]][members[j]].attr) {\n                                                if (base[names[i]][memberPath].attr) {\n                                                    concatSingleKeyValuePairs(path + '/' +\n                                                        names[i] + '/' + memberPath + '/' + '/attr',\n                                                        base[names[i]][memberPath].attr,\n                                                        extension[names[i]][members[j]].attr);\n                                                } else {\n                                                    base[names[i]][memberPath].attr =\n                                                        extension[names[i]][members[j]].attr;\n                                                }\n                                            }\n                                            if (extension[names[i]][members[j]].reg) {\n                                                if (base[names[i]][memberPath].reg) {\n                                                    concatSingleKeyValuePairs(path + '/' +\n                                                        names[i] + '/' + memberPath + '/' + '/reg',\n                                                        base[names[i]][memberPath].reg,\n                                                        extension[names[i]][members[j]].reg);\n                                                } else {\n                                                    base[names[i]][memberPath].reg =\n                                                        extension[names[i]][members[j]].reg;\n                                                }\n                                            }\n\n                                        }\n                                    }\n                                } else {\n                                    //concat\n                                    base[names[i]][memberPath] = extension[names[i]][members[j]];\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    //simple concatenation\n                    //TODO the path for members should be replaced here as well...\n                    base[names[i]] = extension[names[i]];\n                }\n            }\n        }\n\n        function gatherFullMetaConflicts(diffMeta, mine, path, opposingPath) {\n            var conflict, opposingConflict,\n                relids, i, j, keys, tPath, key;\n\n            if (mine) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n\n            if (diffMeta === TODELETESTRING) {\n                conflict[path] = conflict[path] || {value: TODELETESTRING, conflictingPaths: {}};\n                conflict[path].conflictingPaths[opposingPath] = true;\n                opposingConflict.conflictingPaths[path] = true;\n                return; //there is no other conflict\n            }\n\n            //children\n            if (diffMeta.children) {\n                if (diffMeta.children === TODELETESTRING) {\n                    conflict[path + '/children'] = conflict[path + '/children'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/children'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/children'] = true;\n                } else {\n                    if (diffMeta.children.max) {\n                        conflict[path + '/children/max'] = conflict[path + '/children/max'] || {\n                                value: diffMeta.children.max,\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/max'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/max'] = true;\n                    }\n                    if (diffMeta.children.min) {\n                        conflict[path + '/children/min'] = conflict[path + '/children/min'] || {\n                                value: diffMeta.children.min,\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/min'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/min'] = true;\n                    }\n                    relids = getDiffChildrenRelids(diffMeta.children);\n                    for (i = 0; i < relids.length; i++) {\n                        conflict[path + '/children/' + relids[i]] = conflict[path + '/children/' + relids[i]] || {\n                                value: diffMeta.children[relids[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/' + relids[i]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/' + relids[i]] = true;\n                    }\n                }\n            }\n            //attributes\n            if (diffMeta.attributes) {\n                if (diffMeta.attributes === TODELETESTRING) {\n                    conflict[path + '/attributes'] = conflict[path + '/attributes'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/attributes'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/attributes'] = true;\n                } else {\n                    keys = Object.keys(diffMeta.attributes);\n                    for (i = 0; i < keys.length; i++) {\n                        key = path + '/attributes/' + keys[i];\n                        conflict[key] = conflict[key] || {\n                                value: diffMeta.attributes[keys[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[key].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[key] = true;\n                    }\n                }\n            }\n            //pointers\n            if (diffMeta.pointers) {\n                if (diffMeta.pointers === TODELETESTRING) {\n                    conflict[path + '/pointers'] = conflict[path + '/pointers'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/pointers'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/pointers'] = true;\n                } else {\n                    keys = Object.keys(diffMeta.pointers);\n                    for (i = 0; i < keys.length; i++) {\n                        if (diffMeta.pointers[keys[i]] === TODELETESTRING) {\n                            conflict[path + '/pointers/' + keys[i]] = conflict[path + '/pointers/' + keys[i]] || {\n                                    value: TODELETESTRING,\n                                    conflictingPaths: {}\n                                };\n                            conflict[path + '/pointers/' + keys[i]].conflictingPaths[opposingPath] = true;\n                            opposingConflict.conflictingPaths[path + '/pointers/' + keys[i]] = true;\n                        } else {\n                            if (diffMeta.pointers[keys[i]].max) {\n                                conflict[path + '/pointers/' + keys[i] + '/max'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/max'] || {\n                                        value: diffMeta.pointers[keys[i]].max,\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/max'].conflictingPaths[opposingPath] = true;\n                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/max'] = true;\n                            }\n                            if (diffMeta.pointers[keys[i]].min) {\n                                conflict[path + '/pointers/' + keys[i] + '/min'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/min'] || {\n                                        value: diffMeta.pointers[keys[i]].min,\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/min'].conflictingPaths[opposingPath] = true;\n                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/min'] = true;\n                            }\n                            relids = getDiffChildrenRelids(diffMeta.pointers[keys[i]]);\n                            for (j = 0; j < relids.length; j++) {\n                                tPath = getCommonPathForConcat(relids[j]);\n                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] || {\n                                        value: diffMeta.pointers[keys[i]][relids[j]],\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'].\n                                    conflictingPaths[opposingPath] = true;\n                                opposingConflict.\n                                    conflictingPaths[path + '/pointers/' + keys[i] + '/' + tPath + '//'] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            //aspects\n            //TODO\n        }\n\n        function concatMeta(path, base, extension) {\n            var keys, i, tPath, j, paths, t2Path,\n                mergeMetaItems = function (bPath, bData, eData) {\n                    var bKeys, tKeys, i, tPath, t2Path;\n                    //delete checks\n                    if (bData === TODELETESTRING || eData === TODELETESTRING) {\n                        if (CANON.stringify(bData) !== CANON.stringify(eData)) {\n                            _conflictMine[bPath] = _conflictMine[bPath] || {value: bData, conflictingPaths: {}};\n                            _conflictMine[bPath].conflictingPaths[bPath] = true;\n                            _conflictTheirs[bPath] = _conflictTheirs[bPath] || {value: eData, conflictingPaths: {}};\n                            _conflictTheirs[bPath].conflictingPaths[bPath] = true;\n                        }\n                    } else {\n                        //max\n                        if (eData.max) {\n                            if (bData.max && bData.max !== eData.max) {\n                                tPath = bPath + '/max';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData.max,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData.max,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData.max = eData.max;\n                            }\n                        }\n                        //min\n                        if (eData.min) {\n                            if (bData.min && bData.min !== eData.min) {\n                                tPath = bPath + '/min';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData.min,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData.min,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData.min = eData.min;\n                            }\n                        }\n                        //targets\n                        bKeys = getDiffChildrenRelids(bData);\n                        tKeys = getDiffChildrenRelids(eData);\n                        for (i = 0; i < tKeys.length; i++) {\n                            tPath = getCommonPathForConcat(tKeys[i]);\n                            if (bKeys.indexOf(tPath) !== -1 && CANON.stringify(bData[tPath]) !==\n                                CANON.stringify(eData[tKeys[i]])) {\n\n                                t2Path = tPath;\n                                tPath = bPath + '/' + tPath + '//';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData[t2Path],\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData[tKeys[i]],\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData[tPath] = eData[tKeys[i]];\n                            }\n                        }\n                    }\n                };\n            if (CANON.stringify(base) !== CANON.stringify(extension)) {\n                if (base === TODELETESTRING) {\n                    _conflictMine[path] = _conflictMine[path] || {value: TODELETESTRING, conflictingPaths: {}};\n                    gatherFullMetaConflicts(extension, false, path, path);\n                } else {\n                    if (extension === TODELETESTRING) {\n                        _conflictTheirs[path] = _conflictTheirs[path] || {\n                                value: TODELETESTRING,\n                                conflictingPaths: {}\n                            };\n                        gatherFullMetaConflicts(base, true, path, path);\n                    } else {\n                        //now check for sub-meta conflicts\n\n                        //children\n                        if (extension.children) {\n                            if (base.children) {\n                                mergeMetaItems(path + '/children', base.children, extension.children);\n                            } else {\n                                //we just simply merge the extension's\n                                base.children = extension.children;\n                            }\n                        }\n                        //pointers\n                        if (extension.pointers) {\n                            if (base.pointers) {\n                                //complete deletion\n                                if (base.pointers === TODELETESTRING || extension.pointers === TODELETESTRING) {\n                                    if (CANON.stringify(base.pointers) !== CANON.stringify(extension.pointers)) {\n                                        tPath = path + '/pointers';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.pointers,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.pointers,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.pointers);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.pointers[keys[i]]) {\n                                            mergeMetaItems(path + '/pointers/' + keys[i], base.pointers[keys[i]],\n                                                extension.pointers[keys[i]]);\n                                        } else {\n                                            base.pointers[keys[i]] = extension.pointers[keys[i]];\n                                        }\n                                    }\n                                }\n                            } else {\n                                base.pointers = extension.pointers;\n                            }\n                        }\n                        //attributes\n                        if (extension.attributes) {\n                            if (base.attributes) {\n                                if (extension.attributes === TODELETESTRING || base.attributes === TODELETESTRING) {\n                                    if (CANON.stringify(base.attributes) !== CANON.stringify(extension.attributes)) {\n                                        tPath = path + '/attributes';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.attributes,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.attributes,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.attributes);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.attributes[keys[i]]) {\n                                            if (extension.attributes[keys[i]] === TODELETESTRING ||\n                                                base.attributes[keys[i]] === TODELETESTRING) {\n\n                                                if (CANON.stringify(base.attributes[keys[i]]) !==\n                                                    CANON.stringify(extension.attributes[keys[i]])) {\n\n                                                    tPath = path + '/attributes/' + [keys[i]];\n                                                    _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                            value: base.attributes[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                            value: extension.attributes[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                }\n                                            } else {\n                                                concatSingleKeyValuePairs(path + '/attributes/' + keys[i],\n                                                    base.attributes[keys[i]], extension.attributes[keys[i]]);\n                                            }\n                                        } else {\n                                            base.attributes[keys[i]] = extension.attributes[keys[i]];\n                                        }\n                                    }\n\n                                }\n                            } else {\n                                base.attributes = extension.attributes;\n                            }\n                        }\n\n                        //aspects\n                        if (extension.aspects) {\n                            if (base.aspects) {\n                                if (extension.aspects === TODELETESTRING || base.aspects === TODELETESTRING) {\n                                    if (CANON.stringify(base.aspects) !== CANON.stringify(extension.aspects)) {\n                                        tPath = path + '/aspects';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.aspects,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.aspects,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.aspects);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.aspects[keys[i]]) {\n                                            if (extension.aspects[keys[i]] === TODELETESTRING ||\n                                                base.aspects[keys[i]] === TODELETESTRING) {\n                                                if (CANON.stringify(base.aspects[keys[i]]) !==\n                                                    CANON.stringify(extension.aspects[keys[i]])) {\n                                                    tPath = path + '/aspects/' + keys[i];\n                                                    _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                            value: base.aspects[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                            value: extension.aspects[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                }\n                                            } else {\n                                                paths = Object.keys(extension.aspects[keys[i]]);\n                                                for (j = 0; j < paths.length; j++) {\n                                                    tPath = getCommonPathForConcat(paths[j]);\n                                                    if (base.aspects[keys[i]][tPath]) {\n                                                        if (CANON.stringify(base.aspects[keys[i]][tPath]) !==\n                                                            CANON.stringify(extension.aspects[keys[i]][paths[j]])) {\n                                                            t2Path = tPath;\n                                                            tPath = path + '/aspects/' + keys[i] + '/' + tPath + '//';\n                                                            _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                                    value: base.aspects[keys[i]][t2Path],\n                                                                    conflictingPaths: {}\n                                                                };\n                                                            _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                            _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                                    value: extension.aspects[keys[i]][paths[j]],\n                                                                    conflictingPaths: {}\n                                                                };\n                                                            _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                        }\n                                                    } else {\n                                                        base.aspects[keys[i]][tPath] =\n                                                            extension.aspects[keys[i]][paths[j]];\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            base.aspects[keys[i]] = extension.aspects[keys[i]];\n                                        }\n                                    }\n                                }\n                            } else {\n                                base.aspects = extension.aspects;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function tryToConcatNodeChange(extNode, path) {\n            var guid = extNode.guid,\n                oGuids = getObstructiveGuids(extNode),\n                baseNode = getNodeByGuid(_concatBase, guid),\n                basePath = getPathByGuid(_concatBase, guid, ''),\n                i, tPath,\n                relids = getDiffChildrenRelids(extNode);\n\n            if (extNode.removed === true) {\n                if (baseNode && baseNode.removed !== true) {\n                    tPath = basePath + '/removed';\n                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {value: true, conflictingPaths: {}};\n                    oGuids = getWhomIObstructGuids(guid);\n                    ASSERT(oGuids.length > 0);\n                    for (i = 0; i < oGuids.length; i++) {\n                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);\n                        basePath = getPathByGuid(_concatBase, oGuids[i], '');\n                        gatherFullNodeConflicts(baseNode, true, basePath, tPath);\n                    }\n                } else {\n                    //we simply concat the deletion\n                    insertAtPath(_concatBase, path, extNode);\n                }\n            } else {\n                if (oGuids.length > 0) {\n                    for (i = 0; i < oGuids.length; i++) {\n                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);\n                        basePath = getPathByGuid(_concatBase, oGuids[i], '');\n                        _conflictMine[basePath + '/removed'] = _conflictMine[basePath + '/removed'] || {\n                                value: true,\n                                conflictingPaths: {}\n                            };\n                        gatherFullNodeConflicts(extNode, false, path, basePath + '/removed');\n                    }\n                } else if (baseNode) {\n                    //here we are able to check the sub-node conflicts\n                    //check double moves - we do not care if they moved under the same parent\n                    if (extNode.movedFrom) {\n                        if (baseNode.movedFrom && path !== basePath) {\n                            _conflictMine[basePath] = _conflictMine[basePath] || {\n                                    value: 'move',\n                                    conflictingPaths: {}\n                                };\n                            _conflictTheirs[path] = _conflictTheirs[path] || {value: 'move', conflictingPaths: {}};\n                            _conflictMine[basePath].conflictingPaths[path] = true;\n                            _conflictTheirs[path].conflictingPaths[basePath] = true;\n                            //we keep the node where it is, but synchronize the paths\n                            path = basePath;\n                        } else if (path !== basePath) {\n                            //first we move the base object to its new path\n                            //we copy the moved from information right here\n                            baseNode.movedFrom = extNode.movedFrom;\n                            insertAtPath(_concatBase, path, baseNode);\n                            removePathFromDiff(_concatBase, basePath);\n                            baseNode = getNodeByGuid(_concatBase, guid);\n                            basePath = getPathByGuid(_concatBase, guid, '');\n                            ASSERT(path === basePath);\n                        }\n                    }\n\n                    ASSERT(basePath === path || baseNode.movedFrom === path);\n                    path = basePath; //the base was moved\n\n\n                    //and now the sub-node conflicts\n                    if (extNode.attr) {\n                        if (baseNode.attr) {\n                            concatSingleKeyValuePairs(path + '/attr', baseNode.attr, extNode.attr);\n                        } else {\n                            insertAtPath(_concatBase, path + '/attr', extNode.attr);\n                        }\n                    }\n                    if (extNode.reg) {\n                        if (baseNode.reg) {\n                            concatSingleKeyValuePairs(path + '/reg', baseNode.reg, extNode.reg);\n                        } else {\n                            insertAtPath(_concatBase, path + '/reg', extNode.reg);\n                        }\n                    }\n                    if (extNode.pointer) {\n                        if (baseNode.pointer) {\n                            concatSingleKeyValuePairs(path + '/pointer', baseNode.pointer, extNode.pointer);\n                        } else {\n                            insertAtPath(_concatBase, path + '/pointer', extNode.pointer);\n                        }\n                    }\n                    if (extNode.set) {\n                        if (baseNode.set) {\n                            concatSet(path + '/set', baseNode.set, extNode.set);\n                        } else {\n                            insertAtPath(_concatBase, path + '/set', extNode.set);\n                        }\n                    }\n                    if (extNode.meta) {\n                        if (baseNode.meta) {\n                            concatMeta(path + '/meta', baseNode.meta, extNode.meta);\n                        } else {\n                            insertAtPath(_concatBase, path + '/meta', extNode.meta);\n                        }\n                    }\n                } else {\n                    //there is no basenode so we can concat the whole node\n                    insertAtPath(_concatBase, path, getSingleNode(extNode));\n                }\n            }\n\n            //here comes the recursion\n            for (i = 0; i < relids.length; i++) {\n                tryToConcatNodeChange(extNode[relids[i]], path + '/' + relids[i]);\n            }\n\n        }\n\n        function generateConflictItems() {\n            var items = [],\n                keys, i, j, conflicts;\n            keys = Object.keys(_conflictMine);\n\n            for (i = 0; i < keys.length; i++) {\n                conflicts = Object.keys(_conflictMine[keys[i]].conflictingPaths || {});\n                ASSERT(conflicts.length > 0);\n                for (j = 0; j < conflicts.length; j++) {\n                    items.push({\n                        selected: 'mine',\n                        mine: {\n                            path: keys[i],\n                            info: keys[i].replace(/\\//g, ' / '),\n                            value: _conflictMine[keys[i]].value\n                        },\n                        theirs: {\n                            path: conflicts[j],\n                            info: conflicts[j].replace(/\\//g, ' / '),\n                            value: _conflictTheirs[conflicts[j]].value\n                        }\n                    });\n                }\n            }\n            return items;\n        }\n\n        function harmonizeConflictPaths(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                keys, i, members, j;\n\n            keys = Object.keys(diff.pointer || {});\n            for (i = 0; i < keys.length; i++) {\n                diff.pointer[keys[i]] = getCommonPathForConcat(diff.pointer[keys[i]]);\n            }\n            keys = Object.keys(diff.set || {});\n            for (i = 0; i < keys.length; i++) {\n                members = Object.keys(diff.set[keys[i]] || {});\n                for (j = 0; j < members.length; j++) {\n                    if (members[j] !== getCommonPathForConcat(members[j])) {\n                        diff.set[keys[i]][getCommonPathForConcat(members[j])] = diff.set[keys[i]][members[j]];\n                        delete diff.set[keys[i]][members[j]];\n                    }\n                }\n            }\n\n            //TODO we have to do the meta as well\n            for (i = 0; i < relids.length; i++) {\n                harmonizeConflictPaths(diff[relids[i]]);\n            }\n        }\n\n        _core.tryToConcatChanges = function (base, extension) {\n            var result = {};\n            _conflictItems = [];\n            _conflictMine = {};\n            _conflictTheirs = {};\n            _concatBase = base;\n            _concatExtension = extension;\n            _concatBaseRemovals = {};\n            _concatMoves = {\n                getBaseSourceFromDestination: {},\n                getBaseDestinationFromSource: {},\n                getExtensionSourceFromDestination: {},\n                getExtensionDestinationFromSource: {}\n            };\n            getMoveSources(base,\n                '', _concatMoves.getBaseSourceFromDestination, _concatMoves.getBaseDestinationFromSource);\n            getMoveSources(extension,\n                '', _concatMoves.getExtensionSourceFromDestination, _concatMoves.getExtensionDestinationFromSource);\n            getConcatBaseRemovals(base);\n            tryToConcatNodeChange(_concatExtension, '');\n\n            result.items = generateConflictItems();\n            result.mine = _conflictMine;\n            result.theirs = _conflictTheirs;\n            result.merge = _concatBase;\n            harmonizeConflictPaths(result.merge);\n            return result;\n        };\n\n        function depthOfPath(path) {\n            ASSERT(typeof path === 'string');\n            return path.split('/').length;\n        }\n\n        function resolveMoves(resolveObject) {\n            var i, moves = {},\n                filteredItems = [],\n                path,\n                moveBaseOfPath = function (path) {\n                    var keys = Object.keys(moves),\n                        i, maxDepth = -1,\n                        base = null;\n                    for (i = 0; i < keys.length; i++) {\n                        if (path.indexOf(keys[i]) === 1 && depthOfPath(keys[i]) > maxDepth) {\n                            base = keys[i];\n                            maxDepth = depthOfPath(keys[i]);\n                        }\n                    }\n                    return base;\n                };\n            for (i = 0; i < resolveObject.items.length; i++) {\n                if (resolveObject.items[i].selected === 'theirs' && resolveObject.items[i].theirs.value === 'move') {\n                    moves[resolveObject.items[i].mine.path] = resolveObject.items[i].theirs.path;\n                    //and we also make the move\n                    insertAtPath(resolveObject.merge,\n                        resolveObject.items[i].theirs.path,\n                        getPathOfDiff(resolveObject.merge, resolveObject.items[i].mine.path));\n                    removePathFromDiff(resolveObject.merge, resolveObject.items[i].mine.path);\n                } else {\n                    filteredItems.push(resolveObject.items[i]);\n                }\n            }\n            resolveObject.items = filteredItems;\n\n            //in a second run we modify all sub-path of the moves paths\n            for (i = 0; i < resolveObject.items.length; i++) {\n                if (resolveObject.items[i].selected === 'theirs') {\n                    path = moveBaseOfPath(resolveObject.items[i].theirs.path);\n                    if (path) {\n                        resolveObject.items[i].theirs.path =\n                            resolveObject.items[i].theirs.path.replace(path, moves[path]);\n                    }\n                    path = moveBaseOfPath(resolveObject.items[i].mine.path);\n                    if (path) {\n                        resolveObject.items[i].mine.path = resolveObject.items[i].mine.path.replace(path, moves[path]);\n                    }\n                }\n            }\n        }\n\n        _core.applyResolution = function (conflictObject) {\n            //we apply conflict items to the merge and return it as a diff\n            var i;\n            resolveMoves(conflictObject);\n            for (i = 0; i < conflictObject.items.length; i++) {\n                if (conflictObject.items[i].selected !== 'mine') {\n                    removePathFromDiff(conflictObject.merge, conflictObject.items[i].mine.path);\n                    insertAtPath(conflictObject.merge,\n                        conflictObject.items[i].theirs.path, conflictObject.items[i].theirs.value);\n                }\n            }\n\n            return conflictObject.merge;\n        };\n\n\n        //we remove some low level functions as they should not be used on high level\n        delete _core.overlayInsert;\n\n        return _core;\n    }\n\n    return diffCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/metacachecore',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\n        'use strict';\n\n        var MetaCacheCore = function (oldcore, options) {\n            ASSERT(typeof options === 'object');\n            ASSERT(typeof options.globConf === 'object');\n            ASSERT(typeof options.logger !== 'undefined');\n            // copy all operations\n            var core = {},\n                META_SET_NAME = 'MetaAspectSet',\n                logger = options.logger.fork('MetaCacheCore');\n            for (var key in oldcore) {\n                core[key] = oldcore[key];\n            }\n            logger.debug('initialized');\n\n            function loadMetaSet(root) {\n                var paths = oldcore.getMemberPaths(root, META_SET_NAME),\n                    i,\n                    metaNodes = [];\n\n                for (i = 0; i < paths.length; i += 1) {\n                    metaNodes.push(oldcore.loadByPath(root, paths[i]));\n                }\n\n                return TASYNC.lift(metaNodes);\n            }\n\n            core.loadRoot = function (hash) {\n                return TASYNC.call(function (root) {\n                    return TASYNC.call(function (elements) {\n                        var i = 0;\n                        root.metaNodes = {};\n                        for (i = 0; i < elements.length; i += 1) {\n                            root.metaNodes[oldcore.getPath(elements[i])] = elements[i];\n                        }\n                        return root;\n                    }, loadMetaSet(root));\n                }, oldcore.loadRoot(hash));\n            };\n\n            //functions where the cache may needs to be updated\n            core.createNode = function (parameters) {\n                var node = oldcore.createNode(parameters);\n\n                if (!parameters || !parameters.parent) {\n                    //a root just have been created\n                    node.metaNodes = {};\n                }\n\n                return node;\n            };\n\n            core.addMember = function (node, setName, member) {\n                var root = core.getRoot(node);\n                oldcore.addMember(node, setName, member);\n\n                //check if our cache needs to be updated\n                if (setName === META_SET_NAME && core.getPath(node) === core.getPath(root)) {\n                    root.metaNodes[core.getPath(member)] = member;\n                }\n            };\n\n            core.delMember = function (node, setName, memberPath) {\n                var root = core.getRoot(node);\n                oldcore.delMember(node, setName, memberPath);\n\n                //check if our cache needs to be updated\n                if (setName === META_SET_NAME && core.getPath(node) === core.getPath(root)) {\n                    delete root.metaNodes[memberPath];\n                }\n            };\n\n            core.deleteNode = function (node, technical) {\n                var root = core.getRoot(node);\n                if (root.metaNodes[core.getPath(node)]) {\n                    delete root.metaNodes[core.getPath(node)];\n                }\n                oldcore.deleteNode(node, technical);\n            };\n\n            core.moveNode = function (node, parent) {\n                var root = core.getRoot(node),\n                    oldpath = core.getPath(node),\n                    moved = oldcore.moveNode(node, parent);\n\n                if (root.metaNodes[oldpath]) {\n                    delete root.metaNodes[oldpath];\n                    root.metaNodes[core.getPath(moved)] = moved;\n                }\n\n                return moved;\n            };\n\n            //additional inquiry functions\n            core.isMetaNode = function (node) {\n                var root = core.getRoot(node);\n                if (root.metaNodes && root.metaNodes[core.getPath(node)]) {\n                    return true;\n                }\n\n                return false;\n            };\n\n            core.getAllMetaNodes = function (node) {\n                var root = core.getRoot(node);\n\n                if (root.metaNodes) {\n                    return root.metaNodes;\n                }\n\n                return [];\n            };\n\n            core.isAbstract = function (node) {\n                return core.getRegistry(node, 'isAbstract') === true;\n            };\n\n            core.isConnection = function (node) {\n                var validPtrNames = oldcore.getValidPointerNames(node);\n\n                return validPtrNames.indexOf('dst') !== -1 && validPtrNames.indexOf('src') !== -1;\n            };\n\n            function sensitiveFilter(validNodes) {\n                var i;\n\n                i = validNodes.length;\n                while (i--) {\n                    if (core.isConnection(validNodes[i]) || core.isAbstract(validNodes[i])) {\n                        validNodes.splice(i, 1);\n                    }\n                }\n            }\n\n            //parameters\n            // node - the node in question\n            // children - the current children of the node, so that multiplicity can be checked\n            // sensitive - if true the function do not return the connection and abstract types\n            // multiplicity - if true the function filters out possibilities that fail multiplicity check\n            // aspect - if given the function also filters out valid children type meta nodes based on aspect rule\n            core.getValidChildrenMetaNodes = function (parameters) {\n                var validNodes = [],\n                    node = parameters.node,\n                    metaNodes = core.getRoot(node).metaNodes,\n                    keys = Object.keys(metaNodes || {}),\n                    i, j,\n                    typeCounters = {},\n                    children = parameters.children || [],\n                    rules,\n                    inAspect,\n                    temp;\n\n                rules = oldcore.getChildrenMeta(node) || {};\n\n                for (i = 0; i < keys.length; i += 1) {\n                    temp = metaNodes[keys[i]];\n                    while (temp) {\n                        if (rules[oldcore.getPath(temp)]) {\n                            validNodes.push(metaNodes[keys[i]]);\n                            break;\n                        }\n                        temp = oldcore.getBase(temp);\n                    }\n                    //if (core.isValidChildOf(metaNodes[keys[i]], node)) {\n                    //    validNodes.push(metaNodes[keys[i]]);\n                    //}\n                }\n\n                //before every next step we check if we still have potential nodes\n                if (validNodes.length === 0) {\n                    return validNodes;\n                }\n\n                if (parameters.sensitive === true) {\n                    sensitiveFilter(validNodes);\n                }\n\n                //before every next step we check if we still have potential nodes\n                if (validNodes.length === 0) {\n                    return validNodes;\n                }\n\n                if (parameters.multiplicity === true) {\n                    if (rules.max && rules.max > -1 && oldcore.getChildrenRelids(node).length >= rules.max) {\n                        validNodes = [];\n                        return validNodes;\n                    }\n                    if (children.length === 0) {\n                        return validNodes; //we cannot check type-multiplicity without children\n                    }\n\n                    delete rules.max;\n                    delete rules.min;\n\n                    //we need to clear nodes that are not on the meta sheet\n                    // and we have to initialize the counters\n                    keys = Object.keys(rules);\n                    for (i = 0; i < keys.length; i += 1) {\n                        if (!metaNodes[keys[i]]) {\n                            delete rules[keys[i]];\n                        } else {\n                            typeCounters[keys[i]] = 0;\n                        }\n                    }\n\n                    keys = Object.keys(rules);\n                    for (i = 0; i < children.length; i += 1) {\n                        for (j = 0; j < keys.length; j += 1) {\n                            if (oldcore.isTypeOf(children[i], metaNodes[keys[j]])) {\n                                typeCounters[keys[j]] += 1;\n                            }\n                        }\n                    }\n\n                    i = validNodes.length;\n                    keys = Object.keys(typeCounters);\n                    while (i--) {\n                        for (j = 0; j < keys.length; j += 1) {\n                            if (rules[keys[j]].max &&\n                                rules[keys[j]].max > -1 &&\n                                rules[keys[j]].max <= typeCounters[keys[j]] &&\n                                oldcore.isTypeOf(validNodes[i], metaNodes[keys[j]])) {\n                                validNodes.splice(i, 1);\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                //before every next step we check if we still have potential nodes\n                if (validNodes.length === 0) {\n                    return validNodes;\n                }\n\n\n                if (parameters.aspect) {\n                    keys = oldcore.getAspectMeta(node, parameters.aspect);\n                    i = validNodes.length;\n\n                    while (i--) {\n                        inAspect = false;\n                        for (j = 0; j < keys.length; j += 1) {\n                            if (oldcore.isTypeOf(validNodes[i], metaNodes[keys[j]])) {\n                                inAspect = true;\n                                break;\n                            }\n                        }\n                        if (!inAspect) {\n                            validNodes.splice(i, 1);\n                        }\n                    }\n                }\n                return validNodes;\n            };\n\n            //parameters\n            // node - the node in question\n            // name - the name of the set\n            // members - the current members of the set, so that multiplicity can be checked\n            // sensitive - if true the function do not return the connection and abstract types\n            // multiplicity - if true the function filters out possibilities that fail multiplicity check\n            core.getValidSetElementsMetaNodes = function (parameters) {\n                var validNodes = [],\n                    node = parameters.node,\n                    metaNodes = core.getRoot(node).metaNodes,\n                    keys = Object.keys(metaNodes || {}),\n                    i, j,\n                    typeCounters = {},\n                    members = parameters.members || [],\n                    rules = core.getPointerMeta(node, parameters.name) || {},\n                    temp;\n\n                for (i = 0; i < keys.length; i += 1) {\n                    temp = metaNodes[keys[i]];\n                    while (temp) {\n                        if (rules[oldcore.getPath(temp)]) {\n                            validNodes.push(metaNodes[keys[i]]);\n                            break;\n                        }\n                        temp = oldcore.getBase(temp);\n                    }\n                }\n\n                //before every next step we check if we still have potential nodes\n                if (validNodes.length === 0) {\n                    return validNodes;\n                }\n\n                if (parameters.sensitive === true) {\n                    sensitiveFilter(validNodes);\n                }\n\n                //before every next step we check if we still have potential nodes\n                if (validNodes.length === 0) {\n                    return validNodes;\n                }\n\n                if (parameters.multiplicity === true) {\n                    if (rules.max && rules.max > -1 && oldcore.getMemberPaths(node).length >= rules.max) {\n                        validNodes = [];\n                        return validNodes;\n                    }\n\n                    if (members.length === 0) {\n                        return validNodes; //we cannot check type-multiplicity without children\n                    }\n\n                    delete rules.max;\n                    delete rules.min;\n\n                    //we need to clear nodes that are not on the meta sheet\n                    // and we have to initialize the counters\n                    keys = Object.keys(rules);\n                    for (i = 0; i < keys.length; i += 1) {\n                        if (!metaNodes[keys[i]]) {\n                            delete rules[keys[i]];\n                        } else {\n                            typeCounters[keys[i]] = 0;\n                        }\n                    }\n\n                    keys = Object.keys(rules);\n                    for (i = 0; i < members.length; i += 1) {\n                        for (j = 0; j < keys.length; j += 1) {\n                            if (oldcore.isTypeOf(members[i], metaNodes[keys[j]])) {\n                                typeCounters[keys[j]] += 1;\n                            }\n                        }\n                    }\n\n                    i = validNodes.length;\n                    keys = Object.keys(typeCounters);\n                    while (i--) {\n                        for (j = 0; j < keys.length; j += 1) {\n                            if (rules[keys[j]].max &&\n                                rules[keys[j]].max > -1 &&\n                                rules[keys[j]].max <= typeCounters[keys[j]] &&\n                                oldcore.isTypeOf(validNodes[i], metaNodes[keys[j]])) {\n                                validNodes.splice(i, 1);\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return validNodes;\n            };\n            return core;\n        };\n\n        return MetaCacheCore;\n    }\n)\n;\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * This class defines the public API of the WebGME-Core\n *\n * @author kecso / https://github.com/kecso\n * @module Core\n */\n\n/**\n * @typedef {object} Node - the object that represents the atomic element of the containment hierarchy.\n */\n\n/**\n * @typedef {object} DataObject - Inner data of {@link module:Core~Node} that can be serialized and saved in the storage.\n */\n\n/**\n * @typedef {object} GmePersisted - the result object of a persist which contains information about the newly\n * created data objects.\n * @prop {module:Core~ObjectHash} rootHash - Hash of the root node.\n * @prop {Object.<module:Core~ObjectHash, module:Core~DataObject>} objects - Hash of the root node.\n */\n\n/**\n * @typedef {string} ObjectHash - Unique SHA-1 hash for the node object.\n * @example\n * '#5496cf226542fcceccf89056f0d27564abc88c99'\n */\n\n/**\n * @typedef {string} GUID - Globally unique identifier. A formatted string containing hexadecimal characters. If some\n * projects share some GUIDs that can only be because the node with the given identification represents the same\n * concept.\n * @example\n * 'cd891e7b-e2ea-e929-f6cd-9faf4f1fc045'\n */\n\n/**\n * @typedef {object} Constraint - An object that represents some additional rule regarding some node of the project.\n * @prop {string} script - The script which checks if the contraint is met.\n * @prop {string} info - Short description of the constraint.\n * @prop {string} priority - Gives instructions on how to deal with violations of the constraint.\n */\n\n/**\n * @typedef {object} RelationRule - An object that represents a relational type rule-set (pointer/set).\n * @prop {integer} [min] - The minimum amount of target necessary for the relationship (if not present or '-1'\n * then there is no minimum rule that applies)\n * @prop {integer} [max] - The minimum amount of target necessary for the relationship (if not present or '-1'\n * then there is no minimum rule that applies)\n * @prop {object} [absolutePathOfTarget] - special rules regarding the given type (if the object is empty, it still\n * represents that the type is a valid target of the relationship)\n * @prop {integer} [absolutePathOfTarget.min] - The minimum amount of target necessary for the relationship\n * from the given type (if not present or '-1' then there is no minimum rule that applies)\n * @prop {integer} [absolutePathOfTarget.max] - The minimum amount of target necessary for the relationship\n * from the given type (if not present or '-1' then there is no minimum rule that applies)\n * @example\n * '{\n *  'min': 1,\n *  'max': -1,\n *  'any/path/of/node':{\n *   'min':-1,\n *   'max':2\n *   },\n *   'any/other/valid/path':{\n *   }\n * }'\n */\n\ndefine('common/core/core',[\n    'common/core/corerel',\n    'common/core/setcore',\n    'common/core/guidcore',\n    'common/core/nullpointercore',\n    'common/core/coreunwrap',\n    'common/core/coretype',\n    'common/core/constraintcore',\n    'common/core/coretree',\n    'common/core/metacore',\n    'common/core/coretreeloader',\n    'common/core/corediff',\n    'common/core/metacachecore'\n], function (CoreRel,\n             Set,\n             Guid,\n             NullPtr,\n             UnWrap,\n             Type,\n             Constraint,\n             CoreTree,\n             MetaCore,\n             TreeLoader,\n             CoreDiff,\n             MetaCacheCore) {\n    'use strict';\n\n    /**\n     * @param {object} storageObject\n     * @param {object} options - contains logging information\n     * @alias Core\n     * @constructor\n     */\n    function Core(storage, options) {\n        var core,\n            coreLayers = [];\n        coreLayers.push(CoreRel);\n        coreLayers.push(NullPtr);\n        coreLayers.push(Type);\n        coreLayers.push(NullPtr);\n        coreLayers.push(Set);\n        coreLayers.push(Guid);\n        coreLayers.push(Constraint);\n        coreLayers.push(MetaCore);\n        coreLayers.push(CoreDiff);\n        coreLayers.push(TreeLoader);\n        coreLayers.push(MetaCacheCore);\n\n        if (options.usertype !== 'tasync') {\n            coreLayers.push(UnWrap);\n        }\n\n        core = coreLayers.reduce(function (inner, Class) {\n            return new Class(inner, options);\n        }, new CoreTree(storage, options));\n\n        /**\n         * Returns the parent of the node.\n         * @param {module:Core~Node} node - the node in question\n         *\n         * @return {module:Core~Node} Returns the parent of the node or NULL if it has no parent.\n         *\n         * @func\n         */\n        this.getParent = core.getParent;\n\n        /**\n         * Returns the parent-relative identifier of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string} Returns the id string or return NULL and UNDEFINED if there is no such id for the node.\n         *\n         * @func\n         */\n        this.getRelid = core.getRelid;\n\n        //this.getLevel = core.getLevel;\n\n        /**\n         * Returns the root node of the containment tree.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {module:Core~Node} Returns the root of the containment hierarchy (it can be the node itself).\n         *\n         * @func\n         */\n        this.getRoot = core.getRoot;\n\n        /**\n         * Retuns the complete path of the node in the containment hierarchy.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string} Returns a path string where each portion is a relative id and they are separated by '/'.\n         * The path can be empty as well if the node in question is the  root itself, otherwise it should be a chain\n         * of relative ids from the root of the containment hierarchy.\n         *\n         * @func\n         */\n        this.getPath = core.getPath;\n\n        //this.isValidPath = core.isValidPath;\n        //this.splitPath = core.splitPath;\n        //this.buildPath = core.buildPath;\n        //this.joinPaths = core.joinPaths;\n        //this.getCommonPathPrefixData = core.getCommonPathPrefixData;\n        //this.normalize = core.normalize;\n        //this.getAncestor = core.getAncestor;\n        //this.isAncestor = core.isAncestor;\n        //this.createRoot = core.createRoot;\n        //this.createChild = core.createChild;\n\n        /**\n         * Retrieves the child of the input node at the given relative id. It is not an asynchronous load\n         * and it automatically creates the child under the given relative id if no child was there beforehand.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} relativeId - the relative id which our child in question has.\n         *\n         * @return {module:Core~Node} Return an empty node if it was created as a result of the function or\n         * return the already existing and loaded node if it found.\n         *\n         * @func\n         */\n        this.getChild = core.getChild;\n\n        //this.getDescendant = core.getDescendant;\n        //this.getDescendantByPath = core.getDescendantByPath;\n        //this.isMutable = core.isMutable;\n        //this.isObject = core.isObject;\n\n        /**\n         * Checks if the node in question is exists or not.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {bool} Returns true if the node is 'empty' meaning that it is not reserved by real data.\n         * Returns false if the node is exists and have some meaningful value.\n         *\n         * @func\n         */\n        this.isEmpty = core.isEmpty;\n\n        //this.mutate = core.mutate;\n        //this.getData = core.getData;\n        //this.setData = core.setData;\n        //this.deleteData = core.deleteData;\n        //this.copyData = core.copyData;\n        //this.getProperty = core.getProperty;\n        //this.setProperty = core.setProperty;\n        //this.deleteProperty = core.deleteProperty;\n        //this.getKeys = core.getKeys;\n        //this.getRawKeys = core.getRawKeys;\n        //this.isHashed = core.isHashed;\n        //this.setHashed = core.setHashed;\n\n        /**\n         * Returns the calculated database id of the data of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {module:Core~ObjectHash} Returns the so called Hash value of the data of the given node. If the string is empty,\n         * then it means that the node was mutated but not yet saved to the database, so it do not have a hash\n         * temporarily.\n         *\n         * @func\n         */\n        this.getHash = core.getHash;\n\n        /**\n         * Persists the changes made in memory and computed the data blobs that needs to be saved into the database\n         * to make the change and allow other users to see the new state of the project.\n         * @param {module:Core~Node} node - some node element of the modified containment hierarchy (usually the root).\n         * @param {function(module:Core~Node)} callback\n         *\n         * @return {module:Core~GmePersisted} The function returns an object which collects all the changes\n         * on data level and necessary to update the databse on server side\n         *\n         * @func\n         */\n        this.persist = core.persist;\n\n        /**\n         * Loads the data object with the given hash and makes it a root of a containment hierarchy.\n         * @param {module:Core~ObjectHash} hash - the hash of the data object we like to load as root.\n         * @param {function(module:Core~Node)} callback\n         *\n         * @func\n         */\n        this.loadRoot = core.loadRoot;\n\n        /**\n         * Loads the child of the given parent pointed by the relative id. Behind the scenes, it means\n         * that it actually loads the data pointed by a hash stored inside the parent under the given id\n         * and wraps it in a node object which will be connected to the parent as a child in the containment\n         * hierarchy.\n         * @param {module:Core~Node} parent - the container node in question.\n         * @param {string} relativeId - the relative id of the child in question.\n         * @param {function(module:Core~Node)} callback\n         *\n         * @func\n         */\n        this.loadChild = core.loadChild;\n\n        /**\n         * From the given starting node, it loads the path given as a series of relative ids (separated by '/')\n         * and returns the node it finds at the ends of the path. If there is no node, it will not stop but create\n         * empty nodes on demand and return a new empty node back.\n         * @param {module:Core~Node} startNode - the starting node of our search.\n         * @param {string} relativePath - the relative path - built by relative ids - of the node in question.\n         * @param {function(module:Core~Node)} callback\n         *\n         * @func\n         */\n        this.loadByPath = core.loadByPath;\n\n        /**\n         * Loads the all children of the given parent. As it first checks the already reserved relative ids of\n         * the parent, it only loads the already existing children (so no on-demand empty node creation).\n         * @param {module:Core~Node} parent - the container node in question.\n         * @param {function(module:Core~Node[])} callback\n         *\n         * @func\n         */\n        this.loadChildren = core.loadChildren;\n\n        /**\n         * Loads the target of the given pointer of the given node. In the callback the node can have three values:\n         * if the node is valid, then it is the defined target of a valid pointer,\n         * if the returned value is null, then it means that the pointer is defined, but has no real target,\n         * finally if the returned value is undefined than there is no such pointer defined for the given node.\n         * @param {module:Core~Node} source - the container node in question.\n         * @param {string} pointerName - the relative id of the child in question.\n         * @param {function(module:Core~Node)} callback\n         *\n         * @func\n         */\n        this.loadPointer = core.loadPointer;\n\n        /**\n         * Loads all the source nodes that has such a pointer and its target is the given node.\n         * @param {module:Core~Node} target - the container node in question.\n         * @param {string} pointerName - the relative id of the child in question.\n         * @param {function(module:Core~Node[])} callback\n         *\n         * @func\n         */\n        this.loadCollection = core.loadCollection;\n\n        /**\n         * Loads a complete sub-tree of the containment hierarchy starting from the given node.\n         * @param {module:Core~Node} node - the container node in question.\n         * @param {function(module:Core~Node[])} callback\n         *\n         * @func\n         */\n        this.loadSubTree = core.loadSubTree;\n\n        /**\n         * Loads a complete complete containment hierarchy using the data object - pointed by the given hash -\n         * as the root.\n         * @param {module:Core~ObjectHash} rootHash - hash of the root node.\n         * @param {function(module:Core~Node[])} callback\n         *\n         * @func\n         */\n        this.loadTree = core.loadTree;\n\n        //this.isValidNode = core.isValidNode;\n        //this.getChildHash = core.getChildHash;\n        //this.isValidRelid = core.isValidRelid;\n\n        /**\n         * Collects the relative ids of all the children of the given node.\n         * @param {module:Core~Node} parent - the container node in question.\n         *\n         *@return {string[]} The function returns an array of the relative ids.\n         *\n         * @func\n         */\n        this.getChildrenRelids = core.getChildrenRelids;\n\n        /**\n         * Collects the paths of all the children of the given node.\n         * @param {module:Core~Node} parent - the container node in question.\n         *\n         *@return {string[]} The function returns an array of the absolute paths of the children.\n         *\n         * @func\n         */\n        this.getChildrenPaths = core.getChildrenPaths;\n\n        /**\n         * Creates a node according to the given parameters.\n         * @param {object} parameters - the details of the creation.\n         * @param {module:Core~Node | null} [parameters.parent] - the parent of the node to be created.\n         * @param {module:Core~Node | null} [parameters.base] - the base of the node to be created.\n         * @param {string} [parameters.relid] - the relative id of the node to be created (if reserved, the function\n         * returns the node behind the relative id)\n         * @param {module:Core~GUID} [parameters.guid] - the GUID of the node to be created\n         *\n         *\n         *@return {module:Core~Node} The function returns the created node or null if no node was created.\n         *\n         * @func\n         */\n        this.createNode = core.createNode;\n\n        /**\n         * Removes a node from the containment hierarchy.\n         * @param {module:Core~Node} node - the node to be removed.\n         *\n         * @func\n         */\n        this.deleteNode = core.deleteNode;\n\n        /**\n         * Copies the given to be a child of the given parent.\n         * @param {module:Core~Node} node - the node to be copied.\n         * @param {module:Core~Node} parent - the parent node of the copy.\n         *\n         * @return {module:Core~Node} The function returns the copy of the original node.\n         *\n         * @func\n         */\n        this.copyNode = core.copyNode;\n\n        /**\n         * Create copy of the given nodes under the given parent. The copy will\n         * @param {module:Core~Node[]} nodes - the nodes to be copied.\n         * @param {module:Core~Node} parent - the parent node of the copy.\n         *\n         * @return {module:Core~Node} The function returns the copy of the original node.\n         *\n         * @func\n         */\n        this.copyNodes = core.copyNodes;\n\n        /**\n         * Moves the given node under the given parent.\n         * @param {module:Core~Node} node - the node to be moved.\n         * @param {module:Core~Node} parent - the parent node of the copy.\n         *\n         * @return {module:Core~Node} The function returns the node after the move.\n         *\n         * @func\n         */\n        this.moveNode = core.moveNode;\n\n        /**\n         * Returns the names of the defined attributes of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of the names of the attributes of the node.\n         *\n         * @func\n         */\n        this.getAttributeNames = core.getAttributeNames;\n\n        /**\n         * Retrieves the value of the given attribute of the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         *\n         * @return {object | primitive | null | undefined} The function returns the value of the attribute of the node.\n         * The value can be an object or any primitive type. If the value is undefined that means the node do not have\n         * such attribute defined. [The retrieved attribute should not be modified as is - it should be copied first!!]\n         *\n         * @func\n         */\n        this.getAttribute = core.getAttribute;\n\n        /**\n         * Sets the value of the given attribute of the given node. It defines the attribute on demand, means that it\n         * will set the given attribute even if was ot defined for the node beforehand.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         * @param {object | primitive | null} value - the new of the attribute. Can be any primitive type or object.\n         * Undefined is not allowed.\n         *\n         * @func\n         */\n        this.setAttribute = core.setAttribute;\n\n        /**\n         * Removes the given attributes from the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         *\n         * @func\n         */\n        this.delAttribute = core.delAttribute;\n\n        /**\n         * Returns the names of the defined registry entries of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of the names of the registry entries of the node.\n         *\n         * @func\n         */\n        this.getRegistryNames = core.getRegistryNames;\n\n        /**\n         * Retrieves the value of the given registry entry of the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the registry entry.\n         *\n         * @return {object | primitive | null | undefined} The function returns the value of the registry entry\n         * of the node. The value can be an object or any primitive type. If the value is undefined that means\n         * the node do not have such attribute defined. [The retrieved registry value should\n         * not be modified as is - it should be copied first!!]\n         *\n         * @func\n         */\n        this.getRegistry = core.getRegistry;\n\n        /**\n         * Sets the value of the given registry entry of the given node. It defines the registry entry on demand,\n         * means that it will set the given registry entry even if was ot defined for the node beforehand.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the registry entry.\n         * @param {object | primitive | null} value - the new of the registry entry. Can be any primitive\n         * type or object. Undefined is not allowed.\n         *\n         * @func\n         */\n        this.setRegistry = core.setRegistry;\n\n        /**\n         * Removes the given registry entry from the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the registry entry.\n         *\n         * @func\n         */\n        this.delRegistry = core.delRegistry;\n\n        /**\n         * Retrieves a list of the defined pointer names of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of the names of the pointers of the node.\n         *\n         * @func\n         */\n        this.getPointerNames = core.getPointerNames;\n\n        /**\n         * Retrieves the path of the target of the given pointer of the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer in question.\n         *\n         * @return {string | null | undefined} The function returns the absolute path of the target node\n         * if there is a valid target. It returns null if though the pointer is defined it does not have any\n         * valid target. Finally, it return undefined if there is no pointer defined for the node under the given name.\n         *\n         * @func\n         */\n        this.getPointerPath = core.getPointerPath;\n\n        //TODO check if this could be completely removed - or we have to start using it instead of relying on undefined\n        //this.hasPointer = core.hasPointer;\n\n        //this.getOutsidePointerPath = core.getOutsidePointerPath;\n\n        /**\n         * Removes the pointer from the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer in question.\n         *\n         * @func\n         */\n        this.deletePointer = core.deletePointer;\n\n        /**\n         * Sets the target of the pointer of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer in question.\n         * @param {module:Core~Node} target - the new target of the pointer.\n         *\n         * @func\n         */\n        this.setPointer = core.setPointer;\n\n        /**\n         * Retrieves a list of the defined pointer names that has the node as target.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of the names of the pointers pointing to the node.\n         *\n         * @func\n         */\n        this.getCollectionNames = core.getCollectionNames;\n\n        /**\n         * Retrieves a list of absolute paths of nodes that has a given pointer which points to the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer.\n         *\n         * @return {string[]} The function returns an array of absolute paths of nodes thath\n         * has the pointer pointing to the node.\n         *\n         * @func\n         */\n        this.getCollectionPaths = core.getCollectionPaths;\n\n        //this.getCoreTree = core.getCoreTree;\n\n        /**\n         * Collects the data hash values of the children of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {object} The function returns a dictionary of {@link module:Core~ObjectHash} that stored in pair\n         * with the relative id of the corresponding child of the node.\n         *\n         * @func\n         */\n        this.getChildrenHashes = core.getChildrenHashes;\n\n        /**\n         * Returns the base node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {module:Core~Node | null} Returns the base of the given node or null if there is no such node.\n         *\n         * @func\n         */\n        this.getBase = core.getBase;\n\n        /**\n         * Returns the root of the inheritance chain of the given node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {module:Core~Node} Returns the root of the inheritance chain (usually the FCO).\n         *\n         * @func\n         */\n        this.getBaseRoot = core.getBaseRoot;\n\n        /**\n         * Returns the names of the attributes of the node that have been first defined for the node and not for its\n         * bases.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of the names of the own attributes of the node.\n         *\n         * @func\n         */\n        this.getOwnAttributeNames = core.getOwnAttributeNames;\n\n        /**\n         * Returns the names of the registry enrties of the node that have been first defined for the node\n         * and not for its bases.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of the names of the own registry entries of the node.\n         *\n         * @func\n         */\n        this.getOwnRegistryNames = core.getOwnRegistryNames;\n\n        /**\n         * Returns the value of the attribute defined for the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         *\n         * @return {object | primitive | null | undefined} Returns the value of the attribute defined specifically for\n         * the node. If undefined then it means that there is no such attribute defined directly for the node, meaning\n         * that it either inherits some value or there is no such attribute at all.\n         *\n         * @func\n         */\n        this.getOwnAttribute = core.getOwnAttribute;\n\n        /**\n         * Returns the value of the registry entry defined for the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the registry entry.\n         *\n         * @return {object | primitive | null | undefined} Returns the value of the registry entry defined specifically\n         * for the node. If undefined then it means that there is no such registry entry defined directly for the node,\n         * meaning that it either inherits some value or there is no such registry entry at all.\n         *\n         * @func\n         */\n        this.getOwnRegistry = core.getOwnRegistry;\n\n        /**\n         * Returns the list of the names of the pointers that were defined specifically for the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} Returns an array of names of pointers defined specifically for the node.\n         *\n         *@func\n         */\n        this.getOwnPointerNames = core.getOwnPointerNames;\n\n        /**\n         * Returns the absolute path of the target of the pointer specifically defined for the node.\n         * @param {module:Core~Node} node - the node in question\n         * @param {string} name - the name of the pointer\n         *\n         * @return {string | null | undefined} Returns the absolute path. If the path is null, then it means that\n         * 'no-target' was defined specifically for this node for the pointer. If undeinfed it means that the node\n         * either inherits the target of the pointer or there is no pointer defined at all.\n         *\n         * @func\n         */\n        this.getOwnPointerPath = core.getOwnPointerPath;\n\n        /**\n         * Sets the base node of the given node. The function doesn't touches the properties or the children of the node\n         * so it can cause META rule violations that needs to be corrected manually.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {module:Core~Node | null} base - the new base.\n         *\n         * @func\n         */\n        this.setBase = core.setBase;\n\n        /**\n         * Returns the root of the inheritance chain (cannot be the node itself).\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {module:Core~Node | null} Returns the root of the inheritance chain of the node. If returns null,\n         * that means the node in question is the root of the chain.\n         *\n         * @func\n         */\n        this.getTypeRoot = core.getTypeRoot;\n\n        //TODO check if the whole function could be removed\n        //this.getSetNumbers = core.getSetNumbers;\n\n        /**\n         * Returns the names of the sets of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} Returns an array of set names that the node has.\n         *\n         * @func\n         */\n        this.getSetNames = core.getSetNames;\n\n        /**\n         * Returns the list of absolute paths of the members of the given set of the given node.\n         * @param {module:Core~Node} node - the set owner.\n         * @param {string} name - the name of the set.\n         *\n         * @return {string[]} Returns an array of absolute path strings of the member nodes of the set.\n         * @func\n         */\n        this.getMemberPaths = core.getMemberPaths;\n\n        /**\n         * Removes a member from the set. The functions doesn't remove the node itself.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         * @param {string} path - the absolute path of the member to be removed.\n         *\n         * @func\n         */\n        this.delMember = core.delMember;\n\n        /**\n         * Adds a member to the given set.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         * @param {module:Core~Node} member - the new member of the set.\n         *\n         * @func\n         */\n        this.addMember = core.addMember;\n\n        /**\n         * Return the names of the attributes defined for the set membership to the member node.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         * @param {string} memberPath - the absolute path of the member.\n         *\n         * @return {string[]} Returns the array of names of attributes that represents some property of the membership.\n         *\n         * @func\n         */\n        this.getMemberAttributeNames = core.getMemberAttributeNames;\n\n        /**\n         * Return the names of the attributes defined for the set membership specifically defined to the member node.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         * @param {string} memberPath - the absolute path of the member.\n         *\n         * @return {string[]} Returns the array of names of attributes that represents some property of the membership.\n         *\n         * @func\n         */\n        this.getMemberOwnAttributeNames = core.getMemberOwnAttributeNames;\n\n        /**\n         * Get the value of the attribute in relation with the set membership.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} setName - the name of the set.\n         * @param {string} memberPath - the absolute path of the member node.\n         * @param {string} attrName - the name of the attribute.\n         *\n         * @return {object|primitive|null|undefined} Return teh value of the attribute. If it is undefined, than there\n         * is no such attributed connected to the given set membership.\n         *\n         * @func\n         */\n        this.getMemberAttribute = core.getMemberAttribute;\n\n        /**\n         * Sets the attribute value which represents a property of the membership.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} setName - the name of the set.\n         * @param {string} memberPath - the absolute path of the member node.\n         * @param {string} attrName - the name of the attribute.\n         * @param {object|primitive|null} value - the new value of the attribute.\n         * @func\n         */\n        this.setMemberAttribute = core.setMemberAttribute;\n\n\n        /**\n         * Removes an attribute which represented a property of the given set membership.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} setName - the name of the set.\n         * @param {string} memberPath - the absolute path of the member node.\n         * @param {string} attrName - the name of the attribute.\n         *\n         * @func\n         */\n        this.delMemberAttribute = core.delMemberAttribute;\n\n        /**\n         * Return the names of the registry entries defined for the set membership to the member node.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         * @param {string} memberPath - the absolute path of the member.\n         *\n         * @return {string[]} Returns the array of names of registry entries that represents some property of the\n         * membership.\n         *\n         * @func\n         */\n        this.getMemberRegistryNames = core.getMemberRegistryNames;\n\n        /**\n         * Return the names of the registry entries defined for the set membership specifically defined to\n         * the member node.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         * @param {string} memberPath - the absolute path of the member.\n         *\n         * @return {string[]} Returns the array of names of registry entries that represents some property of the\n         * membership.\n         *\n         * @func\n         */\n        this.getMemberOwnRegistryNames = core.getMemberOwnRegistryNames;\n\n        /**\n         * Get the value of the registry entry in relation with the set membership.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} setName - the name of the set.\n         * @param {string} memberPath - the absolute path of the member node.\n         * @param {string} regName - the name of the registry entry.\n         *\n         * @return {object|primitive|null|undefined} Return teh value of the attribute. If it is undefined, than there\n         * is no such attributed connected to the given set membership.\n         *\n         * @func\n         */\n        this.getMemberRegistry = core.getMemberRegistry;\n\n        /**\n         * Sets the registry entry value which represents a property of the membership.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} setName - the name of the set.\n         * @param {string} memberPath - the absolute path of the member node.\n         * @param {string} regName - the name of the registry entry.\n         * @param {object|primitive|null} value - the new value of the attribute.\n         * @func\n         */\n        this.setMemberRegistry = core.setMemberRegistry;\n\n        /**\n         * Removes a registry entry which represented a property of the given set membership.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} setName - the name of the set.\n         * @param {string} memberPath - the absolute path of the member node.\n         * @param {string} regName - the name of the registry entry.\n         *\n         * @func\n         */\n        this.delMemberRegistry = core.delMemberRegistry;\n\n        /**\n         * Creates a set for the node.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         *\n         * @func\n         */\n        this.createSet = core.createSet;\n\n        /**\n         * Removes a set from the node.\n         * @param {module:Core~Node} node - the owner of the set.\n         * @param {string} name - the name of the set.\n         *\n         * @func\n         */\n        this.deleteSet = core.deleteSet;\n\n        /**\n         * Returns all membership information of the given node.\n         * @param {module:Core~Node} node - the node in question\n         *\n         * @return {object} Returns a dictionary where every the key of every entry is an absolute path of a set owner\n         * node. The value of each entry is an array with the set names in which the node can be found as a member.\n         *\n         * @func\n         */\n        this.isMemberOf = core.isMemberOf;\n\n        //this.getMiddleGuid = core.getMiddleGuid;\n\n        /**\n         * Get the GUID of a node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {module:Core~GUID} Returns the globally unique identifier.\n         * @func\n         */\n        this.getGuid = core.getGuid;\n\n        //TODO this is only used in import - export use-cases, probably could be removed...\n        /**\n         * Get the GUID of a node. As the Core itself do not checks whether the GUID already exists. The use of\n         * this function is only advised during the creation of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {module:Core~GUID} guid - the new globally unique identifier.\n         * @func\n         */\n        this.setGuid = core.setGuid;\n\n        /**\n         * Gets a constraint object of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the constraint.\n         *\n         * @return {module:Core~Constraint | null} Returns the defined constraint or null if it was not\n         * defined for the node.\n         * @func\n         */\n        this.getConstraint = core.getConstraint;\n\n        /**\n         * Sets a constraint object of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the constraint.\n         * @param {module:Core~Constraint} constraint  - the contraint to be set.\n         * @func\n         */\n        this.setConstraint = core.setConstraint;\n\n        /**\n         * Removes a constraint from the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the constraint.\n         *\n         * @func\n         */\n        this.delConstraint = core.delConstraint;\n\n        /**\n         * Retrieves the list of constraint names defined for the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} Returns the array of names of constraints available for the node.\n         *\n         * @func\n         */\n        this.getConstraintNames = core.getConstraintNames;\n\n        /**\n         * Retrieves the list of constraint names defined specifically for the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} Returns the array of names of constraints for the node.\n         *\n         * @func\n         */\n        this.getOwnConstraintNames = core.getOwnConstraintNames;\n\n        /**\n         * Checks if the given typeNode is really a base of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {module:Core~Node} type - the type node we want to check.\n         *\n         * @return {bool} The function returns true if the type is in the inheritance chain of the node or false\n         * otherwise. Every node is type of itself.\n         *\n         * @func\n         */\n        this.isTypeOf = core.isTypeOf;\n\n        /**\n         * Checks if according to the META rules the given node can be a child of the parent.\n         * @param {module:Core~Node} node - the node in question\n         * @param {module:Core~Node} parent - the parent we like to test.\n         *\n         * @return {bool} The function returns true if according to the META rules the node can be a child of the\n         * parent. The check does not cover multiplicity (so if the parent can only have twi children and it already\n         * has them, this function will still returns true).\n         * @func\n         */\n        this.isValidChildOf = core.isValidChildOf;\n\n        /**\n         * Returns the list of the META defined pointer names of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns all the pointer names that are defined among the META rules of the node.\n         *\n         * @func\n         */\n        this.getValidPointerNames = core.getValidPointerNames;\n\n        /**\n         * Returns the list of the META defined set names of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns all the set names that are defined among the META rules of the node.\n         *\n         * @func\n         */\n        this.getValidSetNames = core.getValidSetNames;\n\n        /**\n         * Returns the list of the META defined pointers of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {module:Core~Node} source - the source to test.\n         * @param {string} name - the name of the pointer.\n         *\n         * @return {bool} The function returns true if according to the META rules, the given node is a valid\n         * target of the given pointer of the source.\n         *\n         * @func\n         */\n        this.isValidTargetOf = core.isValidTargetOf;\n\n        /**\n         * Returns the list of the META defined attribute names of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns all the attribute names that are defined among the META rules of the\n         * node.\n         *\n         * @func\n         */\n        this.getValidAttributeNames = core.getValidAttributeNames;\n\n        /**\n         * Checks if the given value is of the necessary type, according to the META rules.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         * @param {object|primitive|null} value - the value to test.\n         *\n         * @return {bool} Returns true if the value matches the META definitions.\n         *\n         * @func\n         */\n        this.isValidAttributeValueOf = core.isValidAttributeValueOf;\n\n        /**\n         * Returns the list of the META defined aspect names of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns all the aspect names that are defined among the META rules of the\n         * node.\n         *\n         * @func\n         */\n        this.getValidAspectNames = core.getValidAspectNames;\n\n        /**\n         * Returns the list of valid children types of the given aspect.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the aspect.\n         *\n         * @return {string[]} The function returns a list of absolute paths of nodes that are valid childrens of the node\n         * and fits to the META rules defined for the aspect. Any children, visible under the given aspect of the node\n         * must be an instance of at least one node represented by the absolute paths.\n         *\n         * @func\n         */\n        this.getAspectMeta = core.getAspectMeta;\n\n        /**\n         * Gives a JSON representation of the META rules of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {object} Returns an object that represents all the META rules of the node.\n         *\n         * @func\n         */\n        this.getJsonMeta = core.getJsonMeta;\n\n        /**\n         * Returns the META rules specifically defined for the given node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {object} The function returns an object that represent the META rules that were defined\n         * specifically for the node.\n         *\n         * @func\n         */\n        this.getOwnJsonMeta = core.getOwnJsonMeta;\n\n        /**\n         * Removes all META rules that were specifically defined for the node (so the function do not touches\n         * inherited rules).\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @func\n         */\n        this.clearMetaRules = core.clearMetaRules;\n\n        /**\n         * Sets the META rules of the attribute of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         * @param {object} rule - the rules that defines the attribute\n         * @param {'string'|'integer'|'float'|'bool'} rule.type - the type of the attribute\n         * @param {string[]} rule.enum - if the attribute is an enumeration, this array contains the possible values\n         *\n         * @func\n         */\n        this.setAttributeMeta = core.setAttributeMeta;\n\n        /**\n         * Removes an attribute definition from the META rules of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         *\n         * @func\n         */\n        this.delAttributeMeta = core.delAttributeMeta;\n\n        /**\n         * Returns the definition object of an attribute from the META rules of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the attribute.\n         *\n         * @return {object} The function returns the definition object\n         * @func\n         */\n        this.getAttributeMeta = core.getAttributeMeta;\n\n        /**\n         * Returns the list of absolute path of the valid children types of the node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {string[]} The function returns an array of absolute paths of the nodes that was defined as valid\n         * children for the node.\n         *\n         * @func\n         */\n        this.getValidChildrenPaths = core.getValidChildrenPaths;\n\n        /**\n         * Sets the given child as a valid children type for the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {module:Core~Node} child - the valid child node.\n         * @param {integer} [min] - the allowed minimum number of children from this given node type (if not given or\n         * -1 is set, then there will be no minimum rule according this child type)\n         * @param {integer} [max] - the allowed maximum number of children from this given node type (if not given or\n         * -1 is set, then there will be no minimum rule according this child type)\n         *\n         * @func\n         */\n        this.setChildMeta = core.setChildMeta;\n\n        /**\n         * Removes the given child rule from the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} childPath - the absolute path of the child which rule is to be removed from the node.\n         *\n         * @func\n         */\n        this.delChildMeta = core.delChildMeta;\n\n        /**\n         * Sets the global containment limits for the node.\n         *\n         * @param {integer} [min] - the allowed minimum number of children (if not given or\n         * -1 is set, then there will be no minimum rule according this child type)\n         * @param {integer} [min] - the allowed minimum number of children (if not given or\n         * -1 is set, then there will be no minimum rule according this child type)\n         *\n         * @func\n         */\n        this.setChildrenMetaLimits = core.setChildrenMetaLimits;\n\n        /**\n         * Sets the given target as a valid target type for the pointer/set of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer/set.\n         * @param {module:Core~Node} target - the valid target/member node.\n         * @param {integer} [min] - the allowed minimum number of target/member from this given node type (if not\n         * given or -1 is set, then there will be no minimum rule according this child type)\n         * @param {integer} [max] - the allowed maximum number of target/member from this given node type (if not\n         * given or -1 is set, then there will be no minimum rule according this child type)\n         *\n         * @func\n         */\n        this.setPointerMetaTarget = core.setPointerMetaTarget;\n\n        /**\n         * Removes a possible target type from the pointer/set of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer/set\n         * @param {string} targetPath - the absolute path of the possible target type.\n         *\n         * @func\n         */\n        this.delPointerMetaTarget = core.delPointerMetaTarget;\n\n        /**\n         * Sets the global target limits for pointer/set of the node. On META level the only distinction between\n         * pointer and sets is the global multiplicity which has to maximize the number of possible targets to 1 in\n         * case of 'pure' pointer definitions.\n         *\n         * @param {integer} [min] - the allowed minimum number of children (if not given or\n         * -1 is set, then there will be no minimum rule according this child type)\n         * @param {integer} [min] - the allowed minimum number of children (if not given or\n         * -1 is set, then there will be no minimum rule according this child type)\n         *\n         * @func\n         */\n        this.setPointerMetaLimits = core.setPointerMetaLimits;\n\n        /**\n         * Removes the complete META rule regarding the given pointer/set of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer/set.\n         *\n         * @func\n         */\n        this.delPointerMeta = core.delPointerMeta;\n\n        /**\n         * Return a JSON representation of the META rules regarding the given pointer/set of the given node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the pointer/set.\n         *\n         * @return {module:Core~RelationRule} The funciton returns a detailed JSON structure that represents the META\n         * rules regarding the given pointer/set of the node.\n         *\n         * @func\n         */\n        this.getPointerMeta = core.getPointerMeta;\n\n        /**\n         * Sets a valid type for the given aspect of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the aspect.\n         * @param {module:Core~Node} target - the valid type for the aspect.\n         *\n         * @func\n         */\n        this.setAspectMetaTarget = core.setAspectMetaTarget;\n\n\n        /**\n         * Removes a valid type from the given aspect of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the aspect.\n         * @param {string} targetPath - the absolute path of the valid type of the aspect.\n         *\n         * @func\n         */\n        this.delAspectMetaTarget = core.delAspectMetaTarget;\n\n        /**\n         * Removes the given aspect rule of the node.\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the aspect.\n         *\n         * @func\n         */\n        this.delAspectMeta = core.delAspectMeta;\n\n        /**\n         * Searches for the closes META node of the node in question.\n         * @param {module:Core~Node} node - the node in question\n         *\n         * @return {module:Core~Node | null} Returns the first node (including itself) among the inheritance chain\n         * that is a META node. It returns null if it does not find such node (ideally the only node with this result\n         * is the ROOT).\n         *\n         * @func\n         */\n        this.getBaseType = core.getBaseType;\n\n        /**\n         * Checks if there is a node with the given name in the nodes inheritance chain (excluding itself).\n         * @param {module:Core~Node} node - the node in question.\n         * @param {string} name - the name of the base node.\n         *\n         * @return {bool} The function returns true if it finds an ancestor with the given name attribute.\n         *\n         * @func\n         */\n        this.isInstanceOf = core.isInstanceOf;\n\n        //this.nodeDiff = core.nodeDiff;\n\n        /**\n         * Generates a differential tree among the two states of the project that contains the necessary changes\n         * that can modify the source to be identical to the target.\n         * @param {module:Core~Node} sourceRoot - the root node of the source state.\n         * @param {module:Core~Node} targetRoot - the root node of the target state.\n         *\n         * @return {object} The function returns a tree structured patch, that contains the necessary modification\n         * that would changes the source state to be identical with the target state.\n         *\n         * @func\n         */\n        this.generateTreeDiff = core.generateTreeDiff;\n\n        //this.generateLightTreeDiff = core.generateLightTreeDiff;\n\n        /**\n         * Apply changes to the current project.\n         * @param {module:Core~Node} root - the root of the containment hierarchy where we wish to apply the changes\n         * @param {object} patch - the tree structured collection of changes represented with a special JSON object\n         *\n         * @func\n         */\n        this.applyTreeDiff = core.applyTreeDiff;\n\n        /**\n         * Tries to merge two patch object. The patches ideally represents changes made by two parties. They represents\n         * changes from the same source ending in different states. Our aim is to generate a single patch that could\n         * cover the changes of both party.\n         * @param {object} mine - the tree structured JSON patch that represents my changes.\n         * @param {object} theirs - the tree structured JSON patch that represents the changes of the other party.\n         *\n         * @return {object} The function returns with an object that contains the conflicts (if any) and the merged\n         * patch.\n         *\n         * @func\n         */\n        this.tryToConcatChanges = core.tryToConcatChanges;\n\n        /**\n         * When our attempt to merge two patches ended in some conflict, then we can modify that result highlighting\n         * that in case of every conflict, which side we prefer (mine vs. theirs). If we give that object as an input\n         * to this function, it will finish the merge resolving the conflict according our settings and present a final\n         * patch.\n         * @param {object} conflict - the object that represents our settings for every conflict and the so-far-merged\n         * patch.\n         *\n         * @return {object} The function results in a tree structured patch object that contains the changesthat cover\n         * both parties modifications (and the conflicts are resolved according the input settings).\n         *\n         * @func\n         */\n        this.applyResolution = core.applyResolution;\n\n        /**\n         * Checks if the node is abstract.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {bool} The function returns true if the registry entry 'isAbstract' of the node if true hence\n         * the node is abstract.\n         *\n         * @func\n         */\n        this.isAbstract = core.isAbstract;\n\n        /**\n         * Check is the node is a connection-like node.\n         * @param {module:Core~Node} node - the node in question.\n         *\n         * @return {bool} Returns true if both the 'src' and 'dst' pointer are defined as valid for the node.\n         *\n         * @func\n         */\n        this.isConnection = core.isConnection;\n\n        /**\n         * Retrieves the valid META nodes that can be base of a child of the node.\n         * @param {object} parameters - the input parameters of the query.\n         * @param {module:Core~Node} parameters.node - the node in question.\n         * @param {module:Core~Node[]} [parameters.children] - the children of the node in question.\n         * @param {bool} - [parameters.sensitive] - if true, the query filters out the abstract and connection-like\n         * nodes (the default value is false)\n         * @param {bool} - [parameters.multiplicity] - if true, the query tries to filter out even more nodes according\n         * to the multiplicity rules (the default value is false, the check is only meaningful if all the children were\n         * passed)\n         * @param {string} - [parameters.aspect] - if given, the query filters to contain only types that are visible\n         * in the given aspect.\n         * @return {module:Core~Node[]} The function returns a list of valid nodes that can be instantiated as a\n         * child of the node.\n         *\n         * @func\n         */\n        this.getValidChildrenMetaNodes = core.getValidChildrenMetaNodes;\n\n        /**\n         * Retrieves the valid META nodes that can be base of a member of the set of the node.\n         * @param {object} parameters - the input parameters of the query.\n         * @param {module:Core~Node} parameters.node - the node in question.\n         * @param {string} parameters.name - the name of the set.\n         * @param {module:Core~Node[]} [parameters.members] - the members of the set of the node in question.\n         * @param {bool} - [parameters.sensitive] - if true, the query filters out the abstract and connection-like\n         * nodes (the default value is false)\n         * @param {bool} - [parameters.multiplicity] - if true, the query tries to filter out even more nodes according\n         * to the multiplicity rules (the default value is false, the check is only meaningful if all the members were\n         * passed)\n         *\n         * @return {module:Core~Node[]} The function returns a list of valid nodes that can be instantiated as a\n         * member of the set of the node.\n         *\n         * @func\n         */\n        this.getValidSetElementsMetaNodes = core.getValidSetElementsMetaNodes;\n\n        /**\n         * Returns all META nodes.\n         * @param {module:Core~Node} node - any node of the containment hierarchy.\n         *\n         * @return {object} The function returns a dictionary. The keys of the dictionary are the absolute paths of\n         * the META nodes of the project. Every value of the dictionary is a {@link module:Core~Node}.\n         *\n         * @func\n         */\n        this.getAllMetaNodes = core.getAllMetaNodes;\n\n        /**\n         * Checks if the node is a META node.\n         * @param {module:Core~Node} node - the node to test.\n         *\n         * @return {bool} Returns true if the node is a member of the METAAspectSet of the ROOT node hence can be\n         * seen as a META node.\n         *\n         * @func\n         */\n        this.isMetaNode = core.isMetaNode;\n    }\n\n    return Core;\n});\n\n",
    "/*globals define*/\n/*jshint browser:true*/\n\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/client/constants',['common/storage/constants'], function (STORAGE_CONSTANTS) {\n    'use strict';\n\n    return {\n\n        STORAGE: STORAGE_CONSTANTS,\n\n        BRANCH_STATUS: STORAGE_CONSTANTS.BRANCH_STATUS,\n\n        // Events\n        NETWORK_STATUS_CHANGED: 'NETWORK_STATUS_CHANGED',\n        BRANCH_STATUS_CHANGED: 'BRANCH_STATUS_CHANGED',\n\n        BRANCH_CHANGED: 'BRANCH_CHANGED',\n        PROJECT_CLOSED: 'PROJECT_CLOSED',\n        PROJECT_OPENED: 'PROJECT_OPENED',\n\n        UNDO_AVAILABLE: 'UNDO_AVAILABLE',\n        REDO_AVAILABLE: 'REDO_AVAILABLE',\n\n        // general notification event\n        NOTIFICATION: 'NOTIFICATION',\n\n        // Constraint Checking\n        META_RULES_RESULT: 'META_RULES_RESULT',\n        CONSTRAINT_RESULT: 'CONSTRAINT_RESULT'\n    };\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/meta',[], function () {\n    'use strict';\n\n    function metaStorage() {\n        var _core = null,\n            _nodes = null,\n            _save = function () {\n            },\n            _initialized = false;\n\n        function initialize(core, nodes, save) {\n            _core = core;\n            _nodes = nodes;\n            _save = save;\n            _initialized = true;\n        }\n\n        function isValidMeta(/*meta*/) {\n            /*if( typeof meta === 'object'){\n             if(\n             //children\n             typeof meta.children === 'object' &&\n             (meta.children.types === null || typeof meta.children.types === 'array') &&\n             (typeof meta.children.min === 'undefined' || typeof meta.children.min === 'number') &&\n             (typeof meta.children.max === 'undefined' || typeof meta.children.max === 'number')){\n\n             //attributes\n             }\n             }\n\n             return false;*/\n            //TODO implement it :)\n            return true;\n        }\n\n        //function isValidAttributeSchema(atrSchema) {\n        //    //TODO implement :)\n        //    return true;\n        //}\n\n        //TODO this may change\n        function pathToRefObject(path) {\n            var ref = {};\n            ref.$ref = path;\n            return ref;\n        }\n\n        //TODO this may change\n        function refObjectToPath(ref) {\n            if (typeof ref.$ref === 'string') {\n                return ref.$ref/*.substring(1)*/;\n            } else {\n                return null;\n            }\n        }\n\n        //getter setter functions\n        function getMeta(path) {\n            var i, j,\n                meta = {children: {}, attributes: {}, pointers: {}, aspects: {}};\n\n            if (_nodes === null || _nodes === undefined) {\n                return meta;\n            }\n            var node = _nodes[path] || null;\n            if (!node) {\n                return null;\n            }\n\n            var metaNode = _core.getChild(node, '_meta');\n            var childrenNode = _core.getChild(metaNode, 'children');\n            //children\n            meta.children = {};\n            meta.children.minItems = [];\n            meta.children.maxItems = [];\n            meta.children.items = _core.getMemberPaths(childrenNode, 'items');\n            for (i = 0; i < meta.children.items.length; i++) {\n                meta.children.minItems.push(\n                    _core.getMemberAttribute(childrenNode, 'items', meta.children.items[i], 'min') || -1);\n\n                meta.children.maxItems.push(\n                    _core.getMemberAttribute(childrenNode, 'items', meta.children.items[i], 'max') || -1);\n\n                meta.children.items[i] = pathToRefObject(meta.children.items[i]);\n            }\n            meta.children.min = _core.getAttribute(childrenNode, 'min');\n            meta.children.max = _core.getAttribute(childrenNode, 'max');\n\n            //attributes - they are simple json objects from our point of view\n            var atrNames = _core.getAttributeNames(metaNode);\n            for (i = 0; i < atrNames.length; i++) {\n                meta.attributes[atrNames[i]] = JSON.parse(JSON.stringify(\n                    _core.getAttribute(metaNode, atrNames[i])));\n            }\n\n            //pointers and pointer lists\n            var pointerNames = _core.getPointerNames(metaNode) || [];\n            for (i = 0; i < pointerNames.length; i++) {\n                var pointerNode = _core.getChild(metaNode, '_p_' + pointerNames[i]);\n                var pointer = {};\n                pointer.items = _core.getMemberPaths(pointerNode, 'items');\n                pointer.min = _core.getAttribute(pointerNode, 'min');\n                pointer.max = _core.getAttribute(pointerNode, 'max');\n                pointer.minItems = [];\n                pointer.maxItems = [];\n\n                for (j = 0; j < pointer.items.length; j++) {\n                    pointer.minItems.push(\n                        _core.getMemberAttribute(pointerNode, 'items', pointer.items[j], 'min') || -1);\n\n                    pointer.maxItems.push(\n                        _core.getMemberAttribute(pointerNode, 'items', pointer.items[j], 'max') || -1);\n\n                    pointer.items[j] = pathToRefObject(pointer.items[j]);\n\n                }\n\n                meta.pointers[pointerNames[i]] = pointer;\n            }\n\n            //aspects\n            var aspectsNode = _core.getChild(metaNode, 'aspects');\n            var aspectNames = _core.getPointerNames(aspectsNode);\n            if (aspectNames.length > 0) {\n                meta.aspects = {};\n                for (i = 0; i < aspectNames.length; i++) {\n                    var aspectNode = _core.getChild(aspectsNode, '_a_' + aspectNames[i]);\n                    meta.aspects[aspectNames[i]] = {items: []};\n                    var items = _core.getMemberPaths(aspectNode, 'items');\n                    for (j = 0; j < items.length; j++) {\n                        meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\n                    }\n                }\n            }\n\n            return meta;\n        }\n\n        function setMeta(path, meta) {\n            var i,\n                j,\n                aspectNode,\n                targetPath;\n            if (!isValidMeta) {\n                return;\n            }\n            var node = _nodes[path] || null;\n            if (node) {\n                var metaNode = _core.getChild(node, '_meta');\n                _core.deleteNode(metaNode, true);\n                metaNode = _core.getChild(node, '_meta');\n                if (meta.children) {\n                    var childrenNode = _core.getChild(metaNode, 'children');\n                    if (meta.children.items && meta.children.items.length) {\n                        if (meta.children.min) {\n                            _core.setAttribute(childrenNode, 'min', meta.children.min);\n                        }\n                        if (meta.children.max) {\n                            _core.setAttribute(childrenNode, 'max', meta.children.max);\n                        }\n\n                        for (i = 0; i < meta.children.items.length; i++) {\n                            targetPath = refObjectToPath(meta.children.items[i]);\n                            if (typeof targetPath === 'string' && _nodes[targetPath]) {\n                                _core.addMember(childrenNode, 'items', _nodes[targetPath]);\n                                if (meta.children.minItems[i] !== -1) {\n                                    _core.setMemberAttribute(childrenNode, 'items', targetPath, 'min',\n                                        meta.children.minItems[i]);\n                                }\n                                if (meta.children.maxItems[i] !== -1) {\n                                    _core.setMemberAttribute(childrenNode, 'items', targetPath, 'max',\n                                        meta.children.maxItems[i]);\n                                }\n                            }\n                        }\n\n                    } else {\n                        _core.deleteNode(childrenNode, true);\n                    }\n                }\n\n                if (meta.attributes) {\n                    for (i in meta.attributes) {\n                        _core.setAttribute(metaNode, i, meta.attributes[i]);\n                    }\n                }\n\n                if (meta.pointers) {\n                    for (i in meta.pointers) {\n                        _core.setPointer(metaNode, i, null);\n                        var pointerNode = _core.getChild(metaNode, '_p_' + i);\n                        if (meta.pointers[i].items && meta.pointers[i].items.length) {\n                            if (meta.pointers[i].min) {\n                                _core.setAttribute(pointerNode, 'min', meta.pointers[i].min);\n                            }\n                            if (meta.pointers[i].max) {\n                                _core.setAttribute(pointerNode, 'max', meta.pointers[i].max);\n                            }\n\n                            for (j = 0; j < meta.pointers[i].items.length; j++) {\n                                targetPath = refObjectToPath(meta.pointers[i].items[j]);\n                                if (typeof targetPath === 'string' && _nodes[targetPath]) {\n                                    _core.addMember(pointerNode, 'items', _nodes[targetPath]);\n                                    if (meta.pointers[i].minItems[j] !== -1) {\n                                        _core.setMemberAttribute(pointerNode, 'items', targetPath, 'min',\n                                            meta.pointers[i].minItems[j]);\n                                    }\n                                    if (meta.pointers[i].maxItems[j] !== -1) {\n                                        _core.setMemberAttribute(pointerNode, 'items', targetPath, 'max',\n                                            meta.pointers[i].maxItems[j]);\n                                    }\n                                }\n                            }\n\n                        }\n                    }\n                }\n\n                if (meta.aspects) {\n                    var aspectsNode = _core.getChild(metaNode, 'aspects'),\n                        aspectNames = [];\n                    for (i in meta.aspects) {\n                        _core.setPointer(aspectsNode, i, null);\n                        aspectNode = _core.getChild(aspectsNode, '_a_' + i);\n                        if (meta.aspects[i].items) {\n                            for (j = 0; j < meta.aspects[i].items.length; j++) {\n                                var member = _nodes[refObjectToPath(meta.aspects[i].items[j])];\n                                if (member) {\n                                    _core.addMember(aspectNode, 'items', member);\n                                }\n                            }\n                        }\n                        aspectNames.push(i);\n                    }\n                    if (aspectNames.length > 0) {\n                        meta.aspects = {};\n                        for (i = 0; i < aspectNames.length; i++) {\n                            aspectNode = _core.getChild(aspectsNode, '_a_' + aspectNames[i]);\n                            meta.aspects[aspectNames[i]] = {items: []};\n                            var items = _core.getMemberPaths(aspectNode, 'items');\n                            for (j = 0; j < items.length; j++) {\n                                meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\n                            }\n                        }\n                    }\n                }\n\n                var metaEvent = _core.getRegistry(node, '_meta_event_') || 0;\n                _core.setRegistry(node, '_meta_event_', metaEvent + 1);\n                _save('setMeta(' + path + ')');\n            }\n        }\n\n\n        //validation functions\n        function getBaseChain(path) {\n            var chain = [];\n            var node = _nodes[path];\n            if (node) {\n                while (node !== null) {\n                    chain.push(_core.getPath(node));\n                    node = _core.getBase(node);\n                }\n            }\n            return chain;\n        }\n\n        function isTypeOf(path, typePath) {\n            var node = _nodes[path];\n            if (node) {\n                var chain = getBaseChain(path);\n                if (chain.indexOf(typePath) !== -1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function isValidTypeOfArray(path, typePathArray) {\n            var i = 0,\n                isGood = false;\n            while (i < typePathArray.length && isGood === false) {\n                isGood = isTypeOf(path, typePathArray[i]);\n                i++;\n            }\n            return isGood;\n        }\n\n        function isValidChild(path, childPath) {\n            var node = _nodes[path];\n            var child = _nodes[childPath];\n            if (node && child) {\n                var metaNode = _core.getChild(node, '_meta');\n                var childrenNode = _core.getChild(metaNode, 'children');\n                var items = _core.getMemberPaths(childrenNode, 'items');\n                return isValidTypeOfArray(childPath, items);\n            }\n            return false;\n        }\n\n        function isValidTarget(path, name, targetPath) {\n            var node = _nodes[path];\n            var target = _nodes[targetPath];\n            if (node && target) {\n                var meta = _core.getChild(node, '_meta');\n                var pointer = _core.getChild(meta, '_p_' + name);\n                var items = _core.getMemberPaths(pointer, 'items');\n                return isValidTypeOfArray(targetPath, items);\n            }\n            return false;\n        }\n\n        function isValidAttribute(/*path, name, attribute*/) {\n            //TODO we should check against schema\n            return true;\n        }\n\n        function getValidChildrenTypes(path) {\n            var node = _nodes[path];\n            if (node) {\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node, '_meta'), 'children'), 'items');\n            }\n            return [];\n        }\n\n        function getValidTargetTypes(path, name) {\n            var node = _nodes[path];\n            if (node) {\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node, '_meta'), '_p_' + name), 'items');\n            }\n            return [];\n        }\n\n        function hasOwnMetaRules(path) {\n            var node = _nodes[path];\n            if (node) {\n                var own = getMeta(path);\n                var base = getMeta(_core.getPath(_core.getBase(node)));\n                return own !== base;\n            }\n            return false;\n        }\n\n        function filterValidTarget(path, name, paths) {\n            var targets = [];\n            for (var i = 0; i < paths.length; i++) {\n                if (isValidTarget(path, name, paths[i])) {\n                    targets.push(paths[i]);\n                }\n            }\n            return targets;\n        }\n\n        function getOwnValidChildrenTypes(path) {\n            var node = _nodes[path];\n            var items = [];\n            if (node) {\n                var own = getValidChildrenTypes(path);\n                var base = getValidChildrenTypes(_core.getPath(_core.getBase(node)));\n                for (var i = 0; i < own.length; i++) {\n                    if (base.indexOf(own[i]) === -1) {\n                        items.push(own[i]);\n                    }\n                }\n            }\n            return items;\n        }\n\n        function getOwnValidTargetTypes(path, name) {\n            var node = _nodes[path];\n            var items = [];\n            if (node) {\n                var own = getValidTargetTypes(path, name);\n                var base = getValidTargetTypes(_core.getPath(_core.getBase(node)), name);\n                for (var i = 0; i < own.length; i++) {\n                    if (base.indexOf(own[i]) === -1) {\n                        items.push(own[i]);\n                    }\n                }\n            }\n            return items;\n        }\n\n        function getValidAttributeNames(path) {\n            var rawMeta = getMeta(path),\n                names = [];\n            if (rawMeta) {\n                for (var i in rawMeta.attributes) {\n                    names.push(i);\n                }\n            }\n            return names;\n        }\n\n        function getOwnValidAttributeNames(path) {\n            var names = [],\n                node = _nodes[path];\n\n            if (node) {\n                var own = getValidAttributeNames(path);\n                var base = getValidAttributeNames(_core.getPath(_core.getBase(node)));\n                for (var i = 0; i < own.length; i++) {\n                    if (base.indexOf(own[i]) === -1) {\n                        names.push(own[i]);\n                    }\n                }\n            }\n            return names;\n        }\n\n        function indexOfPathInRefObjArray(array, path) {\n            var index = 0;\n            while (index < array.length) {\n                if (path === refObjectToPath(array[index])) {\n                    return index;\n                }\n                index++;\n            }\n            return -1;\n        }\n\n        function getChildrenMeta(path) {\n            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var childrenMeta = {};\n                childrenMeta.min = rawMeta.children.min;\n                childrenMeta.max = rawMeta.children.max;\n                childrenMeta.items = rawMeta.children.items;\n                if (childrenMeta.items !== null) {\n                    for (var i = 0; i < childrenMeta.items.length; i++) {\n                        var child = {};\n                        child.id = refObjectToPath(childrenMeta.items[i]);\n                        if (rawMeta.children.minItems) {\n                            child.min = rawMeta.children.minItems[i] === -1 ? undefined : rawMeta.children.minItems[i];\n                        }\n                        if (rawMeta.children.maxItems) {\n                            child.max = rawMeta.children.maxItems[i] === -1 ? undefined : rawMeta.children.maxItems[i];\n                        }\n\n                        childrenMeta.items[i] = child;\n                    }\n                }\n\n                return childrenMeta;\n            }\n            return null;\n        }\n\n        function getChildrenMetaAttribute(path/*, attrName*/) {\n            var childrenMeta = getChildrenMeta(path);\n            if (childrenMeta) {\n                return childrenMeta.attrName;\n            }\n            return null;\n        }\n\n        function setChildrenMetaAttribute(path, attrName, value) {\n            if (attrName !== 'items') {\n                var rawMeta = getMeta(path);\n                rawMeta.children[attrName] = value;\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getValidChildrenItems(path) {\n            var childrenMeta = getChildrenMeta(path);\n            if (childrenMeta) {\n                return childrenMeta.items;\n            }\n            return null;\n        }\n\n        function updateValidChildrenItem(path, newTypeObj) {\n            var i,\n                rawMeta;\n            if (newTypeObj && newTypeObj.id) {\n                rawMeta = getMeta(path);\n                if (rawMeta) {\n                    if (rawMeta.children.minItems === null || rawMeta.children.minItems === undefined) { //TODO: use ! ?\n                        rawMeta.children.minItems = [];\n                        for (i = 0; i < rawMeta.children.items.length; i++) {\n                            rawMeta.children.minItems.push(-1);\n                        }\n                    }\n                    if (rawMeta.children.maxItems === null || rawMeta.children.maxItems === undefined) { //TODO: use ! ?\n                        rawMeta.children.maxItems = [];\n                        for (i = 0; i < rawMeta.children.items.length; i++) {\n                            rawMeta.children.maxItems.push(-1);\n                        }\n                    }\n                    var refObj = pathToRefObject(newTypeObj.id);\n                    var index = indexOfPathInRefObjArray(rawMeta.children.items, newTypeObj.id);\n                    if (index === -1) {\n                        index = rawMeta.children.items.length;\n                        rawMeta.children.items.push(refObj);\n                        rawMeta.children.minItems.push(-1);\n                        rawMeta.children.maxItems.push(-1);\n                    }\n                    // jshint expr:true\n                    (newTypeObj.min === null || newTypeObj.min === undefined) ?\n                        rawMeta.children.minItems[index] = -1 : rawMeta.children.minItems[index] = newTypeObj.min;\n\n                    (newTypeObj.max === null || newTypeObj.max === undefined) ?\n                        rawMeta.children.maxItems[index] = -1 : rawMeta.children.maxItems[index] = newTypeObj.max;\n                    // jshint expr:false\n                    setMeta(path, rawMeta);\n                }\n            }\n        }\n\n        function removeValidChildrenItem(path, typeId) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                //var refObj = pathToRefObject(typeId);\n                var index = indexOfPathInRefObjArray(rawMeta.children.items, typeId);\n                if (index !== -1) {\n                    rawMeta.children.items.splice(index, 1);\n                    if (rawMeta.children.minItems) {\n                        rawMeta.children.minItems.splice(index, 1);\n                    }\n                    if (rawMeta.children.maxItems) {\n                        rawMeta.children.maxItems.splice(index, 1);\n                    }\n                    setMeta(path, rawMeta);\n                }\n            }\n        }\n\n        function getAttributeSchema(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                if (rawMeta.attributes[name]) {\n                    return rawMeta.attributes[name];\n                }\n            }\n            return null;\n        }\n\n        function setAttributeSchema(path, name, schema) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                //TODO check schema validity - but it is also viable to check it only during setMeta\n                rawMeta.attributes[name] = schema;\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function removeAttributeSchema(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                delete rawMeta.attributes[name];\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getPointerMeta(path, name) {\n            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}\n            var rawMeta = getMeta(path);\n            if (rawMeta && rawMeta.pointers[name]) {\n                var pointerMeta = {};\n                pointerMeta.min = rawMeta.pointers[name].min;\n                pointerMeta.max = rawMeta.pointers[name].max;\n                pointerMeta.items = rawMeta.pointers[name].items;\n                if (pointerMeta.items !== null) {\n                    for (var i = 0; i < pointerMeta.items.length; i++) {\n                        var child = {};\n                        child.id = refObjectToPath(pointerMeta.items[i]);\n                        if (rawMeta.pointers[name].minItems) {\n                            child.min = rawMeta.pointers[name].minItems[i] === -1 ?\n                                undefined : rawMeta.pointers[name].minItems[i]; //FIXME: avoid assigning undefined\n                        }\n                        if (rawMeta.pointers[name].maxItems) {\n                            child.max = rawMeta.pointers[name].maxItems[i] === -1 ?\n                                undefined : rawMeta.pointers[name].maxItems[i]; //FIXME: avoid assigning undefined\n                        }\n                        pointerMeta.items[i] = child;\n                    }\n                }\n                return pointerMeta;\n            }\n            return null;\n        }\n\n        function getValidTargetItems(path, name) {\n            var pointerMeta = getPointerMeta(path, name);\n            if (pointerMeta) {\n                return pointerMeta.items;\n            }\n            return null;\n        }\n\n        function updateValidTargetItem(path, name, targetObj) {\n            var rawMeta = getMeta(path);\n            if (rawMeta && targetObj && targetObj.id) {\n                var pointer = rawMeta.pointers[name] || null;\n                if (pointer === null) {\n                    rawMeta.pointers[name] = {items: [], minItems: [], maxItems: []};\n                    pointer = rawMeta.pointers[name];\n                }\n                var refObj = pathToRefObject(targetObj.id);\n                var index = indexOfPathInRefObjArray(pointer.items, targetObj.id);\n                if (index === -1) {\n                    index = pointer.items.length;\n                    pointer.items.push(refObj);\n                    pointer.minItems.push(-1);\n                    pointer.maxItems.push(-1);\n                }\n                // jshint expr:true\n                (targetObj.min === null || targetObj.min === undefined) ?\n                    pointer.minItems[index] = -1 : pointer.minItems[index] = targetObj.min;\n\n                (targetObj.max === null || targetObj.max === undefined) ?\n                    pointer.maxItems[index] = -1 : pointer.maxItems[index] = targetObj.max;\n                // jshint expr:false\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function removeValidTargetItem(path, name, targetId) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var pointer = rawMeta.pointers[name] || null;\n                if (pointer !== null) {\n                    //var refObj = pathToRefObject(targetId);\n                    var index = indexOfPathInRefObjArray(pointer.items, targetId);\n                    if (index !== -1) {\n                        pointer.items.splice(index, 1);\n                        if (pointer.minItems) {\n                            pointer.minItems.splice(index, 1);\n                        }\n                        if (pointer.maxItems) {\n                            pointer.maxItems.splice(index, 1);\n                        }\n                        setMeta(path, rawMeta);\n                    }\n                }\n            }\n        }\n\n        function deleteMetaPointer(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                delete rawMeta.pointers[name];\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function setPointerMeta(path, name, meta) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var pointer = rawMeta.pointers[name] || null;\n                if (pointer === null) {\n                    rawMeta.pointers[name] = {items: [], minItems: [], maxItems: []};\n                    pointer = rawMeta.pointers[name];\n                }\n                pointer.min = meta.min;\n                pointer.max = meta.max;\n                if (meta.items && meta.items.length) {\n                    for (var i = 0; i < meta.items.length; i++) {\n                        pointer.items.push(pathToRefObject(meta.items[i].id));\n                        pointer.minItems.push(meta.items[i].min || -1);\n                        pointer.maxItems.push(meta.items[i].max || -1);\n                    }\n                }\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function setChildrenMeta(path, name, meta) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var children = rawMeta.children;\n\n                children.min = meta.min;\n                children.max = meta.max;\n                if (meta.items && meta.items.length) {\n                    for (var i = 0; i < meta.items.length; i++) {\n                        children.items.push(pathToRefObject(meta.items[i].id));\n                        children.minItems.push(meta.items[i].min || -1);\n                        children.maxItems.push(meta.items[i].max || -1);\n                    }\n                }\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getMetaAspectNames(path) {\n            var rawMeta = getMeta(path),\n                names = [];\n\n            if (rawMeta && rawMeta.aspects) {\n                for (var i in rawMeta.aspects) {\n                    names.push(i);\n                }\n            }\n            return names;\n        }\n\n        function getOwnMetaAspectNames(path) {\n            var names = getMetaAspectNames(path),\n                ownNames = [];\n            if (_nodes[path]) {\n                var baseNames = getMetaAspectNames(_core.getPath(_core.getBase(_nodes[path])));\n                for (var i = 0; i < names.length; i++) {\n                    if (baseNames.indexOf(names[i]) === -1) {\n                        ownNames.push(names[i]);\n                    }\n                }\n            }\n            return ownNames;\n        }\n\n        function getMetaAspect(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                if (rawMeta.aspects[name]) {\n                    var aspect = {items: []};\n                    for (var i = 0; i < rawMeta.aspects[name].items.length; i++) {\n                        aspect.items.push(refObjectToPath(rawMeta.aspects[name].items[i]));\n                    }\n                    if (aspect.items.length === 0) {\n                        delete aspect.items;\n                    }\n                    return aspect;\n                }\n                return null;\n            }\n            return null;\n        }\n\n        function setMetaAspect(path, name, aspect) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n\n                rawMeta.aspects = rawMeta.aspects || {};\n                rawMeta.aspects[name] = {items: []};\n                for (var i = 0; i < aspect.items.length; i++) {\n                    rawMeta.aspects[name].items.push(pathToRefObject(aspect.items[i]));\n                }\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getAspectTerritoryPattern(path, name) {\n            var aspect = getMetaAspect(path, name);\n            if (aspect !== null) {\n                aspect.children = 1; //TODO now it is fixed, maybe we can change that in the future\n                return aspect;\n            }\n            return null;\n        }\n\n        function deleteMetaAspect(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                if (rawMeta.aspects && rawMeta.aspects[name]) {\n                    delete rawMeta.aspects[name];\n                    setMeta(path, rawMeta);\n                }\n            }\n        }\n\n        return {\n            refObjectToPath: refObjectToPath,\n            pathToRefObject: pathToRefObject,\n\n\n            initialize: initialize,\n            getMeta: getMeta,\n            setMeta: setMeta,\n            isTypeOf: isTypeOf,\n            hasOwnMetaRules: hasOwnMetaRules,\n\n            //containment\n            isValidChild: isValidChild,\n            getChildrenMeta: getChildrenMeta,\n            setChildrenMeta: setChildrenMeta,\n            getChildrenMetaAttribute: getChildrenMetaAttribute,\n            setChildrenMetaAttribute: setChildrenMetaAttribute,\n            getValidChildrenTypes: getValidChildrenTypes,\n            getOwnValidChildrenTypes: getOwnValidChildrenTypes,\n            getValidChildrenItems: getValidChildrenItems,\n            updateValidChildrenItem: updateValidChildrenItem,\n            removeValidChildrenItem: removeValidChildrenItem,\n\n            //attribute\n            isValidAttribute: isValidAttribute,\n            getAttributeSchema: getAttributeSchema,\n            setAttributeSchema: setAttributeSchema,\n            removeAttributeSchema: removeAttributeSchema,\n            getValidAttributeNames: getValidAttributeNames,\n            getOwnValidAttributeNames: getOwnValidAttributeNames,\n\n            //pointer\n            isValidTarget: isValidTarget,\n            getPointerMeta: getPointerMeta,\n            setPointerMeta: setPointerMeta,\n            getValidTargetItems: getValidTargetItems,\n            getValidTargetTypes: getValidTargetTypes,\n            getOwnValidTargetTypes: getOwnValidTargetTypes,\n            filterValidTarget: filterValidTarget,\n            updateValidTargetItem: updateValidTargetItem,\n            removeValidTargetItem: removeValidTargetItem,\n            deleteMetaPointer: deleteMetaPointer,\n\n            //aspect\n            getMetaAspectNames: getMetaAspectNames,\n            getOwnMetaAspectNames: getOwnMetaAspectNames,\n            getMetaAspect: getMetaAspect,\n            setMetaAspect: setMetaAspect,\n            getAspectTerritoryPattern: getAspectTerritoryPattern,\n            deleteMetaAspect: deleteMetaAspect\n\n        };\n    }\n\n    return metaStorage;\n});\n\n",
    "/*globals define*/\r\n/*jshint browser: true, node:true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n *\r\n * FIXME: is there a built in function to JavaScript to parse cookies?\r\n */\r\n\r\ndefine('common/util/url',[],function () {\r\n    'use strict';\r\n\r\n    function parseCookie(cookie) {\r\n        var parsed,\r\n            elements,\r\n            i,\r\n            pair;\r\n\r\n        cookie = decodeURIComponent(cookie);\r\n        parsed = {};\r\n        elements = cookie.split(/[;] */);\r\n        for (i = 0; i < elements.length; i++) {\r\n            pair = elements[i].split('=');\r\n            parsed[pair[0]] = pair[1];\r\n        }\r\n        return parsed;\r\n    }\r\n\r\n    function urlToRefObject(url) {\r\n        return {\r\n            $ref: url\r\n        };\r\n    }\r\n\r\n    return {\r\n        parseCookie: parseCookie,\r\n        urlToRefObject: urlToRefObject\r\n    };\r\n});\r\n\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * REGISTRY KEY NAMES USED BY THE UI\n *\n * @author rkereskenyi / https://github.com/rkereskenyi\n */\n\ndefine('js/RegistryKeys',[], function () {\n\n    'use strict';\n\n    return {\n        COLOR: 'color',   //fill color of the item\n        TEXT_COLOR: 'textColor',   //color of the texts of the item\n        BORDER_COLOR: 'borderColor',   //border color of the item (if any)\n        POSITION: 'position',  //position of the item {x, y}\n        ROTATION: 'rotation',   //rotation of the item\n        DECORATOR: 'decorator', //custom decorator name of the item\n        IS_PORT: 'isPort',  //if the item is port in its parent or not\n        IS_ABSTRACT: 'isAbstract',  //whether the item is abstract or not !!! (attribute???)\n        LINE_STYLE: 'lineStyle',    //the style of the line (solid, dot, dash-dot)\n        LINE_TYPE: 'lineType',      //the type of the line (straight, bezier, ...)\n        LINE_WIDTH: 'lineWidth',     //width of the line\n        LINE_START_ARROW: 'lineStartArrow',     //start arrow of a line\n        LINE_END_ARROW: 'lineEndArrow',     //start arrow of a line\n        LINE_CUSTOM_POINTS: 'lineCustomPoints',  //custom routing points of a line\n\n        //TODO maybe we should harmonize with project registry\n        VALID_PLUGINS: 'validPlugins', //space separated list of valid plugins for the project\n        USED_ADDONS: 'usedAddOns', //space separated list of used addons in the given project\n        VALID_VISUALIZERS: 'validVisualizers', //space separated list of valid visualizers for the node\n        VALID_DECORATORS: 'validDecorators', //space separated list of valid decorators for the project\n        /*\n         *  MISC\n         */\n        PROJECT_REGISTRY: 'ProjectRegistry',\n        DISPLAY_FORMAT: 'DisplayFormat',\n        SVG_ICON: 'SVGIcon',\n        PORT_SVG_ICON: 'PortSVGIcon',\n\n        /*\n         * META_SHEETS_METADATA (title, order, setID, etc)\n         */\n        META_SHEETS: 'MetaSheets',\n\n        /*\n         * CROSSCUTS_META_INFO_REGISTRY_KEY\n         */\n        CROSSCUTS: 'CrossCuts',\n\n        /*\n         * DISABLED CONNECTION AREAS FOR DIAGRAM-DESIGNER-WIDGET DECORATORS ARE STORED UNDER THIS REGISTRY KEY\n         * ON A PER DECORATOR BASIS\n         */\n        DIAGRAM_DESIGNER_WIDGET_DECORATOR_DISABLED_CONNECTION_AREAS:\n            'diagramDesignerWidgetDecoratorDisabledConnectionAreas_'\n    };\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('js/client/gmeNodeGetter',['js/RegistryKeys'], function (REG_KEYS) {\n    'use strict';\n\n    //getNode\n    function getNode(_id, logger, state, meta, storeNode) {\n\n        function getParentId() {\n            //just for sure, as it may missing from the cache\n            return storeNode(state.core.getParent(state.nodes[_id].node));\n        }\n\n        function getId() {\n            return _id;\n        }\n\n        function getGuid() {\n            return state.core.getGuid(state.nodes[_id].node);\n        }\n\n        function getChildrenIds() {\n            return state.core.getChildrenPaths(state.nodes[_id].node);\n        }\n\n        function getBaseId() {\n            var base = state.core.getBase(state.nodes[_id].node);\n            if (base) {\n                return storeNode(base);\n            } else {\n                return null;\n            }\n\n        }\n\n        function getInheritorIds() {\n            return [];\n        }\n\n        function getAttribute(name) {\n            return state.core.getAttribute(state.nodes[_id].node, name);\n        }\n\n        function getOwnAttribute(name) {\n            return state.core.getOwnAttribute(state.nodes[_id].node, name);\n        }\n\n        function getEditableAttribute(name) {\n            var value = state.core.getAttribute(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getOwnEditableAttribute(name) {\n            var value = state.core.getOwnAttribute(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getRegistry(name) {\n            return state.core.getRegistry(state.nodes[_id].node, name);\n        }\n\n        function getOwnRegistry(name) {\n            return state.core.getOwnRegistry(state.nodes[_id].node, name);\n        }\n\n        function getEditableRegistry(name) {\n            var value = state.core.getRegistry(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getOwnEditableRegistry(name) {\n            var value = state.core.getOwnRegistry(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getPointer(name) {\n            //return _core.getPointerPath(_nodes[_id].node,name);\n            if (name === 'base') {\n                //base is a special case as it complicates with inherited children\n                return {\n                    to: state.core.getPath(state.core.getBase(state.nodes[_id].node)),\n                    from: []\n                };\n            }\n            return {to: state.core.getPointerPath(state.nodes[_id].node, name), from: []};\n        }\n\n        function getOwnPointer(name) {\n            return {to: state.core.getOwnPointerPath(state.nodes[_id].node, name), from: []};\n        }\n\n        function getPointerNames() {\n            return state.core.getPointerNames(state.nodes[_id].node);\n        }\n\n        function getOwnPointerNames() {\n            return state.core.getOwnPointerNames(state.nodes[_id].node);\n        }\n\n        function getAttributeNames() {\n            return state.core.getAttributeNames(state.nodes[_id].node);\n        }\n\n        function getOwnAttributeNames() {\n            return state.core.getOwnAttributeNames(state.nodes[_id].node);\n        }\n\n        function getRegistryNames() {\n            return state.core.getRegistryNames(state.nodes[_id].node);\n        }\n\n        function getOwnRegistryNames() {\n            return state.core.getOwnRegistryNames(state.nodes[_id].node);\n        }\n\n        //SET\n        function getMemberIds(setid) {\n            return state.core.getMemberPaths(state.nodes[_id].node, setid);\n        }\n\n        function getSetNames() {\n            return state.core.getSetNames(state.nodes[_id].node);\n        }\n\n        function getMemberAttributeNames(setid, memberid) {\n            return state.core.getMemberAttributeNames(state.nodes[_id].node, setid, memberid);\n        }\n\n        function getMemberAttribute(setid, memberid, name) {\n            return state.core.getMemberAttribute(state.nodes[_id].node, setid, memberid, name);\n        }\n\n        function getEditableMemberAttribute(setid, memberid, name) {\n            var attr = state.core.getMemberAttribute(state.nodes[_id].node, setid, memberid, name);\n            if (attr !== null && attr !== undefined) {\n                return JSON.parse(JSON.stringify(attr));\n            }\n            return null;\n        }\n\n        function getMemberRegistryNames(setid, memberid) {\n            return state.core.getMemberRegistryNames(state.nodes[_id].node, setid, memberid);\n        }\n\n        function getMemberRegistry(setid, memberid, name) {\n            return state.core.getMemberRegistry(state.nodes[_id].node, setid, memberid, name);\n        }\n\n        function getEditableMemberRegistry(setid, memberid, name) {\n            var attr = state.core.getMemberRegistry(state.nodes[_id].node, setid, memberid, name);\n            if (attr !== null && attr !== undefined) {\n                return JSON.parse(JSON.stringify(attr));\n            }\n            return null;\n        }\n\n        //META\n        function getValidChildrenTypes() {\n            //return getMemberIds('ValidChildren');\n            return meta.getValidChildrenTypes(_id);\n        }\n\n        function getValidAttributeNames() {\n            return state.core.getValidAttributeNames(state.nodes[_id].node);\n        }\n\n        function getValidPointerNames() {\n            return state.core.getValidPointerNames(state.nodes[_id].node);\n        }\n\n        function getValidSetNames() {\n            return state.core.getValidSetNames(state.nodes[_id].node);\n        }\n\n        //constraint functions\n        function getConstraintNames() {\n            return state.core.getConstraintNames(state.nodes[_id].node);\n        }\n\n        function getOwnConstraintNames() {\n            return state.core.getOwnConstraintNames(state.nodes[_id].node);\n        }\n\n        function getConstraint(name) {\n            return state.core.getConstraint(state.nodes[_id].node, name);\n        }\n\n        function toString() {\n            return state.core.getAttribute(state.nodes[_id].node, 'name') + ' (' + _id + ')';\n        }\n\n        function getCollectionPaths(name) {\n            return state.core.getCollectionPaths(state.nodes[_id].node, name);\n        }\n\n        //adding functionality to get rid of GMEConcepts\n        function isConnection() {\n            return state.core.isConnection(state.nodes[_id].node);\n        }\n\n        function isAbstract() {\n            return state.core.isAbstract(state.nodes[_id].node);\n        }\n\n        function getCrosscutsInfo() {\n            return state.core.getRegistry(state.nodes[_id].node, REG_KEYS.CROSSCUTS) || [];\n        }\n\n        function getValidChildrenTypesDetailed(aspect) {\n            var parameters = {\n                    node: state.nodes[_id].node,\n                    children: [],\n                    sensitive: true,\n                    multiplicity: false,\n                    aspect: aspect\n                },\n                fullList,\n                filteredList,\n                validTypes = {},\n                keys = getChildrenIds(),\n                i;\n\n            for (i = 0; i < keys.length; i++) {\n                if (state.nodes[keys[i]]) {\n                    parameters.children.push(state.nodes[keys[i]].node);\n                }\n            }\n\n            fullList = state.core.getValidChildrenMetaNodes(parameters);\n\n            parameters.multiplicity = true;\n            filteredList = state.core.getValidChildrenMetaNodes(parameters);\n\n            for (i = 0; i < fullList.length; i += 1) {\n                validTypes[state.core.getPath(fullList[i])] = false;\n            }\n\n            for (i = 0; i < filteredList.length; i += 1) {\n                validTypes[state.core.getPath(filteredList[i])] = true;\n            }\n\n            return validTypes;\n        }\n\n        function getValidSetMemberTypesDetailed(setName) {\n            var parameters = {\n                    node: state.nodes[_id].node,\n                    children: [],\n                    sensitive: true,\n                    multiplicity: false,\n                    name: setName\n                },\n                fullList,\n                filteredList,\n                validTypes = {},\n                keys = getChildrenIds(),\n                i;\n\n            for (i = 0; i < keys.length; i++) {\n                if (state.nodes[keys[i]]) {\n                    parameters.children.push(state.nodes[keys[i]].node);\n                }\n            }\n\n            fullList = state.core.getValidSetElementsMetaNodes(parameters);\n\n            parameters.multiplicity = true;\n            filteredList = state.core.getValidSetElementsMetaNodes(parameters);\n\n            for (i = 0; i < fullList.length; i += 1) {\n                validTypes[state.core.getPath(fullList[i])] = false;\n            }\n\n            for (i = 0; i < filteredList.length; i += 1) {\n                validTypes[state.core.getPath(filteredList[i])] = true;\n            }\n\n            return validTypes;\n        }\n\n        if (state.nodes[_id]) {\n            return {\n                getParentId: getParentId,\n                getId: getId,\n                getGuid: getGuid,\n                getChildrenIds: getChildrenIds,\n                getBaseId: getBaseId,\n                getInheritorIds: getInheritorIds,\n                getAttribute: getAttribute,\n                getEditableAttribute: getEditableAttribute,\n                getRegistry: getRegistry,\n                getEditableRegistry: getEditableRegistry,\n                getOwnAttribute: getOwnAttribute,\n                getOwnEditableAttribute: getOwnEditableAttribute,\n                getOwnRegistry: getOwnRegistry,\n                getOwnEditableRegistry: getOwnEditableRegistry,\n                getPointer: getPointer,\n                getPointerNames: getPointerNames,\n                getAttributeNames: getAttributeNames,\n                getRegistryNames: getRegistryNames,\n                getOwnAttributeNames: getOwnAttributeNames,\n                getOwnRegistryNames: getOwnRegistryNames,\n                getOwnPointer: getOwnPointer,\n                getOwnPointerNames: getOwnPointerNames,\n\n                //SetFunctions\n                getMemberIds: getMemberIds,\n                getSetNames: getSetNames,\n                getMemberAttributeNames: getMemberAttributeNames,\n                getMemberAttribute: getMemberAttribute,\n                getEditableMemberAttribute: getEditableMemberAttribute,\n                getMemberRegistryNames: getMemberRegistryNames,\n                getMemberRegistry: getMemberRegistry,\n                getEditableMemberRegistry: getEditableMemberRegistry,\n\n                //META functions\n                getValidChildrenTypes: getValidChildrenTypes,\n                getValidAttributeNames: getValidAttributeNames,\n                getValidPointerNames: getValidPointerNames,\n                getValidSetNames: getValidSetNames,\n                getValidChildrenTypesDetailed: getValidChildrenTypesDetailed,\n                getValidSetMemberTypesDetailed: getValidSetMemberTypesDetailed,\n                isConnection: isConnection,\n                isAbstract: isAbstract,\n                getCrosscutsInfo: getCrosscutsInfo,\n\n                //constraint functions\n                getConstraintNames: getConstraintNames,\n                getOwnConstraintNames: getOwnConstraintNames,\n                getConstraint: getConstraint,\n\n                toString: toString,\n\n                getCollectionPaths: getCollectionPaths\n\n            };\n        } else {\n            //logger.warn('Tried to get node with path \"' + _id + '\" but was not in state.nodes');\n        }\n\n        return null;\n    }\n\n    return getNode;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('js/client/gmeNodeSetter',[], function () {\n    'use strict';\n    function gmeNodeSetter(logger, state, saveRoot, storeNode) {\n\n        function setAttributes(path, name, value, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setAttribute(state.nodes[path].node, name, value);\n                msg = msg || 'setAttribute(' + path + ',' + name + ',' + value + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delAttributes(path, name, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delAttribute(state.nodes[path].node, name);\n                msg = msg || 'delAttribute(' + path + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setRegistry(path, name, value, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setRegistry(state.nodes[path].node, name, value);\n                msg = msg || 'setRegistry(' + path + ',' + ',' + name + ',' + value + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delRegistry(path, name, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delRegistry(state.nodes[path].node, name);\n                msg = msg || 'delRegistry(' + path + ',' + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function copyMoreNodes(parameters, msg) {\n            var pathestocopy = [],\n                i,\n                j,\n                newNode;\n\n            if (typeof parameters.parentId === 'string' && state.nodes[parameters.parentId] &&\n                typeof state.nodes[parameters.parentId].node === 'object') {\n                for (i in parameters) {\n                    if (i !== 'parentId') {\n                        pathestocopy.push(i);\n                    }\n                }\n\n                msg = msg || 'copyMoreNodes(' + pathestocopy + ',' + parameters.parentId + ')';\n                if (pathestocopy.length < 1) {\n                    // empty on purpose\n                } else if (pathestocopy.length === 1) {\n                    newNode = state.core.copyNode(state.nodes[pathestocopy[0]].node,\n                        state.nodes[parameters.parentId].node);\n                    storeNode(newNode);\n                    if (parameters[pathestocopy[0]]) {\n                        for (j in parameters[pathestocopy[0]].attributes) {\n                            if (parameters[pathestocopy[0]].attributes.hasOwnProperty(j)) {\n                                state.core.setAttribute(newNode, j, parameters[pathestocopy[0]].attributes[j]);\n                            }\n                        }\n                        for (j in parameters[pathestocopy[0]].registry) {\n                            if (parameters[pathestocopy[0]].registry.hasOwnProperty(j)) {\n                                state.core.setRegistry(newNode, j, parameters[pathestocopy[0]].registry[j]);\n                            }\n                        }\n                    }\n                    saveRoot(msg);\n                } else {\n                    copyMoreNodesAsync(pathestocopy, parameters.parentId, function (err, copyarr) {\n                        var i,\n                            j;\n                        if (err) {\n                            //rollBackModification();\n                            state.logger.error(err);\n                        } else {\n                            for (i in copyarr) {\n                                if (copyarr.hasOwnProperty(i) && parameters[i]) {\n                                    for (j in parameters[i].attributes) {\n                                        if (parameters[i].attributes.hasOwnProperty(j)) {\n                                            state.core.setAttribute(copyarr[i], j, parameters[i].attributes[j]);\n                                        }\n                                    }\n                                    for (j in parameters[i].registry) {\n                                        if (parameters[i].registry.hasOwnProperty(j)) {\n                                            state.core.setRegistry(copyarr[i], j, parameters[i].registry[j]);\n                                        }\n                                    }\n                                }\n                            }\n                            saveRoot(msg);\n                        }\n                    });\n                }\n            } else {\n                state.logger.error('wrong parameters for copy operation - denied -');\n            }\n        }\n\n        function copyMoreNodesAsync(nodePaths, parentPath, callback) {\n            var i,\n                tempFrom,\n                tempTo,\n                helpArray,\n                subPathArray,\n                parent,\n                returnArray,\n                checkPaths = function () {\n                    var i,\n                        result = true;\n\n                    for (i = 0; i < nodePaths.length; i += 1) {\n                        result = result && (state.nodes[nodePaths[i]] &&\n                            typeof state.nodes[nodePaths[i]].node === 'object');\n                    }\n                    return result;\n                };\n\n            if (state.nodes[parentPath] &&\n                typeof state.nodes[parentPath].node === 'object' && checkPaths()) {\n                helpArray = {};\n                subPathArray = {};\n                parent = state.nodes[parentPath].node;\n                returnArray = {};\n\n                //creating the 'from' object\n                tempFrom = state.core.createNode({\n                    parent: parent,\n                    base: state.core.getTypeRoot(state.nodes[nodePaths[0]].node)\n                });\n                //and moving every node under it\n                for (i = 0; i < nodePaths.length; i += 1) {\n                    helpArray[nodePaths[i]] = {};\n                    helpArray[nodePaths[i]].origparent =\n                        state.core.getParent(state.nodes[nodePaths[i]].node);\n                    helpArray[nodePaths[i]].tempnode =\n                        state.core.moveNode(state.nodes[nodePaths[i]].node, tempFrom);\n                    subPathArray[state.core.getRelid(helpArray[nodePaths[i]].tempnode)] = nodePaths[i];\n                    delete state.nodes[nodePaths[i]];\n                }\n\n                //do the copy\n                tempTo = state.core.copyNode(tempFrom, parent);\n\n                //moving back the temporary source\n                for (i = 0; i < nodePaths.length; i += 1) {\n                    helpArray[nodePaths[i]].node = state.core.moveNode(helpArray[nodePaths[i]].tempnode,\n                        helpArray[nodePaths[i]].origparent);\n                    storeNode(helpArray[nodePaths[i]].node);\n                }\n\n                //gathering the destination nodes\n                state.core.loadChildren(tempTo, function (err, children) {\n                    var newNode;\n\n                    if (!err && children && children.length > 0) {\n                        for (i = 0; i < children.length; i += 1) {\n                            if (subPathArray[state.core.getRelid(children[i])]) {\n                                newNode = state.core.moveNode(children[i], parent);\n                                storeNode(newNode);\n                                returnArray[subPathArray[state.core.getRelid(children[i])]] = newNode;\n                            } else {\n                                state.logger.error('635 - should never happen!!!');\n                            }\n                        }\n                        state.core.deleteNode(tempFrom);\n                        state.core.deleteNode(tempTo);\n                        callback(null, returnArray);\n                    } else {\n                        //clean up the mess and return\n                        state.core.deleteNode(tempFrom);\n                        state.core.deleteNode(tempTo);\n                        callback(err, {});\n                    }\n                });\n            }\n        }\n\n        function moveMoreNodes(parameters) {\n            var pathsToMove = [],\n                returnParams = {},\n                i,\n                j,\n                newNode;\n\n            for (i in parameters) {\n                if (parameters.hasOwnProperty(i)) {\n                    if (i !== 'parentId') {\n                        pathsToMove.push(i);\n                    }\n                }\n            }\n\n            if (pathsToMove.length > 0 &&\n                typeof parameters.parentId === 'string' &&\n                state.nodes[parameters.parentId] &&\n                typeof state.nodes[parameters.parentId].node === 'object') {\n                for (i = 0; i < pathsToMove.length; i += 1) {\n                    if (state.nodes[pathsToMove[i]] &&\n                        typeof state.nodes[pathsToMove[i]].node === 'object') {\n                        newNode = state.core.moveNode(state.nodes[pathsToMove[i]].node,\n                            state.nodes[parameters.parentId].node);\n                        returnParams[pathsToMove[i]] = state.core.getPath(newNode);\n                        if (parameters[pathsToMove[i]].attributes) {\n                            for (j in parameters[pathsToMove[i]].attributes) {\n                                if (parameters[pathsToMove[i]].attributes.hasOwnProperty(j)) {\n                                    state.core.setAttribute(newNode,\n                                        j, parameters[pathsToMove[i]].attributes[j]);\n                                }\n                            }\n                        }\n                        if (parameters[pathsToMove[i]].registry) {\n                            for (j in parameters[pathsToMove[i]].registry) {\n                                if (parameters[pathsToMove[i]].registry.hasOwnProperty(j)) {\n                                    state.core.setRegistry(newNode,\n                                        j, parameters[pathsToMove[i]].registry[j]);\n                                }\n                            }\n                        }\n\n                        delete state.nodes[pathsToMove[i]];\n                        storeNode(newNode, true);\n                    }\n                }\n            }\n\n            return returnParams;\n        }\n\n        function createChildren(parameters, msg) {\n            //TODO we also have to check out what is happening with the sets!!!\n            var result = {},\n                paths = [],\n                nodes = [],\n                node,\n                parent = state.nodes[parameters.parentId].node,\n                names, i, j, index, pointer,\n                newChildren = [],\n                relations = [];\n\n            //to allow 'meaningfull' instantiation of multiple objects\n            // we have to recreate the internal relations - except the base\n            paths = Object.keys(parameters);\n            paths.splice(paths.indexOf('parentId'), 1);\n            for (i = 0; i < paths.length; i++) {\n                node = state.nodes[paths[i]].node;\n                nodes.push(node);\n                pointer = {};\n                names = state.core.getPointerNames(node);\n                index = names.indexOf('base');\n                if (index !== -1) {\n                    names.splice(index, 1);\n                }\n\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(state.core.getPointerPath(node, names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                relations.push(pointer);\n            }\n\n            //now the instantiation\n            for (i = 0; i < nodes.length; i++) {\n                newChildren.push(state.core.createNode({parent: parent, base: nodes[i]}));\n            }\n\n            //now for the storage and relation setting\n            for (i = 0; i < paths.length; i++) {\n                //attributes\n                names = Object.keys(parameters[paths[i]].attributes || {});\n                for (j = 0; j < names.length; j++) {\n                    state.core.setAttribute(newChildren[i],\n                        names[j], parameters[paths[i]].attributes[names[j]]);\n                }\n                //registry\n                names = Object.keys(parameters[paths[i]].registry || {});\n                for (j = 0; j < names.length; j++) {\n                    state.core.setRegistry(newChildren[i],\n                        names[j], parameters[paths[i]].registry[names[j]]);\n                }\n\n                //relations\n                names = Object.keys(relations[i]);\n                for (j = 0; j < names.length; j++) {\n                    state.core.setPointer(newChildren[i], names[j], newChildren[relations[i][names[j]]]);\n                }\n\n                //store\n                result[paths[i]] = storeNode(newChildren[i]);\n\n            }\n\n            msg = msg || 'createChildren(' + JSON.stringify(result) + ')';\n            saveRoot(msg);\n            return result;\n        }\n\n        //TODO should be removed as there is no user or public API related to this function\n        //function deleteNode(path, msg) {\n        //  if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n        //    state.core.deleteNode(state.nodes[path].node);\n        //    //delete state.nodes[path];\n        //    msg = msg || 'deleteNode(' + path + ')';\n        //    saveRoot(msg);\n        //  }\n        //}\n\n        function delMoreNodes(paths, msg) {\n            if (state.core) {\n                for (var i = 0; i < paths.length; i++) {\n                    if (state.nodes[paths[i]] && typeof state.nodes[paths[i]].node === 'object') {\n                        state.core.deleteNode(state.nodes[paths[i]].node);\n                        //delete state.nodes[paths[i]];\n                    }\n                }\n                msg = msg || 'delMoreNodes(' + paths + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function createChild(parameters, msg) {\n            var newID;\n\n            if (state.core) {\n                if (typeof parameters.parentId === 'string' && state.nodes[parameters.parentId] &&\n                    typeof state.nodes[parameters.parentId].node === 'object') {\n                    var baseNode = null;\n                    if (state.nodes[parameters.baseId]) {\n                        baseNode = state.nodes[parameters.baseId].node || baseNode;\n                    }\n                    var child = state.core.createNode({\n                        parent: state.nodes[parameters.parentId].node,\n                        base: baseNode,\n                        guid: parameters.guid,\n                        relid: parameters.relid\n                    });\n                    if (parameters.position) {\n                        state.core.setRegistry(child,\n                            'position',\n                            {\n                                x: parameters.position.x || 100,\n                                y: parameters.position.y || 100\n                            });\n                    } else {\n                        state.core.setRegistry(child, 'position', {x: 100, y: 100});\n                    }\n                    storeNode(child);\n                    newID = state.core.getPath(child);\n                    msg = msg || 'createChild(' + parameters.parentId + ',' + parameters.baseId + ',' + newID + ')';\n                    saveRoot(msg);\n                }\n            }\n\n            return newID;\n        }\n\n        function makePointer(id, name, to, msg) {\n            if (to === null) {\n                state.core.setPointer(state.nodes[id].node, name, to);\n            } else {\n\n\n                state.core.setPointer(state.nodes[id].node, name, state.nodes[to].node);\n            }\n\n            msg = msg || 'makePointer(' + id + ',' + name + ',' + to + ')';\n            saveRoot(msg);\n        }\n\n        function delPointer(path, name, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.deletePointer(state.nodes[path].node, name);\n                msg = msg || 'delPointer(' + path + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n\n        //MGAlike - set functions\n        function addMember(path, memberpath, setid, msg) {\n            if (state.nodes[path] &&\n                state.nodes[memberpath] &&\n                typeof state.nodes[path].node === 'object' &&\n                typeof state.nodes[memberpath].node === 'object') {\n                state.core.addMember(state.nodes[path].node,\n                    setid, state.nodes[memberpath].node);\n                msg = msg || 'addMember(' + path + ',' + memberpath + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function removeMember(path, memberpath, setid, msg) {\n            if (state.nodes[path] &&\n                typeof state.nodes[path].node === 'object') {\n                state.core.delMember(state.nodes[path].node, setid, memberpath);\n                msg = msg || 'removeMember(' + path + ',' + memberpath + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setMemberAttribute(path, memberpath, setid, name, value, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setMemberAttribute(state.nodes[path].node, setid, memberpath, name, value);\n                msg = msg ||\n                    'setMemberAttribute(' + path + ',' + memberpath + ',' + setid + ',' + name + ',' + value +\n                    ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delMemberAttribute(path, memberpath, setid, name, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delMemberAttribute(state.nodes[path].node, setid, memberpath, name);\n                msg = msg || 'delMemberAttribute(' + path + ',' + memberpath + ',' + setid + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setMemberRegistry(path, memberpath, setid, name, value, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setMemberRegistry(state.nodes[path].node, setid, memberpath, name, value);\n                msg = msg ||\n                    'setMemberRegistry(' + path + ',' + memberpath + ',' + setid + ',' + name + ',' + value + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delMemberRegistry(path, memberpath, setid, name, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delMemberRegistry(state.nodes[path].node, setid, memberpath, name);\n                msg = msg || 'delMemberRegistry(' + path + ',' + memberpath + ',' + setid + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function createSet(path, setid, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.createSet(state.nodes[path].node, setid);\n                msg = msg || 'createSet(' + path + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function deleteSet(path, setid, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.deleteSet(state.nodes[path].node, setid);\n                msg = msg || 'deleteSet(' + path + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setBase(path, basepath) {\n            /*if (state.core &&\n             state.nodes[path] && typeof state.nodes[path].node === 'object') {\n             state.core.setRegistry(state.nodes[path].node,'base',basepath);\n             saveRoot('setBase('+path+','+basepath+')');\n             }*/\n            if (state.core &&\n                state.nodes[path] &&\n                typeof state.nodes[path].node === 'object' &&\n                state.nodes[basepath] &&\n                typeof state.nodes[basepath].node === 'object') {\n                state.core.setBase(state.nodes[path].node, state.nodes[basepath].node);\n                saveRoot('setBase(' + path + ',' + basepath + ')');\n            }\n        }\n\n        function delBase(path) {\n            /*if (state.core &&\n             state.nodes[path] && typeof state.nodes[path].node === 'object') {\n             state.core.delRegistry(state.nodes[path].node,'base');\n             saveRoot('delBase('+path+')');\n             }*/\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setBase(state.nodes[path].node, null);\n                saveRoot('delBase(' + path + ')');\n            }\n        }\n\n        return {\n            setAttributes: setAttributes,\n            delAttributes: delAttributes,\n            setRegistry: setRegistry,\n            delRegistry: delRegistry,\n            copyMoreNodes: copyMoreNodes,\n            moveMoreNodes: moveMoreNodes,\n            delMoreNodes: delMoreNodes,\n            createChild: createChild,\n            createChildren: createChildren,\n            makePointer: makePointer,\n            delPointer: delPointer,\n            addMember: addMember,\n            removeMember: removeMember,\n            setMemberAttribute: setMemberAttribute,\n            delMemberAttribute: delMemberAttribute,\n            setMemberRegistry: setMemberRegistry,\n            delMemberRegistry: delMemberRegistry,\n            createSet: createSet,\n            deleteSet: deleteSet,\n\n            setBase: setBase,\n            delBase: delBase,\n        };\n    }\n\n    return gmeNodeSetter;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/serialization',['common/util/assert'], function (ASSERT) {\n\n    'use strict';\n    var _nodes = {},\n        _core = null,\n        _pathToGuidMap = {},\n        _guidKeys = [], //ordered list of GUIDs\n        _extraBasePaths = {},\n        _export = {},\n        _import = {},\n        _newNodeGuids = [],\n        _removedNodeGuids = [],\n        _updatedNodeGuids = [],\n        _log = '';\n\n    function log(txt) {\n        if (_log) {\n            _log += '\\n' + txt;\n        } else {\n            _log = '' + txt;\n        }\n    }\n\n    function exportLibrary(core, libraryRoot, callback) {\n        //initialization\n        _core = core;\n        _nodes = {};\n        _pathToGuidMap = {};\n        _guidKeys = [];\n        _extraBasePaths = {};\n        _export = {};\n\n        //loading all library element\n        gatherNodesSlowly(libraryRoot, function (err) {\n            if (err) {\n                return callback(err);\n            }\n\n            _guidKeys = _guidKeys.sort();\n            gatherAncestors(); //collecting the 'external' base classes - probably we should avoid these\n\n            var keys = Object.keys(_extraBasePaths),\n                i;\n            _export.bases = {};\n            for (i = 0; i < keys.length; i++) {\n                _export.bases[_extraBasePaths[keys[i]]] = keys[i];\n            }\n\n            //_export.bases = _extraBasePaths;\n            // we save this info alongside with the library export, to be on the safe side\n\n            _export.root = getLibraryRootInfo(libraryRoot);\n            _export.relids = getRelIdInfo();\n            _export.containment = {};\n            fillContainmentTree(libraryRoot, _export.containment);\n            _export.nodes = getNodesData();\n\n            //we export MetaSheet info only if not the whole project is exported!!!\n            _export.metaSheets = core.getParent(libraryRoot) ? getMetaSheetInfo(_core.getRoot(libraryRoot)) : {};\n\n            callback(null, _export);\n\n        });\n    }\n\n    function getMetaSheetInfo(root) {\n        var getMemberRegistry = function (setname, memberpath) {\n                var names = _core.getMemberRegistryNames(root, setname, memberpath),\n                    i,\n                    registry = {};\n                for (i = 0; i < names.length; i++) {\n                    registry[names[i]] = _core.getMemberRegistry(root, setname, memberpath, names[i]);\n                }\n                return registry;\n            },\n            getMemberAttributes = function (setname, memberpath) {\n                var names = _core.getMemberAttributeNames(root, setname, memberpath),\n                    i,\n                    attributes = {};\n                for (i = 0; i < names.length; i++) {\n                    attributes[names[i]] = _core.getMemberAttribute(root, setname, memberpath, names[i]);\n                }\n                return attributes;\n            },\n            getRegistryEntry = function (setname) {\n                var index = registry.length;\n\n                while (--index >= 0) {\n                    if (registry[index].SetID === setname) {\n                        return registry[index];\n                    }\n                }\n                return {};\n            },\n            sheets = {},\n            registry = _core.getRegistry(root, 'MetaSheets'),\n            keys = _core.getSetNames(root),\n            elements, guid,\n            i,\n            j;\n\n        for (i = 0; i < keys.length; i++) {\n            if (keys[i].indexOf('MetaAspectSet') === 0) {\n                elements = _core.getMemberPaths(root, keys[i]);\n                for (j = 0; j < elements.length; j++) {\n                    guid = _pathToGuidMap[elements[j]] || _extraBasePaths[elements[j]];\n                    if (guid) {\n                        sheets[keys[i]] = sheets[keys[i]] || {};\n                        sheets[keys[i]][guid] = {\n                            registry: getMemberRegistry(keys[i], elements[j]),\n                            attributes: getMemberAttributes(keys[i], elements[j])\n                        };\n                    }\n                }\n\n                if (sheets[keys[i]] && keys[i] !== 'MetaAspectSet') {\n                    //we add the global registry values as well\n                    sheets[keys[i]].global = getRegistryEntry(keys[i]);\n                }\n            }\n        }\n        return sheets;\n    }\n\n    function importMetaSheetInfo(root) {\n        var setMemberAttributesAndRegistry = function (setname, memberguid) {\n                var attributes = oldSheets[setname][memberguid].attributes || {},\n                    registry = oldSheets[setname][memberguid].registry || {},\n                    keys = Object.keys(attributes),\n                    i;\n\n                for (i = 0; i < keys.length; i++) {\n                    _core.setMemberAttribute(root, setname, _core.getPath(_nodes[memberguid]), keys[i],\n                        attributes[keys[i]]);\n                }\n                keys = Object.keys(registry);\n                for (i = 0; i < keys.length; i++) {\n                    _core.setMemberRegistry(root, setname, _core.getPath(_nodes[memberguid]), keys[i],\n                        registry[keys[i]]);\n                }\n            },\n            updateSheet = function (name) {\n                //the removed object should be already removed...\n                //if some element is extra in the place of import, then it stays untouched\n                var oldMemberGuids = Object.keys(oldSheets[name]),\n                    i;\n                oldMemberGuids.splice(oldMemberGuids.indexOf('global'), 1);\n                for (i = 0; i < oldMemberGuids.length; i++) {\n                    _core.addMember(root, name, _nodes[oldMemberGuids[i]]);\n                    setMemberAttributesAndRegistry(name, oldMemberGuids[i]);\n                }\n            },\n            addSheet = function (name) {\n                var registry = JSON.parse(JSON.stringify(_core.getRegistry(root, 'MetaSheets')) || {}),\n                    i,\n                    memberpath,\n                    memberguids = Object.keys(oldSheets[name]);\n\n                memberguids.splice(memberguids.indexOf('global'), 1);\n\n                if (name !== 'MetaAspectSet') {\n                    registry.push(oldSheets[name].global);\n                    _core.setRegistry(root, 'MetaSheets', registry);\n                }\n\n                _core.createSet(root, name);\n                for (i = 0; i < memberguids.length; i++) {\n                    memberpath = _core.getPath(_nodes[memberguids[i]]);\n                    _core.addMember(root, name, _nodes[memberguids[i]]);\n                    setMemberAttributesAndRegistry(name, memberguids[i]);\n                }\n            },\n            oldSheets = _import.metaSheets || {},\n            newSheets = _export.metaSheets || {},\n            oldSheetNames = Object.keys(oldSheets),\n            newSheetNames = Object.keys(newSheets),\n            i;\n\n        for (i = 0; i < oldSheetNames.length; i++) {\n            if (newSheetNames.indexOf(oldSheetNames[i]) !== -1) {\n                updateSheet(oldSheetNames[i]);\n            } else {\n                addSheet(oldSheetNames[i]);\n            }\n        }\n    }\n\n    function getLibraryRootInfo(node) {\n        return {\n            path: _core.getPath(node),\n            guid: _core.getGuid(node)\n        };\n    }\n\n    function gatherNodesSlowly(node, callback) {\n        _core.loadSubTree(node, function (err, nodes) {\n            var guid, i;\n            if (!err && nodes) {\n                for (i = 0; i < nodes.length; i++) {\n                    guid = _core.getGuid(nodes[i]);\n                    _nodes[guid] = nodes[i];\n                    _guidKeys.push(guid);\n                    _pathToGuidMap[_core.getPath(nodes[i])] = guid;\n                }\n                callback(null);\n            } else {\n                callback(err);\n            }\n        });\n    }\n\n    function gatherAncestors() {\n        //this function inserts the needed base classes which were not included in the library\n        var i, base, guid;\n        for (i = 0; i < _guidKeys.length; i++) {\n            base = _nodes[_guidKeys[i]];\n            while (base !== null) {\n                guid = _core.getGuid(base);\n                if (!_nodes[guid]) {\n                    _nodes[guid] = base;\n                    _extraBasePaths[_core.getPath(base)] = guid;\n                } else if (_guidKeys.indexOf(guid) === -1) {\n                    _extraBasePaths[_core.getPath(base)] = guid;\n                }\n                base = _core.getBase(base);\n            }\n        }\n    }\n\n    function pathsToSortedGuidList(pathsList) { //it will also filter out not wanted elements\n        var i, guids = [];\n        for (i = 0; i < pathsList.length; i++) {\n            if (_pathToGuidMap[pathsList[i]]) {\n                guids.push(_pathToGuidMap[pathsList[i]]);\n            }\n        }\n        return guids.sort();\n    }\n\n    function fillContainmentTree(node, myTreeObject) {\n        var childrenGuids = pathsToSortedGuidList(_core.getChildrenPaths(node)),\n            i;\n        for (i = 0; i < childrenGuids.length; i++) {\n            myTreeObject[childrenGuids[i]] = {};\n            fillContainmentTree(_nodes[childrenGuids[i]], myTreeObject[childrenGuids[i]]);\n        }\n    }\n\n    function getRelIdInfo() {\n        var i,\n            relIdInfo = {};\n        for (i = 0; i < _guidKeys.length; i++) {\n            relIdInfo[_guidKeys[i]] = _core.getRelid(_nodes[_guidKeys[i]]);\n        }\n        return relIdInfo;\n    }\n\n    function getNodesData() {\n        var data = {},\n            i;\n        for (i = 0; i < _guidKeys.length; i++) {\n            data[_guidKeys[i]] = getNodeData(_nodes[_guidKeys[i]]);\n        }\n        return data;\n    }\n\n    function getNodeData(node) {\n        /*{\n         //only the ones defined on this level\n         attributes:{name:value},\n         base:GUID,\n         registry:{name:value},\n         parent:GUID,\n         pointers:{name:targetGuid},\n         sets:{name:[{guid:GUID,attributes:{name:value},registy:{name:value}}]}\n         meta:{}\n         }*/\n        return {\n            attributes: getAttributesOfNode(node),\n            base: _core.getBase(node) ? _core.getGuid(_core.getBase(node)) : null,\n            meta: pathsToGuids(JSON.parse(JSON.stringify(_core.getOwnJsonMeta(node)) || {})),\n            parent: _core.getParent(node) ? _core.getGuid(_core.getParent(node)) : null,\n            pointers: getPointersOfNode(node),\n            registry: getRegistryOfNode(node),\n            sets: getSetsOfNode(node),\n            constraints: getConstraintsOfNode(node)\n        };\n    }\n\n    function baseGuid(path) {\n        /*var keys = Object.keys(_extraBasePaths),\n         i;\n         for(i=0;i<keys.length;i++){\n         if(_extraBasePaths[keys[i]] === path){\n         return keys[i];\n         }\n         }\n         return null;*/\n        return _extraBasePaths[path];\n    }\n\n    var sortMultipleArrays = function () {\n        var index = getSortedIndex(arguments[0]);\n        for (var j = 0; j < arguments.length; j++) {\n            var _arr = arguments[j].slice();\n            for (var i = 0; i < _arr.length; i++) {\n                arguments[j][i] = _arr[index[i]];\n            }\n        }\n    };\n\n    var getSortedIndex = function (arr) {\n        var index = [];\n        for (var i = 0; i < arr.length; i++) {\n            index.push(i);\n        }\n        index = index.sort((function (arr) {\n            return function (a, b) {\n                return ((arr[a] > arr[b]) ? 1 : ((arr[a] < arr[b]) ? -1 : 0));\n            };\n        })(arr));\n        return index;\n    };\n\n    function pathsToGuids(jsonObject) {\n        if (jsonObject && typeof jsonObject === 'object') {\n            var keys = Object.keys(jsonObject),\n                i, j, k, toDelete, tArray;\n\n            for (i = 0; i < keys.length; i++) {\n                if (keys[i] === 'items') {\n                    //here comes the transformation itself\n                    toDelete = [];\n                    for (j = 0; j < jsonObject.items.length; j++) {\n                        if (_pathToGuidMap[jsonObject.items[j]]) {\n                            jsonObject.items[j] = _pathToGuidMap[jsonObject.items[j]];\n                        } else if (baseGuid(jsonObject.items[j])) {\n                            jsonObject.items[j] = baseGuid(jsonObject.items[j]);\n                        } else {\n                            toDelete.push(j);\n                        }\n                    }\n\n                    if (toDelete.length > 0) {\n                        toDelete = toDelete.sort();\n                        toDelete = toDelete.reverse();\n                        for (j = 0; j < toDelete.length; j++) {\n                            jsonObject.items.splice(toDelete[j], 1);\n                            jsonObject.minItems.splice(toDelete[j], 1);\n                            jsonObject.maxItems.splice(toDelete[j], 1);\n                        }\n                    }\n                    sortMultipleArrays(jsonObject.items, jsonObject.minItems, jsonObject.maxItems);\n                } else if (keys[i] === 'aspects') {\n                    //aspects are a bunch of named path list, so we have to handle them separately\n                    tArray = Object.keys(jsonObject[keys[i]]);\n                    for (j = 0; j < tArray.length; j++) {\n                        //here comes the transformation itself\n                        toDelete = [];\n                        for (k = 0; k < jsonObject.aspects[tArray[j]].length; k++) {\n                            if (_pathToGuidMap[jsonObject.aspects[tArray[j]][k]]) {\n                                jsonObject.aspects[tArray[j]][k] = _pathToGuidMap[jsonObject.aspects[tArray[j]][k]];\n                            } else if (baseGuid(jsonObject.aspects[tArray[j]][k])) {\n                                jsonObject.aspects[tArray[j]][k] = baseGuid(jsonObject.aspects[tArray[j]][k]);\n                            } else {\n                                toDelete.push(k);\n                            }\n                        }\n\n                        if (toDelete.length > 0) {\n                            toDelete = toDelete.sort();\n                            toDelete = toDelete.reverse();\n                            for (k = 0; k < toDelete.length; k++) {\n                                jsonObject.aspects[tArray[j]].splice(toDelete[k], 1);\n                            }\n                        }\n\n                        jsonObject.aspects[tArray[j]] = jsonObject.aspects[tArray[j]].sort();\n\n                    }\n                } else {\n                    if (typeof jsonObject[keys[i]] === 'object') {\n                        jsonObject[keys[i]] = pathsToGuids(jsonObject[keys[i]]);\n                    }\n                }\n            }\n\n        }\n        return jsonObject;\n    }\n\n    function getAttributesOfNode(node) {\n        var names = _core.getOwnAttributeNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getAttribute(node, names[i]);\n        }\n        return result;\n    }\n\n    function getRegistryOfNode(node) {\n        var names = _core.getOwnRegistryNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getRegistry(node, names[i]);\n        }\n        return result;\n    }\n\n    function getConstraintsOfNode(node) {\n        var names = _core.getOwnConstraintNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getConstraint(node, names[i]);\n        }\n        return result;\n    }\n\n    function getPointersOfNode(node) {\n        var names = _core.getOwnPointerNames(node).sort(),\n            i,\n            result = {},\n            target;\n        for (i = 0; i < names.length; i++) {\n            target = _core.getPointerPath(node, names[i]);\n            if (_pathToGuidMap[target] || baseGuid(target) || target === null) {\n                result[names[i]] = _pathToGuidMap[target] || baseGuid(target) || null;\n            }\n        }\n        return result;\n    }\n\n    function getOwnMemberPaths(node, setName) {\n        var base = _core.getBase(node),\n            baseMembers = base === null ? [] : _core.getMemberPaths(base, setName),\n            members = _core.getMemberPaths(node, setName),\n            ownMembers = [],\n            i;\n        for (i = 0; i < members.length; i++) {\n            if (baseMembers.indexOf(members[i]) === -1) {\n                ownMembers.push(members[i]);\n            }\n        }\n        return ownMembers;\n    }\n\n    function getSetsOfNode(node) {\n        var names = _core.getSetNames(node).sort(),\n            i, j, k,\n            result = {},\n            targetGuids,\n            attributeNames,\n            registryNames,\n            memberInfo,\n            path;\n        for (i = 0; i < names.length; i++) {\n            targetGuids = pathsToSortedGuidList(getOwnMemberPaths(node, names[i]));\n            result[names[i]] = [];\n            for (j = 0; j < targetGuids.length; j++) {\n                path = _core.getPath(_nodes[targetGuids[j]]);\n                memberInfo = {\n                    attributes: {},\n                    guid: targetGuids[j],\n                    registry: {}\n                };\n\n                //attributes\n                attributeNames = _core.getMemberAttributeNames(node, names[i], path).sort();\n                for (k = 0; k < attributeNames.length; k++) {\n                    memberInfo.attributes[attributeNames[k]] =\n                        _core.getMemberAttribute(node, names[i], path, attributeNames[k]);\n                }\n\n                //registry\n                registryNames = _core.getMemberRegistryNames(node, names[i], path).sort();\n                for (k = 0; k < registryNames.length; k++) {\n                    memberInfo.registry[registryNames[k]] =\n                        _core.getMemberRegistry(node, names[i], path, registryNames[k]);\n                }\n\n                result[names[i]].push(memberInfo);\n            }\n        }\n        return result;\n    }\n\n    function logId(nodes, id) {\n        var txtId = id + '';\n        if (nodes[id] && nodes[id].attributes && nodes[id].attributes.name) {\n            txtId = nodes[id].attributes.name + '(' + id + ')';\n        }\n\n        return txtId;\n    }\n\n    function loadImportBases(guids, root, callback) {\n        var needed = [],\n            error = null,\n            stillToGo = 0,\n            i,\n            guidList = Object.keys(guids),\n            baseLoaded = function (err) {\n                error = error || err;\n                if (--stillToGo === 0) {\n                    callback(error);\n                }\n            },\n            loadBase = function (guid, path) {\n                _core.loadByPath(root, path, function (err, node) {\n                    if (err) {\n                        return baseLoaded(err);\n                    }\n                    if (_core.getGuid(node) !== guid) {\n                        return baseLoaded('GUID mismatch');\n                    }\n\n                    _nodes[guid] = node;\n                    baseLoaded(null);\n                });\n            };\n\n        for (i = 0; i < guidList.length; i++) {\n            if (_nodes[guidList[i]] === undefined) {\n                needed.push(guidList[i]);\n            }\n        }\n\n        if (needed.length > 0) {\n            stillToGo = needed.length;\n            for (i = 0; i < needed.length; i++) {\n                loadBase(needed[i], guids[needed[i]]);\n            }\n        } else {\n            return callback(null);\n        }\n\n    }\n\n    function importLibrary(core, originLibraryRoot, updatedLibraryJson, callback) {\n        _core = core;\n        _import = updatedLibraryJson;\n        _newNodeGuids = [];\n        _updatedNodeGuids = [];\n        _removedNodeGuids = [];\n        _log = '';\n\n        synchronizeRoots(originLibraryRoot, _import.root.guid);\n        exportLibrary(core, originLibraryRoot, function (err) {\n            //we do not need the returned json object as that is stored in our global _export variable\n            if (err) {\n                return callback(err);\n            }\n\n            //now we will search for the bases of the import and load them\n            loadImportBases(_import.bases, _core.getRoot(originLibraryRoot), function (err) {\n                if (err) {\n                    return callback(err);\n                }\n\n                //now we fill the insert/update/remove lists of GUIDs\n                var oldkeys = Object.keys(_export.nodes),\n                    newkeys = Object.keys(_import.nodes),\n                    i;\n\n                //TODO now we make three rounds although one would be sufficient on ordered lists\n                for (i = 0; i < oldkeys.length; i++) {\n                    if (newkeys.indexOf(oldkeys[i]) === -1) {\n                        log('node ' + logId(_export.nodes, oldkeys[i]) +\n                            ', all of its sub-types and its children will be removed');\n\n                        _removedNodeGuids.push(oldkeys[i]);\n                    }\n                }\n\n                for (i = 0; i < oldkeys.length; i++) {\n                    if (newkeys.indexOf(oldkeys[i]) !== -1) {\n                        log('node ' + logId(_export.nodes, oldkeys[i]) + ' will be updated');\n                        _updatedNodeGuids.push(oldkeys[i]);\n                    }\n                }\n\n                for (i = 0; i < newkeys.length; i++) {\n                    if (oldkeys.indexOf(newkeys[i]) === -1) {\n                        log('node ' + logId(_import.nodes, newkeys[i]) + ' will be added');\n                        _newNodeGuids.push(newkeys[i]);\n                    }\n                }\n\n                //Now we normalize the removedGUIDs by containment and remove them\n                var toDelete = [],\n                    parent;\n                for (i = 0; i < _removedNodeGuids.length; i++) {\n                    parent = _core.getParent(_nodes[_removedNodeGuids[i]]);\n                    if (parent && _removedNodeGuids.indexOf(_core.getGuid(parent)) === -1) {\n                        toDelete.push(_removedNodeGuids[i]);\n                    }\n                }\n                //and as a final step we remove all that is needed\n                for (i = 0; i < toDelete.length; i++) {\n                    _core.deleteNode(_nodes[toDelete[i]]);\n                }\n\n                //as a second step we should deal with the updated nodes\n                //we should go among containment hierarchy\n                updateNodes(_import.root.guid, null, _import.containment);\n\n                //now update inheritance chain\n                //we assume that our inheritance chain comes from the FCO and that it is identical everywhere\n                updateInheritance();\n\n                //now we can add or modify the relations of the nodes - we go along the hierarchy chain\n                updateRelations();\n\n                //finally we need to update the meta rules of each node - again along the containment hierarchy\n                updateMetaRules(_import.root.guid, _import.containment);\n\n                //after everything is done we try to synchronize the metaSheet info\n                importMetaSheetInfo(_core.getRoot(originLibraryRoot));\n\n                callback(null, _log);\n            });\n        });\n    }\n\n    function synchronizeRoots(oldRoot, newGuid) {\n        _core.setGuid(oldRoot, newGuid);\n    }\n\n    //it will update the modified nodes and create the new ones regarding their place in the hierarchy chain\n    function updateNodes(guid, parent, containmentTreeObject) {\n        if (_updatedNodeGuids.indexOf(guid) !== -1) {\n            updateNode(guid, parent);\n        }\n\n        var keys = Object.keys(containmentTreeObject),\n            i,\n            node = _nodes[guid],\n            relid;\n\n        for (i = 0; i < keys.length; i++) {\n            if (_updatedNodeGuids.indexOf(keys[i]) === -1) {\n                relid = _import.relids[keys[i]];\n                if (_core.getChildrenRelids(node).indexOf(relid) !== -1) {\n                    relid = undefined;\n                }\n                //this child is a new one so we should create\n                _nodes[keys[i]] = _core.createNode({parent: node, guid: keys[i], relid: relid});\n                addNode(keys[i]);\n            }\n            updateNodes(keys[i], node, containmentTreeObject[keys[i]]);\n        }\n    }\n\n    function updateRegistry(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n\n        keys = _core.getOwnRegistryNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delRegistry(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.registry);\n        for (i = 0; i < keys.length; i++) {\n            _core.setRegistry(node, keys[i], jsonNode.registry[keys[i]]);\n        }\n    }\n\n    function updateAttributes(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n\n        keys = _core.getOwnAttributeNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delAttribute(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.attributes);\n        for (i = 0; i < keys.length; i++) {\n            _core.setAttribute(node, keys[i], jsonNode.attributes[keys[i]]);\n        }\n    }\n\n    function updateConstraints(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n        keys = _core.getOwnConstraintNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delConstraint(node, keys[i]);\n        }\n\n        keys = Object.keys(jsonNode.constraints || {});\n        for (i = 0; i < keys.length; i++) {\n            _core.setConstraint(node, keys[i], jsonNode.constraints[keys[i]]);\n        }\n    }\n\n    //this function does not cover relations - it means only attributes and registry have been updated here\n    function updateNode(guid, parent) {\n        //first we check if the node have to be moved\n        var node = _nodes[guid];\n\n        if (parent && _core.getParent(node) && _core.getGuid(parent) !== _core.getGuid(_core.getParent(node))) {\n            //parent changed so it has to be moved...\n            _nodes[guid] = _core.moveNode(node, parent);\n        }\n\n        updateAttributes(guid);\n        updateRegistry(guid);\n        updateConstraints(guid);\n    }\n\n    //this function doesn't not cover relations - so only attributes and registry have been taken care of here\n    function addNode(guid) {\n        //at this point we assume that an empty vessel has been already created and part of the _nodes\n        updateAttributes(guid);\n        updateRegistry(guid);\n        updateConstraints(guid);\n    }\n\n    function getInheritanceBasedGuidOrder() {\n        var inheritanceOrdered = Object.keys(_import.nodes).sort(),\n            i = 0,\n            baseGuid,\n            baseIndex;\n\n        while (i < inheritanceOrdered.length) {\n            baseGuid = _import.nodes[inheritanceOrdered[i]].base;\n            if (baseGuid) {\n                baseIndex = inheritanceOrdered.indexOf(baseGuid);\n                if (baseIndex > i) {\n                    inheritanceOrdered.splice(baseIndex, 1);\n                    inheritanceOrdered.splice(i, 0, baseGuid);\n                } else {\n                    ++i;\n                }\n            } else {\n                ++i;\n            }\n        }\n        return inheritanceOrdered;\n    }\n\n    function updateRelations() {\n        var guids = getInheritanceBasedGuidOrder(),\n            i;\n        for (i = 0; i < guids.length; i++) {\n            updateNodeRelations(guids[i]);\n        }\n    }\n\n    function updateNodeRelations(guid) {\n        // Although it is possible that we set the base pointer at this point\n        // we should go through inheritance just to be sure.\n        var node = _nodes[guid],\n            jsonNode = _import.nodes[guid],\n            keys, i, j, k, target, memberGuid;\n\n        //pointers\n        keys = _core.getOwnPointerNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.deletePointer(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.pointers);\n        for (i = 0; i < keys.length; i++) {\n            target = jsonNode.pointers[keys[i]];\n            if (target === null) {\n                _core.setPointer(node, keys[i], null);\n            } else if (_nodes[target] && _removedNodeGuids.indexOf(target) === -1) {\n                _core.setPointer(node, keys[i], _nodes[target]);\n            } else {\n                console.log('error handling needed???!!!???');\n            }\n        }\n\n        //sets\n        keys = _core.getSetNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.deleteSet(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.sets);\n        for (i = 0; i < keys.length; i++) {\n            //for every set we create it, go through its members...\n            _core.createSet(node, keys[i]);\n            for (j = 0; j < jsonNode.sets[keys[i]].length; j++) {\n                memberGuid = jsonNode.sets[keys[i]][j].guid;\n                if (_nodes[memberGuid]) {\n                    _core.addMember(node, keys[i], _nodes[memberGuid]);\n                    for (k in jsonNode.sets[keys[i]][j].attributes) {\n                        _core.setMemberAttribute(node, keys[i], _core.getPath(_nodes[memberGuid]), k,\n                            jsonNode.sets[keys[i]][j].attributes[k]);\n                    }\n                    for (k in jsonNode.sets[keys[i]][j].registry) {\n                        _core.setMemberRegistry(node, keys[i], _core.getPath(_nodes[memberGuid]), k,\n                            jsonNode.sets[keys[i]][j].registry[k]);\n                    }\n                }\n            }\n        }\n    }\n\n    function updateInheritance() {\n        var i,\n            guidList = Object.keys(_import.nodes),\n            base;\n        for (i = 0; i < guidList.length; i++) {\n            base = _core.getBase(_nodes[guidList[i]]);\n            if ((base && _core.getGuid(base) !== _import.nodes[guidList[i]].base) ||\n                (base === null && _import.nodes[guidList[i]].base !== null)) {\n\n                updateNodeInheritance(guidList[i]);\n            }\n        }\n    }\n\n    function updateNodeInheritance(guid) {\n        _core.setBase(_nodes[guid], _nodes[_import.nodes[guid].base]);\n    }\n\n    function updateMetaRules(guid, containmentTreeObject) {\n\n        var keys, i;\n\n        updateMeta(guid);\n\n        keys = Object.keys(containmentTreeObject);\n        for (i = 0; i < keys.length; i++) {\n            updateMetaRules(keys[i], containmentTreeObject[keys[i]]);\n        }\n    }\n\n    function updateMeta(guid) {\n        _core.clearMetaRules(_nodes[guid]);\n\n        updateAttributeMeta(guid);\n        updateChildrenMeta(guid);\n        updatePointerMeta(guid);\n        updateAspectMeta(guid);\n        updateConstraintMeta(guid);\n    }\n\n    function updateAttributeMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.attributes || {},\n            node = _nodes[guid],\n            keys, i;\n\n        keys = Object.keys(jsonMeta);\n        for (i = 0; i < keys.length; i++) {\n            _core.setAttributeMeta(node, keys[i], jsonMeta[keys[i]]);\n        }\n    }\n\n    function updateChildrenMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.children || {items: [], minItems: [], maxItems: []},\n            i;\n        ASSERT(jsonMeta.items.length === jsonMeta.minItems.length &&\n            jsonMeta.minItems.length === jsonMeta.maxItems.length);\n\n        _core.setChildrenMetaLimits(_nodes[guid], jsonMeta.min, jsonMeta.max);\n        for (i = 0; i < jsonMeta.items.length; i++) {\n            _core.setChildMeta(_nodes[guid], _nodes[jsonMeta.items[i]], jsonMeta.minItems[i], jsonMeta.maxItems[i]);\n        }\n    }\n\n    function updatePointerMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.pointers || {},\n            keys = Object.keys(jsonMeta),\n            i, j;\n\n        for (i = 0; i < keys.length; i++) {\n            ASSERT(jsonMeta[keys[i]].items.length === jsonMeta[keys[i]].minItems.length &&\n                jsonMeta[keys[i]].maxItems.length === jsonMeta[keys[i]].minItems.length);\n\n            for (j = 0; j < jsonMeta[keys[i]].items.length; j++) {\n                _core.setPointerMetaTarget(_nodes[guid], keys[i], _nodes[jsonMeta[keys[i]].items[j]],\n                    jsonMeta[keys[i]].minItems[j], jsonMeta[keys[i]].maxItems[j]);\n            }\n            _core.setPointerMetaLimits(_nodes[guid], keys[i], jsonMeta[keys[i]].min, jsonMeta[keys[i]].max);\n        }\n    }\n\n    function updateAspectMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.aspects || {},\n            keys = Object.keys(jsonMeta),\n            i, j;\n\n        for (i = 0; i < keys.length; i++) {\n            for (j = 0; j < jsonMeta[keys[i]].length; j++) {\n                _core.setAspectMetaTarget(_nodes[guid], keys[i], _nodes[jsonMeta[keys[i]][j]]);\n            }\n        }\n    }\n\n    function updateConstraintMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.constraints || {},\n            keys = Object.keys(jsonMeta),\n            i;\n\n        for (i = 0; i < keys.length; i++) {\n            _core.setConstraint(_nodes[guid], keys[i], jsonMeta[keys[i]]);\n        }\n    }\n\n    return {\n        export: exportLibrary,\n        import: importLibrary\n    };\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/BlobConfig',[], function () {\n    'use strict';\n    var BlobConfig = {\n        hashMethod: 'sha1', // TODO: in the future we may switch to sha512\n        hashRegex: new RegExp('^[0-9a-f]{40}$')\n    };\n\n    return BlobConfig;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/BlobMetadata',['blob/BlobConfig'], function (BlobConfig) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of BlobMetadata\n     * @param {object} metadata - A serialized metadata object.\n     * @param {string} metadata.name\n     * @param {string|Object} metadata.content\n     * @param {number} [metadata.size=0]\n     * @param {BlobMetadata.CONTENT_TYPES} [metadata.contentType=BlobMetadata.CONTENT_TYPES.OBJECT]\n     * @param {string} [metadata.mime='']\n     * @param {boolean} [metadata.isPublic=false]\n     * @param {string[]} [metadata.tags=[]]\n     * @constructor\n     */\n    var BlobMetadata = function (metadata) {\n        var key;\n        if (metadata) {\n            this.name = metadata.name;\n            this.size = metadata.size || 0;\n            this.mime = metadata.mime || '';\n            this.isPublic = metadata.isPublic || false;\n            this.tags = metadata.tags || [];\n            this.content = metadata.content;\n            this.contentType = metadata.contentType || BlobMetadata.CONTENT_TYPES.OBJECT;\n            if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n                for (key in this.content) {\n                    if (this.content.hasOwnProperty(key)) {\n                        if (BlobConfig.hashRegex.test(this.content[key].content) === false) {\n                            throw new Error('BlobMetadata is malformed: hash \\'' + this.content[key].content + '\\'is invalid');\n                        }\n                    }\n                }\n            }\n        } else {\n            throw new Error('metadata parameter is not defined');\n        }\n    };\n\n    /**\n     * Type of the metadata\n     * @type {{OBJECT: string, COMPLEX: string, SOFT_LINK: string}}\n     */\n    BlobMetadata.CONTENT_TYPES = {\n        OBJECT: 'object',\n        COMPLEX: 'complex',\n        SOFT_LINK: 'softLink'\n    };\n\n    /**\n     * Serializes the metadata to a JSON object.\n     * @returns {{\n     *  name: string,\n     *  size: number,\n     *  mime: string,\n     *  tags: Array.<string>,\n     *  content: (string|Object),\n     *  contentType: string}}\n     */\n    BlobMetadata.prototype.serialize = function () {\n        var metadata = {\n            name: this.name,\n            size: this.size,\n            mime: this.mime,\n            isPublic: this.isPublic,\n            tags: this.tags,\n            content: this.content,\n            contentType: this.contentType\n        };\n\n        metadata.tags.sort();\n\n        if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n            // override on  purpose to normalize content\n            metadata.content = {};\n            var fnames = Object.keys(this.content);\n            fnames.sort();\n\n            for (var j = 0; j < fnames.length; j += 1) {\n                metadata.content[fnames[j]] = this.content[fnames[j]];\n            }\n        }\n\n        return metadata;\n    };\n\n    return BlobMetadata;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/*\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/Artifact',['blob/BlobMetadata', 'blob/BlobConfig', 'common/core/tasync'], function (BlobMetadata, BlobConfig, tasync) {\n    'use strict';\n    /**\n     * Creates a new instance of artifact, i.e. complex object, in memory. This object can be saved in the storage.\n     * @param {string} name Artifact's name without extension\n     * @param {blob.BlobClient} blobClient\n     * @param {blob.BlobMetadata} descriptor\n     * @constructor\n     */\n    var Artifact = function (name, blobClient, descriptor) {\n        this.name = name;\n        this.blobClient = blobClient;\n        this.blobClientPutFile = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.putFile), 5));\n        this.blobClientGetMetadata = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.getMetadata), 5));\n        // TODO: use BlobMetadata class here\n        this.descriptor = descriptor || {\n            name: name + '.zip',\n            size: 0,\n            mime: 'application/zip',\n            content: {},\n            contentType: 'complex'\n        }; // name and hash pairs\n    };\n\n    /**\n     * Adds content to the artifact as a file.\n     * @param {string} name filename\n     * @param {Blob} content File object or Blob\n     * @param callback\n     */\n    Artifact.prototype.addFile = function (name, content, callback) {\n        var self = this;\n        var filename = name.substring(name.lastIndexOf('/') + 1);\n\n        self.blobClientPutFile.call(self.blobClient, filename, content, function (err, hash) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            self.addObjectHash(name, hash, function (err, hash) {\n                callback(err, hash);\n            });\n        });\n    };\n\n    Artifact.prototype.addFileAsSoftLink = function (name, content, callback) {\n        var self = this;\n        var filename = name.substring(name.lastIndexOf('/') + 1);\n\n        self.blobClientPutFile.call(self.blobClient, filename, content,\n            function (err, hash) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                var size;\n                if (content.size !== undefined) {\n                    size = content.size;\n                }\n                if (content.length !== undefined) {\n                    size = content.length;\n                }\n\n                self.addMetadataHash(name, hash, size, function (err, hash) {\n                    callback(err, hash);\n                });\n            });\n    };\n\n    /**\n     * Adds a hash to the artifact using the given file path.\n     * @param {string} name Path to the file in the artifact. Note: 'a/b/c.txt'\n     * @param {string} hash Metadata hash that has to be added.\n     * @param callback\n     */\n    Artifact.prototype.addObjectHash = function (name, hash, callback) {\n        var self = this;\n\n        if (BlobConfig.hashRegex.test(hash) === false) {\n            callback('Blob hash is invalid');\n            return;\n        }\n\n        self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            if (self.descriptor.content.hasOwnProperty(name)) {\n                callback('Another content with the same name was already added. ' +\n                JSON.stringify(self.descriptor.content[name]));\n\n            } else {\n                self.descriptor.size += metadata.size;\n\n                self.descriptor.content[name] = {\n                    content: metadata.content,\n                    contentType: BlobMetadata.CONTENT_TYPES.OBJECT\n                };\n                callback(null, hash);\n            }\n        });\n    };\n\n    Artifact.prototype.addMetadataHash = function (name, hash, size, callback) {\n        var self = this,\n            addMetadata = function (size) {\n                if (self.descriptor.content.hasOwnProperty(name)) {\n                    callback('Another content with the same name was already added. ' +\n                    JSON.stringify(self.descriptor.content[name]));\n\n                } else {\n                    self.descriptor.size += size;\n\n                    self.descriptor.content[name] = {\n                        content: hash,\n                        contentType: BlobMetadata.CONTENT_TYPES.SOFT_LINK\n                    };\n                    callback(null, hash);\n                }\n            };\n\n        if (typeof size === 'function') {\n            callback = size;\n            size = undefined;\n        }\n\n        if (BlobConfig.hashRegex.test(hash) === false) {\n            callback('Blob hash is invalid');\n            return;\n        }\n        if (size === undefined) {\n            self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                addMetadata(metadata.size);\n            });\n        } else {\n            addMetadata(size);\n        }\n    };\n\n    /**\n     * Adds multiple files.\n     * @param {Object.<string, Blob>} files files to add\n     * @param callback\n     */\n    Artifact.prototype.addFiles = function (files, callback) {\n        var self = this,\n            fileNames = Object.keys(files),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding files: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addFile(fileNames[i], files[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds multiple files as soft-links.\n     * @param {Object.<string, Blob>} files files to add\n     * @param callback\n     */\n    Artifact.prototype.addFilesAsSoftLinks = function (files, callback) {\n        var self = this,\n            fileNames = Object.keys(files),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding files as soft-links: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addFileAsSoftLink(fileNames[i], files[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds hashes to the artifact using the given file paths.\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\n     * @param callback\n     */\n    Artifact.prototype.addObjectHashes = function (objectHashes, callback) {\n        var self = this,\n            fileNames = Object.keys(objectHashes),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding objectHashes: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addObjectHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds hashes to the artifact using the given file paths.\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\n     * @param callback\n     */\n    Artifact.prototype.addMetadataHashes = function (objectHashes, callback) {\n        var self = this,\n            fileNames = Object.keys(objectHashes),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding objectHashes: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addMetadataHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Saves this artifact and uploads the metadata to the server's storage.\n     * @param callback\n     */\n    Artifact.prototype.save = function (callback) {\n        this.blobClient.putMetadata(this.descriptor, callback);\n    };\n\n    return Artifact;\n});\n\n",
    "!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define('lib/superagent/superagent',[],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.superagent=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root = 'undefined' == typeof window\n  ? (this || self)\n  : window;\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"})\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n  err.crossDomain = true;\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var contentType = this.getHeader('Content-Type');\n    var serialize = request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n  xhr.send(data);\n  return this;\n};\n\n/**\n * Faux promise support\n *\n * @param {Function} fulfill\n * @param {Function} reject\n * @return {Request}\n */\n\nRequest.prototype.then = function (fulfill, reject) {\n  return this.end(function(err, res) {\n    err ? reject(err) : fulfill(res);\n  });\n}\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.del = function(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n},{\"emitter\":2,\"reduce\":3}],2:[function(require,module,exports){\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n},{}],3:[function(require,module,exports){\n\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n},{}]},{},[1])(1)\n});\n",
    "/*globals define, escape*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n * @author ksmyth / https://github.com/ksmyth\n */\n\ndefine('blob/BlobClient',['blob/Artifact', 'blob/BlobMetadata', 'superagent'], function (Artifact, BlobMetadata, superagent) {\n    'use strict';\n\n    var BlobClient = function (parameters) {\n        this.artifacts = [];\n\n        if (parameters) {\n            this.server = parameters.server || this.server;\n            this.serverPort = parameters.serverPort || this.serverPort;\n            this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\n            this.webgmeclientsession = parameters.webgmeclientsession;\n            this.keepaliveAgentOptions = parameters.keepaliveAgentOptions || { /* use defaults */ };\n        } else {\n            this.keepaliveAgentOptions = { /* use defaults */ };\n        }\n        this.blobUrl = '';\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\n            this.blobUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\n        }\n\n        // TODO: TOKEN???\n        this.blobUrl = this.blobUrl + '/rest/blob/'; // TODO: any ways to ask for this or get it from the configuration?\n\n        this.isNodeOrNodeWebKit = typeof process !== 'undefined';\n        if (this.isNodeOrNodeWebKit) {\n            // node or node-webkit\n            if (this.httpsecure) {\n                this.Agent = require('agentkeepalive').HttpsAgent;\n            } else {\n                this.Agent = require('agentkeepalive');\n            }\n            if (this.keepaliveAgentOptions.hasOwnProperty('ca') === false) {\n                this.keepaliveAgentOptions.ca = require('https').globalAgent.options.ca;\n            }\n            this.keepaliveAgent = new this.Agent(this.keepaliveAgentOptions);\n        }\n    };\n\n    BlobClient.prototype.getMetadataURL = function (hash) {\n        var metadataBase = this.blobUrl + 'metadata';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n    BlobClient.prototype._getURL = function (base, hash, subpath) {\n        var subpathURL = '';\n        if (subpath) {\n            subpathURL = subpath;\n        }\n        return this.blobUrl + base + '/' + hash + '/' + encodeURIComponent(subpathURL);\n    };\n\n    BlobClient.prototype.getViewURL = function (hash, subpath) {\n        return this._getURL('view', hash, subpath);\n    };\n\n    BlobClient.prototype.getDownloadURL = function (hash, subpath) {\n        return this._getURL('download', hash, subpath);\n    };\n\n    BlobClient.prototype.getCreateURL = function (filename, isMetadata) {\n        if (isMetadata) {\n            return this.blobUrl + 'createMetadata/';\n        } else {\n            return this.blobUrl + 'createFile/' + encodeURIComponent(filename);\n        }\n    };\n\n    BlobClient.prototype.putFile = function (name, data, callback) {\n        var contentLength,\n            req;\n\n        function toArrayBuffer(buffer) {\n            var ab = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(ab);\n            for (var i = 0; i < buffer.length; ++i) {\n                view[i] = buffer[i];\n            }\n            return ab;\n        }\n\n        // On node-webkit, we use XMLHttpRequest, but xhr.send thinks a Buffer is a string and encodes it in utf-8 -\n        // send an ArrayBuffer instead.\n        if (typeof window !== 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\n            data = toArrayBuffer(data); // FIXME will this have performance problems\n        }\n        // on node, empty Buffers will cause a crash in superagent\n        if (typeof window === 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\n            if (data.length === 0) {\n                data = '';\n            }\n        }\n        contentLength = data.hasOwnProperty('length') ? data.length : data.byteLength;\n        req = superagent.post(this.getCreateURL(name));\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n        if (typeof data !== 'string' && !(data instanceof String)) {\n            req.set('Content-Length', contentLength);\n        }\n        req.set('Content-Type', 'application/octet-stream')\n            .send(data)\n            .end(function (err, res) {\n                if (err || res.status > 399) {\n                    callback(err || res.status);\n                    return;\n                }\n                var response = res.body;\n                // Get the first one\n                var hash = Object.keys(response)[0];\n                callback(null, hash);\n            });\n    };\n\n    BlobClient.prototype.putMetadata = function (metadataDescriptor, callback) {\n        var metadata = new BlobMetadata(metadataDescriptor),\n            blob,\n            contentLength,\n            req;\n        // FIXME: in production mode do not indent the json file.\n        if (typeof Blob !== 'undefined') {\n            blob = new Blob([JSON.stringify(metadata.serialize(), null, 4)], {type: 'text/plain'});\n            contentLength = blob.size;\n        } else {\n            blob = new Buffer(JSON.stringify(metadata.serialize(), null, 4), 'utf8');\n            contentLength = blob.length;\n        }\n\n        req = superagent.post(this.getCreateURL(metadataDescriptor.name, true));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        req.set('Content-Type', 'application/octet-stream')\n            .set('Content-Length', contentLength)\n            .send(blob)\n            .end(function (err, res) {\n                if (err || res.status > 399) {\n                    callback(err || res.status);\n                    return;\n                }\n                // Uploaded.\n                var response = JSON.parse(res.text);\n                // Get the first one\n                var hash = Object.keys(response)[0];\n                callback(null, hash);\n            });\n    };\n\n    BlobClient.prototype.putFiles = function (o, callback) {\n        var self = this,\n            error = '',\n            filenames = Object.keys(o),\n            remaining = filenames.length,\n            hashes = {},\n            putFile;\n        if (remaining === 0) {\n            callback(null, hashes);\n        }\n        putFile = function (filename, data) {\n            self.putFile(filename, data, function (err, hash) {\n                remaining -= 1;\n\n                hashes[filename] = hash;\n\n                if (err) {\n                    error += 'putFile error: ' + err.toString();\n                }\n\n                if (remaining === 0) {\n                    callback(error, hashes);\n                }\n            });\n        };\n\n        for (var j = 0; j < filenames.length; j += 1) {\n            putFile(filenames[j], o[filenames[j]]);\n        }\n    };\n\n    BlobClient.prototype.getSubObject = function (hash, subpath, callback) {\n        return this.getObject(hash, callback, subpath);\n    };\n\n    BlobClient.prototype.getObject = function (hash, callback, subpath) {\n        superagent.parse['application/zip'] = function (obj, parseCallback) {\n            if (parseCallback) {\n                // Running on node; this should be unreachable due to req.pipe() below\n            } else {\n                return obj;\n            }\n        };\n        //superagent.parse['application/json'] = superagent.parse['application/zip'];\n\n        var req = superagent.get(this.getViewURL(hash, subpath));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        if (req.pipe) {\n            // running on node\n            var Writable = require('stream').Writable;\n            var BuffersWritable = function (options) {\n                Writable.call(this, options);\n\n                var self = this;\n                self.buffers = [];\n            };\n            require('util').inherits(BuffersWritable, Writable);\n\n            BuffersWritable.prototype._write = function (chunk, encoding, callback) {\n                this.buffers.push(chunk);\n                callback();\n            };\n\n            var buffers = new BuffersWritable();\n            buffers.on('finish', function () {\n                if (req.req.res.statusCode > 399) {\n                    return callback(req.req.res.statusCode);\n                }\n                callback(null, Buffer.concat(buffers.buffers));\n            });\n            buffers.on('error', function (err) {\n                callback(err);\n            });\n            req.pipe(buffers);\n        } else {\n            req.removeAllListeners('end');\n            req.on('request', function () {\n                if (typeof this.xhr !== 'undefined') {\n                    this.xhr.responseType = 'arraybuffer';\n                }\n            });\n            // req.on('error', callback);\n            req.on('end', function () {\n                if (req.xhr.status > 399) {\n                    callback(req.xhr.status);\n                } else {\n                    var contentType = req.xhr.getResponseHeader('content-type');\n                    var response = req.xhr.response; // response is an arraybuffer\n                    if (contentType === 'application/json') {\n                        var utf8ArrayToString = function (uintArray) {\n                            var inputString = '',\n                                i;\n                            for (i = 0; i < uintArray.byteLength; i++) {\n                                inputString += String.fromCharCode(uintArray[i]);\n                            }\n                            return decodeURIComponent(escape(inputString));\n                        };\n                        response = JSON.parse(utf8ArrayToString(new Uint8Array(response)));\n                    }\n                    callback(null, response);\n                }\n            });\n            req.end(callback);\n        }\n    };\n\n    BlobClient.prototype.getMetadata = function (hash, callback) {\n        var req = superagent.get(this.getMetadataURL(hash));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        req.end(function (err, res) {\n            if (err || res.status > 399) {\n                callback(err || res.status);\n            } else {\n                callback(null, JSON.parse(res.text));\n            }\n        });\n    };\n\n    BlobClient.prototype.createArtifact = function (name) {\n        var artifact = new Artifact(name, this);\n        this.artifacts.push(artifact);\n        return artifact;\n    };\n\n    BlobClient.prototype.getArtifact = function (metadataHash, callback) {\n        // TODO: get info check if complex flag is set to true.\n        // TODO: get info get name.\n        var self = this;\n        this.getMetadata(metadataHash, function (err, info) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            if (info.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n                var artifact = new Artifact(info.name, self, info);\n                self.artifacts.push(artifact);\n                callback(null, artifact);\n            } else {\n                callback('not supported contentType ' + JSON.stringify(info, null, 4));\n            }\n\n        });\n    };\n\n    BlobClient.prototype.saveAllArtifacts = function (callback) {\n        var remaining = this.artifacts.length,\n            hashes = [],\n            error = '',\n            saveCallback;\n\n        if (remaining === 0) {\n            callback(null, hashes);\n        }\n\n        saveCallback = function (err, hash) {\n            remaining -= 1;\n\n            hashes.push(hash);\n\n            if (err) {\n                error += 'artifact.save err: ' + err.toString();\n            }\n            if (remaining === 0) {\n                callback(error, hashes);\n            }\n        };\n\n        for (var i = 0; i < this.artifacts.length; i += 1) {\n\n            this.artifacts[i].save(saveCallback);\n        }\n    };\n\n    return BlobClient;\n});\n\n",
    "/*globals define, console*/\r\n/*jshint browser: true*/\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n * @author pmeijer / https://github.com/pmeijer\r\n */\r\ndefine('client/js/client',[\r\n    'js/logger',\r\n    'common/storage/browserstorage',\r\n    'common/EventDispatcher',\r\n    'common/core/core',\r\n    'js/client/constants',\r\n    'common/core/users/meta',\r\n    'common/util/assert',\r\n    'common/core/tasync',\r\n    'common/util/guid',\r\n    'common/util/url',\r\n    'js/client/gmeNodeGetter',\r\n    'js/client/gmeNodeSetter',\r\n    'common/core/users/serialization',\r\n    'blob/BlobClient'\r\n], function (Logger,\r\n             Storage,\r\n             EventDispatcher,\r\n             Core,\r\n             CONSTANTS,\r\n             META,\r\n             ASSERT,\r\n             TASYNC,\r\n             GUID,\r\n             URL,\r\n             getNode,\r\n             getNodeSetters,\r\n             Serialization,\r\n             BlobClient) {\r\n    'use strict';\r\n\r\n    function Client(gmeConfig) {\r\n        var self = this,\r\n            logger = Logger.create('gme:client', gmeConfig.client.log),\r\n            storage = Storage.getStorage(logger, gmeConfig, true),\r\n            state = {\r\n                connection: null, // CONSTANTS.STORAGE. CONNECTED/DISCONNECTED/RECONNECTED\r\n                project: null,\r\n                core: null,\r\n                branchName: null,\r\n                branchStatus: null, //CONSTANTS.BRANCH_STATUS. SYNC/AHEAD_SYNC/AHEAD_FORKED/PULLING or null\r\n                readOnlyProject: false,\r\n                viewer: false, // This means that a specific commit is selected w/o regards to any branch.\r\n\r\n                users: {},\r\n                nodes: {},\r\n                loadNodes: {},\r\n                // FIXME: This should be the same as nodes (need to make sure they are not modified in meta).\r\n                metaNodes: {},\r\n\r\n                rootHash: null,\r\n                rootObject: null,\r\n                commitHash: null,\r\n\r\n                undoRedoChain: null, //{commitHash: '#hash', rootHash: '#hash', previous: object, next: object}\r\n\r\n                inTransaction: false,\r\n                msg: '',\r\n                gHash: 0,\r\n                loadError: null,\r\n                ongoingTerritoryUpdateCounter: 0,\r\n                ongoingLoadPatternsCounter: 0,\r\n                pendingTerritoryUpdatePatterns: {},\r\n                loadingStatus: null,\r\n                inLoading: false,\r\n                loading: {\r\n                    rootHash: null,\r\n                    commitHash: null,\r\n                    next: null\r\n                }\r\n\r\n            },\r\n            blobClient,\r\n            monkeyPatchKey,\r\n            nodeSetterFunctions,\r\n        //addOnFunctions = new AddOn(state, storage, logger, gmeConfig),\r\n            loadPatternThrottled = TASYNC.throttle(loadPattern, 1); //magic number could be fine-tuned\r\n        //loadPatternThrottled = loadPattern; //magic number could be fine-tuned\r\n\r\n        blobClient = new BlobClient();\r\n        EventDispatcher.call(this);\r\n\r\n        this.CONSTANTS = CONSTANTS;\r\n\r\n        function logState(level, msg) {\r\n            var lightState;\r\n\r\n            function replacer(key, value) {\r\n                var chainItem,\r\n                    prevChain,\r\n                    nextChain,\r\n                    chain;\r\n                if (key === 'project') {\r\n                    if (value) {\r\n                        return value.name;\r\n                    } else {\r\n                        return null;\r\n                    }\r\n\r\n                } else if (key === 'core') {\r\n                    if (value) {\r\n                        return 'instantiated';\r\n                    } else {\r\n                        return 'notInstantiated';\r\n                    }\r\n                } else if (key === 'metaNodes') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'nodes') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'loadNodes') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'users') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'rootObject') {\r\n                    return;\r\n                } else if (key === 'undoRedoChain') {\r\n                    if (value) {\r\n                        chain = {\r\n                            previous: null,\r\n                            next: null\r\n                        };\r\n                        if (value.previous) {\r\n                            prevChain = {};\r\n                            chain.previous = prevChain;\r\n                        }\r\n                        chainItem = value;\r\n                        while (chainItem.previous) {\r\n                            prevChain.previous = {\r\n                                commitHash: chainItem.commitHash,\r\n                                previous: null\r\n                            };\r\n                            prevChain = prevChain.previous;\r\n                            chainItem = chainItem.previous;\r\n                        }\r\n                        if (value.next) {\r\n                            nextChain = {};\r\n                            chain.next = nextChain;\r\n                        }\r\n                        chainItem = value;\r\n                        while (chainItem.next) {\r\n                            nextChain.next = {\r\n                                commitHash: chainItem.commitHash,\r\n                                next: null\r\n                            };\r\n                            nextChain = nextChain.next;\r\n                            chainItem = chainItem.next;\r\n                        }\r\n                        return chain;\r\n                    }\r\n                }\r\n\r\n                return value;\r\n            }\r\n\r\n            if (gmeConfig.debug) {\r\n                logger[level]('state at ' + msg, JSON.stringify(state, replacer, 2));\r\n            } else {\r\n                lightState = {\r\n                    connection: self.getNetworkStatus(),\r\n                    projectId: self.getActiveProjectId(),\r\n                    branchName: self.getActiveBranchName(),\r\n                    branchStatus: self.getBranchStatus(),\r\n                    commitHash: self.getActiveCommitHash(),\r\n                    rootHash: self.getActiveRootHash(),\r\n                    projectReadOnly: self.isProjectReadOnly(),\r\n                    commitReadOnly: self.isCommitReadOnly()\r\n                };\r\n                if (level === 'console') {\r\n                    console.log('state at ' + msg, JSON.stringify(lightState));\r\n                } else {\r\n                    logger[level]('state at ' + msg, JSON.stringify(lightState));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Forwarded functions\r\n        function saveRoot(msg, callback) {\r\n            var persisted,\r\n                numberOfPersistedObjects,\r\n                wrappedCallback,\r\n                newCommitObject;\r\n            logger.debug('saveRoot msg', msg);\r\n            if (callback) {\r\n                wrappedCallback = function (err, result) {\r\n                    if (err) {\r\n                        logger.error('saveRoot failure', err);\r\n                    } else {\r\n                        logger.debug('saveRoot', result);\r\n                    }\r\n                    callback(err, result);\r\n                };\r\n            } else {\r\n                wrappedCallback = function (err, result) {\r\n                    if (err) {\r\n                        logger.error('saveRoot failure', err);\r\n                    } else {\r\n                        logger.debug('saveRoot', result);\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (!state.viewer && !state.readOnlyProject) {\r\n                if (state.msg) {\r\n                    state.msg += '\\n' + msg;\r\n                } else {\r\n                    state.msg += msg;\r\n                }\r\n                if (!state.inTransaction) {\r\n                    ASSERT(state.project && state.core && state.branchName);\r\n\r\n                    logger.debug('is NOT in transaction - will persist.');\r\n                    persisted = state.core.persist(state.nodes[ROOT_PATH].node);\r\n                    logger.debug('persisted', persisted);\r\n                    numberOfPersistedObjects = Object.keys(persisted.objects).length;\r\n                    if (numberOfPersistedObjects === 0) {\r\n                        logger.warn('No changes after persist will return from saveRoot.');\r\n                        wrappedCallback(null);\r\n                        return;\r\n                    } else if (numberOfPersistedObjects > 200) {\r\n                        //This is just for debugging\r\n                        logger.warn('Lots of persisted objects', numberOfPersistedObjects);\r\n                    }\r\n\r\n                    // Make the commit on the storage (will emit hashUpdated)\r\n                    newCommitObject = storage.makeCommit(\r\n                        state.project.projectId,\r\n                        state.branchName,\r\n                        [state.commitHash],\r\n                        persisted.rootHash,\r\n                        persisted.objects,\r\n                        state.msg,\r\n                        wrappedCallback\r\n                    );\r\n\r\n                    state.msg = '';\r\n                } else {\r\n                    logger.debug('is in transaction - will NOT persist.');\r\n                }\r\n            } else {\r\n                //TODO: Why is this set to empty here?\r\n                state.msg = '';\r\n                wrappedCallback(null);\r\n            }\r\n        }\r\n\r\n        function storeNode(node /*, basic */) {\r\n            var path;\r\n            //basic = basic || true;\r\n            if (node) {\r\n                path = state.core.getPath(node);\r\n                state.metaNodes[path] = node;\r\n                if (state.nodes[path]) {\r\n                    //TODO we try to avoid this\r\n                } else {\r\n                    state.nodes[path] = {node: node, hash: ''/*,incomplete:true,basic:basic*/};\r\n                    //TODO this only needed when real eventing will be reintroduced\r\n                    //_inheritanceHash[path] = getInheritanceChain(node);\r\n                }\r\n                return path;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Monkey patching from other files..\r\n        this.meta = new META();\r\n\r\n        for (monkeyPatchKey in this.meta) {\r\n            //TODO: These should be accessed via this.meta.\r\n            //TODO: e.g. client.meta.getMetaAspectNames(id) instead of client.getMetaAspectNames(id)\r\n            //TODO: However that will break a lot since it's used all over the place...\r\n            if (this.meta.hasOwnProperty(monkeyPatchKey)) {\r\n                self[monkeyPatchKey] = this.meta[monkeyPatchKey];\r\n            }\r\n        }\r\n\r\n        function checkMetaNameCollision(core, rootNode) {\r\n            var names = [],\r\n                nodes = core.getAllMetaNodes(rootNode),\r\n                i,\r\n                keys = Object.keys(nodes || {}),\r\n                name;\r\n            for (i = 0; i < keys.length; i += 1) {\r\n                name = core.getAttribute(nodes[keys[i]], 'name');\r\n                if (names.indexOf(name) === -1) {\r\n                    names.push(name);\r\n                } else {\r\n                    self.dispatchEvent(CONSTANTS.NOTIFICATION, {\r\n                        type: 'META',\r\n                        severity: 'error',\r\n                        message: 'Duplicate name on META level: \\'' + name + '\\'',\r\n                        hint: 'Rename one of the objects'\r\n                    });\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n\r\n        nodeSetterFunctions = getNodeSetters(logger, state, saveRoot, storeNode);\r\n\r\n        for (monkeyPatchKey in nodeSetterFunctions) {\r\n            if (nodeSetterFunctions.hasOwnProperty(monkeyPatchKey)) {\r\n                self[monkeyPatchKey] = nodeSetterFunctions[monkeyPatchKey];\r\n            }\r\n        }\r\n\r\n        // Main API functions (with helpers) for connecting, selecting project and branches etc.\r\n        this.connectToDatabase = function (callback) {\r\n            if (isConnected()) {\r\n                logger.warn('connectToDatabase - already connected');\r\n                callback(null);\r\n                return;\r\n            }\r\n            storage.open(function (connectionState) {\r\n                state.connection = connectionState;\r\n                if (connectionState === CONSTANTS.STORAGE.CONNECTED) {\r\n                    //N.B. this event will only be triggered once.\r\n                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);\r\n                    storage.webSocket.addEventListener(CONSTANTS.STORAGE.BRANCH_ROOM_SOCKETS,\r\n                        function (emitter, eventData) {\r\n                            var notification = {\r\n                                severity: 'INFO',\r\n                                message: ''\r\n                            };\r\n                            if (state.project && state.project.projectId === eventData.projectId &&\r\n                                state.branchName === eventData.branchName) {\r\n                                if (eventData.currNbrOfSockets > eventData.prevNbrOfSockets) {\r\n                                    notification.message = 'Another socket joined your branch [' +\r\n                                        eventData.currNbrOfSockets + ']';\r\n                                } else {\r\n                                    notification.message = 'A socket disconnected from your branch [' +\r\n                                        eventData.currNbrOfSockets + ']';\r\n                                }\r\n                                self.dispatchEvent(CONSTANTS.NOTIFICATION, notification);\r\n                            }\r\n                        }\r\n                    );\r\n                    reLaunchUsers();\r\n                    callback(null);\r\n                } else if (connectionState === CONSTANTS.STORAGE.DISCONNECTED) {\r\n                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);\r\n                } else if (connectionState === CONSTANTS.STORAGE.RECONNECTED) {\r\n                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);\r\n                } else { //CONSTANTS.ERROR\r\n                    callback(Error('Connection failed!' + connectionState));\r\n                }\r\n            });\r\n        };\r\n\r\n        this.disconnectFromDatabase = function (callback) {\r\n\r\n            function closeStorage(err) {\r\n                storage.close(function (err2) {\r\n                    state.connection = CONSTANTS.STORAGE.DISCONNECTED;\r\n                    callback(err || err2);\r\n                });\r\n            }\r\n\r\n            if (isConnected()) {\r\n                if (state.project) {\r\n                    closeProject(state.project.projectId, closeStorage);\r\n                } else {\r\n                    closeStorage(null);\r\n                }\r\n            } else {\r\n                logger.warn('Trying to disconnect when already disconnected.');\r\n                callback(null);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * If branchName is given and it does not exist, the project will be closed and callback resolved with an error.\r\n         * If branchName NOT given it will attempt the following in order and break if successful at any step:\r\n         *  1) Select the master if available.\r\n         *  2) Select any available branch.\r\n         *  3) Select the latest commit.\r\n         *  4) Close the project and resolve with error.\r\n         * @param {string} projectId\r\n         * @param {string} [branchName='master']\r\n         * @param {function} callback\r\n         */\r\n        this.selectProject = function (projectId, branchName, callback) {\r\n            if (callback === undefined && typeof branchName === 'function') {\r\n                callback = branchName;\r\n                branchName = undefined;\r\n            }\r\n            if (isConnected() === false) {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n            var prevProjectId,\r\n                branchToOpen = branchName || 'master';\r\n\r\n            logger.debug('selectProject', projectId, branchToOpen);\r\n\r\n            function projectOpened(err, project, branches, access) {\r\n                if (err) {\r\n                    callback(new Error(err));\r\n                    return;\r\n                }\r\n                state.project = project;\r\n                state.readOnlyProject = access.write === false;\r\n                state.core = new Core(project, {\r\n                    globConf: gmeConfig,\r\n                    logger: logger.fork('core')\r\n                });\r\n                self.meta.initialize(state.core, state.metaNodes, saveRoot);\r\n                logState('info', 'projectOpened');\r\n                logger.debug('projectOpened, branches: ', branches);\r\n                self.dispatchEvent(CONSTANTS.PROJECT_OPENED, projectId);\r\n\r\n                if (branches.hasOwnProperty(branchToOpen) === false) {\r\n                    if (branchName) {\r\n                        logger.error('Given branch does not exist \"' + branchName + '\"');\r\n                        closeProject(projectId, function (err) {\r\n                            if (err) {\r\n                                logger.error('closeProject after missing branch failed with err', err);\r\n                            }\r\n                            callback(new Error('Given branch does not exist \"' + branchName + '\"'));\r\n                        });\r\n                        return;\r\n                    }\r\n                    logger.warn('Project \"' + projectId + '\" did not have branch', branchToOpen);\r\n                    branchToOpen = Object.keys(branches)[0] || null;\r\n                    logger.debug('Picked \"' + branchToOpen + '\".');\r\n                }\r\n\r\n                if (branchToOpen) {\r\n                    self.selectBranch(branchToOpen, null, function (err) {\r\n                        if (err) {\r\n                            callback(err);\r\n                            return;\r\n                        }\r\n                        logState('info', 'selectBranch');\r\n                        reLaunchUsers();\r\n                        callback(null);\r\n                    });\r\n                } else {\r\n                    logger.warn('No branches available in project, will attempt to select latest commit.');\r\n                    self.getCommits(projectId, (new Date()).getTime(), 1, function (err, commitObjects) {\r\n                        if (err || commitObjects.length === 0) {\r\n                            logger.error(err);\r\n                            closeProject(projectId, function (err) {\r\n                                if (err) {\r\n                                    logger.error('closeProject after missing any commits failed with err', err);\r\n                                }\r\n                                callback(new Error('Project does not have any commits.'));\r\n                            });\r\n                            return;\r\n                        }\r\n                        self.selectCommit(commitObjects[0]._id, function (err) {\r\n                            if (err) {\r\n                                logger.error(err);\r\n                                closeProject(projectId, function (err) {\r\n                                    if (err) {\r\n                                        logger.error('closeProject after missing any commits failed with err', err);\r\n                                    }\r\n                                    callback(new Error('Failed selecting commit when opening project.'));\r\n                                });\r\n                                return;\r\n                            }\r\n                            reLaunchUsers();\r\n                            callback(null);\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n\r\n            if (state.project) {\r\n                prevProjectId = state.project.projectId;\r\n                logger.debug('A project was open, closing it', prevProjectId);\r\n\r\n                if (prevProjectId === projectId) {\r\n                    logger.warn('projectId is already opened', projectId);\r\n                    callback(null);\r\n                    return;\r\n                }\r\n                closeProject(prevProjectId, function (err) {\r\n                    if (err) {\r\n                        logger.error('problems closing previous project', err);\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    storage.openProject(projectId, projectOpened);\r\n                });\r\n            } else {\r\n                storage.openProject(projectId, projectOpened);\r\n            }\r\n        };\r\n\r\n        function closeProject(projectId, callback) {\r\n            state.project = null;\r\n            //TODO what if for some reason we are in transaction?\r\n            storage.closeProject(projectId, function (err) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                state.core = null;\r\n                state.branchName = null;\r\n                //self.dispatchEvent(null);\r\n                state.patterns = {};\r\n                //state.gHash = 0;\r\n                state.nodes = {};\r\n                state.metaNodes = {};\r\n                state.loadNodes = {};\r\n                state.loadError = 0;\r\n                state.rootHash = null;\r\n                //state.rootObject = null;\r\n                state.inTransaction = false;\r\n                state.msg = '';\r\n\r\n                cleanUsersTerritories();\r\n                self.dispatchEvent(CONSTANTS.PROJECT_CLOSED, projectId);\r\n\r\n                callback(null);\r\n            });\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {string} branchName - name of branch to open.\r\n         * @param {function} [branchStatusHandler=getDefaultCommitHandler()] - Handles returned statuses after commits.\r\n         * @param callback\r\n         */\r\n        this.selectBranch = function (branchName, branchStatusHandler, callback) {\r\n            var prevBranchName = state.branchName;\r\n            logger.debug('selectBranch', branchName);\r\n            if (isConnected() === false) {\r\n                callback(new Error('There is no open database connection!'));\r\n                return;\r\n            }\r\n            if (!state.project) {\r\n                callback(new Error('selectBranch invoked without an opened project'));\r\n                return;\r\n            }\r\n\r\n            if (branchStatusHandler) {\r\n                logger.warn('passing branchStatusHandler is deprecated, use addHashUpdateHandler or' +\r\n                    ' addBranchStatusHandler on the branch object instead (getProjectObject().branches[branchName]).');\r\n            }\r\n\r\n            function openBranch(err) {\r\n                if (err) {\r\n                    logger.error('Problems closing existing branch', err);\r\n                    callback(err);\r\n                    return;\r\n                }\r\n\r\n                state.branchName = branchName;\r\n                logger.debug('openBranch, calling storage openBranch', state.project.projectId, branchName);\r\n                storage.openBranch(state.project.projectId, branchName,\r\n                    getHashUpdateHandler(), getBranchStatusHandler(),\r\n                    function (err /*, latestCommit*/) {\r\n                        if (err) {\r\n                            logger.error('storage.openBranch returned with error', err);\r\n                            self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);\r\n                            callback(err);\r\n                            return;\r\n                        }\r\n\r\n                        state.viewer = false;\r\n                        state.branchName = branchName;\r\n                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, branchName);\r\n                        logState('info', 'openBranch');\r\n                        callback(null);\r\n                    }\r\n                );\r\n            }\r\n\r\n            if (prevBranchName !== null) {\r\n                logger.debug('Branch was open, closing it first', prevBranchName);\r\n                storage.closeBranch(state.project.projectId, prevBranchName, openBranch);\r\n            } else {\r\n                openBranch(null);\r\n            }\r\n        };\r\n\r\n        this.selectCommit = function (commitHash, callback) {\r\n            logger.debug('selectCommit', commitHash);\r\n            if (isConnected() === false) {\r\n                callback(new Error('There is no open database connection!'));\r\n                return;\r\n            }\r\n            if (!state.project) {\r\n                callback(new Error('selectCommit invoked without open project'));\r\n                return;\r\n            }\r\n            var prevBranchName;\r\n\r\n            function openCommit(err) {\r\n                if (err) {\r\n                    logger.error('Problems closing existing branch', err);\r\n                    callback(err);\r\n                    return;\r\n                }\r\n\r\n                state.viewer = true;\r\n\r\n                state.project.loadObject(commitHash, function (err, commitObj) {\r\n                    if (!err && commitObj) {\r\n                        logState('info', 'selectCommit loaded commit');\r\n                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);\r\n                        loading(commitObj.root, commitHash, function (err, aborted) {\r\n                            if (err) {\r\n                                logger.error('loading returned error', commitObj.root, err);\r\n                                logState('error', 'selectCommit loading');\r\n                                callback(err);\r\n                            } else if (aborted === true) {\r\n                                logState('warn', 'selectCommit loading');\r\n                                callback(new Error('Loading selected commit was aborted'));\r\n                            } else {\r\n                                logger.debug('loading complete for selectCommit rootHash', commitObj.root);\r\n                                logState('info', 'selectCommit loading');\r\n                                self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);\r\n                                callback(null);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        logger.error('Cannot view given ' + commitHash + ' commit as it\\'s root cannot be loaded! [' +\r\n                            JSON.stringify(err) + ']');\r\n                        callback(err || new Error('commit object cannot be found!'));\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (state.branchName !== null) {\r\n                logger.debug('Branch was open, closing it first', state.branchName);\r\n                prevBranchName = state.branchName;\r\n                state.branchName = null;\r\n                storage.closeBranch(state.project.projectId, prevBranchName, openCommit);\r\n            } else {\r\n                openCommit(null);\r\n            }\r\n        };\r\n\r\n        function getBranchStatusHandler() {\r\n            return function (branchStatus, commitQueue, updateQueue) {\r\n                logger.debug('branchStatus changed', branchStatus, commitQueue, updateQueue);\r\n                logState('debug', 'branchStatus');\r\n                state.branchStatus = branchStatus;\r\n                self.dispatchEvent(CONSTANTS.BRANCH_STATUS_CHANGED, {\r\n                        status: branchStatus,\r\n                        commitQueue: commitQueue,\r\n                        updateQueue: updateQueue\r\n                    }\r\n                );\r\n            };\r\n        }\r\n\r\n        function getHashUpdateHandler() {\r\n            return function (data, commitQueue, updateQueue, callback) {\r\n                var commitData = data.commitData,\r\n                    clearUndoRedo = data.local !== true,\r\n                    commitHash = commitData.commitObject[CONSTANTS.STORAGE.MONGO_ID];\r\n                logger.debug('hashUpdateHandler invoked. project, branch, commitHash',\r\n                    commitData.projectId, commitData.branchName, commitHash);\r\n\r\n                if (state.inTransaction) {\r\n                    logger.warn('Is in transaction, will not load in changes');\r\n                    callback(null, false); // proceed: false\r\n                    return;\r\n                }\r\n\r\n                //undo-redo\r\n                addModification(commitData.commitObject, clearUndoRedo);\r\n                self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());\r\n                self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());\r\n\r\n                logger.debug('loading commitHash, local?', commitHash, data.local);\r\n                loading(commitData.commitObject.root, commitHash, function (err, aborted) {\r\n                    if (err) {\r\n                        logger.error('hashUpdateHandler invoked loading and it returned error',\r\n                            commitData.commitObject.root, err);\r\n                        logState('error', 'hashUpdateHandler');\r\n                        callback(err, false); // proceed: false\r\n                    } else if (aborted === true) {\r\n                        logState('warn', 'hashUpdateHandler');\r\n                        callback(null, false); // proceed: false\r\n                    } else {\r\n                        logger.debug('loading complete for incoming rootHash', commitData.commitObject.root);\r\n                        logState('debug', 'hashUpdateHandler');\r\n                        callback(null, true); // proceed: true\r\n                    }\r\n                });\r\n            };\r\n        }\r\n\r\n        this.forkCurrentBranch = function (newName, commitHash, callback) {\r\n            var self = this,\r\n                activeBranchName = self.getActiveBranchName(),\r\n                activeProjectId = self.getActiveProjectId(),\r\n                forkName;\r\n\r\n            logger.debug('forkCurrentBranch', newName, commitHash);\r\n            if (!state.project) {\r\n                callback('Cannot fork without an open project!');\r\n                return;\r\n            }\r\n            if (activeBranchName === null) {\r\n                callback('Cannot fork without an open branch!');\r\n                return;\r\n            }\r\n            forkName = newName || activeBranchName + '_' + (new Date()).getTime();\r\n            storage.forkBranch(activeProjectId, activeBranchName, forkName, commitHash,\r\n                function (err, forkHash) {\r\n                    if (err) {\r\n                        logger.error('Could not fork branch:', newName, err);\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    callback(null, forkName, forkHash);\r\n                }\r\n            );\r\n        };\r\n\r\n        // State getters.\r\n        this.getNetworkStatus = function () {\r\n            return state.connection;\r\n        };\r\n\r\n        this.getBranchStatus = function () {\r\n            return state.branchStatus;\r\n        };\r\n\r\n        this.getActiveProjectId = function () {\r\n            return state.project && state.project.projectId;\r\n        };\r\n\r\n        this.getActiveBranchName = function () {\r\n            return state.branchName;\r\n        };\r\n\r\n        this.getActiveCommitHash = function () {\r\n            return state.commitHash;\r\n        };\r\n\r\n        this.getActiveRootHash = function () {\r\n            return state.rootHash;\r\n        };\r\n\r\n        this.isProjectReadOnly = function () {\r\n            return state.readOnlyProject;\r\n        };\r\n\r\n        this.isCommitReadOnly = function () {\r\n            // This means that a specific commit is selected w/o regards to any branch.\r\n            return state.viewer;\r\n        };\r\n\r\n        this.getProjectObject = function () {\r\n            return state.project;\r\n        };\r\n\r\n        // Undo/Redo functionality\r\n        function addModification(commitObject, clear) {\r\n            var newItem,\r\n                commitHash = commitObject[CONSTANTS.STORAGE.MONGO_ID],\r\n                currItem;\r\n            if (clear) {\r\n                logger.debug('foreign modification clearing undo-redo chain');\r\n                state.undoRedoChain = {\r\n                    commitHash: commitHash,\r\n                    rootHash: commitObject.root,\r\n                    previous: null,\r\n                    next: null\r\n                };\r\n                return;\r\n            }\r\n\r\n            // Check if the modification already exist, i.e. commit is from undoing or redoing.\r\n            currItem = state.undoRedoChain;\r\n            while (currItem) {\r\n                if (currItem.commitHash === commitHash) {\r\n                    return;\r\n                }\r\n                currItem = currItem.previous;\r\n            }\r\n\r\n            currItem = state.undoRedoChain;\r\n            while (currItem) {\r\n                if (currItem.commitHash === commitHash) {\r\n                    return;\r\n                }\r\n                currItem = currItem.next;\r\n            }\r\n\r\n            newItem = {\r\n                commitHash: commitHash,\r\n                rootHash: commitObject.root,\r\n                previous: state.undoRedoChain,\r\n                next: null\r\n            };\r\n            state.undoRedoChain.next = newItem;\r\n            state.undoRedoChain = newItem;\r\n        }\r\n\r\n        function canUndo() {\r\n            var result = false;\r\n            if (state.undoRedoChain && state.undoRedoChain.previous && state.undoRedoChain.previous.commitHash) {\r\n                result = true;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function canRedo() {\r\n            var result = false;\r\n            if (state.undoRedoChain && state.undoRedoChain.next) {\r\n                result = true;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        this.undo = function (branchName, callback) {\r\n            if (canUndo() === false) {\r\n                callback(new Error('unable to make undo'));\r\n                return;\r\n            }\r\n\r\n            state.undoRedoChain = state.undoRedoChain.previous;\r\n\r\n            logState('info', 'undo [before setBranchHash]');\r\n            storage.setBranchHash(state.project.projectId, branchName, state.undoRedoChain.commitHash, state.commitHash,\r\n                function (err) {\r\n                    if (err) {\r\n                        //TODO do we need to handle this? How?\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    logState('info', 'undo [after setBranchHash]');\r\n                    callback(null);\r\n                }\r\n            );\r\n\r\n        };\r\n\r\n        this.redo = function (branchName, callback) {\r\n            if (canRedo() === false) {\r\n                callback(new Error('unable to make redo'));\r\n                return;\r\n            }\r\n\r\n            state.undoRedoChain = state.undoRedoChain.next;\r\n\r\n            logState('info', 'redo [before setBranchHash]');\r\n            storage.setBranchHash(state.project.projectId, branchName, state.undoRedoChain.commitHash, state.commitHash,\r\n                function (err) {\r\n                    if (err) {\r\n                        //TODO do we need to handle this? How?\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    logState('info', 'redo [after setBranchHash]');\r\n                    callback(null);\r\n                }\r\n            );\r\n        };\r\n\r\n        // REST-like functions and forwarded to storage TODO: add these to separate base class\r\n\r\n        //  Getters\r\n        this.getProjects = function (options, callback) {\r\n            var asObject;\r\n            if (isConnected()) {\r\n                if (options.asObject) {\r\n                    asObject = true;\r\n                    delete options.asObject;\r\n                }\r\n                storage.getProjects(options, function (err, result) {\r\n                    var i,\r\n                        resultObj = {};\r\n                    if (err) {\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    if (asObject === true) {\r\n                        for (i = 0; i < result.length; i += 1) {\r\n                            resultObj[result[i]._id] = result[i];\r\n                        }\r\n                        callback(null, resultObj);\r\n                    } else {\r\n                        callback(null, result);\r\n                    }\r\n                });\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.getProjectsAndBranches = function (asObject, callback) {\r\n            //This is kept for the tests.\r\n            self.getProjects({rights: true, branches: true, asObject: asObject}, callback);\r\n        };\r\n\r\n        this.getBranches = function (projectId, callback) {\r\n            if (isConnected()) {\r\n                storage.getBranches(projectId, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.getCommits = function (projectId, before, number, callback) {\r\n            if (isConnected()) {\r\n                storage.getCommits(projectId, before, number, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.getLatestCommitData = function (projectId, branchName, callback) {\r\n            if (isConnected()) {\r\n                storage.getLatestCommitData(projectId, branchName, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        //  Setters\r\n        this.createProject = function (projectName, parameters, callback) {\r\n            if (isConnected()) {\r\n                storage.createProject(projectName, parameters, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.deleteProject = function (projectId, callback) {\r\n            if (isConnected()) {\r\n                storage.deleteProject(projectId, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.transferProject = function (projectId, newOwnerId, callback) {\r\n            if (isConnected()) {\r\n                storage.transferProject(projectId, newOwnerId, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.createBranch = function (projectId, branchName, newHash, callback) {\r\n            if (isConnected()) {\r\n                storage.createBranch(projectId, branchName, newHash, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.deleteBranch = function (projectId, branchName, oldHash, callback) {\r\n            if (isConnected()) {\r\n                storage.deleteBranch(projectId, branchName, oldHash, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        // Watchers (used in e.g. ProjectNavigator).\r\n        /**\r\n         * Triggers eventHandler(storage, eventData) on PROJECT_CREATED and PROJECT_DELETED.\r\n         *\r\n         * eventData = {\r\n         *    etype: PROJECT_CREATED||DELETED,\r\n         *    projectId: %id of project%\r\n         * }\r\n         *\r\n         * @param {function} eventHandler\r\n         * @param {function} [callback]\r\n         */\r\n        this.watchDatabase = function (eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems watching database room');\r\n                    }\r\n                };\r\n            storage.watchDatabase(eventHandler, callback);\r\n        };\r\n\r\n        this.unwatchDatabase = function (eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems unwatching database room');\r\n                    }\r\n                };\r\n            storage.unwatchDatabase(eventHandler, callback);\r\n        };\r\n\r\n        /**\r\n         * Triggers eventHandler(storage, eventData) on BRANCH_CREATED, BRANCH_DELETED and BRANCH_HASH_UPDATED\r\n         * for the given projectId.\r\n         *\r\n         *\r\n         * eventData = {\r\n         *    etype: BRANCH_CREATED||DELETED||HASH_UPDATED,\r\n         *    projectId: %id of project%,\r\n         *    branchName: %name of branch%,\r\n         *    newHash: %new commitHash (='' when DELETED)%\r\n         *    oldHash: %previous commitHash (='' when CREATED)%\r\n         * }\r\n         *\r\n         * @param {string} projectId\r\n         * @param {function} eventHandler\r\n         * @param {function} [callback]\r\n         */\r\n        this.watchProject = function (projectId, eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems watching project room', projectId);\r\n                    }\r\n                };\r\n            storage.watchProject(projectId, eventHandler, callback);\r\n        };\r\n\r\n        this.unwatchProject = function (projectId, eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems unwatching project room', projectId);\r\n                    }\r\n                };\r\n            storage.unwatchProject(projectId, eventHandler, callback);\r\n        };\r\n\r\n        // Internal functions\r\n        function isConnected() {\r\n            return state.connection === CONSTANTS.STORAGE.CONNECTED ||\r\n                state.connection === CONSTANTS.STORAGE.RECONNECTED;\r\n        }\r\n\r\n        var ROOT_PATH = ''; //FIXME: This should come from constants..\r\n\r\n        function COPY(object) {\r\n            if (object) {\r\n                return JSON.parse(JSON.stringify(object));\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Node handling\r\n        this.getNode = function (nodePath) {\r\n            return getNode(nodePath, logger, state, self.meta, storeNode);\r\n        };\r\n\r\n        this.getAllMetaNodes = function () {\r\n            if (state && state.core && state.nodes && state.nodes[ROOT_PATH]) {\r\n                var metaNodes = state.core.getAllMetaNodes(state.nodes[ROOT_PATH].node),\r\n                    gmeNodes = [],\r\n                    keys = Object.keys(metaNodes || {}),\r\n                    i;\r\n\r\n                for (i = 0; i < keys.length; i += 1) {\r\n                    gmeNodes.push(this.getNode(storeNode(metaNodes[keys[i]]), logger, state, self.meta, storeNode));\r\n                }\r\n\r\n                return gmeNodes;\r\n            }\r\n\r\n            return [];\r\n        };\r\n\r\n        function getStringHash(node) {\r\n            //TODO there is a memory issue with the huge strings so we have to replace it with something\r\n            if (node.parent && node.parent.data && node.parent.data[node.relid]) {\r\n                return node.parent.data[node.relid]; // FIXME this is buggy when creating connections\r\n            }\r\n            state.gHash += 1;\r\n            return state.gHash;\r\n        }\r\n\r\n        function getModifiedNodes(newerNodes) {\r\n            var modifiedNodes = [],\r\n                i;\r\n\r\n            for (i in state.nodes) {\r\n                if (state.nodes.hasOwnProperty(i)) {\r\n                    if (newerNodes[i]) {\r\n                        if (newerNodes[i].hash !== state.nodes[i].hash && state.nodes[i].hash !== '') {\r\n                            modifiedNodes.push(i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return modifiedNodes;\r\n        }\r\n\r\n        //this is just a first brute implementation it needs serious optimization!!!\r\n        function fitsInPatternTypes(path, pattern) {\r\n            var i;\r\n\r\n            if (pattern.items && pattern.items.length > 0) {\r\n                for (i = 0; i < pattern.items.length; i += 1) {\r\n                    if (self.meta.isTypeOf(path, pattern.items[i])) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function patternToPaths(patternId, pattern, pathsSoFar) {\r\n            var children,\r\n                subPattern,\r\n                i;\r\n\r\n            if (state.nodes[patternId]) {\r\n                pathsSoFar[patternId] = true;\r\n                if (pattern.children && pattern.children > 0) {\r\n                    children = state.core.getChildrenPaths(state.nodes[patternId].node);\r\n                    subPattern = COPY(pattern);\r\n                    subPattern.children -= 1;\r\n                    for (i = 0; i < children.length; i += 1) {\r\n                        if (fitsInPatternTypes(children[i], pattern)) {\r\n                            patternToPaths(children[i], subPattern, pathsSoFar);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                state.loadError++;\r\n            }\r\n        }\r\n\r\n        function userEvents(userId, modifiedNodes) {\r\n            var newPaths = {},\r\n                startErrorLevel = state.loadError,\r\n                i,\r\n                events = [];\r\n\r\n            for (i in state.users[userId].PATTERNS) {\r\n                if (state.users[userId].PATTERNS.hasOwnProperty(i)) {\r\n                    if (state.nodes[i]) { //TODO we only check pattern if its root is there...\r\n                        patternToPaths(i, state.users[userId].PATTERNS[i], newPaths);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (startErrorLevel !== state.loadError) {\r\n                return; //we send events only when everything is there correctly\r\n            }\r\n\r\n            //deleted items\r\n            for (i in state.users[userId].PATHS) {\r\n                if (!newPaths[i]) {\r\n                    events.push({etype: 'unload', eid: i});\r\n                }\r\n            }\r\n\r\n            //added items\r\n            for (i in newPaths) {\r\n                if (!state.users[userId].PATHS[i]) {\r\n                    events.push({etype: 'load', eid: i});\r\n                }\r\n            }\r\n\r\n            //updated items\r\n            for (i = 0; i < modifiedNodes.length; i++) {\r\n                if (newPaths[modifiedNodes[i]]) {\r\n                    events.push({etype: 'update', eid: modifiedNodes[i]});\r\n                }\r\n            }\r\n\r\n            state.users[userId].PATHS = newPaths;\r\n\r\n            //this is how the events should go\r\n            if (events.length > 0) {\r\n                if (state.loadError > startErrorLevel) {\r\n                    events.unshift({etype: 'incomplete', eid: null});\r\n                } else {\r\n                    events.unshift({etype: 'complete', eid: null});\r\n                }\r\n            } else {\r\n                events.unshift({etype: 'complete', eid: null});\r\n            }\r\n            state.users[userId].FN(events);\r\n        }\r\n\r\n        function loadChildrenPattern(core, nodesSoFar, node, level, callback) {\r\n            var path = core.getPath(node),\r\n                childrenPaths = core.getChildrenPaths(node),\r\n                childrenRelids = core.getChildrenRelids(node),\r\n                missing = childrenPaths.length,\r\n                error = null,\r\n                i,\r\n                childLoaded = function (err, child) {\r\n                    if (err || child === null) {\r\n                        error = error || err;\r\n                        missing -= 1;\r\n                        if (missing === 0) {\r\n                            callback(error);\r\n                        }\r\n                    } else {\r\n                        loadChildrenPattern(core, nodesSoFar, child, level - 1, childrenPatternLoaded);\r\n                    }\r\n                },\r\n                childrenPatternLoaded = function (err) {\r\n                    error = error || err;\r\n                    missing -= 1;\r\n                    if (missing === 0) {\r\n                        callback(error);\r\n                    }\r\n                };\r\n\r\n            if (!nodesSoFar[path]) {\r\n                nodesSoFar[path] = {node: node, incomplete: true, basic: true, hash: getStringHash(node)};\r\n            }\r\n            if (level > 0) {\r\n                if (missing > 0) {\r\n                    for (i = 0; i < childrenPaths.length; i++) {\r\n                        if (nodesSoFar[childrenPaths[i]]) {\r\n                            loadChildrenPattern(core,\r\n                                nodesSoFar,\r\n                                nodesSoFar[childrenPaths[i]].node,\r\n                                level - 1, childrenPatternLoaded);\r\n                        } else {\r\n                            core.loadChild(node, childrenRelids[i], childLoaded);\r\n                        }\r\n                    }\r\n                } else {\r\n                    callback(error);\r\n                }\r\n            } else {\r\n                callback(error);\r\n            }\r\n        }\r\n\r\n        function loadPattern(core, id, pattern, nodesSoFar, callback) {\r\n            //console.log('LP',id,pattern);\r\n            //var _callback = callback;\r\n            //callback = function(error){\r\n            //    console.log('LPF',id,pattern);\r\n            //    _callback(error);\r\n            //};\r\n\r\n            var base = null,\r\n                baseLoaded = function () {\r\n                    if (pattern.children && pattern.children > 0) {\r\n                        var level = pattern.children;\r\n                        loadChildrenPattern(core, nodesSoFar, base, level, callback);\r\n                    } else {\r\n                        callback(null);\r\n                    }\r\n                };\r\n\r\n            if (nodesSoFar[id]) {\r\n                base = nodesSoFar[id].node;\r\n                baseLoaded();\r\n            } else {\r\n                if (!nodesSoFar[ROOT_PATH]) {\r\n                    logger.error('pattern cannot be loaded if there is no root!!!');\r\n                }\r\n                base = nodesSoFar[ROOT_PATH].node;\r\n\r\n                core.loadByPath(base, id, function (err, node) {\r\n                    var path;\r\n                    if (!err && node && !core.isEmpty(node)) {\r\n                        path = core.getPath(node);\r\n                        if (!nodesSoFar[path]) {\r\n                            nodesSoFar[path] = {\r\n                                node: node,\r\n                                incomplete: false,\r\n                                basic: true,\r\n                                hash: getStringHash(node)\r\n                            };\r\n                        }\r\n                        base = node;\r\n                        baseLoaded();\r\n                    } else {\r\n                        callback(err);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        function orderStringArrayByElementLength(strArray) {\r\n            var ordered = [],\r\n                i, j, index;\r\n\r\n            for (i = 0; i < strArray.length; i++) {\r\n                index = -1;\r\n                j = 0;\r\n                while (index === -1 && j < ordered.length) {\r\n                    if (ordered[j].length > strArray[i].length) {\r\n                        index = j;\r\n                    }\r\n                    j++;\r\n                }\r\n\r\n                if (index === -1) {\r\n                    ordered.push(strArray[i]);\r\n                } else {\r\n                    ordered.splice(index, 0, strArray[i]);\r\n                }\r\n            }\r\n            return ordered;\r\n        }\r\n\r\n        this.startTransaction = function (msg) {\r\n            if (state.inTransaction) {\r\n                logger.error('Already in transaction, will proceed though..');\r\n            }\r\n            if (state.core) {\r\n                state.inTransaction = true;\r\n                msg = msg || 'startTransaction()';\r\n                saveRoot(msg);\r\n            } else {\r\n                logger.error('Can not start transaction with no core avaliable.');\r\n            }\r\n        };\r\n\r\n        this.completeTransaction = function (msg, callback) {\r\n            state.inTransaction = false;\r\n            if (state.core) {\r\n                msg = msg || 'completeTransaction()';\r\n                saveRoot(msg, callback);\r\n            }\r\n        };\r\n\r\n        //territory functions\r\n        this.addUI = function (ui, fn, guid) {\r\n            ASSERT(fn);\r\n            ASSERT(typeof fn === 'function');\r\n            guid = guid || GUID();\r\n            state.users[guid] = {type: 'notused', UI: ui, PATTERNS: {}, PATHS: {}, SENDEVENTS: true, FN: fn};\r\n            return guid;\r\n        };\r\n\r\n        this.removeUI = function (guid) {\r\n            logger.debug('removeUI', guid);\r\n            delete state.users[guid];\r\n        };\r\n\r\n        function reLaunchUsers() {\r\n            var i;\r\n            for (i in state.users) {\r\n                if (state.users.hasOwnProperty(i)) {\r\n                    if (state.users[i].UI.reLaunch) {\r\n                        state.users[i].UI.reLaunch();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function _updateTerritoryAllDone(guid, patterns, error) {\r\n\r\n            logger.debug('updateTerritory related loads finished', {\r\n                metadata: {\r\n                    userId: guid, patterns: patterns, error: error\r\n                }\r\n            });\r\n            refreshMetaNodes(state.nodes, state.nodes);\r\n\r\n            if (state.users[guid]) {\r\n                state.users[guid].PATTERNS = COPY(patterns);\r\n                if (!error) {\r\n                    userEvents(guid, []);\r\n                }\r\n            }\r\n        }\r\n\r\n        function canSwitchStates() {\r\n            if (state.inLoading && state.ongoingTerritoryUpdateCounter === 0 &&\r\n                state.ongoingLoadPatternsCounter === 0) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function loadingPatternFinished(err) {\r\n            state.loadingStatus = state.loadingStatus || err;\r\n            state.ongoingLoadPatternsCounter -= 1;\r\n\r\n            if (canSwitchStates()) {\r\n                switchStates();\r\n            }\r\n        }\r\n\r\n        this.updateTerritory = function (guid, patterns) {\r\n            var loadRequestCounter = 0,\r\n                updateRequestId = GUID(),\r\n                error = null,\r\n                keys = Object.keys(patterns || {}),\r\n                i,\r\n                patternLoaded = function (err) {\r\n                    error = error || err;\r\n                    if (--loadRequestCounter === 0) {\r\n                        delete state.pendingTerritoryUpdatePatterns[updateRequestId];\r\n                        _updateTerritoryAllDone(guid, patterns, error);\r\n                        state.ongoingTerritoryUpdateCounter -= 1;\r\n                        if (state.ongoingTerritoryUpdateCounter < 0) {\r\n                            logger.error('patternLoaded callback have been called multiple times!!');\r\n                            state.ongoingTerritoryUpdateCounter = 0; //FIXME\r\n                        }\r\n                        if (canSwitchStates()) {\r\n                            switchStates();\r\n                        }\r\n                    }\r\n                };\r\n\r\n            logger.debug('updatingTerritory', {\r\n                metadata: {\r\n                    userId: guid,\r\n                    patterns: patterns\r\n                }\r\n            });\r\n\r\n            if (!state.nodes[ROOT_PATH]) {\r\n                if (state.users[guid]) {\r\n                    logger.debug('early updateTerritory for user[' + guid + ']. No loaded project state yet.');\r\n                    state.users[guid].PATTERNS = COPY(patterns);\r\n                }\r\n                return;\r\n            }\r\n\r\n            //empty territory check\r\n            if (keys.length === 0) {\r\n                _updateTerritoryAllDone(guid, patterns, null);\r\n                return;\r\n            }\r\n\r\n            state.ongoingTerritoryUpdateCounter += 1;\r\n\r\n            //first we have to set the internal counter as the actual load can get synchronous :(\r\n            loadRequestCounter = keys.length;\r\n\r\n\r\n            for (i = 0; i < keys.length; i += 1) {\r\n                if (state.inLoading) {\r\n                    state.ongoingLoadPatternsCounter += 1;\r\n                    loadPatternThrottled(state.core,\r\n                        keys[i], patterns[keys[i]], state.loadNodes, loadingPatternFinished);\r\n                } else {\r\n                    //we should save the patterns to a pending directory\r\n                    state.pendingTerritoryUpdatePatterns[updateRequestId] = patterns;\r\n                }\r\n                loadPatternThrottled(state.core, keys[i], patterns[keys[i]], state.nodes, patternLoaded);\r\n            }\r\n\r\n        };\r\n\r\n        function refreshMetaNodes(oldSource, newSource) {\r\n            var pathsToRemove = [],\r\n                i,\r\n                oldPaths = Object.keys(oldSource),\r\n                newPaths = Object.keys(newSource);\r\n\r\n            for (i = 0; i < oldPaths.length; i += 1) {\r\n                if (newPaths.indexOf(oldPaths[i]) === -1) {\r\n                    pathsToRemove.push(oldPaths[i]);\r\n                }\r\n            }\r\n\r\n            for (i = 0; i < newPaths.length; i += 1) {\r\n                state.metaNodes[newPaths[i]] = newSource[newPaths[i]].node;\r\n            }\r\n\r\n            for (i = 0; i < pathsToRemove.length; i += 1) {\r\n                delete state.metaNodes[pathsToRemove[i]];\r\n            }\r\n        }\r\n\r\n        function switchStates() {\r\n            //it is safe now to move the loadNodes into nodes,\r\n            // refresh the metaNodes and generate events - all in a synchronous manner!!!\r\n            var modifiedPaths,\r\n                i;\r\n\r\n            logger.debug('switching project state [C#' +\r\n                state.commitHash + ']->[C#' + state.loading.commitHash + '] : [R#' +\r\n                state.rootHash + ']->[R#' + state.loading.rootHash + ']');\r\n            refreshMetaNodes(state.nodes, state.loadNodes);\r\n\r\n            modifiedPaths = getModifiedNodes(state.loadNodes);\r\n            state.nodes = state.loadNodes;\r\n            state.loadNodes = {};\r\n\r\n            state.inLoading = false;\r\n            state.rootHash = state.loading.rootHash;\r\n            state.loading.rootHash = null;\r\n            state.commitHash = state.loading.commitHash;\r\n            state.loading.commitHash = null;\r\n\r\n            checkMetaNameCollision(state.core, state.nodes[ROOT_PATH].node);\r\n\r\n            for (i in state.users) {\r\n                if (state.users.hasOwnProperty(i)) {\r\n                    userEvents(i, modifiedPaths);\r\n                }\r\n            }\r\n\r\n            if (state.loadingStatus) {\r\n                state.loading.next(state.loadingStatus);\r\n            } else {\r\n                state.loading.next(null);\r\n            }\r\n        }\r\n\r\n        function loading(newRootHash, newCommitHash, callback) {\r\n            var i, j,\r\n                userIds,\r\n                patternPaths,\r\n                patternsToLoad = [];\r\n\r\n            if (state.ongoingLoadPatternsCounter !== 0) {\r\n                throw new Error('at the start of loading counter should bee zero!!! [' +\r\n                    state.ongoingLoadPatternsCounter + ']');\r\n            }\r\n\r\n            state.loadingStatus = null;\r\n            state.loadNodes = {};\r\n            state.loading.rootHash = newRootHash;\r\n            state.loading.commitHash = newCommitHash;\r\n            state.loading.next = callback;\r\n\r\n            state.core.loadRoot(state.loading.rootHash, function (err, root) {\r\n                if (err) {\r\n                    return state.loading.next(err);\r\n                }\r\n\r\n                state.inLoading = true;\r\n                state.loadNodes[state.core.getPath(root)] = {\r\n                    node: root,\r\n                    incomplete: true,\r\n                    basic: true,\r\n                    hash: getStringHash(root)\r\n                };\r\n\r\n\r\n                //we first only set the counter of patterns but we also generate a completely separate pattern queue\r\n                //as we cannot be sure if all the users will remain at the point of giving the actual load command!!!\r\n                userIds = Object.keys(state.users);\r\n                for (i = 0; i < userIds.length; i += 1) {\r\n                    state.ongoingLoadPatternsCounter += Object.keys(state.users[userIds[i]].PATTERNS || {}).length;\r\n                    patternPaths = Object.keys(state.users[userIds[i]].PATTERNS || {});\r\n                    for (j = 0; j < patternPaths.length; j += 1) {\r\n                        patternsToLoad.push({\r\n                            id: patternPaths[j],\r\n                            pattern: COPY(state.users[userIds[i]].PATTERNS[patternPaths[j]])\r\n                        });\r\n                    }\r\n                }\r\n                userIds = Object.keys(state.pendingTerritoryUpdatePatterns);\r\n                for (i = 0; i < userIds.length; i += 1) {\r\n                    state.ongoingLoadPatternsCounter +=\r\n                        Object.keys(state.pendingTerritoryUpdatePatterns[userIds[i]] || {}).length;\r\n                    patternPaths = Object.keys(state.pendingTerritoryUpdatePatterns[userIds[i]] || {});\r\n                    for (j = 0; j < patternPaths.length; j += 1) {\r\n                        patternsToLoad.push({\r\n                            id: patternPaths[j],\r\n                            pattern: COPY(state.pendingTerritoryUpdatePatterns[userIds[i]][patternPaths[j]])\r\n                        });\r\n                    }\r\n                }\r\n\r\n                //empty load check\r\n                if (state.ongoingLoadPatternsCounter === 0) {\r\n                    if (canSwitchStates()) {\r\n                        switchStates();\r\n                        reLaunchUsers();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                for (i = 0; i < patternsToLoad.length; i += 1) {\r\n                    loadPatternThrottled(state.core,\r\n                        patternsToLoad[i].id, patternsToLoad[i].pattern, state.loadNodes, loadingPatternFinished);\r\n                }\r\n            });\r\n        }\r\n\r\n        function cleanUsersTerritories() {\r\n            //look out as the user can remove itself at any time!!!\r\n            var userIds = Object.keys(state.users),\r\n                i,\r\n                j,\r\n                events;\r\n\r\n            for (i = 0; i < userIds.length; i++) {\r\n                if (state.users[userIds[i]]) {\r\n                    events = [{eid: null, etype: 'complete'}];\r\n                    for (j in state.users[userIds[i]].PATHS\r\n                        ) {\r\n                        events.push({etype: 'unload', eid: j});\r\n                    }\r\n                    state.users[userIds[i]].PATTERNS = {};\r\n                    state.users[userIds[i]].PATHS = {};\r\n                    state.users[userIds[i]].SENDEVENTS = true;\r\n                    state.users[userIds[i]].FN(events);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.getUserId = function () {\r\n            var cookies = URL.parseCookie(document.cookie);\r\n            if (cookies.webgme) {\r\n                return cookies.webgme;\r\n            } else {\r\n                return 'n/a';\r\n            }\r\n        };\r\n\r\n        //create from file\r\n        this.createProjectFromFile = function (projectName, branchName, jProject, ownerId, callback) {\r\n            branchName = branchName || 'master';\r\n            if (callback === undefined && typeof ownerId === 'function') {\r\n                callback = ownerId;\r\n                ownerId = undefined;\r\n            }\r\n\r\n            storage.createProject(projectName, ownerId, function (err, projectId) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                storage.openProject(projectId, function (err, project) {\r\n                    var core,\r\n                        rootNode,\r\n                        persisted;\r\n                    if (err) {\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n\r\n                    core = new Core(project, {\r\n                        globConf: gmeConfig,\r\n                        logger: logger.fork('core')\r\n                    });\r\n\r\n                    rootNode = core.createNode({parent: null, base: null});\r\n                    Serialization.import(core, rootNode, jProject, function (err) {\r\n                        if (err) {\r\n                            return callback(err);\r\n                        }\r\n\r\n                        persisted = core.persist(rootNode);\r\n\r\n                        storage.makeCommit(projectId,\r\n                            null,\r\n                            [],\r\n                            persisted.rootHash,\r\n                            persisted.objects,\r\n                            'creating project from a file',\r\n                            function (err, commitResult) {\r\n                                if (err) {\r\n                                    logger.error('cannot make initial commit for project creation from file');\r\n                                    callback(err);\r\n                                    return;\r\n                                }\r\n\r\n                                project.createBranch(branchName, commitResult.hash, function (err) {\r\n                                    if (err) {\r\n                                        logger.error('cannot set branch \\'master\\' for project creation from file');\r\n                                        callback(err);\r\n                                        return;\r\n                                    }\r\n\r\n                                    storage.closeProject(projectId, function (err) {\r\n                                        if (err) {\r\n                                            logger.error('Closing temporary project failed in project creation ' +\r\n                                                'from file', err);\r\n                                            callback(err);\r\n                                            return;\r\n                                        }\r\n                                        callback(null, projectId, branchName);\r\n                                    });\r\n                                });\r\n                            }\r\n                        );\r\n                    });\r\n                });\r\n            });\r\n        };\r\n\r\n        //meta rules checking\r\n        /**\r\n         *\r\n         * @param {string[]} nodePaths - Paths to nodes of which to check.\r\n         * @param includeChildren\r\n         * @param callback\r\n         */\r\n        this.checkMetaRules = function (nodePaths, includeChildren, callback) {\r\n            var parameters = {\r\n                command: 'checkConstraints',\r\n                checkType: 'META', //TODO this should come from a constant\r\n                includeChildren: includeChildren,\r\n                nodePaths: nodePaths,\r\n                commitHash: state.commitHash,\r\n                projectId: state.project.projectId\r\n            };\r\n\r\n            storage.simpleRequest(parameters, function (err, result) {\r\n                if (err) {\r\n                    logger.error(err);\r\n                }\r\n\r\n                self.dispatchEvent(CONSTANTS.META_RULES_RESULT, result);\r\n\r\n                if (callback) {\r\n                    callback(err, result);\r\n                }\r\n            });\r\n        };\r\n\r\n        /**\r\n         *\r\n         * @param {string[]} nodePaths - Paths to nodes of which to check.\r\n         * @param includeChildren\r\n         * @param callback\r\n         */\r\n        this.checkCustomConstraints = function (nodePaths, includeChildren, callback) {\r\n            var parameters = {\r\n                command: 'checkConstraints',\r\n                checkType: 'CUSTOM', //TODO this should come from a constant\r\n                includeChildren: includeChildren,\r\n                nodePaths: nodePaths,\r\n                commitHash: state.commitHash,\r\n                projectId: state.project.projectId\r\n            };\r\n\r\n            storage.simpleRequest(parameters, function (err, result) {\r\n                if (err) {\r\n                    logger.error(err);\r\n                }\r\n\r\n                self.dispatchEvent(CONSTANTS.CONSTRAINT_RESULT, result);\r\n\r\n                if (callback) {\r\n                    callback(err, result);\r\n                }\r\n            });\r\n        };\r\n\r\n        //seed\r\n        this.seedProject = function (parameters, callback) {\r\n            logger.debug('seeding project', parameters);\r\n            parameters.command = 'seedProject';\r\n            storage.simpleRequest(parameters, function (err, result) {\r\n                if (err) {\r\n                    logger.error(err);\r\n                }\r\n                callback(err, result);\r\n            });\r\n        };\r\n\r\n        //export branch\r\n        this.getExportProjectBranchUrl = function (projectId, branchName, fileName, callback) {\r\n            var command = {};\r\n            command.command = 'exportLibrary';\r\n            command.projectId = projectId;\r\n            command.branchName = branchName;\r\n            command.path = ROOT_PATH;\r\n            logger.debug('getExportProjectBranchUrl, command', command);\r\n            if (command.projectId && command.branchName) {\r\n                storage.simpleRequest(command, function (err, result) {\r\n                    if (err) {\r\n                        logger.error('getExportProjectBranchUrl failed with error', err);\r\n                        callback(err);\r\n                    } else {\r\n                        callback(null, blobClient.getDownloadURL(result.file.hash));\r\n                    }\r\n                });\r\n            } else {\r\n                callback(new Error('invalid parameters!'));\r\n            }\r\n        };\r\n\r\n        this.getExportItemsUrl = function (paths, filename, callback) {\r\n            callback(new Error('getExportItemsUrl is no longer supported!'));\r\n        };\r\n\r\n        //library functions\r\n        /**\r\n         * Request an export of the given library.\r\n         * A library can be any sub-tree of the project (the whole project as well).\r\n         * The export will only keep the internal relation, and it just notices the targets of any\r\n         * outgoing relation. If those outgoing relations will not present in the source, the result\r\n         * could be faulty.\r\n         * @param {string} libraryRootPath - the absolute path of the root node of the library.\r\n         * @param {string} filename - the requested output name of the library.\r\n         * @param {funciton} callback - if successful, the result is a URL where the exported format of the library\r\n         * can be found.\r\n         */\r\n        this.getExportLibraryUrl = function (libraryRootPath, filename, callback) {\r\n            var command = {};\r\n            command.command = 'exportLibrary';\r\n            command.projectId = state.project.projectId;\r\n            command.hash = state.rootHash;\r\n            command.path = libraryRootPath;\r\n            if (command.projectId && command.hash) {\r\n                storage.simpleRequest(command, function (err, result) {\r\n                    if (err) {\r\n                        logger.error('getExportLibraryUrl failed with error', err);\r\n                        callback(err);\r\n                    } else {\r\n                        callback(null, blobClient.getDownloadURL(result.file.hash));\r\n                    }\r\n                });\r\n            } else {\r\n                callback(new Error('there is no open project!'));\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Updates a library.\r\n         * 1, it removes the nodes that are not exists in the new library\r\n         * 2, adds the nodes that only exists in the new library\r\n         * 3, updates all properties and relations of the nodes in the library\r\n         * (it keeps all incoming relations, so the instance models will updates their state automatically)\r\n         * @param {string} libraryRootPath - the absolute path of the root node of the library.\r\n         * @param {object} newLibrary - JSON export format of the updated library.\r\n         * @param callback\r\n         */\r\n        this.updateLibrary = function (libraryRootPath, newLibrary, callback) {\r\n            Serialization.import(state.core, state.nodes[libraryRootPath].node, newLibrary, function (err, log) {\r\n                if (err) {\r\n                    return callback(err);\r\n                }\r\n\r\n                saveRoot('library update done\\nlogs:\\n' + log, callback);\r\n            });\r\n        };\r\n\r\n        /**\r\n         * Imports a library into the project under the given parent.\r\n         * @param {string} libraryParentPath - absolute path of the parent node of the library.\r\n         * @param {object} newLibrary - JSON export format of the library.\r\n         * @param {function} callback\r\n         */\r\n        this.addLibrary = function (libraryParentPath, newLibrary, callback) {\r\n            self.startTransaction('creating library as a child of ' + libraryParentPath);\r\n            var libraryRoot = self.createChild({\r\n                parentId: libraryParentPath,\r\n                baseId: null\r\n            }, 'library placeholder');\r\n            Serialization.import(state.core,\r\n                state.nodes[libraryRoot].node, newLibrary, function (err, log) {\r\n                    if (err) {\r\n                        return callback(err);\r\n                    }\r\n\r\n                    self.completeTransaction('library update done\\nlogs:\\n' + log, callback);\r\n                }\r\n            );\r\n        };\r\n\r\n        /**\r\n         * Run the plugin on the server inside a worker process.\r\n         * @param {string} name - name of plugin.\r\n         * @param {object} context\r\n         * @param {object} context.managerConfig - where the plugin should execute.\r\n         * @param {string} context.managerConfig.project - id of project.\r\n         * @param {string} context.managerConfig.activeNode - path to activeNode.\r\n         * @param {string} [context.managerConfig.activeSelection=[]] - paths to selected nodes.\r\n         * @param {string} context.managerConfig.commit - commit hash to start the plugin from.\r\n         * @param {string} context.managerConfig.branchName - branch which to save to.\r\n         * @param {object} [context.pluginConfig=%defaultForPlugin%] - specific configuration for the plugin.\r\n         * @param {function} callback\r\n         */\r\n        this.runServerPlugin = function (name, context, callback) {\r\n            storage.simpleRequest({command: 'executePlugin', name: name, context: context}, callback);\r\n        };\r\n\r\n        /**\r\n         * @param {string[]} pluginNames - All avaliable plugins from server.\r\n         * @param {string} [nodePath=''] - Node to get the validPlugins from.\r\n         * @returns {string[]} - Filtered plugin names.\r\n         */\r\n        this.filterPlugins = function (pluginNames, nodePath) {\r\n            var filteredNames = [],\r\n                validPlugins,\r\n                i,\r\n                node;\r\n\r\n            logger.debug('filterPluginsBasedOnNode allPlugins, given nodePath', pluginNames, nodePath);\r\n            if (!nodePath) {\r\n                logger.debug('filterPluginsBasedOnNode nodePath not given - will fall back on root-node.');\r\n                nodePath = ROOT_PATH;\r\n            }\r\n\r\n            node = state.nodes[nodePath];\r\n\r\n            if (!node) {\r\n                logger.warn('filterPluginsBasedOnNode node not loaded - will fall back on root-node.', nodePath);\r\n                nodePath = ROOT_PATH;\r\n                node = state.nodes[nodePath];\r\n            }\r\n\r\n            if (!node) {\r\n                logger.warn('filterPluginsBasedOnNode root node not loaded - will return full list.');\r\n                return pluginNames;\r\n            }\r\n\r\n            validPlugins = (state.core.getRegistry(node.node, 'validPlugins') || '').split(' ');\r\n            for (i = 0; i < validPlugins.length; i += 1) {\r\n                if (pluginNames.indexOf(validPlugins[i]) > -1) {\r\n                    filteredNames.push(validPlugins[i]);\r\n                } else {\r\n                    logger.warn('Registered plugin for node at path \"' + nodePath +\r\n                        '\" is not amongst avaliable plugins', pluginNames);\r\n                }\r\n            }\r\n\r\n            return filteredNames;\r\n        };\r\n\r\n        // Constraints\r\n        this.setConstraint = function (path, name, constraintObj) {\r\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\r\n                state.core.setConstraint(state.nodes[path].node, name, constraintObj);\r\n                saveRoot('setConstraint(' + path + ',' + name + ')');\r\n            }\r\n        };\r\n\r\n        this.delConstraint = function (path, name) {\r\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\r\n                state.core.delConstraint(state.nodes[path].node, name);\r\n                saveRoot('delConstraint(' + path + 'name' + ')');\r\n            }\r\n        };\r\n\r\n        //automerge\r\n        this.autoMerge = function (projectId, mine, theirs, callback) {\r\n            var command = {\r\n                command: 'autoMerge',\r\n                projectId: projectId,\r\n                mine: mine,\r\n                theirs: theirs\r\n            };\r\n            storage.simpleRequest(command, function (err, result) {\r\n                if (err) {\r\n                    logger.error('autoMerge failed with error', err);\r\n                    callback(err);\r\n                } else {\r\n                    callback(null, result);\r\n                }\r\n            });\r\n        };\r\n\r\n        this.resolve = function (mergeResult, callback) {\r\n            var command = {\r\n                command: 'resolve',\r\n                partial: mergeResult\r\n            };\r\n            storage.simpleRequest(command, function (err, result) {\r\n                if (err) {\r\n                    logger.error('resolve failed with error', err);\r\n                    callback(err);\r\n                } else {\r\n                    callback(null, result);\r\n                }\r\n            });\r\n        };\r\n\r\n        this.gmeConfig = gmeConfig;\r\n    }\r\n\r\n\r\n    // Inherit from the EventDispatcher\r\n    Client.prototype = Object.create(EventDispatcher.prototype);\r\n    Client.prototype.constructor = Client;\r\n\r\n    return Client;\r\n  });\r\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for creating, monitoring executor jobs.\n *\n * @author lattmann / https://github.com/lattmann\n * @author ksmyth / https://github.com/ksmyth\n */\n\n\ndefine('executor/ExecutorClient',['superagent'], function (superagent) {\n    'use strict';\n\n    var ExecutorClient = function (parameters) {\n        parameters = parameters || {};\n        this.isNodeJS = (typeof window === 'undefined') && (typeof process === 'object');\n        this.isNodeWebkit = (typeof window === 'object') && (typeof process === 'object');\n        //console.log(isNode);\n        if (this.isNodeJS) {\n            this.server = '127.0.0.1';\n            this._clientSession = null; // parameters.sessionId;;\n        }\n        this.server = parameters.server || this.server;\n        this.serverPort = parameters.serverPort || this.serverPort;\n        this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\n        if (this.isNodeJS) {\n            this.http = this.httpsecure ? require('https') : require('http');\n        }\n        this.executorUrl = '';\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\n            this.executorUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\n        }\n        // TODO: TOKEN???\n        // TODO: any ways to ask for this or get it from the configuration?\n        this.executorUrl = this.executorUrl + '/rest/executor/';\n        if (parameters.executorNonce) {\n            this.executorNonce = parameters.executorNonce;\n        }\n    };\n\n    ExecutorClient.prototype.getInfoURL = function (hash) {\n        var metadataBase = this.executorUrl + 'info';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n\n    ExecutorClient.prototype.getCreateURL = function (hash) {\n        var metadataBase = this.executorUrl + 'create';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n    ExecutorClient.prototype.createJob = function (jobInfo, callback) {\n        if (typeof jobInfo === 'string') {\n            jobInfo = { hash: jobInfo }; // old API\n        }\n        this.sendHttpRequestWithData('POST', this.getCreateURL(jobInfo.hash), jobInfo, function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.updateJob = function (jobInfo, callback) {\n        this.sendHttpRequestWithData('POST', this.executorUrl + 'update/' + jobInfo.hash, jobInfo,\n            function (err, response) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                callback(null, response);\n            }\n        );\n    };\n\n    ExecutorClient.prototype.getInfo = function (hash, callback) {\n        this.sendHttpRequest('GET', this.getInfoURL(hash), function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getAllInfo = function (callback) {\n\n        this.sendHttpRequest('GET', this.getInfoURL(), function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getInfoByStatus = function (status, callback) {\n\n        this.sendHttpRequest('GET', this.executorUrl + '?status=' + status, function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getWorkersInfo = function (callback) {\n\n        this.sendHttpRequest('GET', this.executorUrl + 'worker', function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.sendHttpRequest = function (method, url, callback) {\n        return this.sendHttpRequestWithData(method, url, null, callback);\n    };\n\n    ExecutorClient.prototype.sendHttpRequestWithData = function (method, url, data, callback) {\n        var req = new superagent.Request(method, url);\n        if (this.executorNonce) {\n            req.set('x-executor-nonce', this.executorNonce);\n        }\n        if (data) {\n            req.send(data);\n        }\n        req.end(function (err, res) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (res.status > 399) {\n                callback(res.status, res.text);\n            } else {\n                callback(null, res.text);\n            }\n        });\n    };\n\n    ExecutorClient.prototype._ensureAuthenticated = function (options, callback) {\n        //this function enables the session of the client to be authenticated\n        //TODO currently this user does not have a session, so it has to upgrade the options always!!!\n//        if (options.headers) {\n//            options.headers.webgmeclientsession = this._clientSession;\n//        } else {\n//            options.headers = {\n//                'webgmeclientsession': this._clientSession\n//            }\n//        }\n        callback(null, options);\n    };\n\n    return ExecutorClient;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginConfig',[], function () {\n    'use strict';\n    /**\n     * Initializes a new instance of plugin configuration.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param {object} config - deserializes an existing configuration to this object.\n     * @alias PluginConfig\n     * @constructor\n     */\n    var PluginConfig = function (config) {\n        if (config) {\n            var keys = Object.keys(config);\n            for (var i = 0; i < keys.length; i += 1) {\n                // TODO: check for type on deserialization\n                this[keys[i]] = config[keys[i]];\n            }\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {object}\n     */\n    PluginConfig.prototype.serialize = function () {\n        var keys = Object.keys(this);\n        var result = {};\n\n        for (var i = 0; i < keys.length; i += 1) {\n            // TODO: check for type on serialization\n            result[keys[i]] = this[keys[i]];\n        }\n\n        return result;\n    };\n\n\n    return PluginConfig;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * A module representing a PluginNodeDescription.\n *\n * @module PluginNodeDescription\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginNodeDescription',[], function () {\n    'use strict';\n    /**\n     * Initializes a new instance of plugin node description object.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     * @alias PluginNodeDescription\n     */\n    var PluginNodeDescription = function (config) {\n        if (config) {\n            this.name = config.name;\n            this.id = config.id;\n        } else {\n            this.name = '';\n            this.id = '';\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginNodeDescription.prototype.serialize = function () {\n        var keys = Object.keys(this),\n            result = {},\n            i;\n\n        for (i = 0; i < keys.length; i += 1) {\n            // TODO: check for type on serialization\n            result[keys[i]] = this[keys[i]];\n        }\n\n        return result;\n    };\n\n    return PluginNodeDescription;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * A module representing a PluginMessage.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginMessage',['plugin/PluginNodeDescription'], function (PluginNodeDescription) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of plugin message.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param {object} config - deserializes an existing configuration to this object.\n     * @constructor\n     * @alias PluginMessage\n     */\n    var PluginMessage = function (config) {\n        if (config) {\n            this.commitHash = config.commitHash;\n            if (config.activeNode instanceof PluginNodeDescription) {\n                this.activeNode = config.activeNode;\n            } else {\n                this.activeNode = new PluginNodeDescription(config.activeNode);\n            }\n\n            this.message = config.message;\n            if (config.severity) {\n                this.severity = config.severity;\n            } else {\n                this.severity = 'info';\n            }\n        } else {\n            this.commitHash = '';\n            this.activeNode = new PluginNodeDescription();\n            this.message = '';\n            this.severity = 'info';\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {object}\n     */\n    PluginMessage.prototype.serialize = function () {\n        var result = {\n            commitHash: this.commitHash,\n            activeNode: this.activeNode.serialize(),\n            message: this.message,\n            severity: this.severity\n        };\n\n        return result;\n    };\n\n    return PluginMessage;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * A module representing a PluginResult.\n *\n * @module PluginResult\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginResult',['plugin/PluginMessage'], function (PluginMessage) {\n    'use strict';\n    /**\n     * Initializes a new instance of a plugin result object.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     * @alias PluginResult\n     */\n    var PluginResult = function (config) {\n        var pluginMessage,\n            i;\n        if (config) {\n            this.success = config.success;\n            this.pluginName = config.pluginName;\n            this.startTime = config.startTime;\n            this.finishTime = config.finishTime;\n            this.messages = [];\n            this.artifacts = config.artifacts;\n            this.error = config.error;\n            this.commits = config.commits;\n\n            for (i = 0; i < config.messages.length; i += 1) {\n                if (config.messages[i] instanceof PluginMessage) {\n                    pluginMessage = config.messages[i];\n                } else {\n                    pluginMessage = new PluginMessage(config.messages[i]);\n                }\n                this.messages.push(pluginMessage);\n            }\n        } else {\n            this.success = false;\n            this.messages = []; // array of PluginMessages\n            this.artifacts = []; // array of hashes\n            this.pluginName = 'PluginName N/A';\n            this.startTime = null;\n            this.finishTime = null;\n            this.error = null;\n            this.commits = [];\n        }\n    };\n\n    /**\n     * Gets the success flag of this result object\n     *\n     * @returns {boolean}\n     */\n    PluginResult.prototype.getSuccess = function () {\n        return this.success;\n    };\n\n    /**\n     * Sets the success flag of this result.\n     *\n     * @param {boolean} value\n     */\n    PluginResult.prototype.setSuccess = function (value) {\n        this.success = value;\n    };\n\n    /**\n     * Returns with the plugin messages.\n     *\n     * @returns {PluginMessage[]}\n     */\n    PluginResult.prototype.getMessages = function () {\n        return this.messages;\n    };\n\n    /**\n     * Adds a new plugin message to the messages list.\n     *\n     * @param {PluginMessage} pluginMessage\n     */\n    PluginResult.prototype.addMessage = function (pluginMessage) {\n        this.messages.push(pluginMessage);\n    };\n\n    PluginResult.prototype.getArtifacts = function () {\n        return this.artifacts;\n    };\n\n    PluginResult.prototype.addArtifact = function (hash) {\n        this.artifacts.push(hash);\n    };\n\n    /**\n     *\n     * @param {object} commitData\n     * @param {string} commitData.commitHash - hash of the commit.\n     * @param {string} commitData.status - storage.constants./SYNCED/FORKED/MERGED\n     * @param {string} commitData.branchName - name of branch that got updated with the commitHash.\n     */\n    PluginResult.prototype.addCommit = function (commitData) {\n        this.commits.push(commitData);\n    };\n\n    /**\n     * Gets the name of the plugin to which the result object belongs to.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getPluginName = function () {\n        return this.pluginName;\n    };\n\n    //------------------------------------------------------------------------------------------------------------------\n    //--------------- Methods used by the plugin manager\n\n    /**\n     * Sets the name of the plugin to which the result object belongs to.\n     *\n     * @param {string} pluginName - name of the plugin\n     */\n    PluginResult.prototype.setPluginName = function (pluginName) {\n        this.pluginName = pluginName;\n    };\n\n    /**\n     * Gets the ISO 8601 representation of the time when the plugin started its execution.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getStartTime = function () {\n        return this.startTime;\n    };\n\n    /**\n     * Sets the ISO 8601 representation of the time when the plugin started its execution.\n     *\n     * @param {string} time\n     */\n    PluginResult.prototype.setStartTime = function (time) {\n        this.startTime = time;\n    };\n\n    /**\n     * Gets the ISO 8601 representation of the time when the plugin finished its execution.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getFinishTime = function () {\n        return this.finishTime;\n    };\n\n    /**\n     * Sets the ISO 8601 representation of the time when the plugin finished its execution.\n     *\n     * @param {string} time\n     */\n    PluginResult.prototype.setFinishTime = function (time) {\n        this.finishTime = time;\n    };\n\n    /**\n     * Gets error if any error occured during execution.\n     * FIXME: should this be an Error object?\n     * @returns {string}\n     */\n    PluginResult.prototype.getError = function () {\n        return this.error;\n    };\n\n    /**\n     * Sets the error string if any error occured during execution.\n     * FIXME: should this be an Error object?\n     * @param {string} time\n     */\n    PluginResult.prototype.setError = function (error) {\n        if (error instanceof Error) {\n            this.error = error.message;\n        } else {\n            this.error = error;\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{success: boolean, messages: plugin.PluginMessage[], pluginName: string, finishTime: stirng}}\n     */\n    PluginResult.prototype.serialize = function () {\n        var result = {\n            success: this.success,\n            messages: [],\n            commits: this.commits,\n            artifacts: this.artifacts,\n            pluginName: this.pluginName,\n            startTime: this.startTime,\n            finishTime: this.finishTime,\n            error: null\n        },\n            i;\n\n        for (i = 0; i < this.messages.length; i += 1) {\n            result.messages.push(this.messages[i].serialize());\n        }\n\n        return result;\n    };\n\n    return PluginResult;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * This is the base class that plugins should inherit from.\n * (Using the plugin-generator - the generated plugin will do that.)\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginBase',[\n    'plugin/PluginConfig',\n    'plugin/PluginResult',\n    'plugin/PluginMessage',\n    'plugin/PluginNodeDescription',\n    'common/storage/constants',\n], function (PluginConfig, PluginResult, PluginMessage, PluginNodeDescription, STORAGE_CONSTANTS) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of a plugin object, which should be a derived class.\n     *\n     * @constructor\n     * @alias PluginBase\n     */\n    var PluginBase = function () {\n        // set by initialize\n        this.logger = null;\n        this.blobClient = null;\n        this._currentConfig = null;\n\n        // set by configure\n        this.core = null;\n        this.project = null;\n        this.projectName = null;\n        this.projectId = null;\n        this.branchName = null;\n        this.branchHash = null;\n        this.commitHash = null;\n        this.currentHash = null;\n        this.rootNode = null;\n        this.activeNode = null;\n        this.activeSelection = [];\n        this.META = null;\n\n        this.result = null;\n        this.isConfigured = false;\n        this.gmeConfig = null;\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods must be overridden by the derived classes\n\n    /**\n     * Main function for the plugin to execute. This will perform the execution.\n     * Notes:\n     * - do NOT use console.log use this.logger.[error,warning,info,debug] instead\n     * - do NOT put any user interaction logic UI, etc. inside this function\n     * - callback always have to be called even if error happened\n     *\n     * @param {function(string|Error, PluginResult)} callback - the result callback\n     */\n    PluginBase.prototype.main = function (/*callback*/) {\n        throw new Error('implement this function in the derived class');\n    };\n\n    /**\n     * Readable name of this plugin that can contain spaces.\n     *\n     * @returns {string}\n     */\n    PluginBase.prototype.getName = function () {\n        throw new Error('implement this function in the derived class - getting type automatically is a bad idea,' +\n            'when the js scripts are minified names are useless.');\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods could be overridden by the derived classes\n\n    /**\n     * Current version of this plugin using semantic versioning.\n     * @returns {string}\n     */\n    PluginBase.prototype.getVersion = function () {\n        return '0.1.0';\n    };\n\n    /**\n     * A detailed description of this plugin and its purpose. It can be one or more sentences.\n     *\n     * @returns {string}\n     */\n    PluginBase.prototype.getDescription = function () {\n        return '';\n    };\n\n    /**\n     * Configuration structure with names, descriptions, minimum, maximum values, default values and\n     * type definitions.\n     *\n     * Example:\n     *\n     * [{\n         *    \"name\": \"logChildrenNames\",\n         *    \"displayName\": \"Log Children Names\",\n         *    \"description\": '',\n         *    \"value\": true, // this is the 'default config'\n         *    \"valueType\": \"boolean\",\n         *    \"readOnly\": false\n         * },{\n         *    \"name\": \"logLevel\",\n         *    \"displayName\": \"Logger level\",\n         *    \"description\": '',\n         *    \"value\": \"info\",\n         *    \"valueType\": \"string\",\n         *    \"valueItems\": [\n         *          \"debug\",\n         *          \"info\",\n         *          \"warn\",\n         *          \"error\"\n         *      ],\n         *    \"readOnly\": false\n         * },{\n         *    \"name\": \"maxChildrenToLog\",\n         *    \"displayName\": \"Maximum children to log\",\n         *    \"description\": 'Set this parameter to blabla',\n         *    \"value\": 4,\n         *    \"minValue\": 1,\n         *    \"valueType\": \"number\",\n         *    \"readOnly\": false\n         * }]\n     *\n     * @returns {object[]}\n     */\n    PluginBase.prototype.getConfigStructure = function () {\n        return [];\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods that can be used by the derived classes\n\n    /**\n     * Updates the current success flag with a new value.\n     *\n     * NewValue = OldValue && Value\n     *\n     * @param {boolean} value - apply this flag on current success value\n     * @param {string|null} message - optional detailed message\n     */\n    PluginBase.prototype.updateSuccess = function (value, message) {\n        var prevSuccess = this.result.getSuccess();\n        var newSuccessValue = prevSuccess && value;\n\n        this.result.setSuccess(newSuccessValue);\n        var msg = '';\n        if (message) {\n            msg = ' - ' + message;\n        }\n\n        this.logger.debug('Success was updated from ' + prevSuccess + ' to ' + newSuccessValue + msg);\n    };\n\n    /**\n     * WebGME can export the META types as path and this method updates the generated domain specific types with\n     * webgme node objects. These can be used to define the base class of new objects created through the webgme API.\n     *\n     * @param {object} generatedMETA\n     */\n    PluginBase.prototype.updateMETA = function (generatedMETA) {\n        var name;\n        for (name in this.META) {\n            if (this.META.hasOwnProperty(name)) {\n                generatedMETA[name] = this.META[name];\n            }\n        }\n\n        // TODO: check if names are not the same\n        // TODO: log if META is out of date\n    };\n\n    /**\n     * Checks if the given node is of the given meta-type.\n     * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>\n     * @param {module:Core~Node} node - Node to be checked for type.\n     * @param {module:Core~Node} metaNode - Node object defining the meta type.\n     * @returns {boolean} - True if the given object was of the META type.\n     */\n    PluginBase.prototype.isMetaTypeOf = function (node, metaNode) {\n        var self = this;\n        while (node) {\n            if (self.core.getGuid(node) === self.core.getGuid(metaNode)) {\n                return true;\n            }\n            node = self.core.getBase(node);\n        }\n        return false;\n    };\n\n    /**\n     * Finds and returns the node object defining the meta type for the given node.\n     * @param {module:Core~Node} node - Node to be checked for type.\n     * @returns {module:Core~Node} - Node object defining the meta type of node.\n     */\n    PluginBase.prototype.getMetaType = function (node) {\n        var self = this,\n            name;\n        while (node) {\n            name = self.core.getAttribute(node, 'name');\n            if (self.META.hasOwnProperty(name) && self.core.getGuid(node) === self.core.getGuid(self.META[name])) {\n                break;\n            }\n            node = self.core.getBase(node);\n        }\n        return node;\n    };\n\n    /**\n     * Returns true if node is a direct instance of a meta-type node (or a meta-type node itself).\n     * @param {module:Core~Node} node - Node to be checked.\n     * @returns {boolean}\n     */\n    PluginBase.prototype.baseIsMeta = function (node) {\n        var self = this,\n            baseName,\n            baseNode = self.core.getBase(node);\n        if (!baseNode) {\n            // FCO does not have a base node, by definition function returns true.\n            return true;\n        }\n        baseName = self.core.getAttribute(baseNode, 'name');\n        return self.META.hasOwnProperty(baseName) &&\n            self.core.getGuid(self.META[baseName]) === self.core.getGuid(baseNode);\n    };\n\n    /**\n     * Gets the current configuration of the plugin that was set by the user and plugin manager.\n     *\n     * @returns {PluginConfig}\n     */\n    PluginBase.prototype.getCurrentConfig = function () {\n        return this._currentConfig;\n    };\n\n    /**\n     * Creates a new message for the user and adds it to the result.\n     *\n     * @param {module:Core~Node} node - webgme object which is related to the message\n     * @param {string} message - feedback to the user\n     * @param {string} severity - severity level of the message: 'debug', 'info' (default), 'warning', 'error'.\n     */\n    PluginBase.prototype.createMessage = function (node, message, severity) {\n        var severityLevel = severity || 'info';\n        //this occurrence of the function will always handle a single node\n\n        var descriptor = new PluginNodeDescription({\n            name: node ? this.core.getAttribute(node, 'name') : '',\n            id: node ? this.core.getPath(node) : ''\n        });\n        var pluginMessage = new PluginMessage({\n            commitHash: this.currentHash,\n            activeNode: descriptor,\n            message: message,\n            severity: severityLevel\n        });\n\n        this.result.addMessage(pluginMessage);\n    };\n\n    /**\n     * Saves all current changes if there is any to a new commit.\n     * If the commit result is either 'FORKED' or 'CANCELED', it creates a new branch.\n     *\n     * @param {string|null} message - commit message\n     * @param {function(Error|string, module:Storage~commitResult)} callback\n     */\n    PluginBase.prototype.save = function (message, callback) {\n        var self = this,\n            persisted,\n            commitMessage = '[Plugin] ' + self.getName() + ' (v' + self.getVersion() + ') updated the model.';\n\n        commitMessage = message ? commitMessage + ' - ' + message : commitMessage;\n\n        self.logger.debug('Saving project');\n        persisted = self.core.persist(self.rootNode);\n        if (Object.keys(persisted.objects).length === 0) {\n            self.logger.warn('save invoked with no changes, will still proceed');\n        }\n\n        self.project.makeCommit(self.branchName,\n            [self.currentHash],\n            persisted.rootHash,\n            persisted.objects,\n            commitMessage,\n            function (err, commitResult) {\n                if (err) {\n                    self.logger.error('project.makeCommit failed.');\n                    callback(err);\n                    return;\n                }\n                self.currentHash = commitResult.hash;\n\n                if (commitResult.status === STORAGE_CONSTANTS.SYNCED) {\n                    self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\n                    self.addCommitToResult(STORAGE_CONSTANTS.SYNCED);\n                    callback(null, {status: STORAGE_CONSTANTS.SYNCED, hash: self.currentHash});\n                } else if (commitResult.status === STORAGE_CONSTANTS.FORKED) {\n                    self._createFork(callback);\n                } else if (commitResult.status === STORAGE_CONSTANTS.CANCELED) {\n                    // Plugin running in the browser and the client has made changes since plugin was invoked.\n                    // Since the commitData was never sent to the server, a commit w/o branch is made before forking.\n                    self.project.makeCommit(null,\n                        [self.currentHash],\n                        persisted.rootHash,\n                        persisted.objects,\n                        commitMessage,\n                        function (err, commitResult) {\n                            if (err) {\n                                self.logger.error('project.makeCommit failed.');\n                                callback(err);\n                                return;\n                            }\n                            self.currentHash = commitResult.hash; // This is needed in case hash is randomly generated.\n                            self._createFork(callback);\n                        });\n                } else {\n                    callback('setBranchHash returned unexpected status' + commitResult.status);\n                }\n            }\n        );\n    };\n\n    PluginBase.prototype._createFork = function (callback) {\n        // User can set self.forkName, but must make sure it is unique.\n        var self = this,\n            oldBranchName = self.branchName,\n            forkName = self.forkName || self.branchName + '_' + (new Date()).getTime();\n        self.logger.warn('Plugin got forked from \"' + self.branchName + '\". ' +\n            'Trying to create a new branch \"' + forkName + '\".');\n        self.project.createBranch(forkName, self.currentHash, function (err, forkResult) {\n            if (err) {\n                self.logger.error('createBranch failed with error.');\n                callback(err);\n                return;\n            }\n            if (forkResult.status === STORAGE_CONSTANTS.SYNCED) {\n                self.branchName = forkName;\n                self.logger.info('\"' + self.branchName + '\" was updated to the new commit.' +\n                    '(Successive saves will try to save to this new branch.)');\n                self.addCommitToResult(STORAGE_CONSTANTS.FORKED);\n\n                callback(null, {status: STORAGE_CONSTANTS.FORKED, forkName: forkName, hash: forkResult.hash});\n\n            } else if (forkResult.status === STORAGE_CONSTANTS.FORKED) {\n                self.branchName = null;\n                self.addCommitToResult(STORAGE_CONSTANTS.FORKED);\n\n                callback('Plugin got forked from \"' + oldBranchName + '\". ' +\n                    'And got forked from \"' + forkName + '\" too.');\n            } else {\n                callback('createBranch returned unexpected status' + forkResult.status);\n            }\n        });\n    };\n\n    PluginBase.prototype.addCommitToResult = function (status) {\n        var newCommit = {\n            commitHash: this.currentHash,\n            branchName: this.branchName,\n            status: status\n        };\n        this.result.addCommit(newCommit);\n        this.logger.debug('newCommit added', newCommit);\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods that are used by the Plugin Manager. Derived classes should not use these methods\n\n    /**\n     * Initializes the plugin with objects that can be reused within the same plugin instance.\n     *\n     * @param {GmeLogger} logger - logging capability to console (or file) based on PluginManager configuration\n     * @param {BlobClient} blobClient - virtual file system where files can be generated then saved as a zip file.\n     * @param {GmeConfig} gmeConfig - global configuration for webGME.\n     */\n    PluginBase.prototype.initialize = function (logger, blobClient, gmeConfig) {\n        if (logger) {\n            this.logger = logger;\n        } else {\n            this.logger = console;\n        }\n        if (!gmeConfig) {\n            // TODO: Remove this check at some point\n            throw new Error('gmeConfig was not provided to Plugin.initialize!');\n        }\n        this.blobClient = blobClient;\n        this.gmeConfig = gmeConfig;\n\n        this._currentConfig = null;\n        // initialize default configuration\n        this.setCurrentConfig(this.getDefaultConfig());\n\n        this.isConfigured = false;\n    };\n\n    /**\n     * Configures this instance of the plugin for a specific execution. This function is called before the main by\n     * the PluginManager.\n     * Initializes the result with a new object.\n     *\n     * @param {PluginContext} config - specific context: project, branch, core, active object and active selection.\n     */\n    PluginBase.prototype.configure = function (config) {\n        this.core = config.core;\n        this.project = config.project;\n        this.branch = config.branch;  // This is only for client side.\n        this.projectName = config.projectName;\n        this.projectId = config.projectId;\n        this.branchName = config.branchName;\n        this.branchHash = config.branchName ? config.commitHash : null;\n\n        this.commitHash = config.commitHash;\n        this.currentHash = config.commitHash;\n\n        this.rootNode = config.rootNode;\n        this.activeNode = config.activeNode;\n        this.activeSelection = config.activeSelection;\n        this.META = config.META;\n\n        this.result = new PluginResult();\n\n        this.addCommitToResult(STORAGE_CONSTANTS.SYNCED);\n\n        this.isConfigured = true;\n    };\n\n    /**\n     * Gets the default configuration based on the configuration structure for this plugin.\n     *\n     * @returns {PluginConfig}\n     */\n    PluginBase.prototype.getDefaultConfig = function () {\n        var configStructure = this.getConfigStructure();\n\n        var defaultConfig = new PluginConfig();\n\n        for (var i = 0; i < configStructure.length; i += 1) {\n            defaultConfig[configStructure[i].name] = configStructure[i].value;\n        }\n\n        return defaultConfig;\n    };\n\n    /**\n     * Sets the current configuration of the plugin.\n     *\n     * @param {PluginConfig} newConfig - this is the actual configuration and NOT the configuration structure.\n     */\n    PluginBase.prototype.setCurrentConfig = function (newConfig) {\n        this._currentConfig = newConfig;\n    };\n\n    return PluginBase;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginContext',[], function () {\n    'use strict';\n\n    /**\n     * Initializes a new instance of PluginContext. This context is set through PluginBase.configure method for a given\n     * plugin instance and execution.\n     *\n     * @constructor\n     */\n    var PluginContext = function () {\n\n        // TODO: something like this\n//        context.project = project;\n//        context.projectName = config.project;\n//        context.core = new Core(context.project);\n//        context.commitHash = config.commit;\n//        context.selected = config.selected;\n//        context.storage = null;\n\n    };\n\n\n    return PluginContext;\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('common/storage/util',['common/storage/constants'], function (CONSTANTS) {\n    'use strict';\n    return {\n\n        getProjectFullNameFromProjectId: function (projectId) {\n            if (projectId) {\n                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, CONSTANTS.PROJECT_DISPLAYED_NAME_SEP);\n            }\n        },\n        getProjectDisplayedNameFromProjectId: function (projectId) {\n            if (projectId) {\n                return projectId.replace(CONSTANTS.PROJECT_ID_SEP, ' ' + CONSTANTS.PROJECT_DISPLAYED_NAME_SEP + ' ');\n            }\n        },\n        getProjectIdFromProjectFullName: function (projectFullName) {\n            if (projectFullName) {\n                return projectFullName.replace(CONSTANTS.PROJECT_DISPLAYED_NAME_SEP, CONSTANTS.PROJECT_ID_SEP);\n            }\n        },\n        getProjectIdFromOwnerIdAndProjectName: function (userId, projectName) {\n            return userId + CONSTANTS.PROJECT_ID_SEP + projectName;\n        },\n        getProjectNameFromProjectId: function (projectId) {\n            if (projectId) {\n                return projectId.substring(projectId.indexOf(CONSTANTS.PROJECT_ID_SEP) + 1);\n            }\n        }\n    };\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n// TODO: Use PluginManagerConfiguration\n// TODO: Load ActiveSelection objects and pass it correctly\n// TODO: Add more statistics to the result object\n// TODO: Result object rename name -> pluginName, time -> finishTime)\n// TODO: Make this class testable\n// TODO: PluginManager should download the plugins\n\n\ndefine('plugin/PluginManagerBase',['plugin/PluginBase', 'plugin/PluginContext', 'common/storage/util'],\n    function (PluginBase, PluginContext, storageUtil) {\n        'use strict';\n\n        var PluginManagerBase = function (storage, Core, logger, plugins, gmeConfig) {\n            this.gmeConfig = gmeConfig; // global configuration of webgme\n            this.logger = logger.fork('PluginManager');\n            this._Core = Core;       // webgme core class is used to operate on objects\n            this._storage = storage; // webgme storage (project)\n            this._plugins = plugins; // key value pair of pluginName: pluginType - plugins are already loaded/downloaded\n            this._pluginConfigs = {}; // keeps track of the current configuration for each plugins by name\n\n            if (!this.gmeConfig) {\n                // TODO: this error check is temporary\n                throw new Error('PluginManagerBase takes gmeConfig as parameter!');\n            }\n\n            var pluginNames = Object.keys(this._plugins);\n            for (var i = 0; i < pluginNames.length; i += 1) {\n                var p = new this._plugins[pluginNames[i]]();\n                this._pluginConfigs[pluginNames[i]] = p.getDefaultConfig();\n            }\n        };\n\n        PluginManagerBase.prototype.initialize = function (managerConfiguration, configCallback, callbackContext) {\n            var self = this,\n                pluginName,\n                plugins = this._plugins;\n\n            //#1: PluginManagerBase should load the plugins\n\n            //#2: PluginManagerBase iterates through each plugin and collects the config data\n            var pluginConfigs = {};\n\n            for (pluginName in plugins) {\n                if (plugins.hasOwnProperty(pluginName)) {\n                    var plugin = new plugins[pluginName]();\n                    pluginConfigs[pluginName] = plugin.getConfigStructure();\n                }\n            }\n\n            if (configCallback) {\n                configCallback.call(callbackContext, pluginConfigs, function (updatedPluginConfig) {\n                    for (pluginName in updatedPluginConfig) {\n                        if (updatedPluginConfig.hasOwnProperty(pluginName)) {\n                            //save it back to the plugin\n                            self._pluginConfigs[pluginName] = updatedPluginConfig[pluginName];\n                        }\n                    }\n                });\n            }\n        };\n\n        /**\n         * Gets a new instance of a plugin by name.\n         *\n         * @param {string} name\n         * @returns {plugin.PluginBase}\n         */\n        PluginManagerBase.prototype.getPluginByName = function (name) {\n            return this._plugins[name];\n        };\n\n        PluginManagerBase.prototype.loadMetaNodes = function (pluginContext, callback) {\n            var self = this;\n\n            this.logger.debug('Loading meta nodes');\n\n            // get meta members\n            var metaIDs = pluginContext.core.getMemberPaths(pluginContext.rootNode, 'MetaAspectSet');\n\n            var len = metaIDs.length;\n\n            var nodeObjs = [];\n\n\n            var allObjectsLoadedHandler = function () {\n                var len2 = nodeObjs.length;\n\n                var nameObjMap = {};\n\n                while (len2--) {\n                    var nodeObj = nodeObjs[len2];\n\n                    nameObjMap[pluginContext.core.getAttribute(nodeObj, 'name')] = nodeObj;\n                }\n\n                pluginContext.META = nameObjMap;\n\n                self.logger.debug('Meta nodes are loaded');\n\n                callback(null, pluginContext);\n            };\n\n            var loadedMetaObjectHandler = function (err, nodeObj) {\n                nodeObjs.push(nodeObj);\n\n                if (nodeObjs.length === metaIDs.length) {\n                    allObjectsLoadedHandler();\n                }\n            };\n\n            while (len--) {\n                pluginContext.core.loadByPath(pluginContext.rootNode, metaIDs[len], loadedMetaObjectHandler);\n            }\n        };\n\n        /**\n         *\n         * @param {plugin.PluginManagerConfiguration} managerConfiguration\n         * @param {function} callback\n         */\n        PluginManagerBase.prototype.getPluginContext = function (managerConfiguration, callback) {\n            var self = this,\n                pluginContext = new PluginContext();\n\n            // TODO: check if callback is a function\n            // based on the string values get the node objects\n            // 1) Open project\n            // 2) Load branch OR commit hash\n            // 3) Load rootNode\n            // 4) Load active object\n            // 5) Load active selection\n            // 6) Update context\n            // 7) return\n\n            pluginContext.project = this._storage;\n            pluginContext.projectName = storageUtil.getProjectNameFromProjectId(managerConfiguration.project);\n            pluginContext.projectId = managerConfiguration.project;\n            pluginContext.branchName = managerConfiguration.branchName;\n\n            pluginContext.core = new self._Core(pluginContext.project, {\n                globConf: self.gmeConfig,\n                logger: self.logger.fork('core') //TODO: This logger should probably fork from the plugin logger\n            });\n            pluginContext.commitHash = managerConfiguration.commit;\n            pluginContext.activeNode = null;    // active object\n            pluginContext.activeSelection = []; // selected objects\n\n\n            // add activeSelection\n            function loadActiveSelectionAndMetaNodes() {\n                var remaining = managerConfiguration.activeSelection.length,\n                    i;\n                function loadNodeByNode(selectedNodePath) {\n                    pluginContext.core.loadByPath(pluginContext.rootNode, selectedNodePath,\n                        function (err, selectedNode) {\n                                remaining -= 1;\n\n                                if (err) {\n                                self.logger.warn('unable to load active selection: ' + selectedNodePath);\n                                } else {\n                                pluginContext.activeSelection.push(selectedNode);\n                                }\n\n                                if (remaining === 0) {\n                                    // all nodes from active selection are loaded\n                                    self.loadMetaNodes(pluginContext, callback);\n                                }\n                        }\n                    );\n                }\n                if (managerConfiguration.activeSelection.length === 0) {\n                    self.loadMetaNodes(pluginContext, callback);\n                } else {\n                    for (i = 0; i < managerConfiguration.activeSelection.length; i += 1) {\n                        loadNodeByNode(managerConfiguration.activeSelection[i]);\n                    }\n                    }\n                }\n\n            // add activeNode\n            function loadCommitHashAndRun(commitHash) {\n                self.logger.info('Loading commit ' + commitHash);\n                pluginContext.project.getCommits(commitHash, 1, function (err, commitObjects) {\n                    var commitObj;\n                    if (err || commitObjects.length !== 1) {\n                        if (err) {\n                            callback(err, pluginContext);\n                        } else {\n                            self.logger.error('commitObjects', commitObjects);\n                            callback('getCommits did not return with one commit', pluginContext);\n                        }\n                        return;\n                    }\n\n                    commitObj = commitObjects[0];\n\n                    if (typeof commitObj === 'undefined' || commitObj === null) {\n                        callback('cannot find commit', pluginContext);\n                        return;\n                    }\n\n                    if (managerConfiguration.rootHash && commitObj.root !== managerConfiguration.rootHash) {\n                        // This is a sanity check for the client state handling..\n                        self.logger.error('Root hash for commit-object, is not the same as passed from the client.' +\n                        'commitHash, rootHash, given rootHash:',\n                            commitHash, commitObj.root, managerConfiguration.rootHash);\n                    }\n\n                    pluginContext.core.loadRoot(commitObj.root, function (err, rootNode) {\n                        if (err) {\n                            callback('unable to load root', pluginContext);\n                            return;\n                        }\n\n                        pluginContext.rootNode = rootNode;\n                        if (typeof managerConfiguration.activeNode === 'string') {\n                            pluginContext.core.loadByPath(pluginContext.rootNode, managerConfiguration.activeNode,\n                                function (err, activeNode) {\n                                if (err) {\n                                        callback('unable to load selected object', pluginContext);\n                                    return;\n                                }\n\n                                pluginContext.activeNode = activeNode;\n                                loadActiveSelectionAndMetaNodes();\n                                }\n                            );\n                        } else {\n                            pluginContext.activeNode = null;\n                            loadActiveSelectionAndMetaNodes();\n                        }\n                    });\n                });\n            }\n\n            // load commit hash and run based on branch name or commit hash\n            if (managerConfiguration.branchName) {\n                pluginContext.project.getBranches(function (err, branchNames) {\n                    //self.logger.debug(branchNames);\n\n                        pluginContext.commitHash = branchNames[managerConfiguration.branchName] || pluginContext.commitHash;\n                        pluginContext.branchName = managerConfiguration.branchName;\n                        loadCommitHashAndRun(pluginContext.commitHash);\n                });\n            } else {\n                loadCommitHashAndRun(pluginContext.commitHash);\n            }\n\n        };\n\n        PluginManagerBase.prototype.executePlugin = function (name, managerConfiguration, callback) {\n            // TODO: check if name is a string\n            // TODO: check if managerConfiguration is an instance of PluginManagerConfiguration\n            // TODO: check if callback is a function\n            var self = this,\n                mainCallbackCalls = 0,\n                multiCallbackHandled = false;\n\n            var PluginClass = this.getPluginByName(name);\n\n            var plugin = new PluginClass();\n\n            var pluginLogger = this.logger.fork('gme:plugin:' + name, true);\n\n            plugin.initialize(pluginLogger, managerConfiguration.blobClient, self.gmeConfig);\n\n            plugin.setCurrentConfig(this._pluginConfigs[name]);\n            for (var key in managerConfiguration.pluginConfig) {\n                if (managerConfiguration.pluginConfig.hasOwnProperty(key) &&\n                    plugin._currentConfig.hasOwnProperty(key)) {\n\n                    plugin._currentConfig[key] = managerConfiguration.pluginConfig[key];\n                }\n            }\n            self.getPluginContext(managerConfiguration, function (err, pluginContext) {\n                if (err) {\n                    // TODO: this has to return with an empty PluginResult object and NOT with null.\n                    callback(err, null);\n                    return;\n\n                }\n\n                plugin.configure(pluginContext);\n\n                var startTime = (new Date()).toISOString();\n\n                plugin.main(function (err, result) {\n                    var stackTrace;\n                    mainCallbackCalls += 1;\n                    // set common information (meta info) about the plugin and measured execution times\n                    result.setFinishTime((new Date()).toISOString());\n                    result.setStartTime(startTime);\n\n                    result.setPluginName(plugin.getName());\n\n                    if (mainCallbackCalls > 1) {\n                        stackTrace = new Error().stack;\n                        self.logger.error('The main callback is being called more than once!', {metadata: stackTrace});\n                        result.setError('The main callback is being called more than once!');\n                        if (multiCallbackHandled === true) {\n                            plugin.createMessage(null, stackTrace);\n                            return;\n                        }\n                        multiCallbackHandled = true;\n                        result.setSuccess(false);\n                        plugin.createMessage(null, 'The main callback is being called more than once.');\n                        plugin.createMessage(null, stackTrace);\n                        callback('The main callback is being called more than once!', result);\n                    } else {\n                        result.setError(err);\n                        callback(err, result);\n                    }\n                });\n\n            });\n\n        };\n\n\n        return PluginManagerBase;\n    });\n",
    "/*globals define*/\ndefine('js/Dialogs/PluginConfig/PluginConfigDialog',[], function () {\n    'use strict';\n});\n\n",
    "/*globals define, WebGMEGlobal, requirejs*/\n/*jshint browser: true*/\n\n/**\n * @author rkereskenyi / https://github.com/rkereskenyi\n * @author lattmann / https://github.com/lattmann\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/Utils/InterpreterManager',[\n    'common/core/core',\n    'plugin/PluginManagerBase',\n    'plugin/PluginResult',\n    'plugin/PluginMessage',\n    'blob/BlobClient',\n    'js/Dialogs/PluginConfig/PluginConfigDialog',\n    'js/logger'\n], function (Core, PluginManagerBase, PluginResult, PluginMessage, BlobClient, PluginConfigDialog, Logger) {\n\n    'use strict';\n\n    var InterpreterManager = function (client, gmeConfig) {\n        this._client = client;\n        //this._manager = new PluginManagerBase();\n        this.gmeConfig = gmeConfig;\n        this._savedConfigs = {};\n        this.logger = Logger.create('gme:InterpreterManager', gmeConfig.client.log);\n        this.logger.debug('InterpreterManager ctor');\n    };\n\n    var getPlugin = function (name, callback) {\n        if (WebGMEGlobal && WebGMEGlobal.plugins && WebGMEGlobal.plugins.hasOwnProperty(name)) {\n            callback(null, WebGMEGlobal.plugins[name]);\n        } else {\n            requirejs(['/plugin/' + name + '/' + name + '/' + name],\n                function (InterpreterClass) {\n                    callback(null, InterpreterClass);\n                },\n                function (err) {\n                    callback(err, null);\n                }\n            );\n        }\n    };\n\n    function getPluginErrorResult(pluginName, message, startTime) {\n        var pluginResult = new PluginResult(),\n            pluginMessage = new PluginMessage();\n        pluginMessage.severity = 'error';\n        pluginMessage.message = message;\n        pluginResult.setSuccess(false);\n        pluginResult.pluginName = pluginName;\n        pluginResult.addMessage(pluginMessage);\n        pluginResult.setStartTime(startTime);\n        pluginResult.setFinishTime((new Date()).toISOString());\n        pluginResult.setError(pluginMessage.message);\n\n        return pluginResult;\n    }\n\n    /**\n     *\n     * @param {string} name - name of plugin to be executed.\n     * @param {object} silentPluginCfg - if falsy dialog window will be shown.\n     * @param {object.string} silentPluginCfg.activeNode - Path to activeNode.\n     * @param {object.Array.<string>} silentPluginCfg.activeSelection - Paths to nodes in activeSelection.\n     * @param {object.boolean} silentPluginCfg.runOnServer - Whether to run the plugin on the server or not.\n     * @param {object.object} silentPluginCfg.pluginConfig - Plugin specific options.\n     * @param callback\n     */\n    InterpreterManager.prototype.run = function (name, silentPluginCfg, callback) {\n        var self = this,\n            startTime = (new Date()).toISOString();\n        getPlugin(name, function (err, plugin) {\n            self.logger.debug('Getting getPlugin in run.');\n            if (!err && plugin) {\n                var plugins = {},\n                    runWithConfiguration;\n                plugins[name] = plugin;\n                var pluginManager = new PluginManagerBase(self._client.getProjectObject(), Core, self.logger, plugins,\n                    self.gmeConfig);\n                pluginManager.initialize(null, function (pluginConfigs, configSaveCallback) {\n                    //#1: display config to user\n                    var noServerExecution = self.gmeConfig.plugin.allowServerExecution === false,\n                        hackedConfig = {\n                            'Global Options': [\n                                {\n                                    name: 'runOnServer',\n                                    displayName: 'Execute on Server',\n                                    description: noServerExecution ? 'Server side execution is disabled.' : '',\n                                    value: false, // this is the 'default config'\n                                    valueType: 'boolean',\n                                    readOnly: noServerExecution\n                                }\n                            ]\n                        },\n                        i, j, d, len;\n\n                    for (i in pluginConfigs) {\n                        if (pluginConfigs.hasOwnProperty(i)) {\n                            hackedConfig[i] = pluginConfigs[i];\n\n                            // retrieve user settings from previous run\n                            if (self._savedConfigs.hasOwnProperty(i)) {\n                                var iConfig = self._savedConfigs[i];\n                                len = hackedConfig[i].length;\n\n                                while (len--) {\n                                    if (iConfig.hasOwnProperty(hackedConfig[i][len].name)) {\n                                        hackedConfig[i][len].value = iConfig[hackedConfig[i][len].name];\n                                    }\n                                }\n\n                            }\n                        }\n                    }\n\n                    runWithConfiguration = function (updatedConfig) {\n                        //when Save&Run is clicked in the dialog (or silentPluginCfg was passed)\n                        var globalconfig = updatedConfig['Global Options'],\n                            activeNode,\n                            errMessage,\n                            activeSelection;\n                        delete updatedConfig['Global Options'];\n\n                        activeNode = silentPluginCfg.activeNode;\n                        if (!activeNode && WebGMEGlobal && WebGMEGlobal.State) {\n                            activeNode = WebGMEGlobal.State.getActiveObject();\n                        }\n                        activeSelection = silentPluginCfg.activeSelection;\n                        if (!activeSelection && WebGMEGlobal && WebGMEGlobal.State) {\n                            activeSelection = WebGMEGlobal.State.getActiveSelection();\n                        }\n                        // save config from user\n                        for (i in updatedConfig) {\n                            self._savedConfigs[i] = updatedConfig[i];\n                        }\n\n                        //#2: save it back and run the plugin\n                        if (configSaveCallback) {\n                            configSaveCallback(updatedConfig);\n\n                            if (self._client.getBranchStatus() !== self._client.CONSTANTS.BRANCH_STATUS.SYNC) {\n                                errMessage = 'Not allowed to invoke plugin ';\n                                if (self._client.isProjectReadOnly) {\n                                    errMessage += 'when in readOnly state.';\n                                } else {\n                                    errMessage += 'while local branch is AHEAD or PULLING changes from server.';\n                                }\n                                self.logger.error(errMessage);\n                                callback(getPluginErrorResult(name, errMessage, startTime));\n                                return;\n                            }\n\n                            // TODO: If global config says try to merge branch then we\n                            // TODO: should pass the name of the branch.\n                            var config = {\n                                project: self._client.getActiveProjectId(),\n                                token: '',\n                                activeNode: activeNode, // active object in the editor\n                                activeSelection: activeSelection || [],\n                                commit: self._client.getActiveCommitHash(), //#668b3babcdf2ddcd7ba38b51acb62d63da859d90,\n                                // This will get loaded too which will provide a sanity check on the client state.\n                                rootHash: self._client.getActiveRootHash(),\n                                branchName: self._client.getActiveBranchName()\n                            };\n\n                            if (globalconfig.runOnServer === true || silentPluginCfg.runOnServer === true) {\n                                var context = {\n                                    managerConfig: config,\n                                    pluginConfig: updatedConfig[name]\n                                };\n                                self._client.runServerPlugin(name, context, function (err, result) {\n                                    if (err) {\n                                        self.logger.error(err);\n                                        if (result) {\n                                            callback(new PluginResult(result));\n                                        } else {\n                                            errMessage = 'Plugin execution resulted in error, err: ' + err;\n                                            callback(getPluginErrorResult(name, errMessage, startTime));\n                                        }\n                                    } else {\n                                        var resultObject = new PluginResult(result);\n                                        callback(resultObject);\n                                    }\n                                });\n                            } else {\n                                config.blobClient = new BlobClient();\n\n                                pluginManager.executePlugin(name, config, function (err, result) {\n                                    if (err) {\n                                        self.logger.error(err);\n                                    }\n                                    callback(result);\n                                });\n                            }\n                        }\n                    };\n\n                    if (silentPluginCfg) {\n                        var updatedConfig = {};\n                        for (i in hackedConfig) {\n                            updatedConfig[i] = {};\n                            len = hackedConfig[i].length;\n                            while (len--) {\n                                updatedConfig[i][hackedConfig[i][len].name] = hackedConfig[i][len].value;\n                            }\n\n                            if (silentPluginCfg && silentPluginCfg.pluginConfig) {\n                                for (j in silentPluginCfg.pluginConfig) {\n                                    updatedConfig[i][j] = silentPluginCfg.pluginConfig[j];\n                                }\n                            }\n                        }\n                        runWithConfiguration(updatedConfig);\n                    } else {\n                        d = new PluginConfigDialog();\n                        silentPluginCfg = {};\n                        d.show(hackedConfig, runWithConfiguration);\n                    }\n                });\n            } else {\n                self.logger.error(err);\n                self.logger.error('Unable to load plugin');\n                callback(getPluginErrorResult(name, 'Unable to load plugin, err:' + err, startTime));\n            }\n        });\n    };\n\n    //TODO: Somehow it would feel more right if we do run in async mode, but if not then we should provide getState and\n    //TODO: getResult synchronous functions as well.\n\n    return InterpreterManager;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\nvar CREATE_BRANCH = false;\n//PROJECT_NAME = 'IBug',\n//BRANCH_NAME = 'master',\n//NEW_BRANCH_HASH = '#d2d00cdd50a1ca144666a52a471af59d280ac751';\n\ndefine('teststorage/teststorage',[\n    'js/logger',\n    'common/storage/browserstorage',\n    'common/core/core',\n    'common/storage/constants'\n], function (Logger, Storage, Core, CONSTANTS) {\n    'use strict';\n    function Client(gmeConfig, projectName, branchName) {\n        var logger = Logger.create('gme:client', gmeConfig.client.log),\n            storage = Storage.getStorage(logger, gmeConfig),\n            currRootNode,\n            currCommitObject,\n            intervalId,\n            core,\n            PROJECT_NAME = projectName,\n            BRANCH_NAME = branchName;\n\n        logger.debug('ctor');\n        function loadChildrenAndSetAttribute(rootNode, commitObject) {\n            core.loadChildren(rootNode, function (err, children) {\n                if (err) {\n                    throw new Error(err);\n                }\n                logger.debug('children loaded', children);\n                //children.map(function (child) {\n                var newPos;\n                logger.debug('child name', core.getAttribute(children[0], 'name'));\n                //if (core.getAttribute(children[0], 'name') === 'newName') {\n                newPos = {x: 70 + getRandomInt(0, 100), y: 70 + getRandomInt(0, 100)};\n                core.setRegistry(children[0], 'position', newPos);\n                logger.debug('setting new position', newPos);\n                //}\n                //});\n                currRootNode = rootNode;\n                core.persist(rootNode, function (err, persisted) {\n                    if (err) {\n                        throw new Error(err);\n                    }\n                    logger.debug('cb persist data', persisted);\n                    currCommitObject = storage.makeCommit(PROJECT_NAME, BRANCH_NAME,\n                        [commitObject._id],\n                        persisted.rootHash,\n                        persisted.objects,\n                        'First commit from new storage'\n                    );\n\n                });\n                //logger.debug('persistData', persistData);\n                //core.loadChildren(rootNode, function (err, children) {\n                //    if (err) {\n                //        throw new Error(err);\n                //    }\n                //    logger.debug('children loaded again (should come from cache)', children);\n                //});\n            });\n        }\n\n        storage.open(function (status) {\n            logger.debug('storage is open');\n            if (status === CONSTANTS.CONNECTED) {\n                storage.getProjectNames({}, function (err, projectNames) {\n                    if (err) {\n                        throw new Error(err);\n                    }\n                    if (projectNames.indexOf(projectName) < 0) {\n                        throw new Error('Project does not exist');\n                    }\n                    logger.debug(projectNames);\n                    storage.watchProject(PROJECT_NAME, function (_ws, data) {\n                        logger.debug('watchProject event', data);\n                    });\n                    storage.openProject(PROJECT_NAME, function (err, project, branches) {\n                        if (err) {\n                            throw new Error(err);\n                        }\n                        var updateHandler = function (newCommitData) {\n                            logger.debug('updateHandler invoked', newCommitData);\n                            logger.debug('would call loadNodes...');\n                            currCommitObject = newCommitData.commitObject;\n                            core.loadRoot(newCommitData.commitObject.root, function (err, rootNode) {\n                                if (err) {\n                                    throw new Error(err);\n                                }\n                                logger.debug('rootNode loaded', rootNode);\n                                currRootNode = rootNode;\n                                core.loadChildren(rootNode, function (err, children) {\n                                    if (err) {\n                                        throw new Error(err);\n                                    }\n                                    logger.debug('children loaded', children);\n                                    children.map(function (child) {\n                                        logger.debug('child name', core.getAttribute(child, 'name'));\n                                        if (core.getAttribute(child, 'name') === 'newName') {\n                                            logger.debug('Got new position', core.getRegistry(child, 'position'));\n                                        }\n                                    });\n                                });\n                            });\n                        };\n                        var commitHandler = function (commitQueue, result, callback) {\n                            logger.debug('commitHandler', result);\n                            if (result.status === CONSTANTS.SYNCH) {\n                                callback(true); // All is fine, continue with the commitQueue..\n                            } else if (result.status === CONSTANTS.FORKED) {\n                                logger.debug('You got forked, queued commits', commitQueue);\n                                callback(false);\n                            } else {\n                                throw new Error('Unexpected result', result);\n                            }\n                        };\n                        logger.debug('openProject project', project);\n                        logger.debug('openProject returned branches', branches);\n                        storage.openBranch(PROJECT_NAME, BRANCH_NAME, updateHandler, commitHandler,\n                            function (err, latestCommit) {\n                                if (err) {\n                                    throw new Error(err);\n                                }\n                                logger.debug('latestCommit', latestCommit);\n                                currCommitObject = latestCommit.commitObject;\n                                core = new Core(project, {\n                                    globConf: gmeConfig,\n                                    logger: logger.fork('core')\n                                });\n                                logger.debug('core instantiated');\n                                core.loadRoot(latestCommit.commitObject.root, function (err, rootNode) {\n                                    if (err) {\n                                        throw new Error(err);\n                                    }\n                                    logger.debug('rootNode loaded', rootNode);\n                                    loadChildrenAndSetAttribute(rootNode, latestCommit.commitObject);\n                                });\n                            }\n                        );\n                        //storage.deleteBranch(PROJECT_NAME, 'b535', branches['b535'], function () {\n                        //    logger.debug('branch deleted', arguments);\n                        //});\n                    });\n                    if (CREATE_BRANCH) {\n                        storage.getBranches(PROJECT_NAME, {}, function (err, data) {\n                            if (err) {\n                                throw new Error(err);\n                            }\n                            logger.debug('getBranches return', data);\n                        });\n                        var newBranchName = 'br' + getRandomInt(2, 9999);\n                        logger.debug('will create', newBranchName);\n                        setTimeout(function () {\n                            storage.createBranch(PROJECT_NAME,\n                                newBranchName,\n                                NEW_BRANCH_HASH,\n                                function (err) {\n                                    if (err) {\n                                        throw new Error(err);\n                                    }\n                                    storage.getBranches(PROJECT_NAME, {}, function (err, data) {\n                                        if (err) {\n                                            throw new Error(err);\n                                        }\n                                        logger.debug('getBranches after create returned', data);\n                                    });\n                                });\n                        }, 2000);\n                    }\n                });\n            } else if (status === CONSTANTS.RECONNECTED) {\n                logger.debug('Reconnected!');\n                clearInterval(intervalId);\n            } else if (status === CONSTANTS.DISCONNECTED) {\n                logger.debug('Got disconnect, waiting for reconnect...');\n                intervalId = setInterval(function () {\n                    loadChildrenAndSetAttribute(currRootNode, currCommitObject);\n                }, 2000);\n            } else if (status === CONSTANTS.ERROR) {\n                throw new Error('Could not connect');\n            }\n        });\n\n        function getRandomInt(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n    }\n\n    return Client;\n});\n",
    "/*globals define, document, console, window, GME, docReady, setTimeout*/\n/*jshint browser:true, evil:true*/\n\n/**\n * @author kecso / https://github.com/kecso\n * @author lattmann / https://github.com/lattmann\n * @author nabana / https://github.com/nabana\n * @author ksmyth / https://github.com/ksmyth\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('webgme.classes', [\n    'client/js/client',\n    'blob/BlobClient',\n    'executor/ExecutorClient',\n    'js/Utils/InterpreterManager',\n    'common/core/core',\n    'common/storage/browserstorage',\n    'js/logger',\n    'lib/superagent/superagent',\n    'teststorage/teststorage'\n], function (Client,\n             BlobClient,\n             ExecutorClient,\n             InterpreterManager,\n             Core,\n             Storage,\n             Logger,\n             superagent,\n             TestStorage) {\n\n    'use strict';\n    // Setting global classes\n\n    GME.classes.Client = Client;\n    GME.classes.BlobClient = BlobClient;\n    GME.classes.ExecutorClient = ExecutorClient;\n    GME.classes.InterpreterManager = InterpreterManager;\n    GME.classes.Core = Core;\n    GME.classes.Storage = Storage;\n    GME.classes.Logger = Logger;\n    GME.classes.TestStorage = TestStorage;\n\n    // Exposing built in libraries\n    GME.utils.superagent = superagent;\n\n    // Pure JavaScript equivalent to jQuery's $.ready() from https://github.com/jfriend00/docReady\n\n    (function (funcName, baseObj) {\n        // The public function name defaults to window.docReady\n        // but you can pass in your own object and own function name and those will be used\n        // if you want to put them in a different namespace\n        funcName = funcName || 'docReady';\n        baseObj = baseObj || window;\n        var readyList = [];\n        var readyFired = false;\n        var readyEventHandlersInstalled = false;\n\n        // call this when the document is ready\n        // this function protects itself against being called more than once\n        function ready() {\n            if (!readyFired) {\n                // this must be set to true before we start calling callbacks\n                readyFired = true;\n                for (var i = 0; i < readyList.length; i++) {\n                    // if a callback here happens to add new ready handlers,\n                    // the docReady() function will see that it already fired\n                    // and will schedule the callback to run right after\n                    // this event loop finishes so all handlers will still execute\n                    // in order and no new ones will be added to the readyList\n                    // while we are processing the list\n                    readyList[i].fn.call(window, readyList[i].ctx);\n                }\n                // allow any closures held by these functions to free\n                readyList = [];\n            }\n        }\n\n        function readyStateChange() {\n            if (document.readyState === 'complete') {\n                ready();\n            }\n        }\n\n        // This is the one public interface\n        // docReady(fn, context);\n        // the context argument is optional - if present, it will be passed\n        // as an argument to the callback\n        baseObj[funcName] = function (callback, context) {\n            // if ready has already fired, then just schedule the callback\n            // to fire asynchronously, but right away\n            if (readyFired) {\n                setTimeout(function () {\n                    callback(context);\n                }, 1);\n                return;\n            } else {\n                // add the function and context to the list\n                readyList.push({fn: callback, ctx: context});\n            }\n            // if document already ready to go, schedule the ready function to run\n            if (document.readyState === 'complete') {\n                setTimeout(ready, 1);\n            } else if (!readyEventHandlersInstalled) {\n                // otherwise if we don't have event handlers installed, install them\n                if (document.addEventListener) {\n                    // first choice is DOMContentLoaded event\n                    document.addEventListener('DOMContentLoaded', ready, false);\n                    // backup is window load event\n                    window.addEventListener('load', ready, false);\n                } else {\n                    // must be IE\n                    document.attachEvent('onreadystatechange', readyStateChange);\n                    window.attachEvent('onload', ready);\n                }\n                readyEventHandlersInstalled = true;\n            }\n        };\n    })('docReady', window);\n\n    // See if there is handler attached to body tag when ready\n\n    var evalOnGmeInit = function () {\n        if (document.body.getAttribute('on-gme-init')) {\n            eval(document.body.getAttribute('on-gme-init'));\n        } else {\n            console.warn('To use GME, define a javascript function and set the body ' +\n            'element\\'s on-gme-init property.');\n        }\n    };\n\n    // wait for document.readyState !== 'loading' and getGmeConfig\n    var stillLoading = 2;\n    var somethingFinishedLoading = function () {\n        if (--stillLoading === 0) {\n            evalOnGmeInit();\n        }\n    };\n\n    if (document.readyState === 'loading') {\n        docReady(function () {\n            somethingFinishedLoading();\n        });\n    } else {\n        somethingFinishedLoading();\n    }\n\n\n    (function getGmeConfig() {\n        var http = new XMLHttpRequest(),\n            configUrl = window.location.origin + '/gmeConfig.json';\n        http.onreadystatechange = function () {\n            if (http.readyState === 4 && http.status === 200) {\n                GME.gmeConfig = JSON.parse(http.responseText);\n                somethingFinishedLoading();\n            } else if (http.readyState === 4 && http.status !== 200) {\n                console.warn('Could not load gmeConfig at', configUrl);\n                somethingFinishedLoading();\n            }\n        };\n        http.open('GET', configUrl, true);\n        http.send();\n    })();\n});\n\n"
  ]
}