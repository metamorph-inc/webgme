{
  "version": 3,
  "file": "C:/Users/kevin/Documents/webgme-cyphy/node_modules/webgme/dist/webgme.classes.build.js",
  "sources": [
    "../node_modules/requirejs/require.js",
    "common/util/assert.js",
    "common/EventDispatcher.js",
    "common/util/guid.js",
    "common/util/sha1.js",
    "common/util/zssha1.min.js",
    "common/util/canon.js",
    "common/util/key.js",
    "common/core/future.js",
    "common/core/tasync.js",
    "common/core/coretree.js",
    "common/core/corerel.js",
    "common/core/setcore.js",
    "common/regexp.js",
    "common/core/guidcore.js",
    "common/core/nullpointercore.js",
    "common/core/coreunwrap.js",
    "common/core/coretype.js",
    "common/core/constraintcore.js",
    "common/util/jjv.js",
    "common/core/metacore.js",
    "common/core/coretreeloader.js",
    "common/core/corediff.js",
    "common/core/core.js",
    "common/storage/client.js",
    "common/storage/failsafe.js",
    "common/storage/cache.js",
    "common/storage/commit.js",
    "common/storage/clientstorage.js",
    "client/lib/debug/debug.js",
    "client/js/logger.js",
    "common/util/url.js",
    "common/core/users/meta.js",
    "common/core/users/tojson.js",
    "client/lib/superagent/superagent-1.1.0.js",
    "client/js/client/undoredo.js",
    "client/js/client/gmeNodeGetter.js",
    "client/js/client/gmeNodeSetter.js",
    "client/js/client/commitCache.js",
    "client/js/client/serverEventer.js",
    "client/js/client/addon.js",
    "common/core/users/serialization.js",
    "common/core/users/dump.js",
    "common/core/users/copyimport.js",
    "common/core/users/import.js",
    "client/js/client/requests.js",
    "client/js/client/index.js",
    "client/js/client.js",
    "common/blob/BlobConfig.js",
    "common/blob/BlobMetadata.js",
    "common/blob/Artifact.js",
    "common/blob/BlobClient.js",
    "common/executor/ExecutorClient.js",
    "plugin/PluginConfig.js",
    "plugin/PluginNodeDescription.js",
    "plugin/PluginMessage.js",
    "plugin/PluginResult.js",
    "plugin/PluginBase.js",
    "plugin/PluginContext.js",
    "plugin/PluginManagerBase.js",
    "../utils/build/empty/empty.js",
    "client/js/Utils/InterpreterManager.js",
    "../utils/build/webgme.classes/webgme.classes.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtiEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA,AD2BA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrBA;AACA;AACA;AACA;AACA;AACA;AACA,ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA,AD6DA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA,AD2CA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjvBA,ADkvBA;ACjvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACz9BA,AD09BA;ACz9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACl1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA,AD8DA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA,ADwFA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9xBA,AD+xBA;AC9xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1rBA,AD2rBA;AC1rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/fA,ADggBA;AC/fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA,ADyDA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzuEA,AD0uEA;ACzuEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACj7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpfA,ADqfA;ACpfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AChUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzHA,AD0HA;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA,AD0BA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxfA,ADyfA;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA,ADgEA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACthBA,ADuhBA;ACthBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzxCA,AD0xCA;ACzxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA,AD2FA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpgBA,ADqgBA;ACpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA,AD4DA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACv5BA,ADw5BA;ACv5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClKA,ADmKA;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC7cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChhBA,ADihBA;AChhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChnBA,ADinBA;AChnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9+CA,AD++CA;AC9+CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA,ADiGA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACnWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA,ADgDA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjMA,ADkMA;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnTA,ADoTA;ACnTA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,A3BxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A4BzxCA,A5B0xCA;A4BzxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS 2.1.16 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n//Not using strict: uneven strict support in browsers, #392, and causes\n//problems with requirejs.exec()/transpiler plugins that may not be strict.\n/*jslint regexp: true, nomen: true, sloppy: true */\n/*global window, navigator, document, importScripts, setTimeout, opera */\n\nvar requirejs, require, define;\n(function (global) {\n    var req, s, head, baseElement, dataMain, src,\n        interactiveScript, currentlyAddingScript, mainScript, subPath,\n        version = '2.1.16',\n        commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,\n        cjsRequireRegExp = /[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,\n        jsSuffixRegExp = /\\.js$/,\n        currDirRegExp = /^\\.\\//,\n        op = Object.prototype,\n        ostring = op.toString,\n        hasOwn = op.hasOwnProperty,\n        ap = Array.prototype,\n        apsp = ap.splice,\n        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),\n        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',\n        //PS3 indicates loaded and complete, but need to wait for complete\n        //specifically. Sequence is 'loading', 'loaded', execution,\n        // then 'complete'. The UA check is unfortunate, but not sure how\n        //to feature test w/o causing perf issues.\n        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?\n                      /^complete$/ : /^(complete|loaded)$/,\n        defContextName = '_',\n        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n        contexts = {},\n        cfg = {},\n        globalDefQueue = [],\n        useInteractive = false;\n\n    function isFunction(it) {\n        return ostring.call(it) === '[object Function]';\n    }\n\n    function isArray(it) {\n        return ostring.call(it) === '[object Array]';\n    }\n\n    /**\n     * Helper function for iterating over an array. If the func returns\n     * a true value, it will break out of the loop.\n     */\n    function each(ary, func) {\n        if (ary) {\n            var i;\n            for (i = 0; i < ary.length; i += 1) {\n                if (ary[i] && func(ary[i], i, ary)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function for iterating over an array backwards. If the func\n     * returns a true value, it will break out of the loop.\n     */\n    function eachReverse(ary, func) {\n        if (ary) {\n            var i;\n            for (i = ary.length - 1; i > -1; i -= 1) {\n                if (ary[i] && func(ary[i], i, ary)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    function getOwn(obj, prop) {\n        return hasProp(obj, prop) && obj[prop];\n    }\n\n    /**\n     * Cycles over properties in an object and calls a function for each\n     * property value. If the function returns a truthy value, then the\n     * iteration is stopped.\n     */\n    function eachProp(obj, func) {\n        var prop;\n        for (prop in obj) {\n            if (hasProp(obj, prop)) {\n                if (func(obj[prop], prop)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     */\n    function mixin(target, source, force, deepStringMixin) {\n        if (source) {\n            eachProp(source, function (value, prop) {\n                if (force || !hasProp(target, prop)) {\n                    if (deepStringMixin && typeof value === 'object' && value &&\n                        !isArray(value) && !isFunction(value) &&\n                        !(value instanceof RegExp)) {\n\n                        if (!target[prop]) {\n                            target[prop] = {};\n                        }\n                        mixin(target[prop], value, force, deepStringMixin);\n                    } else {\n                        target[prop] = value;\n                    }\n                }\n            });\n        }\n        return target;\n    }\n\n    //Similar to Function.prototype.bind, but the 'this' object is specified\n    //first, since it is easier to read/figure out what 'this' will be.\n    function bind(obj, fn) {\n        return function () {\n            return fn.apply(obj, arguments);\n        };\n    }\n\n    function scripts() {\n        return document.getElementsByTagName('script');\n    }\n\n    function defaultOnError(err) {\n        throw err;\n    }\n\n    //Allow getting a global that is expressed in\n    //dot notation, like 'a.b.c'.\n    function getGlobal(value) {\n        if (!value) {\n            return value;\n        }\n        var g = global;\n        each(value.split('.'), function (part) {\n            g = g[part];\n        });\n        return g;\n    }\n\n    /**\n     * Constructs an error with a pointer to an URL with more information.\n     * @param {String} id the error ID that maps to an ID on a web page.\n     * @param {String} message human readable error.\n     * @param {Error} [err] the original error, if there is one.\n     *\n     * @returns {Error}\n     */\n    function makeError(id, msg, err, requireModules) {\n        var e = new Error(msg + '\\nhttp://requirejs.org/docs/errors.html#' + id);\n        e.requireType = id;\n        e.requireModules = requireModules;\n        if (err) {\n            e.originalError = err;\n        }\n        return e;\n    }\n\n    if (typeof define !== 'undefined') {\n        //If a define is already in play via another AMD loader,\n        //do not overwrite.\n        return;\n    }\n\n    if (typeof requirejs !== 'undefined') {\n        if (isFunction(requirejs)) {\n            //Do not overwrite an existing requirejs instance.\n            return;\n        }\n        cfg = requirejs;\n        requirejs = undefined;\n    }\n\n    //Allow for a require config object\n    if (typeof require !== 'undefined' && !isFunction(require)) {\n        //assume it is a config object.\n        cfg = require;\n        require = undefined;\n    }\n\n    function newContext(contextName) {\n        var inCheckLoaded, Module, context, handlers,\n            checkLoadedTimeoutId,\n            config = {\n                //Defaults. Do not set a default for map\n                //config to speed up normalize(), which\n                //will run faster if there is no default.\n                waitSeconds: 7,\n                baseUrl: './',\n                paths: {},\n                bundles: {},\n                pkgs: {},\n                shim: {},\n                config: {}\n            },\n            registry = {},\n            //registry of just enabled modules, to speed\n            //cycle breaking code when lots of modules\n            //are registered, but not activated.\n            enabledRegistry = {},\n            undefEvents = {},\n            defQueue = [],\n            defined = {},\n            urlFetched = {},\n            bundlesMap = {},\n            requireCounter = 1,\n            unnormalizedCounter = 1;\n\n        /**\n         * Trims the . and .. from an array of path segments.\n         * It will keep a leading path segment if a .. will become\n         * the first path segment, to help with module name lookups,\n         * which act like paths, but can be remapped. But the end result,\n         * all paths that use this function should look normalized.\n         * NOTE: this method MODIFIES the input array.\n         * @param {Array} ary the array of path segments.\n         */\n        function trimDots(ary) {\n            var i, part;\n            for (i = 0; i < ary.length; i++) {\n                part = ary[i];\n                if (part === '.') {\n                    ary.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        ary.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Given a relative module name, like ./something, normalize it to\n         * a real name that can be mapped to a path.\n         * @param {String} name the relative name\n         * @param {String} baseName a real name that the name arg is relative\n         * to.\n         * @param {Boolean} applyMap apply the map config to the value. Should\n         * only be done if this normalization is for a dependency ID.\n         * @returns {String} normalized name\n         */\n        function normalize(name, baseName, applyMap) {\n            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,\n                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,\n                baseParts = (baseName && baseName.split('/')),\n                map = config.map,\n                starMap = map && map['*'];\n\n            //Adjust any relative paths.\n            if (name) {\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // If wanting node ID compatibility, strip .js from end\n                // of IDs. Have to do this here, and not in nameToUrl\n                // because node allows either .js or non .js to map\n                // to same file.\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                // Starts with a '.' so need the baseName\n                if (name[0].charAt(0) === '.' && baseParts) {\n                    //Convert baseName to array, and lop off the last part,\n                    //so that . matches that 'directory' and not name of the baseName's\n                    //module. For instance, baseName of 'one/two/three', maps to\n                    //'one/two/three.js', but we want the directory, 'one/two' for\n                    //this normalization.\n                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                    name = normalizedBaseParts.concat(name);\n                }\n\n                trimDots(name);\n                name = name.join('/');\n            }\n\n            //Apply map config if available.\n            if (applyMap && map && (baseParts || starMap)) {\n                nameParts = name.split('/');\n\n                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {\n                    nameSegment = nameParts.slice(0, i).join('/');\n\n                    if (baseParts) {\n                        //Find the longest baseName segment match in the config.\n                        //So, do joins on the biggest to smallest lengths of baseParts.\n                        for (j = baseParts.length; j > 0; j -= 1) {\n                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));\n\n                            //baseName segment has config, find if it has one for\n                            //this name.\n                            if (mapValue) {\n                                mapValue = getOwn(mapValue, nameSegment);\n                                if (mapValue) {\n                                    //Match, update name to the new value.\n                                    foundMap = mapValue;\n                                    foundI = i;\n                                    break outerLoop;\n                                }\n                            }\n                        }\n                    }\n\n                    //Check for a star map match, but just hold on to it,\n                    //if there is a shorter segment match later in a matching\n                    //config, then favor over this star map.\n                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {\n                        foundStarMap = getOwn(starMap, nameSegment);\n                        starI = i;\n                    }\n                }\n\n                if (!foundMap && foundStarMap) {\n                    foundMap = foundStarMap;\n                    foundI = starI;\n                }\n\n                if (foundMap) {\n                    nameParts.splice(0, foundI, foundMap);\n                    name = nameParts.join('/');\n                }\n            }\n\n            // If the name points to a package's name, use\n            // the package main instead.\n            pkgMain = getOwn(config.pkgs, name);\n\n            return pkgMain ? pkgMain : name;\n        }\n\n        function removeScript(name) {\n            if (isBrowser) {\n                each(scripts(), function (scriptNode) {\n                    if (scriptNode.getAttribute('data-requiremodule') === name &&\n                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {\n                        scriptNode.parentNode.removeChild(scriptNode);\n                        return true;\n                    }\n                });\n            }\n        }\n\n        function hasPathFallback(id) {\n            var pathConfig = getOwn(config.paths, id);\n            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {\n                //Pop off the first array value, since it failed, and\n                //retry\n                pathConfig.shift();\n                context.require.undef(id);\n\n                //Custom require that does not do map translation, since\n                //ID is \"absolute\", already mapped/resolved.\n                context.makeRequire(null, {\n                    skipMap: true\n                })([id]);\n\n                return true;\n            }\n        }\n\n        //Turns a plugin!resource to [plugin, resource]\n        //with the plugin being undefined if the name\n        //did not have a plugin prefix.\n        function splitPrefix(name) {\n            var prefix,\n                index = name ? name.indexOf('!') : -1;\n            if (index > -1) {\n                prefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n            return [prefix, name];\n        }\n\n        /**\n         * Creates a module mapping that includes plugin prefix, module\n         * name, and path. If parentModuleMap is provided it will\n         * also normalize the name via require.normalize()\n         *\n         * @param {String} name the module name\n         * @param {String} [parentModuleMap] parent module map\n         * for the module name, used to resolve relative names.\n         * @param {Boolean} isNormalized: is the ID already normalized.\n         * This is true if this call is done for a define() module ID.\n         * @param {Boolean} applyMap: apply the map config to the ID.\n         * Should only be true if this map is for a dependency.\n         *\n         * @returns {Object}\n         */\n        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\n            var url, pluginModule, suffix, nameParts,\n                prefix = null,\n                parentName = parentModuleMap ? parentModuleMap.name : null,\n                originalName = name,\n                isDefine = true,\n                normalizedName = '';\n\n            //If no name, then it means it is a require call, generate an\n            //internal name.\n            if (!name) {\n                isDefine = false;\n                name = '_@r' + (requireCounter += 1);\n            }\n\n            nameParts = splitPrefix(name);\n            prefix = nameParts[0];\n            name = nameParts[1];\n\n            if (prefix) {\n                prefix = normalize(prefix, parentName, applyMap);\n                pluginModule = getOwn(defined, prefix);\n            }\n\n            //Account for relative paths if there is a base name.\n            if (name) {\n                if (prefix) {\n                    if (pluginModule && pluginModule.normalize) {\n                        //Plugin is loaded, use its normalize method.\n                        normalizedName = pluginModule.normalize(name, function (name) {\n                            return normalize(name, parentName, applyMap);\n                        });\n                    } else {\n                        // If nested plugin references, then do not try to\n                        // normalize, as it will not normalize correctly. This\n                        // places a restriction on resourceIds, and the longer\n                        // term solution is not to normalize until plugins are\n                        // loaded and all normalizations to allow for async\n                        // loading of a loader plugin. But for now, fixes the\n                        // common uses. Details in #1131\n                        normalizedName = name.indexOf('!') === -1 ?\n                                         normalize(name, parentName, applyMap) :\n                                         name;\n                    }\n                } else {\n                    //A regular module.\n                    normalizedName = normalize(name, parentName, applyMap);\n\n                    //Normalized name may be a plugin ID due to map config\n                    //application in normalize. The map config values must\n                    //already be normalized, so do not need to redo that part.\n                    nameParts = splitPrefix(normalizedName);\n                    prefix = nameParts[0];\n                    normalizedName = nameParts[1];\n                    isNormalized = true;\n\n                    url = context.nameToUrl(normalizedName);\n                }\n            }\n\n            //If the id is a plugin id that cannot be determined if it needs\n            //normalization, stamp it with a unique ID so two matching relative\n            //ids that may conflict can be separate.\n            suffix = prefix && !pluginModule && !isNormalized ?\n                     '_unnormalized' + (unnormalizedCounter += 1) :\n                     '';\n\n            return {\n                prefix: prefix,\n                name: normalizedName,\n                parentMap: parentModuleMap,\n                unnormalized: !!suffix,\n                url: url,\n                originalName: originalName,\n                isDefine: isDefine,\n                id: (prefix ?\n                        prefix + '!' + normalizedName :\n                        normalizedName) + suffix\n            };\n        }\n\n        function getModule(depMap) {\n            var id = depMap.id,\n                mod = getOwn(registry, id);\n\n            if (!mod) {\n                mod = registry[id] = new context.Module(depMap);\n            }\n\n            return mod;\n        }\n\n        function on(depMap, name, fn) {\n            var id = depMap.id,\n                mod = getOwn(registry, id);\n\n            if (hasProp(defined, id) &&\n                    (!mod || mod.defineEmitComplete)) {\n                if (name === 'defined') {\n                    fn(defined[id]);\n                }\n            } else {\n                mod = getModule(depMap);\n                if (mod.error && name === 'error') {\n                    fn(mod.error);\n                } else {\n                    mod.on(name, fn);\n                }\n            }\n        }\n\n        function onError(err, errback) {\n            var ids = err.requireModules,\n                notified = false;\n\n            if (errback) {\n                errback(err);\n            } else {\n                each(ids, function (id) {\n                    var mod = getOwn(registry, id);\n                    if (mod) {\n                        //Set error on module, so it skips timeout checks.\n                        mod.error = err;\n                        if (mod.events.error) {\n                            notified = true;\n                            mod.emit('error', err);\n                        }\n                    }\n                });\n\n                if (!notified) {\n                    req.onError(err);\n                }\n            }\n        }\n\n        /**\n         * Internal method to transfer globalQueue items to this context's\n         * defQueue.\n         */\n        function takeGlobalQueue() {\n            //Push all the globalDefQueue items into the context's defQueue\n            if (globalDefQueue.length) {\n                //Array splice in the values since the context code has a\n                //local var ref to defQueue, so cannot just reassign the one\n                //on context.\n                apsp.apply(defQueue,\n                           [defQueue.length, 0].concat(globalDefQueue));\n                globalDefQueue = [];\n            }\n        }\n\n        handlers = {\n            'require': function (mod) {\n                if (mod.require) {\n                    return mod.require;\n                } else {\n                    return (mod.require = context.makeRequire(mod.map));\n                }\n            },\n            'exports': function (mod) {\n                mod.usingExports = true;\n                if (mod.map.isDefine) {\n                    if (mod.exports) {\n                        return (defined[mod.map.id] = mod.exports);\n                    } else {\n                        return (mod.exports = defined[mod.map.id] = {});\n                    }\n                }\n            },\n            'module': function (mod) {\n                if (mod.module) {\n                    return mod.module;\n                } else {\n                    return (mod.module = {\n                        id: mod.map.id,\n                        uri: mod.map.url,\n                        config: function () {\n                            return  getOwn(config.config, mod.map.id) || {};\n                        },\n                        exports: mod.exports || (mod.exports = {})\n                    });\n                }\n            }\n        };\n\n        function cleanRegistry(id) {\n            //Clean up machinery used for waiting modules.\n            delete registry[id];\n            delete enabledRegistry[id];\n        }\n\n        function breakCycle(mod, traced, processed) {\n            var id = mod.map.id;\n\n            if (mod.error) {\n                mod.emit('error', mod.error);\n            } else {\n                traced[id] = true;\n                each(mod.depMaps, function (depMap, i) {\n                    var depId = depMap.id,\n                        dep = getOwn(registry, depId);\n\n                    //Only force things that have not completed\n                    //being defined, so still in the registry,\n                    //and only if it has not been matched up\n                    //in the module already.\n                    if (dep && !mod.depMatched[i] && !processed[depId]) {\n                        if (getOwn(traced, depId)) {\n                            mod.defineDep(i, defined[depId]);\n                            mod.check(); //pass false?\n                        } else {\n                            breakCycle(dep, traced, processed);\n                        }\n                    }\n                });\n                processed[id] = true;\n            }\n        }\n\n        function checkLoaded() {\n            var err, usingPathFallback,\n                waitInterval = config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                noLoads = [],\n                reqCalls = [],\n                stillLoading = false,\n                needCycleCheck = true;\n\n            //Do not bother if this call was a result of a cycle break.\n            if (inCheckLoaded) {\n                return;\n            }\n\n            inCheckLoaded = true;\n\n            //Figure out the state of all the modules.\n            eachProp(enabledRegistry, function (mod) {\n                var map = mod.map,\n                    modId = map.id;\n\n                //Skip things that are not enabled or in error state.\n                if (!mod.enabled) {\n                    return;\n                }\n\n                if (!map.isDefine) {\n                    reqCalls.push(mod);\n                }\n\n                if (!mod.error) {\n                    //If the module should be executed, and it has not\n                    //been inited and time is up, remember it.\n                    if (!mod.inited && expired) {\n                        if (hasPathFallback(modId)) {\n                            usingPathFallback = true;\n                            stillLoading = true;\n                        } else {\n                            noLoads.push(modId);\n                            removeScript(modId);\n                        }\n                    } else if (!mod.inited && mod.fetched && map.isDefine) {\n                        stillLoading = true;\n                        if (!map.prefix) {\n                            //No reason to keep looking for unfinished\n                            //loading. If the only stillLoading is a\n                            //plugin resource though, keep going,\n                            //because it may be that a plugin resource\n                            //is waiting on a non-plugin cycle.\n                            return (needCycleCheck = false);\n                        }\n                    }\n                }\n            });\n\n            if (expired && noLoads.length) {\n                //If wait time expired, throw error of unloaded modules.\n                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);\n                err.contextName = context.contextName;\n                return onError(err);\n            }\n\n            //Not expired, check for a cycle.\n            if (needCycleCheck) {\n                each(reqCalls, function (mod) {\n                    breakCycle(mod, {}, {});\n                });\n            }\n\n            //If still waiting on loads, and the waiting load is something\n            //other than a plugin resource, or there are still outstanding\n            //scripts, then just try back later.\n            if ((!expired || usingPathFallback) && stillLoading) {\n                //Something is still waiting to load. Wait for it, but only\n                //if a timeout is not already in effect.\n                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {\n                    checkLoadedTimeoutId = setTimeout(function () {\n                        checkLoadedTimeoutId = 0;\n                        checkLoaded();\n                    }, 50);\n                }\n            }\n\n            inCheckLoaded = false;\n        }\n\n        Module = function (map) {\n            this.events = getOwn(undefEvents, map.id) || {};\n            this.map = map;\n            this.shim = getOwn(config.shim, map.id);\n            this.depExports = [];\n            this.depMaps = [];\n            this.depMatched = [];\n            this.pluginMaps = {};\n            this.depCount = 0;\n\n            /* this.exports this.factory\n               this.depMaps = [],\n               this.enabled, this.fetched\n            */\n        };\n\n        Module.prototype = {\n            init: function (depMaps, factory, errback, options) {\n                options = options || {};\n\n                //Do not do more inits if already done. Can happen if there\n                //are multiple define calls for the same module. That is not\n                //a normal, common case, but it is also not unexpected.\n                if (this.inited) {\n                    return;\n                }\n\n                this.factory = factory;\n\n                if (errback) {\n                    //Register for errors on this module.\n                    this.on('error', errback);\n                } else if (this.events.error) {\n                    //If no errback already, but there are error listeners\n                    //on this module, set up an errback to pass to the deps.\n                    errback = bind(this, function (err) {\n                        this.emit('error', err);\n                    });\n                }\n\n                //Do a copy of the dependency array, so that\n                //source inputs are not modified. For example\n                //\"shim\" deps are passed in here directly, and\n                //doing a direct modification of the depMaps array\n                //would affect that config.\n                this.depMaps = depMaps && depMaps.slice(0);\n\n                this.errback = errback;\n\n                //Indicate this module has be initialized\n                this.inited = true;\n\n                this.ignore = options.ignore;\n\n                //Could have option to init this module in enabled mode,\n                //or could have been previously marked as enabled. However,\n                //the dependencies are not known until init is called. So\n                //if enabled previously, now trigger dependencies as enabled.\n                if (options.enabled || this.enabled) {\n                    //Enable this module and dependencies.\n                    //Will call this.check()\n                    this.enable();\n                } else {\n                    this.check();\n                }\n            },\n\n            defineDep: function (i, depExports) {\n                //Because of cycles, defined callback for a given\n                //export can be called more than once.\n                if (!this.depMatched[i]) {\n                    this.depMatched[i] = true;\n                    this.depCount -= 1;\n                    this.depExports[i] = depExports;\n                }\n            },\n\n            fetch: function () {\n                if (this.fetched) {\n                    return;\n                }\n                this.fetched = true;\n\n                context.startTime = (new Date()).getTime();\n\n                var map = this.map;\n\n                //If the manager is for a plugin managed resource,\n                //ask the plugin to load it now.\n                if (this.shim) {\n                    context.makeRequire(this.map, {\n                        enableBuildCallback: true\n                    })(this.shim.deps || [], bind(this, function () {\n                        return map.prefix ? this.callPlugin() : this.load();\n                    }));\n                } else {\n                    //Regular dependency.\n                    return map.prefix ? this.callPlugin() : this.load();\n                }\n            },\n\n            load: function () {\n                var url = this.map.url;\n\n                //Regular dependency.\n                if (!urlFetched[url]) {\n                    urlFetched[url] = true;\n                    context.load(this.map.id, url);\n                }\n            },\n\n            /**\n             * Checks if the module is ready to define itself, and if so,\n             * define it.\n             */\n            check: function () {\n                if (!this.enabled || this.enabling) {\n                    return;\n                }\n\n                var err, cjsModule,\n                    id = this.map.id,\n                    depExports = this.depExports,\n                    exports = this.exports,\n                    factory = this.factory;\n\n                if (!this.inited) {\n                    this.fetch();\n                } else if (this.error) {\n                    this.emit('error', this.error);\n                } else if (!this.defining) {\n                    //The factory could trigger another require call\n                    //that would result in checking this module to\n                    //define itself again. If already in the process\n                    //of doing that, skip this work.\n                    this.defining = true;\n\n                    if (this.depCount < 1 && !this.defined) {\n                        if (isFunction(factory)) {\n                            //If there is an error listener, favor passing\n                            //to that instead of throwing an error. However,\n                            //only do it for define()'d  modules. require\n                            //errbacks should not be called for failures in\n                            //their callbacks (#699). However if a global\n                            //onError is set, use that.\n                            if ((this.events.error && this.map.isDefine) ||\n                                req.onError !== defaultOnError) {\n                                try {\n                                    exports = context.execCb(id, factory, depExports, exports);\n                                } catch (e) {\n                                    err = e;\n                                }\n                            } else {\n                                exports = context.execCb(id, factory, depExports, exports);\n                            }\n\n                            // Favor return value over exports. If node/cjs in play,\n                            // then will not have a return value anyway. Favor\n                            // module.exports assignment over exports object.\n                            if (this.map.isDefine && exports === undefined) {\n                                cjsModule = this.module;\n                                if (cjsModule) {\n                                    exports = cjsModule.exports;\n                                } else if (this.usingExports) {\n                                    //exports already set the defined value.\n                                    exports = this.exports;\n                                }\n                            }\n\n                            if (err) {\n                                err.requireMap = this.map;\n                                err.requireModules = this.map.isDefine ? [this.map.id] : null;\n                                err.requireType = this.map.isDefine ? 'define' : 'require';\n                                return onError((this.error = err));\n                            }\n\n                        } else {\n                            //Just a literal value\n                            exports = factory;\n                        }\n\n                        this.exports = exports;\n\n                        if (this.map.isDefine && !this.ignore) {\n                            defined[id] = exports;\n\n                            if (req.onResourceLoad) {\n                                req.onResourceLoad(context, this.map, this.depMaps);\n                            }\n                        }\n\n                        //Clean up\n                        cleanRegistry(id);\n\n                        this.defined = true;\n                    }\n\n                    //Finished the define stage. Allow calling check again\n                    //to allow define notifications below in the case of a\n                    //cycle.\n                    this.defining = false;\n\n                    if (this.defined && !this.defineEmitted) {\n                        this.defineEmitted = true;\n                        this.emit('defined', this.exports);\n                        this.defineEmitComplete = true;\n                    }\n\n                }\n            },\n\n            callPlugin: function () {\n                var map = this.map,\n                    id = map.id,\n                    //Map already normalized the prefix.\n                    pluginMap = makeModuleMap(map.prefix);\n\n                //Mark this as a dependency for this plugin, so it\n                //can be traced for cycles.\n                this.depMaps.push(pluginMap);\n\n                on(pluginMap, 'defined', bind(this, function (plugin) {\n                    var load, normalizedMap, normalizedMod,\n                        bundleId = getOwn(bundlesMap, this.map.id),\n                        name = this.map.name,\n                        parentName = this.map.parentMap ? this.map.parentMap.name : null,\n                        localRequire = context.makeRequire(map.parentMap, {\n                            enableBuildCallback: true\n                        });\n\n                    //If current map is not normalized, wait for that\n                    //normalized name to load instead of continuing.\n                    if (this.map.unnormalized) {\n                        //Normalize the ID if the plugin allows it.\n                        if (plugin.normalize) {\n                            name = plugin.normalize(name, function (name) {\n                                return normalize(name, parentName, true);\n                            }) || '';\n                        }\n\n                        //prefix and name should already be normalized, no need\n                        //for applying map config again either.\n                        normalizedMap = makeModuleMap(map.prefix + '!' + name,\n                                                      this.map.parentMap);\n                        on(normalizedMap,\n                            'defined', bind(this, function (value) {\n                                this.init([], function () { return value; }, null, {\n                                    enabled: true,\n                                    ignore: true\n                                });\n                            }));\n\n                        normalizedMod = getOwn(registry, normalizedMap.id);\n                        if (normalizedMod) {\n                            //Mark this as a dependency for this plugin, so it\n                            //can be traced for cycles.\n                            this.depMaps.push(normalizedMap);\n\n                            if (this.events.error) {\n                                normalizedMod.on('error', bind(this, function (err) {\n                                    this.emit('error', err);\n                                }));\n                            }\n                            normalizedMod.enable();\n                        }\n\n                        return;\n                    }\n\n                    //If a paths config, then just load that file instead to\n                    //resolve the plugin, as it is built into that paths layer.\n                    if (bundleId) {\n                        this.map.url = context.nameToUrl(bundleId);\n                        this.load();\n                        return;\n                    }\n\n                    load = bind(this, function (value) {\n                        this.init([], function () { return value; }, null, {\n                            enabled: true\n                        });\n                    });\n\n                    load.error = bind(this, function (err) {\n                        this.inited = true;\n                        this.error = err;\n                        err.requireModules = [id];\n\n                        //Remove temp unnormalized modules for this module,\n                        //since they will never be resolved otherwise now.\n                        eachProp(registry, function (mod) {\n                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {\n                                cleanRegistry(mod.map.id);\n                            }\n                        });\n\n                        onError(err);\n                    });\n\n                    //Allow plugins to load other code without having to know the\n                    //context or how to 'complete' the load.\n                    load.fromText = bind(this, function (text, textAlt) {\n                        /*jslint evil: true */\n                        var moduleName = map.name,\n                            moduleMap = makeModuleMap(moduleName),\n                            hasInteractive = useInteractive;\n\n                        //As of 2.1.0, support just passing the text, to reinforce\n                        //fromText only being called once per resource. Still\n                        //support old style of passing moduleName but discard\n                        //that moduleName in favor of the internal ref.\n                        if (textAlt) {\n                            text = textAlt;\n                        }\n\n                        //Turn off interactive script matching for IE for any define\n                        //calls in the text, then turn it back on at the end.\n                        if (hasInteractive) {\n                            useInteractive = false;\n                        }\n\n                        //Prime the system by creating a module instance for\n                        //it.\n                        getModule(moduleMap);\n\n                        //Transfer any config to this other module.\n                        if (hasProp(config.config, id)) {\n                            config.config[moduleName] = config.config[id];\n                        }\n\n                        try {\n                            req.exec(text);\n                        } catch (e) {\n                            return onError(makeError('fromtexteval',\n                                             'fromText eval for ' + id +\n                                            ' failed: ' + e,\n                                             e,\n                                             [id]));\n                        }\n\n                        if (hasInteractive) {\n                            useInteractive = true;\n                        }\n\n                        //Mark this as a dependency for the plugin\n                        //resource\n                        this.depMaps.push(moduleMap);\n\n                        //Support anonymous modules.\n                        context.completeLoad(moduleName);\n\n                        //Bind the value of that module to the value for this\n                        //resource ID.\n                        localRequire([moduleName], load);\n                    });\n\n                    //Use parentName here since the plugin's name is not reliable,\n                    //could be some weird string with no path that actually wants to\n                    //reference the parentName's path.\n                    plugin.load(map.name, localRequire, load, config);\n                }));\n\n                context.enable(pluginMap, this);\n                this.pluginMaps[pluginMap.id] = pluginMap;\n            },\n\n            enable: function () {\n                enabledRegistry[this.map.id] = this;\n                this.enabled = true;\n\n                //Set flag mentioning that the module is enabling,\n                //so that immediate calls to the defined callbacks\n                //for dependencies do not trigger inadvertent load\n                //with the depCount still being zero.\n                this.enabling = true;\n\n                //Enable each dependency\n                each(this.depMaps, bind(this, function (depMap, i) {\n                    var id, mod, handler;\n\n                    if (typeof depMap === 'string') {\n                        //Dependency needs to be converted to a depMap\n                        //and wired up to this module.\n                        depMap = makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false,\n                                               !this.skipMap);\n                        this.depMaps[i] = depMap;\n\n                        handler = getOwn(handlers, depMap.id);\n\n                        if (handler) {\n                            this.depExports[i] = handler(this);\n                            return;\n                        }\n\n                        this.depCount += 1;\n\n                        on(depMap, 'defined', bind(this, function (depExports) {\n                            this.defineDep(i, depExports);\n                            this.check();\n                        }));\n\n                        if (this.errback) {\n                            on(depMap, 'error', bind(this, this.errback));\n                        } else if (this.events.error) {\n                            // No direct errback on this module, but something\n                            // else is listening for errors, so be sure to\n                            // propagate the error correctly.\n                            on(depMap, 'error', bind(this, function(err) {\n                                this.emit('error', err);\n                            }));\n                        }\n                    }\n\n                    id = depMap.id;\n                    mod = registry[id];\n\n                    //Skip special modules like 'require', 'exports', 'module'\n                    //Also, don't call enable if it is already enabled,\n                    //important in circular dependency cases.\n                    if (!hasProp(handlers, id) && mod && !mod.enabled) {\n                        context.enable(depMap, this);\n                    }\n                }));\n\n                //Enable each plugin that is used in\n                //a dependency\n                eachProp(this.pluginMaps, bind(this, function (pluginMap) {\n                    var mod = getOwn(registry, pluginMap.id);\n                    if (mod && !mod.enabled) {\n                        context.enable(pluginMap, this);\n                    }\n                }));\n\n                this.enabling = false;\n\n                this.check();\n            },\n\n            on: function (name, cb) {\n                var cbs = this.events[name];\n                if (!cbs) {\n                    cbs = this.events[name] = [];\n                }\n                cbs.push(cb);\n            },\n\n            emit: function (name, evt) {\n                each(this.events[name], function (cb) {\n                    cb(evt);\n                });\n                if (name === 'error') {\n                    //Now that the error handler was triggered, remove\n                    //the listeners, since this broken Module instance\n                    //can stay around for a while in the registry.\n                    delete this.events[name];\n                }\n            }\n        };\n\n        function callGetModule(args) {\n            //Skip modules already defined.\n            if (!hasProp(defined, args[0])) {\n                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);\n            }\n        }\n\n        function removeListener(node, func, name, ieName) {\n            //Favor detachEvent because of IE9\n            //issue, see attachEvent/addEventListener comment elsewhere\n            //in this file.\n            if (node.detachEvent && !isOpera) {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                if (ieName) {\n                    node.detachEvent(ieName, func);\n                }\n            } else {\n                node.removeEventListener(name, func, false);\n            }\n        }\n\n        /**\n         * Given an event from a script node, get the requirejs info from it,\n         * and then removes the event listeners on the node.\n         * @param {Event} evt\n         * @returns {Object}\n         */\n        function getScriptData(evt) {\n            //Using currentTarget instead of target for Firefox 2.0's sake. Not\n            //all old browsers will be supported, but this one was easy enough\n            //to support and still makes sense.\n            var node = evt.currentTarget || evt.srcElement;\n\n            //Remove the listeners once here.\n            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');\n            removeListener(node, context.onScriptError, 'error');\n\n            return {\n                node: node,\n                id: node && node.getAttribute('data-requiremodule')\n            };\n        }\n\n        function intakeDefines() {\n            var args;\n\n            //Any defined modules in the global queue, intake them now.\n            takeGlobalQueue();\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));\n                } else {\n                    //args are id, deps, factory. Should be normalized by the\n                    //define() function.\n                    callGetModule(args);\n                }\n            }\n        }\n\n        context = {\n            config: config,\n            contextName: contextName,\n            registry: registry,\n            defined: defined,\n            urlFetched: urlFetched,\n            defQueue: defQueue,\n            Module: Module,\n            makeModuleMap: makeModuleMap,\n            nextTick: req.nextTick,\n            onError: onError,\n\n            /**\n             * Set a configuration for the context.\n             * @param {Object} cfg config object to integrate.\n             */\n            configure: function (cfg) {\n                //Make sure the baseUrl ends in a slash.\n                if (cfg.baseUrl) {\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {\n                        cfg.baseUrl += '/';\n                    }\n                }\n\n                //Save off the paths since they require special processing,\n                //they are additive.\n                var shim = config.shim,\n                    objs = {\n                        paths: true,\n                        bundles: true,\n                        config: true,\n                        map: true\n                    };\n\n                eachProp(cfg, function (value, prop) {\n                    if (objs[prop]) {\n                        if (!config[prop]) {\n                            config[prop] = {};\n                        }\n                        mixin(config[prop], value, true, true);\n                    } else {\n                        config[prop] = value;\n                    }\n                });\n\n                //Reverse map the bundles\n                if (cfg.bundles) {\n                    eachProp(cfg.bundles, function (value, prop) {\n                        each(value, function (v) {\n                            if (v !== prop) {\n                                bundlesMap[v] = prop;\n                            }\n                        });\n                    });\n                }\n\n                //Merge shim\n                if (cfg.shim) {\n                    eachProp(cfg.shim, function (value, id) {\n                        //Normalize the structure\n                        if (isArray(value)) {\n                            value = {\n                                deps: value\n                            };\n                        }\n                        if ((value.exports || value.init) && !value.exportsFn) {\n                            value.exportsFn = context.makeShimExports(value);\n                        }\n                        shim[id] = value;\n                    });\n                    config.shim = shim;\n                }\n\n                //Adjust packages if necessary.\n                if (cfg.packages) {\n                    each(cfg.packages, function (pkgObj) {\n                        var location, name;\n\n                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;\n\n                        name = pkgObj.name;\n                        location = pkgObj.location;\n                        if (location) {\n                            config.paths[name] = pkgObj.location;\n                        }\n\n                        //Save pointer to main module ID for pkg name.\n                        //Remove leading dot in main, so main paths are normalized,\n                        //and remove any trailing .js, since different package\n                        //envs have different conventions: some use a module name,\n                        //some use a file name.\n                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')\n                                     .replace(currDirRegExp, '')\n                                     .replace(jsSuffixRegExp, '');\n                    });\n                }\n\n                //If there are any \"waiting to execute\" modules in the registry,\n                //update the maps for them, since their info, like URLs to load,\n                //may have changed.\n                eachProp(registry, function (mod, id) {\n                    //If module already has init called, since it is too\n                    //late to modify them, and ignore unnormalized ones\n                    //since they are transient.\n                    if (!mod.inited && !mod.map.unnormalized) {\n                        mod.map = makeModuleMap(id);\n                    }\n                });\n\n                //If a deps array or a config callback is specified, then call\n                //require with those args. This is useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.deps || cfg.callback) {\n                    context.require(cfg.deps || [], cfg.callback);\n                }\n            },\n\n            makeShimExports: function (value) {\n                function fn() {\n                    var ret;\n                    if (value.init) {\n                        ret = value.init.apply(global, arguments);\n                    }\n                    return ret || (value.exports && getGlobal(value.exports));\n                }\n                return fn;\n            },\n\n            makeRequire: function (relMap, options) {\n                options = options || {};\n\n                function localRequire(deps, callback, errback) {\n                    var id, map, requireMod;\n\n                    if (options.enableBuildCallback && callback && isFunction(callback)) {\n                        callback.__requireJsBuild = true;\n                    }\n\n                    if (typeof deps === 'string') {\n                        if (isFunction(callback)) {\n                            //Invalid call\n                            return onError(makeError('requireargs', 'Invalid require call'), errback);\n                        }\n\n                        //If require|exports|module are requested, get the\n                        //value for them from the special handlers. Caveat:\n                        //this only works while module is being defined.\n                        if (relMap && hasProp(handlers, deps)) {\n                            return handlers[deps](registry[relMap.id]);\n                        }\n\n                        //Synchronous access to one module. If require.get is\n                        //available (as in the Node adapter), prefer that.\n                        if (req.get) {\n                            return req.get(context, deps, relMap, localRequire);\n                        }\n\n                        //Normalize module name, if it contains . or ..\n                        map = makeModuleMap(deps, relMap, false, true);\n                        id = map.id;\n\n                        if (!hasProp(defined, id)) {\n                            return onError(makeError('notloaded', 'Module name \"' +\n                                        id +\n                                        '\" has not been loaded yet for context: ' +\n                                        contextName +\n                                        (relMap ? '' : '. Use require([])')));\n                        }\n                        return defined[id];\n                    }\n\n                    //Grab defines waiting in the global queue.\n                    intakeDefines();\n\n                    //Mark all the dependencies as needing to be loaded.\n                    context.nextTick(function () {\n                        //Some defines could have been added since the\n                        //require call, collect them.\n                        intakeDefines();\n\n                        requireMod = getModule(makeModuleMap(null, relMap));\n\n                        //Store if map config should be applied to this require\n                        //call for dependencies.\n                        requireMod.skipMap = options.skipMap;\n\n                        requireMod.init(deps, callback, errback, {\n                            enabled: true\n                        });\n\n                        checkLoaded();\n                    });\n\n                    return localRequire;\n                }\n\n                mixin(localRequire, {\n                    isBrowser: isBrowser,\n\n                    /**\n                     * Converts a module name + .extension into an URL path.\n                     * *Requires* the use of a module name. It does not support using\n                     * plain URLs like nameToUrl.\n                     */\n                    toUrl: function (moduleNamePlusExt) {\n                        var ext,\n                            index = moduleNamePlusExt.lastIndexOf('.'),\n                            segment = moduleNamePlusExt.split('/')[0],\n                            isRelative = segment === '.' || segment === '..';\n\n                        //Have a file extension alias, and it is not the\n                        //dots from a relative path.\n                        if (index !== -1 && (!isRelative || index > 1)) {\n                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n                        }\n\n                        return context.nameToUrl(normalize(moduleNamePlusExt,\n                                                relMap && relMap.id, true), ext,  true);\n                    },\n\n                    defined: function (id) {\n                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);\n                    },\n\n                    specified: function (id) {\n                        id = makeModuleMap(id, relMap, false, true).id;\n                        return hasProp(defined, id) || hasProp(registry, id);\n                    }\n                });\n\n                //Only allow undef on top level require calls\n                if (!relMap) {\n                    localRequire.undef = function (id) {\n                        //Bind any waiting define() calls to this context,\n                        //fix for #408\n                        takeGlobalQueue();\n\n                        var map = makeModuleMap(id, relMap, true),\n                            mod = getOwn(registry, id);\n\n                        removeScript(id);\n\n                        delete defined[id];\n                        delete urlFetched[map.url];\n                        delete undefEvents[id];\n\n                        //Clean queued defines too. Go backwards\n                        //in array so that the splices do not\n                        //mess up the iteration.\n                        eachReverse(defQueue, function(args, i) {\n                            if(args[0] === id) {\n                                defQueue.splice(i, 1);\n                            }\n                        });\n\n                        if (mod) {\n                            //Hold on to listeners in case the\n                            //module will be attempted to be reloaded\n                            //using a different config.\n                            if (mod.events.defined) {\n                                undefEvents[id] = mod.events;\n                            }\n\n                            cleanRegistry(id);\n                        }\n                    };\n                }\n\n                return localRequire;\n            },\n\n            /**\n             * Called to enable a module if it is still in the registry\n             * awaiting enablement. A second arg, parent, the parent module,\n             * is passed in for context, when this method is overridden by\n             * the optimizer. Not shown here to keep code compact.\n             */\n            enable: function (depMap) {\n                var mod = getOwn(registry, depMap.id);\n                if (mod) {\n                    getModule(depMap).enable();\n                }\n            },\n\n            /**\n             * Internal method used by environment adapters to complete a load event.\n             * A load event could be a script load or just a load pass from a synchronous\n             * load call.\n             * @param {String} moduleName the name of the module to potentially complete.\n             */\n            completeLoad: function (moduleName) {\n                var found, args, mod,\n                    shim = getOwn(config.shim, moduleName) || {},\n                    shExports = shim.exports;\n\n                takeGlobalQueue();\n\n                while (defQueue.length) {\n                    args = defQueue.shift();\n                    if (args[0] === null) {\n                        args[0] = moduleName;\n                        //If already found an anonymous module and bound it\n                        //to this name, then this is some other anon module\n                        //waiting for its completeLoad to fire.\n                        if (found) {\n                            break;\n                        }\n                        found = true;\n                    } else if (args[0] === moduleName) {\n                        //Found matching define call for this script!\n                        found = true;\n                    }\n\n                    callGetModule(args);\n                }\n\n                //Do this after the cycle of callGetModule in case the result\n                //of those calls/init calls changes the registry.\n                mod = getOwn(registry, moduleName);\n\n                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {\n                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {\n                        if (hasPathFallback(moduleName)) {\n                            return;\n                        } else {\n                            return onError(makeError('nodefine',\n                                             'No define call for ' + moduleName,\n                                             null,\n                                             [moduleName]));\n                        }\n                    } else {\n                        //A script that does not call define(), so just simulate\n                        //the call for it.\n                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);\n                    }\n                }\n\n                checkLoaded();\n            },\n\n            /**\n             * Converts a module name to a file path. Supports cases where\n             * moduleName may actually be just an URL.\n             * Note that it **does not** call normalize on the moduleName,\n             * it is assumed to have already been normalized. This is an\n             * internal API, not a public one. Use toUrl for the public API.\n             */\n            nameToUrl: function (moduleName, ext, skipExt) {\n                var paths, syms, i, parentModule, url,\n                    parentPath, bundleId,\n                    pkgMain = getOwn(config.pkgs, moduleName);\n\n                if (pkgMain) {\n                    moduleName = pkgMain;\n                }\n\n                bundleId = getOwn(bundlesMap, moduleName);\n\n                if (bundleId) {\n                    return context.nameToUrl(bundleId, ext, skipExt);\n                }\n\n                //If a colon is in the URL, it indicates a protocol is used and it is just\n                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)\n                //or ends with .js, then assume the user meant to use an url and not a module id.\n                //The slash is important for protocol-less URLs as well as full paths.\n                if (req.jsExtRegExp.test(moduleName)) {\n                    //Just a plain path, not module name lookup, so just return it.\n                    //Add extension if it is included. This is a bit wonky, only non-.js things pass\n                    //an extension, this method probably needs to be reworked.\n                    url = moduleName + (ext || '');\n                } else {\n                    //A module that needs to be converted to a path.\n                    paths = config.paths;\n\n                    syms = moduleName.split('/');\n                    //For each module name segment, see if there is a path\n                    //registered for it. Start with most specific name\n                    //and work up from it.\n                    for (i = syms.length; i > 0; i -= 1) {\n                        parentModule = syms.slice(0, i).join('/');\n\n                        parentPath = getOwn(paths, parentModule);\n                        if (parentPath) {\n                            //If an array, it means there are a few choices,\n                            //Choose the one that is desired\n                            if (isArray(parentPath)) {\n                                parentPath = parentPath[0];\n                            }\n                            syms.splice(0, i, parentPath);\n                            break;\n                        }\n                    }\n\n                    //Join the path parts together, then figure out if baseUrl is needed.\n                    url = syms.join('/');\n                    url += (ext || (/^data\\:|\\?/.test(url) || skipExt ? '' : '.js'));\n                    url = (url.charAt(0) === '/' || url.match(/^[\\w\\+\\.\\-]+:/) ? '' : config.baseUrl) + url;\n                }\n\n                return config.urlArgs ? url +\n                                        ((url.indexOf('?') === -1 ? '?' : '&') +\n                                         config.urlArgs) : url;\n            },\n\n            //Delegates to req.load. Broken out as a separate function to\n            //allow overriding in the optimizer.\n            load: function (id, url) {\n                req.load(context, id, url);\n            },\n\n            /**\n             * Executes a module callback function. Broken out as a separate function\n             * solely to allow the build system to sequence the files in the built\n             * layer in the right sequence.\n             *\n             * @private\n             */\n            execCb: function (name, callback, args, exports) {\n                return callback.apply(exports, args);\n            },\n\n            /**\n             * callback for script loads, used to check status of loading.\n             *\n             * @param {Event} evt the event from the browser for the script\n             * that was loaded.\n             */\n            onScriptLoad: function (evt) {\n                //Using currentTarget instead of target for Firefox 2.0's sake. Not\n                //all old browsers will be supported, but this one was easy enough\n                //to support and still makes sense.\n                if (evt.type === 'load' ||\n                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {\n                    //Reset interactive script so a script node is not held onto for\n                    //to long.\n                    interactiveScript = null;\n\n                    //Pull out the name of the module and the context.\n                    var data = getScriptData(evt);\n                    context.completeLoad(data.id);\n                }\n            },\n\n            /**\n             * Callback for script errors.\n             */\n            onScriptError: function (evt) {\n                var data = getScriptData(evt);\n                if (!hasPathFallback(data.id)) {\n                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));\n                }\n            }\n        };\n\n        context.require = context.makeRequire();\n        return context;\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     *\n     * Make a local req variable to help Caja compliance (it assumes things\n     * on a require that are not standardized), and to give a short\n     * name for minification/local scope use.\n     */\n    req = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n\n        context = getOwn(contexts, contextName);\n        if (!context) {\n            context = contexts[contextName] = req.s.newContext(contextName);\n        }\n\n        if (config) {\n            context.configure(config);\n        }\n\n        return context.require(deps, callback, errback);\n    };\n\n    /**\n     * Support require.config() to make it easier to cooperate with other\n     * AMD loaders on globally agreed names.\n     */\n    req.config = function (config) {\n        return req(config);\n    };\n\n    /**\n     * Execute something after the current tick\n     * of the event loop. Override for other envs\n     * that have a better solution than setTimeout.\n     * @param  {Function} fn function to execute later.\n     */\n    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\n        setTimeout(fn, 4);\n    } : function (fn) { fn(); };\n\n    /**\n     * Export require as a global, but only if it does not already exist.\n     */\n    if (!require) {\n        require = req;\n    }\n\n    req.version = version;\n\n    //Used to filter out dependencies that are already paths.\n    req.jsExtRegExp = /^\\/|:|\\?|\\.js$/;\n    req.isBrowser = isBrowser;\n    s = req.s = {\n        contexts: contexts,\n        newContext: newContext\n    };\n\n    //Create default context.\n    req({});\n\n    //Exports some context-sensitive methods on global require.\n    each([\n        'toUrl',\n        'undef',\n        'defined',\n        'specified'\n    ], function (prop) {\n        //Reference from contexts instead of early binding to default context,\n        //so that during builds, the latest instance of the default context\n        //with its config gets used.\n        req[prop] = function () {\n            var ctx = contexts[defContextName];\n            return ctx.require[prop].apply(ctx, arguments);\n        };\n    });\n\n    if (isBrowser) {\n        head = s.head = document.getElementsByTagName('head')[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName('base')[0];\n        if (baseElement) {\n            head = s.head = baseElement.parentNode;\n        }\n    }\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * @param {Error} err the error object.\n     */\n    req.onError = defaultOnError;\n\n    /**\n     * Creates the node for the load command. Only used in browser envs.\n     */\n    req.createNode = function (config, moduleName, url) {\n        var node = config.xhtml ?\n                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :\n                document.createElement('script');\n        node.type = config.scriptType || 'text/javascript';\n        node.charset = 'utf-8';\n        node.async = true;\n        return node;\n    };\n\n    /**\n     * Does the request to load a module for the browser case.\n     * Make this a separate function to allow other environments\n     * to override it.\n     *\n     * @param {Object} context the require context to find state.\n     * @param {String} moduleName the name of the module.\n     * @param {Object} url the URL to the module.\n     */\n    req.load = function (context, moduleName, url) {\n        var config = (context && context.config) || {},\n            node;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            node = req.createNode(config, moduleName, url);\n\n            node.setAttribute('data-requirecontext', context.contextName);\n            node.setAttribute('data-requiremodule', moduleName);\n\n            //Set up load listener. Test attachEvent first because IE9 has\n            //a subtle issue in its addEventListener and script onload firings\n            //that do not match the behavior of all other browsers with\n            //addEventListener support, which fire the onload event for a\n            //script right after the script execution. See:\n            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n            //UNFORTUNATELY Opera implements attachEvent but does not follow the script\n            //script execution mode.\n            if (node.attachEvent &&\n                    //Check if node.attachEvent is artificially added by custom script or\n                    //natively supported by browser\n                    //read https://github.com/jrburke/requirejs/issues/187\n                    //if we can NOT find [native code] then it must NOT natively supported.\n                    //in IE8, node.attachEvent does not have toString()\n                    //Note the test for \"[native code\" with no closing brace, see:\n                    //https://github.com/jrburke/requirejs/issues/273\n                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n                    !isOpera) {\n                //Probably IE. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous define call to a name.\n                //However, IE reports the script as being in 'interactive'\n                //readyState at the time of the define call.\n                useInteractive = true;\n\n                node.attachEvent('onreadystatechange', context.onScriptLoad);\n                //It would be great to add an error handler here to catch\n                //404s in IE9+. However, onreadystatechange will fire before\n                //the error handler, so that does not help. If addEventListener\n                //is used, then IE will fire error before load, but we cannot\n                //use that pathway given the connect.microsoft.com issue\n                //mentioned above about not doing the 'script execute,\n                //then fire the script load event listener before execute\n                //next script' that other browsers do.\n                //Best hope: IE10 fixes the issues,\n                //and then destroys all installs of IE 6-9.\n                //node.attachEvent('onerror', context.onScriptError);\n            } else {\n                node.addEventListener('load', context.onScriptLoad, false);\n                node.addEventListener('error', context.onScriptError, false);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous define\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                head.insertBefore(node, baseElement);\n            } else {\n                head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n\n            return node;\n        } else if (isWebWorker) {\n            try {\n                //In a web worker, use importScripts. This is not a very\n                //efficient use of importScripts, importScripts will block until\n                //its script is downloaded and evaluated. However, if web workers\n                //are in play, the expectation that a build has been done so that\n                //only one script needs to be loaded anyway. This may need to be\n                //reevaluated if other use cases become common.\n                importScripts(url);\n\n                //Account for anonymous modules\n                context.completeLoad(moduleName);\n            } catch (e) {\n                context.onError(makeError('importscripts',\n                                'importScripts failed for ' +\n                                    moduleName + ' at ' + url,\n                                e,\n                                [moduleName]));\n            }\n        }\n    };\n\n    function getInteractiveScript() {\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\n            return interactiveScript;\n        }\n\n        eachReverse(scripts(), function (script) {\n            if (script.readyState === 'interactive') {\n                return (interactiveScript = script);\n            }\n        });\n        return interactiveScript;\n    }\n\n    //Look for a data-main script attribute, which could also adjust the baseUrl.\n    if (isBrowser && !cfg.skipDataMain) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        eachReverse(scripts(), function (script) {\n            //Set the 'head' where we can append children by\n            //using the script's parent.\n            if (!head) {\n                head = script.parentNode;\n            }\n\n            //Look for a data-main attribute to set main script for the page\n            //to load. If it is there, the path to data main becomes the\n            //baseUrl, if it is not already set.\n            dataMain = script.getAttribute('data-main');\n            if (dataMain) {\n                //Preserve dataMain in case it is a path (i.e. contains '?')\n                mainScript = dataMain;\n\n                //Set final baseUrl if there is not already an explicit one.\n                if (!cfg.baseUrl) {\n                    //Pull off the directory of data-main for use as the\n                    //baseUrl.\n                    src = mainScript.split('/');\n                    mainScript = src.pop();\n                    subPath = src.length ? src.join('/')  + '/' : './';\n\n                    cfg.baseUrl = subPath;\n                }\n\n                //Strip off any trailing .js since mainScript is now\n                //like a module name.\n                mainScript = mainScript.replace(jsSuffixRegExp, '');\n\n                 //If mainScript is still a path, fall back to dataMain\n                if (req.jsExtRegExp.test(mainScript)) {\n                    mainScript = dataMain;\n                }\n\n                //Put the data-main script in the files to load.\n                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\n\n                return true;\n            }\n        });\n    }\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument's\n     * name.\n     */\n    define = function (name, deps, callback) {\n        var node, context;\n\n        //Allow for anonymous modules\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!isArray(deps)) {\n            callback = deps;\n            deps = null;\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!deps && isFunction(callback)) {\n            deps = [];\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies,\n            //but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, '')\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and module. Avoid doing exports and module\n                //work though if it just needs require.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (node) {\n                if (!name) {\n                    name = node.getAttribute('data-requiremodule');\n                }\n                context = contexts[node.getAttribute('data-requirecontext')];\n            }\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n\n\n    /**\n     * Executes the text. Normally just uses eval, but can be modified\n     * to use a better, environment-specific call. Only used for transpiling\n     * loader plugins, not for plain JS modules.\n     * @param {String} text the text to execute/evaluate.\n     */\n    req.exec = function (text) {\n        /*jslint evil: true */\n        return eval(text);\n    };\n\n    //Set up with config info.\n    req(cfg);\n}(this));\n\ndefine(\"../node_modules/requirejs/require\", function(){});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author mmaroti / https://github.com/mmaroti\r\n */\r\n\r\n\r\ndefine('common/util/assert',[],function () {\r\n    'use strict';\r\n\r\n    var assert = function (cond, msg) {\r\n        if (!cond) {\r\n            var error = new Error(msg || 'ASSERT failed');\r\n\r\n            if (typeof TESTING === 'undefined') {\r\n                console.log('Throwing', error.stack);\r\n                console.log();\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    return assert;\r\n});\r\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author rkereskenyi / https://github.com/rkereskenyi\n */\n\ndefine('common/EventDispatcher',[], function () {\n    'use strict';\n\n    var EventDispatcher = function () {\n        this._eventList = {};\n    };\n\n    EventDispatcher.prototype = {\n        _eventList: null,\n        _getEvent: function (eventName, create) {\n            // Check if Array of Event Handlers has been created\n            if (!this._eventList[eventName]) {\n\n                // Check if the calling method wants to create the Array\n                // if not created. This reduces unneeded memory usage.\n                if (!create) {\n                    return null;\n                }\n\n                // Create the Array of Event Handlers\n                this._eventList[eventName] = [];\n                // new Array\n            }\n\n            // return the Array of Event Handlers already added\n            return this._eventList[eventName];\n        },\n        addEventListener: function (eventName, handler) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName, true);\n\n            // Add the new Event Handler to the Array\n            evt.push(handler);\n        },\n        removeEventListener: function (eventName, handler) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName);\n\n            if (!evt) {\n                return;\n            }\n\n            // Helper Method - an Array.indexOf equivalent\n            var getArrayIndex = function (array, item) {\n                for (var i = 0; i < array.length; i++) {\n                    if (array[i] === item) {\n                        return i;\n                    }\n                }\n                return -1;\n            };\n\n            // Get the Array index of the Event Handler\n            var index = getArrayIndex(evt, handler);\n\n            if (index > -1) {\n                // Remove Event Handler from Array\n                evt.splice(index, 1);\n            }\n        },\n        removeAllEventListeners: function (eventName) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName);\n\n            if (!evt) {\n                return;\n            }\n\n            evt.splice(0, evt.length);\n        },\n        dispatchEvent: function (eventName, eventArgs) {\n            // Get a function that will call all the Event Handlers internally\n            var handler = this._getEventHandler(eventName);\n            if (handler) {\n                // call the handler function\n                // Pass in \"sender\" and \"eventArgs\" parameters\n                handler(this, eventArgs);\n            }\n        },\n        _getEventHandler: function (eventName) {\n            // Get Event Handler Array for this Event\n            var evt = this._getEvent(eventName, false);\n            if (!evt || evt.length === 0) {\n                return null;\n            }\n\n            // Create the Handler method that will use currying to\n            // call all the Events Handlers internally\n            var h = function (sender, args) {\n                for (var i = 0; i < evt.length; i++) {\n                    evt[i](sender, args);\n                }\n            };\n\n            // Return this new Handler method\n            return h;\n        }\n    };\n\n    return EventDispatcher;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true, bitwise: false*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/util/guid',[],function () {\n    'use strict';\n\n    var guid = function () {\n        var S4 = function () {\n            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n        };\n\n        //return GUID\n        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());\n    };\n\n    return guid;\n});\n",
    "//jshint ignore: start\n//SHA1 in Javascript 862 bytes, MIT License, http://antimatter15.com/\ndefine('common/util/sha1',[],function() {\nreturn function(l){function p(b,a){return b<<a|b>>>32-a}l+=\"\";for(var n=Math,c=[1518500249,1859775393,2400959708,3395469782,1732584193,4023233417,2562383102,271733878,3285377520,4294967295],s=n.ceil(l.length/4)+2,q=n.ceil(s/16),g=[],a=0,h=[],j,d,e,f,m,i,b,k;a<q;a++){g[a]=[];for(k=0;k<16;k++){function o(b,c){return l.charCodeAt(a*64+k*4+b)<<c}g[a][k]=o(0,24)|o(1,16)|o(2,8)|o(3,0)}}i=l.length*8-8;a=q-1;g[a][14]=i/(c[9]+1);g[a][14]=n.floor(g[a][14]);g[a][15]=i&c[9];for(a=0;a<q;a++){for(b=0;b<16;b++)h[b]=g[a][b];for(b=16;b<80;b++)h[b]=p(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);j=c[4];d=c[5];e=c[6];f=c[7];m=c[8];for(b=0;b<80;b++){var r=n.floor(b/20),t=p(j,5)+(r<1?d&e^~d&f:r==2?d&e^d&f^e&f:d^e^f)+m+c[r]+h[b]&c[9];m=f;f=e;e=p(d,30);d=j;j=t}c[4]+=j;c[5]+=d;c[6]+=e;c[7]+=f;c[8]+=m}i=\"\";for(z=4;z<9;z++)for(a=7;a>=0;a--)i+=((c[z]&c[9])>>>a*4&15).toString(16);return i};\n});\n\n",
    "//jshint ignore: start\ndefine('common/util/zssha1.min',[],function(){\n    function SHA1() {\n\n        this.pp = function (b, a) {\n            return b << a | b >>> 32 - a\n        };\n\n        this.oo = function (l, a, k, b, c) {\n            try{\n                return l.charCodeAt(a * 64 + k * 4 + b) << c\n            } catch(e){}\n        };\n\n        this.getHash = function(l) {\n\n            l += \"\";\n            for (var n = Math, c = [1518500249, 1859775393, 2400959708, 3395469782, 1732584193, 4023233417, 2562383102, 271733878, 3285377520, 4294967295], s = n.ceil(l.length / 4) + 2, q = n.ceil(s / 16), g = [], a = 0, h = [], j, d, e, f, m, i, b, k; a < q; a++) {\n                g[a] = [];\n                for (k = 0; k < 16; k++) {\n                    g[a][k] = this.oo(l, a, k, 0, 24) | this.oo(l, a, k, 1, 16) | this.oo(l, a, k, 2, 8) | this.oo(l, a, k, 3, 0)\n                }\n            }\n            i = l.length * 8 - 8;\n            a = q - 1;\n            g[a][14] = i / (c[9] + 1);\n            g[a][14] = n.floor(g[a][14]);\n            g[a][15] = i & c[9];\n            for (a = 0; a < q; a++) {\n                for (b = 0; b < 16; b++)h[b] = g[a][b];\n                for (b = 16; b < 80; b++)h[b] = this.pp(h[b - 3] ^ h[b - 8] ^ h[b - 14] ^ h[b - 16], 1);\n                j = c[4];\n                d = c[5];\n                e = c[6];\n                f = c[7];\n                m = c[8];\n                for (b = 0; b < 80; b++) {\n                    var r = n.floor(b / 20), t = this.pp(j, 5) + (r < 1 ? d & e ^ ~d & f : r == 2 ? d & e ^ d & f ^ e & f : d ^ e ^ f) + m + c[r] + h[b] & c[9];\n                    m = f;\n                    f = e;\n                    e = this.pp(d, 30);\n                    d = j;\n                    j = t\n                }\n                c[4] += j;\n                c[5] += d;\n                c[6] += e;\n                c[7] += f;\n                c[8] += m\n            }\n            i = \"\";\n            for (z = 4; z < 9; z++)\n                for (a = 7; a >= 0; a--)\n                    i += ((c[z] & c[9]) >>> a * 4 & 15).toString(16);\n            return i\n        };\n    }\n\n    return SHA1;\n});\n\n",
    "//jshint ignore: start\n/* 2012 David Chambers <dc@hashify.me>  */\ndefine('common/util/canon',[], function() {\n    var CANON = {},\n        keys, map, nativeMap, pad,\n        __slice = [].slice,\n        __hasProp = {}.hasOwnProperty;\n\n\n    CANON.stringify = (function() {\n        var canonicalize;\n        canonicalize = function(value) {\n            var pair, _ref;\n            switch (Object.prototype.toString.call(value)) {\n                case '[object Array]':\n                    return ['Array'].concat(__slice.call(map(value, canonicalize)));\n                case '[object Date]':\n                    return ['Date'].concat(isFinite(+value) ? value.getUTCFullYear() + '-' + pad(value.getUTCMonth() + 1) + '-' + pad(value.getUTCDate()) + 'T' + pad(value.getUTCHours()) + ':' + pad(value.getUTCMinutes()) + ':' + pad(value.getUTCSeconds()) + '.' + pad(value.getUTCMilliseconds(), 3) + 'Z' : null);\n                case '[object Function]':\n                    throw new TypeError('functions cannot be serialized');\n                    break;\n                case '[object Number]':\n                    if (isFinite(value)) {\n                        return value;\n                    } else {\n                        return ['Number', \"\" + value];\n                    }\n                    break;\n                case '[object Object]':\n                    pair = function(key) {\n                        return [key, canonicalize(value[key])];\n                    };\n                    return (_ref = ['Object']).concat.apply(_ref, map(keys(value).sort(), pair));\n                case '[object RegExp]':\n                    return ['RegExp', \"\" + value];\n                case '[object Undefined]':\n                    return ['Undefined'];\n                default:\n                    return value;\n            }\n        };\n        return function(value) {\n            return JSON.stringify(canonicalize(value));\n        };\n    })();\n\n    CANON.parse = (function() {\n        var canonicalize;\n        canonicalize = function(value) {\n            var element, elements, idx, object, what, _i, _ref;\n            if (Object.prototype.toString.call(value) !== '[object Array]') {\n                return value;\n            }\n            what = value[0], elements = 2 <= value.length ? __slice.call(value, 1) : [];\n            element = elements[0];\n            switch (what) {\n                case 'Array':\n                    return map(elements, canonicalize);\n                case 'Date':\n                    return new Date(element);\n                case 'Number':\n                    return +element;\n                case 'Object':\n                    object = {};\n                    for (idx = _i = 0, _ref = elements.length; _i < _ref; idx = _i += 2) {\n                        object[elements[idx]] = canonicalize(elements[idx + 1]);\n                    }\n                    return object;\n                case 'RegExp':\n                    return (function(func, args, ctor) {\n                        ctor.prototype = func.prototype;\n                        var child = new ctor, result = func.apply(child, args);\n                        return Object(result) === result ? result : child;\n                    })(RegExp, /^[/](.+)[/]([gimy]*)$/.exec(element).slice(1), function(){});\n                case 'Undefined':\n                    return void 0;\n                default:\n                    throw new Error('invalid input');\n            }\n        };\n        return function(string) {\n            return canonicalize(JSON.parse(string));\n        };\n    })();\n\n    nativeMap = Array.prototype.map;\n\n    map = function(array, iterator) {\n        var el, _i, _len, _results;\n        if (nativeMap && array.map === nativeMap) {\n            return array.map(iterator);\n        } else {\n            _results = [];\n            for (_i = 0, _len = array.length; _i < _len; _i++) {\n                el = array[_i];\n                _results.push(iterator(el));\n            }\n            return _results;\n        }\n    };\n\n    keys = Object.keys || function(object) {\n        var key, _results;\n        _results = [];\n        for (key in object) {\n            if (!__hasProp.call(object, key)) continue;\n            _results.push(key);\n        }\n        return _results;\n    };\n\n    pad = function(n, min) {\n        if (min == null) {\n            min = 2;\n        }\n        return (\"\" + (1000 + n)).substr(4 - min);\n    };\n\n    return CANON;\n\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/util/key',[\n    'common/util/sha1',\n    'common/util/zssha1.min',\n    'common/util/assert',\n    'common/util/canon'\n], function (SHA1, ZS, ASSERT, CANON) {\n    'use strict';\n\n    var keyType = null,\n        ZSSHA = new ZS();\n\n    function rand160Bits() {\n        var result = '',\n            i, code;\n        for (i = 0; i < 40; i++) {\n            code = Math.floor(Math.random() * 16);\n            code = code > 9 ? code + 87 : code + 48;\n            result += String.fromCharCode(code);\n        }\n        return result;\n    }\n\n    return function KeyGenerator(object, gmeConfig) {\n        keyType = gmeConfig.storage.keyType;\n        ASSERT(typeof keyType === 'string');\n\n        switch (keyType) {\n            case 'rand160Bits':\n                return rand160Bits();\n            case 'ZSSHA':\n                return ZSSHA.getHash(CANON.stringify(object));\n            default: //plainSHA1\n                return SHA1(CANON.stringify(object));\n        }\n    };\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/future',[], function () {\n    'use strict';\n\n    var maxDepth = 5;\n\n    var ASSERT = function (cond) {\n        if (!cond) {\n            var error = new Error('future assertion failed');\n            console.log(error.stack);\n            throw error;\n        }\n    };\n\n    // ------- Future -------\n\n    var UNRESOLVED = {};\n\n    var Future = function () {\n        this.value = UNRESOLVED;\n        this.listener = null;\n        this.param = null;\n    };\n\n    var setValue = function (future, value) {\n        ASSERT(future instanceof Future && future.value === UNRESOLVED);\n\n        if (value instanceof Future) {\n            setListener(value, setValue, future);\n        } else {\n            future.value = value;\n\n            if (future.listener !== null) {\n                future.listener(future.param, value);\n            }\n        }\n    };\n\n    var setListener = function (future, listener, param) {\n        ASSERT(future instanceof Future && future.listener === null && future.value === UNRESOLVED);\n        ASSERT(typeof listener === 'function' && listener.length === 2);\n\n        future.listener = listener;\n        future.param = param;\n\n        if (future.value !== UNRESOLVED) {\n            listener(param, future);\n        }\n    };\n\n    var isUnresolved = function (value) {\n        return (value instanceof Future) && value.value === UNRESOLVED;\n    };\n\n    var getValue = function (value) {\n        if (value instanceof Future) {\n            if (value.value instanceof Error) {\n                throw value.value;\n            } else if (value.value !== UNRESOLVED) {\n                return value.value;\n            }\n        }\n        return value;\n    };\n\n    // ------- adapt\n\n    var adapt = function (func) {\n        ASSERT(typeof func === 'function');\n\n        return function adaptx() {\n            var args = arguments;\n            var future = new Future();\n\n            args[args.length++] = function adaptCallback(error, value) {\n                if (error) {\n                    value = error instanceof Error ? error : new Error(error);\n                } else {\n                    ASSERT(!(value instanceof Error));\n                }\n                setValue(future, value);\n            };\n\n            func.apply(this, args);\n\n            return getValue(future);\n        };\n    };\n\n    var unadapt = function (func) {\n        ASSERT(typeof func === 'function');\n\n        if (func.length === 0) {\n            return function unadapt0(callback) {\n                var value;\n                try {\n                    value = func.call(this);\n                } catch (error) {\n                    callback(error);\n                    return;\n                }\n                then(value, callback);\n            };\n        } else if (func.length === 1) {\n            return function unadapt1(arg, callback) {\n                var value;\n                try {\n                    value = func.call(this, arg);\n                } catch (error) {\n                    callback(error);\n                    return;\n                }\n                then(value, callback);\n            };\n        } else {\n            return function unadaptx() {\n                var args = arguments;\n\n                var callback = args[--args.length];\n                ASSERT(typeof callback === 'function');\n\n                var value;\n                try {\n                    value = func.apply(this, args);\n                } catch (error) {\n                    callback(error);\n                    return;\n                }\n                then(value, callback);\n            };\n        }\n    };\n\n    var delay = function (delay, value) {\n        var future = new Future();\n        setTimeout(setValue, delay, future, value);\n        return future;\n    };\n\n    // ------- call -------\n\n    var Func = function (func, that, args, index) {\n        this.value = UNRESOLVED;\n        this.listener = null;\n        this.param = null;\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n        this.index = index;\n\n        setListener(args[index], setArgument, this);\n    };\n\n    Func.prototype = Future.prototype;\n\n    var setArgument = function (future, value) {\n        if (!(value instanceof Error)) {\n            try {\n                var args = future.args;\n                args[future.index] = value;\n\n                while (++future.index < args.length) {\n                    value = args[future.index];\n                    if (isUnresolved(value)) {\n                        setListener(value, setArgument, future);\n                        return;\n                    } else {\n                        args[future.index] = getValue(value);\n                    }\n                }\n\n                value = future.func.apply(future.that, args);\n                ASSERT(!(value instanceof Error));\n            } catch (error) {\n                value = error instanceof Error ? error : new Error(error);\n            }\n        }\n\n        setValue(future, value);\n    };\n\n    var call = function () {\n        var args = arguments;\n\n        var func = args[--args.length];\n        ASSERT(typeof func === 'function');\n\n        for (var i = 0; i < args.length; ++i) {\n            if (isUnresolved(args[i])) {\n                return new Func(func, this, args, i);\n            } else {\n                args[i] = getValue(args[i]);\n            }\n        }\n        return func.apply(this, args);\n    };\n\n    // ------- join -------\n\n    var Join = function (first, second) {\n        this.value = UNRESOLVED;\n        this.listener = null;\n        this.param = null;\n\n        this.missing = 2;\n        setListener(first, setJoinand, this);\n        setListener(second, setJoinand, this);\n    };\n\n    Join.prototype = Object.create(Future.prototype);\n\n    var setJoinand = function (future, value) {\n        if (value instanceof Error) {\n            setValue(future, value);\n        } else if (--future.missing <= 0) {\n            setValue(future, undefined);\n        }\n    };\n\n    var join = function (first, second) {\n        if (getValue(first) instanceof Future) {\n            if (getValue(second) instanceof Future) {\n                if (first instanceof Join) {\n                    first.missing += 1;\n                    setListener(second, setJoinand, first);\n                    return first;\n                } else if (second instanceof Join) {\n                    second.missing += 1;\n                    setListener(first, setJoinand, second);\n                    return second;\n                } else {\n                    return new Join(first, second);\n                }\n            } else {\n                return first;\n            }\n        } else {\n            return getValue(second);\n        }\n    };\n\n    // ------- hide -------\n\n    var Hide = function (future, handler) {\n        this.value = UNRESOLVED;\n        this.listener = null;\n        this.param = null;\n\n        this.handler = handler;\n        setListener(future, hideValue, this);\n    };\n\n    Hide.prototype = Future.prototype;\n\n    var hideValue = function (future, value) {\n        try {\n            if (value instanceof Error) {\n                value = future.handler(value);\n            }\n        } catch (error) {\n            value = error instanceof Error ? error : new Error(error);\n        }\n\n        setValue(future, value);\n    };\n\n    var printStack = function (error) {\n        console.log(error.stack);\n    };\n\n    var hide = function (future, handler) {\n        if (typeof handler !== 'function') {\n            handler = printStack;\n        }\n\n        if (isUnresolved(future)) {\n            return new Hide(future, handler);\n        } else if (future.value instanceof Error) {\n            return handler(future.value);\n        } else {\n            return getValue(future);\n        }\n    };\n\n    // ------- array -------\n\n    var Arr = function (array, index) {\n        this.value = UNRESOLVED;\n        this.listener = null;\n        this.param = null;\n\n        this.array = array;\n        this.index = index;\n\n        setListener(array[index], setMember, this);\n    };\n\n    Arr.prototype = Future.prototype;\n\n    var setMember = function (future, value) {\n        if (!(value instanceof Error)) {\n            try {\n                var array = future.array;\n                array[future.index] = value;\n\n                while (++future.index < array.length) {\n                    value = array[future.index];\n                    if (isUnresolved(value)) {\n                        setListener(value, setMember, future);\n                        return;\n                    } else {\n                        array[future.index] = getValue(value);\n                    }\n                }\n\n                value = array;\n            } catch (error) {\n                value = error instanceof Error ? error : new Error(error);\n            }\n        }\n\n        setValue(future, value);\n    };\n\n    var array = function (array) {\n        ASSERT(array instanceof Array);\n\n        for (var i = 0; i < array.length; ++i) {\n            if (isUnresolved(array[i])) {\n                return new Arr(array, i);\n            }\n        }\n\n        return array;\n    };\n\n    // ------- then -------\n\n    var thenHandler = function (callback, value) {\n        if (value instanceof Error) {\n            callback(value);\n        } else {\n            callback(null, value);\n        }\n    };\n\n    var calldepth = 0;\n    var then = function (future, callback) {\n        var error = null,\n            value;\n\n        if (!(future instanceof Future)) {\n            value = future;\n        } else if (future.value === UNRESOLVED) {\n            setListener(future, thenHandler, callback);\n            return;\n        } else if (future.value instanceof Error) {\n            error = future.value;\n        } else {\n            value = future.value;\n        }\n\n        if (calldepth < maxDepth) {\n            ++calldepth;\n            try {\n                callback(error, value);\n            } catch (err) {\n                console.log('unhandled error from callback', err);\n            }\n            --calldepth;\n        } else {\n            setTimeout(callback, 0, error, value);\n        }\n    };\n\n    // -------\n\n    return {\n        adapt: adapt,\n        unadapt: unadapt,\n        delay: delay,\n        call: call,\n        array: array,\n        join: join,\n        hide: hide,\n        then: then\n    };\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true, camelcase: false*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\n(function () {\n    'use strict';\n\n    // ------- assert -------\n\n    var TASYNC_TRACE_ENABLE = true;\n\n    function setTrace(value) {\n        TASYNC_TRACE_ENABLE = value;\n    }\n\n    function assert(cond) {\n        if (!cond) {\n            throw new Error('tasync internal error');\n        }\n    }\n\n    // ------- Future -------\n\n    var STATE_LISTEN = 0;\n    var STATE_REJECTED = 1;\n    var STATE_RESOLVED = 2;\n\n    var Future = function () {\n        this.state = STATE_LISTEN;\n        this.value = [];\n    };\n\n    Future.prototype.register = function (target) {\n        assert(this.state === STATE_LISTEN);\n        assert(typeof target === 'object' && target !== null);\n\n        this.value.push(target);\n    };\n\n    Future.prototype.resolve = function (value) {\n        assert(this.state === STATE_LISTEN && !(value instanceof Future));\n\n        var listeners = this.value;\n\n        this.state = STATE_RESOLVED;\n        this.value = value;\n\n        var i;\n        for (i = 0; i < listeners.length; ++i) {\n            listeners[i].onResolved(value);\n        }\n    };\n\n    Future.prototype.reject = function (error) {\n        assert(this.state === STATE_LISTEN && error instanceof Error);\n\n        var listeners = this.value;\n\n        this.state = STATE_REJECTED;\n        this.value = error;\n\n        var i;\n        for (i = 0; i < listeners.length; ++i) {\n            listeners[i].onRejected(error);\n        }\n    };\n\n    // ------- Delay -------\n\n    function delay(timeout, value) {\n        if (timeout < 0) {\n            return value;\n        }\n\n        var future = new Future();\n        setTimeout(function () {\n            future.resolve(value);\n        }, timeout);\n        return future;\n    }\n\n    // ------- Lift -------\n\n    var FutureLift = function (array, index) {\n        Future.call(this);\n\n        this.array = array;\n        this.index = index;\n    };\n\n    FutureLift.prototype = Object.create(Future.prototype);\n\n    FutureLift.prototype.onResolved = function (value) {\n        assert(this.state === STATE_LISTEN);\n\n        var array = this.array;\n        array[this.index] = value;\n\n        while (++this.index < array.length) {\n            value = array[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    array[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        this.array = null;\n        this.resolve(array);\n    };\n\n    FutureLift.prototype.onRejected = function (error) {\n        this.array = null;\n        this.reject(error);\n    };\n\n    var lift = function (array) {\n        if (!(array instanceof Array)) {\n            throw new Error('array argument is expected');\n        }\n\n        var index;\n        for (index = 0; index < array.length; ++index) {\n            var value = array[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    array[index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    var future = new FutureLift(array, index);\n                    value.register(future);\n                    return future;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        return array;\n    };\n\n    // ------- Apply -------\n\n    var ROOT = {\n        subframes: 0\n    };\n\n    var FRAME = ROOT;\n\n    var FutureApply = function tasync_trace_end(func, that, args, index) {\n        Future.call(this);\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n        this.subframes = 0;\n\n        if (TASYNC_TRACE_ENABLE) {\n            this.trace = new Error();\n        }\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n        this.index = index;\n    };\n\n    FutureApply.prototype = Object.create(Future.prototype);\n\n    FutureApply.prototype.getPath = function () {\n        var future = this.caller,\n            path = [this.position];\n\n        while (future !== ROOT) {\n            path.push(future.position);\n            future = future.caller;\n        }\n\n        return path;\n    };\n\n    function getSlice(trace) {\n        assert(typeof trace === 'string');\n\n        var end = trace.indexOf('tasync_trace_start');\n        if (end >= 0) {\n            end = trace.lastIndexOf('\\n', end) + 1;\n        } else {\n            if (trace.charAt(trace.length - 1) !== '\\n') {\n                // trace += '\\n';\n            }\n            end = undefined;\n        }\n\n        var start = trace.indexOf('tasync_trace_end');\n        if (start >= 0) {\n            start = trace.indexOf('\\n', start) + 1;\n            if (start >= 0) {\n                start = trace.indexOf('\\n', start) + 1;\n            }\n        } else {\n            start = 0;\n        }\n\n        return trace.substring(start, end);\n    }\n\n    function createError(error, future) {\n        if (!(error instanceof Error)) {\n            error = new Error(error);\n        }\n\n        if (TASYNC_TRACE_ENABLE) {\n            error.trace = getSlice(error.stack);\n            do {\n                error.trace += '*** callback ***\\n';\n                error.trace += getSlice(future.trace.stack);\n                future = future.caller;\n            } while (future !== ROOT);\n        }\n\n        return error;\n    }\n\n    FutureApply.prototype.onRejected = function (error) {\n        this.args = null;\n        this.reject(error);\n    };\n\n    FutureApply.prototype.onResolved = function tasync_trace_start(value) {\n        assert(this.state === STATE_LISTEN);\n\n        var args = this.args;\n        args[this.index] = value;\n\n        while (--this.index >= 0) {\n            value = args[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    args[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        assert(FRAME === ROOT);\n        FRAME = this;\n\n        this.args = null;\n        try {\n            value = this.func.apply(this.that, args);\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(createError(error, this));\n            return;\n        }\n\n        FRAME = ROOT;\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n\n            this.onResolved = this.resolve;\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    var apply = function (func, args, that) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        } else if (!(args instanceof Array)) {\n            throw new Error('array argument is expected');\n        }\n\n        var index = args.length;\n        while (--index >= 0) {\n            var value = args[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_LISTEN) {\n                    var future = new FutureApply(func, that, args, index);\n                    value.register(future);\n                    return future;\n                } else if (value.state === STATE_RESOLVED) {\n                    args[index] = value.value;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        return func.apply(that, args);\n    };\n\n    // ------- Call -------\n\n    var FutureCall = function tasync_trace_end(args, index) {\n        Future.call(this);\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n        this.subframes = 0;\n\n        if (TASYNC_TRACE_ENABLE) {\n            this.trace = new Error();\n        }\n\n        this.args = args;\n        this.index = index;\n    };\n\n    FutureCall.prototype = Object.create(Future.prototype);\n\n    FutureCall.prototype.getPath = FutureApply.prototype.getPath;\n    FutureCall.prototype.onRejected = FutureApply.prototype.onRejected;\n\n    var FUNCTION_CALL = Function.call;\n\n    FutureCall.prototype.onResolved = function tasync_trace_start(value) {\n        assert(this.state === STATE_LISTEN);\n\n        var args = this.args;\n        args[this.index] = value;\n\n        while (--this.index >= 0) {\n            value = args[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    args[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        assert(FRAME === ROOT);\n        FRAME = this;\n\n        this.args = null;\n        try {\n            var func = args[0];\n            args[0] = null;\n            value = FUNCTION_CALL.apply(func, args);\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(createError(error, this));\n            return;\n        }\n\n        FRAME = ROOT;\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n\n            this.onResolved = this.resolve;\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    var call = function () {\n        var index = arguments.length;\n        while (--index >= 0) {\n            var value = arguments[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_LISTEN) {\n                    var future = new FutureCall(arguments, index);\n                    value.register(future);\n                    return future;\n                } else if (value.state === STATE_RESOLVED) {\n                    arguments[index] = value.value;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        var func = arguments[0];\n        return FUNCTION_CALL.apply(func, arguments);\n    };\n\n    // ------- TryCatch -------\n\n    function FutureTryCatch(handler) {\n        Future.call(this);\n\n        this.handler = handler;\n    }\n\n    FutureTryCatch.prototype = Object.create(Future.prototype);\n\n    FutureTryCatch.prototype.onRejected = function (error) {\n        try {\n            var value = this.handler(error);\n\n            if (value instanceof Future) {\n                this.onRejected = Future.prorotype.reject;\n                value.register(this);\n            } else {\n                this.resolve(value);\n            }\n        } catch (err) {\n            this.reject(err);\n        }\n    };\n\n    FutureTryCatch.prototype.onResolved = Future.prototype.resolve;\n\n    function trycatch(func, handler) {\n        if (typeof func !== 'function' || typeof handler !== 'function') {\n            throw new Error('function arguments are expected');\n        }\n\n        try {\n            var value = func();\n\n            if (value instanceof Future) {\n                var future = new FutureTryCatch(handler);\n                value.register(future);\n\n                return future;\n            } else {\n                return value;\n            }\n        } catch (error) {\n            return handler(error);\n        }\n    }\n\n    // ------- Wrap -------\n\n    function wrap(func) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        }\n\n        if (typeof func.tasync_wraped === 'undefined') {\n            func.tasync_wraped = function () {\n                var args = arguments;\n                var future = new Future();\n\n                args[args.length++] = function (error, value) {\n                    if (error) {\n                        future.reject(error instanceof Error ? error : new Error(error));\n                    } else {\n                        future.resolve(value);\n                    }\n                };\n\n                func.apply(this, args);\n\n                if (future.state === STATE_LISTEN) {\n                    return future;\n                } else if (future.state === STATE_RESOLVED) {\n                    return future.value;\n                } else {\n                    assert(future.state === STATE_REJECTED);\n                    throw future.value;\n                }\n            };\n\n            func.tasync_wraped.tasync_unwraped = func;\n        }\n\n        return func.tasync_wraped;\n    }\n\n    // ------- Unwrap -------\n\n    function UnwrapListener(callback) {\n        this.callback = callback;\n    }\n\n    UnwrapListener.prototype.onRejected = function (error) {\n        this.callback(error);\n    };\n\n    UnwrapListener.prototype.onResolved = function (value) {\n        this.callback(null, value);\n    };\n\n    function unwrap(func) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        }\n\n        if (typeof func.tasync_unwraped === 'undefined') {\n            func.tasync_unwraped = function () {\n                var args = arguments;\n\n                var callback = args[--args.length];\n                assert(typeof callback === 'function');\n\n                var value;\n                try {\n                    value = func.apply(this, args);\n                } catch (error) {\n                    callback(error);\n                    return;\n                }\n\n                if (value instanceof Future) {\n                    assert(value.state === STATE_LISTEN);\n\n                    var listener = new UnwrapListener(callback);\n                    value.register(listener);\n                } else {\n                    callback(null, value);\n                }\n            };\n\n            func.tasync_unwraped.tasync_wraped = func;\n        }\n\n        return func.tasync_unwraped;\n    }\n\n    // ------- Throttle -------\n\n    function FutureThrottle(func, that, args) {\n        Future.call(this);\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n\n        this.path = this.getPath();\n    }\n\n    FutureThrottle.prototype = Object.create(Future.prototype);\n\n    FutureThrottle.prototype.execute = function () {\n        var value;\n        try {\n            assert(FRAME === ROOT);\n            FRAME = this;\n\n            value = this.func.apply(this.that, this.args);\n\n            FRAME = ROOT;\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(error);\n            return;\n        }\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    FutureThrottle.prototype.getPath = FutureApply.prototype.getPath;\n    FutureThrottle.prototype.onResolved = Future.prototype.resolve;\n    FutureThrottle.prototype.onRejected = Future.prototype.reject;\n\n    FutureThrottle.prototype.compare = function (second) {\n        var first = this.path;\n        second = second.path;\n\n        var i, limit = first.length < second.length ? first.length : second.length;\n        for (i = 0; i < limit; ++i) {\n            if (first[i] !== second[i]) {\n                return first[i] - second[i];\n            }\n        }\n\n        return first.length - second.length;\n    };\n\n    function ThrottleListener(limit) {\n        this.running = 0;\n        this.limit = limit;\n        this.queue = [];\n    }\n\n    function priorityQueueInsert(queue, elem) {\n        var low = 0;\n        var high = queue.length;\n\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            assert(low <= mid && mid < high);\n\n            if (elem.compare(queue[mid]) < 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        queue.splice(low, 0, elem);\n    }\n\n    ThrottleListener.prototype.execute = function (func, that, args) {\n        if (this.running < this.limit) {\n            var value = func.apply(that, args);\n\n            if (value instanceof Future) {\n                assert(value.state === STATE_LISTEN);\n\n                ++this.running;\n                value.register(this);\n            }\n\n            return value;\n        } else {\n            var future = new FutureThrottle(func, that, args);\n            priorityQueueInsert(this.queue, future);\n\n            return future;\n        }\n    };\n\n    ThrottleListener.prototype.onResolved = function () {\n        if (this.queue.length > 0) {\n            var future = this.queue.pop();\n            future.register(this);\n\n            future.execute();\n        } else {\n            --this.running;\n        }\n    };\n\n    ThrottleListener.prototype.onRejected = ThrottleListener.prototype.onResolved;\n\n    // TODO: prevent recursion, otheriwise throttle will not work\n    function throttle(func, limit) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        } else if (typeof limit !== 'number') {\n            throw new Error('number argument is expected');\n        }\n\n        var listener = new ThrottleListener(limit);\n\n        return function () {\n            return listener.execute(func, this, arguments);\n        };\n    }\n\n    // ------- Join -------\n\n    function FutureJoin(first) {\n        Future.call(this);\n\n        this.first = first;\n        this.missing = first instanceof Future && first.state === STATE_LISTEN ? 1 : 0;\n    }\n\n    FutureJoin.prototype = Object.create(Future.prototype);\n\n    FutureJoin.prototype.onResolved = function (/*value*/) {\n        if (--this.missing === 0) {\n            assert(this.state !== STATE_RESOLVED);\n\n            if (this.state === STATE_LISTEN) {\n                if (this.first instanceof Future) {\n                    assert(this.first.state === STATE_RESOLVED);\n\n                    this.resolve(this.first.value);\n                } else {\n                    this.resolve(this.first);\n                }\n            }\n        }\n    };\n\n    FutureJoin.prototype.onRejected = function (error) {\n        if (this.state === STATE_LISTEN) {\n            this.reject(error);\n        }\n    };\n\n    function join(first, second) {\n        if (first instanceof Future && first.state === STATE_REJECTED) {\n            return first;\n        } else if (second instanceof Future) {\n            if (second.state === STATE_RESOLVED) {\n                return first;\n            } else if (second.state === STATE_REJECTED) {\n                return second;\n            }\n        } else {\n            return first;\n        }\n\n        if (!(first instanceof FutureJoin)) {\n            first = new FutureJoin(first);\n        }\n\n        first.missing += 1;\n        second.register(first);\n\n        return first;\n    }\n\n    // ------- TASYNC -------\n\n    var TASYNC = {\n        setTrace: setTrace,\n        delay: delay,\n        lift: lift,\n        apply: apply,\n        call: call,\n        trycatch: trycatch,\n        wrap: wrap,\n        unwrap: unwrap,\n        throttle: throttle,\n        join: join\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('common/core/tasync',[], function () {\n            return TASYNC;\n        });\n    } else {\n        module.exports = TASYNC;\n    }\n}());\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author mmaroti / https://github.com/mmaroti\r\n */\r\n\r\ndefine('common/core/coretree',[\r\n    'common/util/assert',\r\n    'common/util/key',\r\n    'common/core/future',\r\n    'common/core/tasync'\r\n], function (ASSERT, GENKEY, FUTURE, TASYNC) {\r\n\r\n    'use strict';\r\n\r\n    var HASH_REGEXP = new RegExp('#[0-9a-f]{40}');\r\n\tvar isValidHash = function (key) {\r\n        return typeof key === 'string' && key.length === 41 && HASH_REGEXP.test(key);\r\n\t};\r\n\r\n\tvar MAX_RELID = Math.pow(2, 31);\r\n\tvar createRelid = function (data) {\r\n        ASSERT(data && typeof data === 'object');\r\n\r\n\t\tvar relid;\r\n\t\tdo {\r\n\t\t\trelid = Math.floor(Math.random() * MAX_RELID);\r\n\t\t\t// relid = relid.toString();\r\n\t\t} while (data[relid] !== undefined);\r\n\r\n        return '' + relid;\r\n\t};\r\n\r\n\t// make relids deterministic\r\n\tif (false) {\r\n\t\tvar nextRelid = 0;\r\n\t\tcreateRelid = function (data) {\r\n            ASSERT(data && typeof data === 'object');\r\n\r\n\t\t\tvar relid;\r\n\t\t\tdo {\r\n\t\t\t\trelid = (nextRelid += -1);\r\n\t\t\t} while (data[relid] !== undefined);\r\n\r\n            return '' + relid;\r\n\t\t};\r\n\t}\r\n\r\n\tvar rootCounter = 0;\r\n\r\n\treturn function (storage, options) {\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n\r\n        var gmeConfig = options.globConf;\r\n        //var logger = options.logger.fork('coretree');\r\n\r\n\t\tvar MAX_AGE = 3; // MAGIC NUMBER\r\n\t\tvar MAX_TICKS = 2000; // MAGIC NUMBER\r\n\t\tvar MAX_MUTATE = 30000; // MAGIC NUMBER\r\n\r\n\t\tvar ID_NAME = storage.ID_NAME;\r\n        //var EMPTY_DATA = {};\r\n        var __getEmptyData = function () {\r\n            return {};\r\n        };\r\n\r\n\t\tvar roots = [];\r\n\t\tvar ticks = 0;\r\n\r\n\t\tstorage.loadObject = TASYNC.wrap(storage.loadObject);\r\n\t\tstorage.insertObject = FUTURE.adapt(storage.insertObject);\r\n\t\tstorage.fsyncDatabase = FUTURE.adapt(storage.fsyncDatabase);\r\n\r\n\t\t// ------- static methods\r\n\r\n\t\tvar getParent = function (node) {\r\n            ASSERT(typeof node.parent === 'object');\r\n\r\n\t\t\treturn node.parent;\r\n\t\t};\r\n\r\n\t\tvar getRelid = function (node) {\r\n            ASSERT(node.relid === null || typeof node.relid === 'string');\r\n\r\n\t\t\treturn node.relid;\r\n\t\t};\r\n\r\n\t\tvar getLevel = function (node) {\r\n\t\t\tvar level = 0;\r\n\t\t\twhile (node.parent !== null) {\r\n\t\t\t\t++level;\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t}\r\n\t\t\treturn level;\r\n\t\t};\r\n\r\n\t\tvar getRoot = function (node) {\r\n\t\t\twhile (node.parent !== null) {\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t}\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tvar getPath = function (node, base) {\r\n\t\t\tif (node === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n            var path = '';\r\n\t\t\twhile (node.relid !== null && node !== base) {\r\n                path = '/' + node.relid + path;\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t}\r\n\t\t\treturn path;\r\n\t\t};\r\n\r\n\t\tvar isValidPath = function (path) {\r\n            return typeof path === 'string' && (path === '' || path.charAt(0) === '/');\r\n\t\t};\r\n\r\n\t\tvar splitPath = function (path) {\r\n\t\t\tASSERT(isValidPath(path));\r\n\r\n            path = path.split('/');\r\n\t\t\tpath.splice(0, 1);\r\n\r\n\t\t\treturn path;\r\n\t\t};\r\n\r\n\t\tvar buildPath = function (path) {\r\n\t\t\tASSERT(path instanceof Array);\r\n\r\n            return path.length === 0 ? '' : '/' + path.join('/');\r\n\t\t};\r\n\r\n\t\tvar joinPaths = function (first, second) {\r\n\t\t\tASSERT(isValidPath(first) && isValidPath(second));\r\n\r\n\t\t\treturn first + second;\r\n\t\t};\r\n\r\n        var getCommonPathPrefixData = function (first, second) {\r\n            ASSERT(typeof first === 'string' && typeof second === 'string');\r\n\r\n            first = splitPath(first);\r\n            second = splitPath(second);\r\n\r\n            var common = [];\r\n            for (var i = 0; first[i] === second[i] && i < first.length; ++i) {\r\n                common.push(first[i]);\r\n            }\r\n\r\n            return {\r\n                common: buildPath(common),\r\n                first: buildPath(first.slice(i)),\r\n                firstLength: first.length - i,\r\n                second: buildPath(second.slice(i)),\r\n                secondLength: second.length - i\r\n            };\r\n        };\r\n\r\n\t\t// ------- memory management\r\n\r\n\t\tvar __detachChildren = function (node) {\r\n\t\t\tASSERT(node.children instanceof Array && node.age >= MAX_AGE - 1);\r\n\r\n\t\t\tvar children = node.children;\r\n\t\t\tnode.children = null;\r\n\t\t\tnode.age = MAX_AGE;\r\n\r\n\t\t\tfor (var i = 0; i < children.length; ++i) {\r\n\t\t\t\t__detachChildren(children[i]);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar __ageNodes = function (nodes) {\r\n\t\t\tASSERT(nodes instanceof Array);\r\n\r\n\t\t\tvar i = nodes.length;\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tvar node = nodes[i];\r\n\r\n\t\t\t\tASSERT(node.age < MAX_AGE);\r\n\t\t\t\tif (++node.age >= MAX_AGE) {\r\n\t\t\t\t\tnodes.splice(i, 1);\r\n\t\t\t\t\t__detachChildren(node);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t__ageNodes(node.children);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar __ageRoots = function () {\r\n\t\t\tif (++ticks >= MAX_TICKS) {\r\n\t\t\t\tticks = 0;\r\n\t\t\t\t__ageNodes(roots);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar __getChildNode = function (children, relid) {\r\n            ASSERT(children instanceof Array && typeof relid === 'string');\r\n\r\n\t\t\tfor (var i = 0; i < children.length; ++i) {\r\n\t\t\t\tvar child = children[i];\r\n\t\t\t\tif (child.relid === relid) {\r\n\t\t\t\t\tASSERT(child.parent.age === 0);\r\n\r\n\t\t\t\t\tchild.age = 0;\r\n\t\t\t\t\treturn child;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t};\r\n\r\n\t\tvar __getChildData = function (data, relid) {\r\n            ASSERT(typeof relid === 'string');\r\n\r\n            if (typeof data === 'object' && data !== null) {\r\n\t\t\t\tdata = data[relid];\r\n                return typeof data === 'undefined' ? __getEmptyData() : data;\r\n\t\t\t} else {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar normalize = function (node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n            // console.log('normalize start', printNode(getRoot(node)));\r\n\r\n\t\t\tvar parent;\r\n\r\n\t\t\tif (node.children === null) {\r\n\t\t\t\tASSERT(node.age === MAX_AGE);\r\n\r\n\t\t\t\tif (node.parent !== null) {\r\n\t\t\t\t\tparent = normalize(node.parent);\r\n\r\n\t\t\t\t\tvar temp = __getChildNode(parent.children, node.relid);\r\n\t\t\t\t\tif (temp !== null) {\r\n\t\t\t\t\t\t// TODO: make the current node close to the returned one\r\n\r\n                        // console.log('normalize end1',\r\n\t\t\t\t\t\t// printNode(getRoot(temp)));\r\n\t\t\t\t\t\treturn temp;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tASSERT(node.parent.children === null || __getChildNode(node.parent.children, node.relid) === null);\r\n\t\t\t\t\tASSERT(__getChildNode(parent.children, node.relid) === null);\r\n\r\n\t\t\t\t\tnode.parent = parent;\r\n\t\t\t\t\tparent.children.push(node);\r\n\r\n\t\t\t\t\ttemp = __getChildData(parent.data, node.relid);\r\n\t\t\t\t\tif (!isValidHash(temp) || temp !== __getChildData(node.data, ID_NAME)) {\r\n\t\t\t\t\t\tnode.data = temp;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\troots.push(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.age = 0;\r\n\t\t\t\tnode.children = [];\r\n\t\t\t} else if (node.age !== 0) {\r\n\t\t\t\tparent = node;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tparent.age = 0;\r\n\t\t\t\t\tparent = parent.parent;\r\n\t\t\t\t} while (parent !== null && parent.age !== 0);\r\n\t\t\t}\r\n\r\n            // console.log('normalize end2', printNode(getRoot(node)));\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\t// ------- hierarchy\r\n\r\n\t\tvar getAncestor = function (first, second) {\r\n\t\t\tASSERT(getRoot(first) === getRoot(second));\r\n\r\n\t\t\tfirst = normalize(first);\r\n\t\t\tsecond = normalize(second);\r\n\r\n\t\t\tvar a = [];\r\n\t\t\tdo {\r\n\t\t\t\ta.push(first);\r\n\t\t\t\tfirst = first.parent;\r\n\t\t\t} while (first !== null);\r\n\r\n\t\t\tvar b = [];\r\n\t\t\tdo {\r\n\t\t\t\tb.push(second);\r\n\t\t\t\tsecond = second.parent;\r\n\t\t\t} while (second !== null);\r\n\r\n\t\t\tvar i = a.length - 1;\r\n\t\t\tvar j = b.length - 1;\r\n\t\t\twhile (i !== 0 && j !== 0 && a[i - 1] === b[j - 1]) {\r\n\t\t\t\t--i;\r\n\t\t\t\t--j;\r\n\t\t\t}\r\n\r\n\t\t\tASSERT(a[i] === b[j]);\r\n\t\t\treturn a[i];\r\n\t\t};\r\n\r\n\t\tvar isAncestor = function (node, ancestor) {\r\n\t\t\tASSERT(getRoot(node) === getRoot(ancestor));\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tancestor = normalize(ancestor);\r\n\r\n\t\t\tdo {\r\n\t\t\t\tif (node === ancestor) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode = node.parent;\r\n\t\t\t} while (node !== null);\r\n\r\n\t\t\treturn false;\r\n\t\t};\r\n\r\n\t\tvar createRoot = function () {\r\n\t\t\tvar root = {\r\n\t\t\t\tparent: null,\r\n\t\t\t\trelid: null,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: {\r\n\t\t\t\t\t_mutable: true\r\n\t\t\t\t},\r\n\t\t\t\trootid: ++rootCounter\r\n\t\t\t};\r\n            root.data[ID_NAME] = '';\r\n\t\t\troots.push(root);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn root;\r\n\t\t};\r\n\r\n\t\tvar getChild = function (node, relid) {\r\n            ASSERT(typeof relid === 'string' && relid !== ID_NAME);\r\n\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tvar child = __getChildNode(node.children, relid);\r\n\t\t\tif (child !== null) {\r\n\t\t\t\treturn child;\r\n\t\t\t}\r\n\r\n\t\t\tchild = {\r\n\t\t\t\tparent: node,\r\n\t\t\t\trelid: relid,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: __getChildData(node.data, relid)\r\n\t\t\t};\r\n\t\t\tnode.children.push(child);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn child;\r\n\t\t};\r\n\r\n\t\tvar createChild = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n            if (typeof node.data !== 'object' || node.data === null) {\r\n                throw new Error('invalid node data');\r\n\t\t\t}\r\n\r\n\t\t\tvar relid = createRelid(node.data);\r\n\t\t\tvar child = {\r\n\t\t\t\tparent: node,\r\n\t\t\t\trelid: relid,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n                data: __getEmptyData()\r\n\t\t\t};\r\n\r\n\t\t\t// TODO: make sure that it is not on the list\r\n\t\t\tnode.children.push(child);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn child;\r\n\t\t};\r\n\r\n\t\tvar getDescendant = function (node, head, base) {\r\n            ASSERT(typeof base === 'undefined' || isAncestor(head, base));\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\thead = normalize(head);\r\n            base = typeof base === 'undefined' ? null : normalize(base.parent);\r\n\r\n\t\t\tvar path = [];\r\n\t\t\twhile (head.parent !== base) {\r\n\t\t\t\tpath.push(head.relid);\r\n\t\t\t\thead = head.parent;\r\n\t\t\t}\r\n\r\n\t\t\tvar i = path.length;\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tnode = getChild(node, path[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tvar getDescendantByPath = function (node, path) {\r\n            ASSERT(path === '' || path.charAt(0) === '/');\r\n\r\n            path = path.split('/');\r\n\r\n\t\t\tfor (var i = 1; i < path.length; ++i) {\r\n\t\t\t\tnode = getChild(node, path[i]);\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\t// ------- data manipulation\r\n\r\n\t\tvar __isMutableData = function (data) {\r\n            return typeof data === 'object' && data !== null && data._mutable === true;\r\n\t\t};\r\n\r\n\t\tvar isMutable = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\t\t\treturn __isMutableData(node.data);\r\n\t\t};\r\n\r\n\t\tvar isObject = function (node) {\r\n\t\t\tnode = normalize(node);\r\n            return typeof node.data === 'object' && node.data !== null;\r\n\t\t};\r\n\r\n\t\tvar isEmpty = function (node) {\r\n\t\t\tnode = normalize(node);\r\n            if (typeof node.data !== 'object' || node.data === null) {\r\n\t\t\t\treturn false;\r\n            } else if (node.data === __getEmptyData()) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn __isEmptyData(node.data);\r\n\t\t};\r\n\r\n\t\tvar __isEmptyData = function (data) {\r\n            // TODO: better way to check if object has keys?\r\n\t\t\tfor (var keys in data) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\tvar __areEquivalent = function (data1, data2) {\r\n            return data1 === data2 || (typeof data1 === 'string' && data1 === __getChildData(data2, ID_NAME)) ||\r\n                (__isEmptyData(data1) && __isEmptyData(data2));\r\n\t\t};\r\n\r\n\t\tvar mutateCount = 0;\r\n\t\tvar mutate = function (node) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tvar data = node.data;\r\n\r\n            if (typeof data !== 'object' || data === null) {\r\n\t\t\t\treturn false;\r\n\t\t\t} else if (data._mutable === true) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: infinite cycle if MAX_MUTATE is smaller than depth!\r\n\t\t\tif (gmeConfig.storage.autoPersist && ++mutateCount > MAX_MUTATE) {\r\n\t\t\t\tmutateCount = 0;\r\n\r\n\t\t\t\tfor (var i = 0; i < roots.length; ++i) {\r\n\t\t\t\t\tif (__isMutableData(roots[i].data)) {\r\n\t\t\t\t\t\t__saveData(roots[i].data);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (node.parent !== null && !mutate(node.parent)) {\r\n\t\t\t\t// this should never happen\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar copy = {\r\n\t\t\t};\r\n\r\n\t\t\tfor (var key in data) {\r\n\t\t\t\tcopy[key] = data[key];\r\n\t\t\t}\r\n\r\n            copy._mutable = true;\r\n\r\n            if (typeof data[ID_NAME] === 'string') {\r\n                copy[ID_NAME] = '';\r\n\t\t\t}\r\n\r\n\t\t\tif (node.parent !== null) {\r\n                ASSERT(__areEquivalent(__getChildData(node.parent.data, node.relid), node.data));\r\n\t\t\t\tnode.parent.data[node.relid] = copy;\r\n\t\t\t}\r\n\r\n\t\t\tnode.data = copy;\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t\tvar getData = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tASSERT(!__isMutableData(node.data));\r\n\t\t\treturn node.data;\r\n\t\t};\r\n\r\n\t\tvar __reloadChildrenData = function (node) {\r\n\t\t\tfor (var i = 0; i < node.children.length; ++i) {\r\n\t\t\t\tvar child = node.children[i];\r\n\r\n\t\t\t\tvar data = __getChildData(node.data, child.relid);\r\n\t\t\t\tif (!isValidHash(data) || data !== __getChildData(child.data, ID_NAME)) {\r\n\t\t\t\t\tchild.data = data;\r\n\t\t\t\t\t__reloadChildrenData(child);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar setData = function (node, data) {\r\n            ASSERT(data !== null && typeof data !== 'undefined');\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (node.parent !== null) {\r\n\t\t\t\tif (!mutate(node.parent)) {\r\n                    throw new Error('incorrect node data');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.parent.data[node.relid] = data;\r\n\t\t\t}\r\n\r\n\t\t\tnode.data = data;\r\n\t\t\t__reloadChildrenData(node);\r\n\t\t};\r\n\r\n\t\tvar deleteData = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (node.parent !== null) {\r\n\t\t\t\tif (!mutate(node.parent)) {\r\n                    throw new Error('incorrect node data');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete node.parent.data[node.relid];\r\n\t\t\t}\r\n\r\n\t\t\tvar data = node.data;\r\n\r\n            node.data = __getEmptyData();\r\n\t\t\t__reloadChildrenData(node);\r\n\r\n\t\t\treturn data;\r\n\t\t};\r\n\r\n\t\tvar copyData = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n            if (typeof node.data !== 'object' || node.data === null) {\r\n\t\t\t\treturn node.data;\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: return immutable data without coping\r\n\t\t\treturn JSON.parse(JSON.stringify(node.data));\r\n\t\t};\r\n\r\n\t\tvar getProperty = function (node, name) {\r\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\r\n\r\n\t\t\tvar data;\r\n\t\t\tnode = normalize(node);\r\n\r\n            if (typeof node.data === 'object' && node.data !== null) {\r\n\t\t\t\tdata = node.data[name];\r\n\t\t\t}\r\n\r\n\t\t\t// TODO: corerel uses getProperty to get the overlay content which can get mutable\r\n\t\t\t// ASSERT(!__isMutableData(data));\r\n\t\t\treturn data;\r\n\t\t};\r\n\r\n\t\tvar setProperty = function (node, name, data) {\r\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\r\n            ASSERT(!__isMutableData(data) /*&& data !== null*/ && data !== undefined);\r\n            //TODO is the 'null' really can be a value of a property???\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (!mutate(node)) {\r\n                throw new Error('incorrect node data');\r\n\t\t\t}\r\n\r\n\t\t\tnode.data[name] = data;\r\n\r\n\t\t\tvar child = __getChildNode(node.children, name);\r\n\t\t\tif (child !== null) {\r\n\t\t\t\tchild.data = data;\r\n\t\t\t\t__reloadChildrenData(child);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar deleteProperty = function (node, name) {\r\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tif (!mutate(node)) {\r\n                throw new Error('incorrect node data');\r\n\t\t\t}\r\n\r\n\t\t\tdelete node.data[name];\r\n\r\n\t\t\tvar child = __getChildNode(node.children, name);\r\n\t\t\tif (child !== null) {\r\n                child.data = __getEmptyData();\r\n\t\t\t\t__reloadChildrenData(child);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar noUnderscore = function (relid) {\r\n            ASSERT(typeof relid === 'string');\r\n            return relid.charAt(0) !== '_';\r\n\t\t};\r\n\r\n\t\tvar getKeys = function (node, predicate) {\r\n            ASSERT(typeof predicate === 'undefined' || typeof predicate === 'function');\r\n\r\n\t\t\tnode = normalize(node);\r\n\t\t\tpredicate = predicate || noUnderscore;\r\n\r\n            if (typeof node.data !== 'object' || node.data === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar keys = Object.keys(node.data);\r\n\r\n\t\t\tvar i = keys.length;\r\n\t\t\twhile (--i >= 0 && !predicate(keys[i])) {\r\n\t\t\t\tkeys.pop();\r\n\t\t\t}\r\n\r\n\t\t\twhile (--i >= 0) {\r\n\t\t\t\tif (!predicate(keys[i])) {\r\n\t\t\t\t\tkeys[i] = keys.pop();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn keys;\r\n\t\t};\r\n\r\n        var getRawKeys = function(object,predicate){\r\n            ASSERT(typeof predicate === 'undefined' || typeof predicate === 'function');\r\n            predicate = predicate || noUnderscore;\r\n\r\n            var keys = Object.keys(object);\r\n\r\n            var i = keys.length;\r\n            while (--i >= 0 && !predicate(keys[i])) {\r\n                keys.pop();\r\n            }\r\n\r\n            while (--i >= 0) {\r\n                if (!predicate(keys[i])) {\r\n                    keys[i] = keys.pop();\r\n                }\r\n            }\r\n\r\n            return keys;\r\n        };\r\n\r\n\t\t// ------- persistence\r\n\r\n\t\tvar getHash = function (node) {\r\n\t\t\tif (node === null) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tvar hash;\r\n\t\t\tnode = normalize(node);\r\n            if (typeof node.data === 'object' && node.data !== null) {\r\n\t\t\t\thash = node.data[ID_NAME];\r\n\t\t\t}\r\n\r\n            ASSERT(typeof hash === 'string' || typeof hash === 'undefined');\r\n\t\t\treturn hash;\r\n\t\t};\r\n\r\n\t\tvar isHashed = function (node) {\r\n\t\t\tnode = normalize(node);\r\n            return typeof node.data === 'object' && node.data !== null && typeof node.data[ID_NAME] === 'string';\r\n\t\t};\r\n\r\n\t\tvar setHashed = function (node, hashed, noMutate) {\r\n            ASSERT(typeof hashed === 'boolean');\r\n\r\n\t\t\tnode = normalize(node);\r\n            if(!noMutate){\r\n                if (!mutate(node)) {\r\n                    throw new Error('incorrect node data');\r\n                }\r\n            }\r\n\r\n\t\t\tif (hashed) {\r\n                node.data[ID_NAME] = '';\r\n\t\t\t} else {\r\n\t\t\t\tdelete node.data[ID_NAME];\r\n\t\t\t}\r\n\r\n            ASSERT(typeof node.children[ID_NAME] === 'undefined');\r\n\t\t};\r\n\r\n\t\tvar __saveData = function (data) {\r\n\t\t\tASSERT(__isMutableData(data));\r\n\r\n            var done = __getEmptyData();\r\n\t\t\tdelete data._mutable;\r\n\r\n\t\t\tfor (var relid in data) {\r\n\t\t\t\tvar child = data[relid];\r\n\t\t\t\tif (__isMutableData(child)) {\r\n\t\t\t\t\tvar sub = __saveData(child);\r\n                    if (sub === __getEmptyData()) {\r\n\t\t\t\t\t\tdelete data[relid];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tdone = FUTURE.join(done, sub);\r\n                        if (typeof child[ID_NAME] === 'string') {\r\n\t\t\t\t\t\t\tdata[relid] = child[ID_NAME];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdone = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n            if (done !== __getEmptyData()) {\r\n\t\t\t\tvar hash = data[ID_NAME];\r\n                ASSERT(hash === '' || typeof hash === 'undefined');\r\n\r\n                if (hash === '') {\r\n                    hash = '#' + GENKEY(data, gmeConfig);\r\n\t\t\t\t\tdata[ID_NAME] = hash;\r\n\r\n\t\t\t\t\tdone = FUTURE.join(done, storage.insertObject(data));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn done;\r\n\t\t};\r\n\r\n\t\tvar persist = function (node) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\tif (!__isMutableData(node.data)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tvar done = __saveData(node.data);\r\n\t\t\treturn FUTURE.join(done, storage.fsyncDatabase());\r\n\t\t};\r\n\r\n\t\tvar loadRoot = function (hash) {\r\n\t\t\tASSERT(isValidHash(hash));\r\n\r\n\t\t\treturn TASYNC.call(__loadRoot2, storage.loadObject(hash));\r\n\t\t};\r\n\r\n\t\tvar __loadRoot2 = function (data) {\r\n\t\t\tvar root = {\r\n\t\t\t\tparent: null,\r\n\t\t\t\trelid: null,\r\n\t\t\t\tage: 0,\r\n\t\t\t\tchildren: [],\r\n\t\t\t\tdata: data,\r\n\t\t\t\trootid: ++rootCounter\r\n\t\t\t};\r\n\t\t\troots.push(root);\r\n\r\n\t\t\t__ageRoots();\r\n\t\t\treturn root;\r\n\t\t};\r\n\r\n\t\tvar loadChild = function (node, relid) {\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = getChild(node, relid);\r\n\r\n\t\t\tif (isValidHash(node.data)) {\r\n\t\t\t\t// TODO: this is a hack, we should avoid loading it multiple\r\n\t\t\t\t// times\r\n\t\t\t\treturn TASYNC.call(__loadChild2, node, storage.loadObject(node.data));\r\n\t\t\t} else {\r\n                return typeof node.data === 'object' && node.data !== null ? node : null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar getChildHash = function(node,relid){\r\n\t\t\tASSERT(isValidNode(node));\r\n\r\n\t\t\tnode = getChild(node, relid);\r\n\r\n\t\t\tif (isValidHash(node.data)) {\r\n\t\t\t\t// TODO: this is a hack, we should avoid loading it multiple\r\n\t\t\t\t// times\r\n\t\t\t\treturn node.data;\r\n\t\t\t} else {\r\n                return typeof node.data === 'object' && node.data !== null ? getHash(node) : null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\r\n\t\tvar __loadChild2 = function (node, newdata) {\r\n\t\t\tnode = normalize(node);\r\n\r\n\t\t\t// TODO: this is a hack, we should avoid loading it multiple times\r\n\t\t\tif (isValidHash(node.data)) {\r\n\t\t\t\tASSERT(node.data === newdata[ID_NAME]);\r\n\r\n\t\t\t\tnode.data = newdata;\r\n\t\t\t\t__reloadChildrenData(node);\r\n\t\t\t} else {\r\n\t\t\t\t// TODO: if this bites you, use the Cache\r\n                /*if(node.data !== newdata){\r\n                 console.log('kecso',node);\r\n                }\r\n\t\t\t\tASSERT(node.data === newdata);*/\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\t\t};\r\n\r\n\t\tvar loadByPath = function (node, path) {\r\n\t\t\tASSERT(isValidNode(node));\r\n            ASSERT(path === '' || path.charAt(0) === '/');\r\n\r\n            path = path.split('/');\r\n\t\t\treturn __loadDescendantByPath2(node, path, 1);\r\n\t\t};\r\n\r\n\t\tvar __loadDescendantByPath2 = function (node, path, index) {\r\n\t\t\tif (node === null || index === path.length) {\r\n\t\t\t\treturn node;\r\n\t\t\t}\r\n\r\n\t\t\tvar child = loadChild(node, path[index]);\r\n\t\t\treturn TASYNC.call(__loadDescendantByPath2, child, path, index + 1);\r\n\t\t};\r\n\r\n\t\t// ------- valid -------\r\n\r\n\t\tvar printNode = function (node) {\r\n            var str = '{';\r\n            str += 'age:' + node.age;\r\n\r\n            if (typeof node.relid === 'string') {\r\n                str += ', relid: \"' + node.relid + '\"';\r\n\t\t\t}\r\n\r\n            str += ', children:';\r\n\t\t\tif (node.children === null) {\r\n                str += 'null';\r\n\t\t\t} else {\r\n                str += '[';\r\n\t\t\t\tfor (var i = 0; i < node.children.length; ++i) {\r\n\t\t\t\t\tif (i !== 0) {\r\n                        str += ', ';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstr += printNode(node.children[i]);\r\n\t\t\t\t}\r\n                str += ']';\r\n\t\t\t}\r\n\r\n            str += '}';\r\n\t\t\treturn str;\r\n\t\t};\r\n\r\n\t\tvar __test = function (text, cond) {\r\n\t\t\tif (!cond) {\r\n\t\t\t\tthrow new Error(text);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar checkValidTree = function (node) {\r\n\t\t\tif (isValidNode(node)) {\r\n\t\t\t\tif (node.children instanceof Array) {\r\n\t\t\t\t\tfor (var i = 0; i < node.children.length; ++i) {\r\n\t\t\t\t\t\tcheckValidTree(node.children[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// disable checking for now\r\n\t\tvar checkValidTreeRunning = true;\r\n\r\n\t\tvar isValidNode = function (node) {\r\n\t\t\ttry {\r\n                __test('object', typeof node === 'object' && node !== null);\r\n                __test('object 2', node.hasOwnProperty('parent') && node.hasOwnProperty('relid'));\r\n                __test('parent', typeof node.parent === 'object');\r\n                __test('relid', typeof node.relid === 'string' || node.relid === null);\r\n                __test('parent 2', (node.parent === null) === (node.relid === null));\r\n                __test('age', node.age >= 0 && node.age <= MAX_AGE);\r\n                __test('children', node.children === null || node.children instanceof Array);\r\n                __test('children 2', (node.age === MAX_AGE) === (node.children === null));\r\n                __test('data', typeof node.data === 'object' || typeof node.data === 'string' ||\r\n                typeof node.data === 'number');\r\n\r\n\t\t\t\tif (node.parent !== null) {\r\n                    __test('age 2', node.age >= node.parent.age);\r\n                    __test('mutable', !__isMutableData(node.data) || __isMutableData(node.parent.data));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!checkValidTreeRunning) {\r\n\t\t\t\t\tcheckValidTreeRunning = true;\r\n\t\t\t\t\tcheckValidTree(getRoot(node));\r\n\t\t\t\t\tcheckValidTreeRunning = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t} catch (error) {\r\n                console.log('Wrong node', error.stack);\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\treturn {\r\n\t\t\tgetParent: getParent,\r\n\t\t\tgetRelid: getRelid,\r\n\t\t\tgetLevel: getLevel,\r\n\t\t\tgetRoot: getRoot,\r\n\t\t\tgetPath: getPath,\r\n\t\t\tisValidPath: isValidPath,\r\n\t\t\tsplitPath: splitPath,\r\n\t\t\tbuildPath: buildPath,\r\n\t\t\tjoinPaths: joinPaths,\r\n\t\t\tgetCommonPathPrefixData: getCommonPathPrefixData,\r\n\r\n\t\t\tnormalize: normalize,\r\n\t\t\tgetAncestor: getAncestor,\r\n\t\t\tisAncestor: isAncestor,\r\n\t\t\tcreateRoot: createRoot,\r\n\t\t\tcreateChild: createChild,\r\n\t\t\tgetChild: getChild,\r\n\t\t\tgetDescendant: getDescendant,\r\n\t\t\tgetDescendantByPath: getDescendantByPath,\r\n\r\n\t\t\tisMutable: isMutable,\r\n\t\t\tisObject: isObject,\r\n\t\t\tisEmpty: isEmpty,\r\n\t\t\tmutate: mutate,\r\n\t\t\tgetData: getData,\r\n\t\t\tsetData: setData,\r\n\t\t\tdeleteData: deleteData,\r\n\t\t\tcopyData: copyData,\r\n\t\t\tgetProperty: getProperty,\r\n\t\t\tsetProperty: setProperty,\r\n\t\t\tdeleteProperty: deleteProperty,\r\n\t\t\tgetKeys: getKeys,\r\n            getRawKeys: getRawKeys,\r\n\r\n\t\t\tisHashed: isHashed,\r\n\t\t\tsetHashed: setHashed,\r\n\t\t\tgetHash: getHash,\r\n\t\t\tpersist: TASYNC.wrap(FUTURE.unadapt(persist)),\r\n\t\t\tloadRoot: loadRoot,\r\n\t\t\tloadChild: loadChild,\r\n\t\t\tloadByPath: loadByPath,\r\n\r\n\t\t\tisValidNode: isValidNode,\r\n\r\n\t\t\tgetChildHash: getChildHash\r\n\t\t};\r\n\t};\r\n});\r\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/corerel',['common/util/assert', 'common/core/coretree', 'common/core/tasync'], function (ASSERT, CoreTree, TASYNC) {\n\n    'use strict';\n\n    // ----------------- RELID -----------------\n\n    var ATTRIBUTES = 'atr';\n    var REGISTRY = 'reg';\n    var OVERLAYS = 'ovr';\n    var COLLSUFFIX = '-inv';\n\n    function isPointerName(name) {\n        ASSERT(typeof name === 'string');\n        //TODO this is needed as now we work with modified data as well\n        if (name === '_mutable') {\n            return false;\n        }\n        return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\n    }\n\n    function isValidRelid(relid) {\n        return typeof relid === 'string' && parseInt(relid, 10).toString() === relid;\n    }\n\n    function __test(text, cond) {\n        if (!cond) {\n            throw new Error(text);\n        }\n    }\n\n    // ----------------- Core -----------------\n\n    function CoreRel(coretree, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        ASSERT(typeof coretree === 'object');\n\n        var logger = options.logger.fork('corerel');\n\n        logger.debug('initialized');\n\n        function isValidNode(node) {\n            try {\n                __test('coretree', coretree.isValidNode(node));\n                __test('isobject', coretree.isObject(node));\n\n                return true;\n            } catch (error) {\n                console.log('Wrong node', error.stack);\n                return false;\n            }\n        }\n\n        function getAttributeNames(node) {\n            ASSERT(isValidNode(node));\n\n            node = (coretree.getProperty(node, ATTRIBUTES) || {});\n            var keys = coretree.getRawKeys(node);\n            var i = keys.length;\n            while (--i >= 0) {\n                if (keys[i].charAt(0) === '') {\n                    console.log('***** This happens?');\n                    keys.splice(i, 1);\n                }\n            }\n\n            return keys;\n        }\n\n        function getRegistryNames(node) {\n            ASSERT(isValidNode(node));\n\n            node = (coretree.getProperty(node, REGISTRY) || {});\n            var keys = coretree.getRawKeys(node);\n            var i = keys.length;\n            while (--i >= 0) {\n                if (keys[i].charAt(0) === '') {\n                    console.log('***** This happens?');\n                    keys.splice(i, 1);\n                }\n            }\n\n            return keys;\n        }\n\n        function getAttribute(node, name) {\n            /*node = coretree.getChild(node, ATTRIBUTES);\n             return coretree.getProperty(node, name);*/\n            return (coretree.getProperty(node, ATTRIBUTES) || {})[name];\n        }\n\n        function delAttribute(node, name) {\n            node = coretree.getChild(node, ATTRIBUTES);\n            coretree.deleteProperty(node, name);\n        }\n\n        function setAttribute(node, name, value) {\n            node = coretree.getChild(node, ATTRIBUTES);\n            coretree.setProperty(node, name, value);\n        }\n\n        function getRegistry(node, name) {\n            /*node = coretree.getChild(node, REGISTRY);\n             return coretree.getProperty(node, name);*/\n            return (coretree.getProperty(node, REGISTRY) || {})[name];\n        }\n\n        function delRegistry(node, name) {\n            node = coretree.getChild(node, REGISTRY);\n            coretree.deleteProperty(node, name);\n        }\n\n        function setRegistry(node, name, value) {\n            node = coretree.getChild(node, REGISTRY);\n            coretree.setProperty(node, name, value);\n        }\n\n        function overlayInsert(overlays, source, name, target) {\n            ASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\n            ASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\n            ASSERT(coretree.getCommonPathPrefixData(source, target).common === '');\n\n            // console.log('insert', overlays.parent.data.atr.name, source, name, target);\n\n            var node = coretree.getChild(overlays, source);\n\n            ASSERT(coretree.getProperty(node, name) === undefined);\n            coretree.setProperty(node, name, target);\n\n            node = coretree.getChild(overlays, target);\n            name = name + COLLSUFFIX;\n\n            var array = coretree.getProperty(node, name);\n            if (array) {\n                ASSERT(array.indexOf(source) < 0);\n\n                array = array.slice(0);\n                array.push(source);\n            } else {\n                array = [source];\n            }\n\n            coretree.setProperty(node, name, array);\n        }\n\n        function overlayRemove(overlays, source, name, target) {\n            ASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\n            ASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\n            ASSERT(coretree.getCommonPathPrefixData(source, target).common === '');\n\n            // console.log('remove', overlays.parent.data.atr.name, source, name, target);\n\n            var node = coretree.getChild(overlays, source);\n            ASSERT(node && coretree.getProperty(node, name) === target);\n            coretree.deleteProperty(node, name);\n\n            node = coretree.getChild(overlays, target);\n            ASSERT(node);\n\n            name = name + COLLSUFFIX;\n\n            var array = coretree.getProperty(node, name);\n            ASSERT(Array.isArray(array) && array.length >= 1);\n\n            if (array.length === 1) {\n                ASSERT(array[0] === source);\n\n                coretree.deleteProperty(node, name);\n            } else {\n                var index = array.indexOf(source);\n                ASSERT(index >= 0);\n\n                array = array.slice(0);\n                array.splice(index, 1);\n\n                coretree.setProperty(node, name, array);\n            }\n        }\n\n        function overlayQuery(overlays, prefix) {\n            ASSERT(isValidNode(overlays) && coretree.isValidPath(prefix));\n\n            var prefix2 = prefix + '/';\n            var list = [];\n            var paths = coretree.getKeys(overlays);\n\n            for (var i = 0; i < paths.length; ++i) {\n                var path = paths[i];\n                if (path === prefix || path.substr(0, prefix2.length) === prefix2) {\n                    var node = coretree.getChild(overlays, path);\n                    var names = coretree.getKeys(node);\n                    \n                    for (var j = 0; j < names.length; ++j) {\n                        var name = names[j];\n                        if (isPointerName(name)) {\n                            list.push({\n                                s: path,\n                                n: name,\n                                t: coretree.getProperty(node, name),\n                                p: true\n                            });\n                        } else {\n                            var array = coretree.getProperty(node, name);\n                            ASSERT(Array.isArray(array));\n                            name = name.slice(0, -COLLSUFFIX.length);\n                            for (var k = 0; k < array.length; ++k) {\n                                list.push({\n                                    s: array[k],\n                                    n: name,\n                                    t: path,\n                                    p: false\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n\n            // console.log('query', overlays.parent.data.atr.name, prefix, list);\n\n            return list;\n        }\n\n        function createNode(parameters) {\n            parameters = parameters || {};\n            var relid = parameters.relid,\n                parent = parameters.parent;\n\n            ASSERT(!parent || isValidNode(parent));\n            ASSERT(!relid || typeof relid === 'string');\n\n            var node;\n            if (parent) {\n                if (relid) {\n                    node = coretree.getChild(parent, relid);\n                } else {\n                    node = coretree.createChild(parent);\n                }\n                coretree.setHashed(node, true);\n            } else {\n                node = coretree.createRoot();\n            }\n\n            return node;\n        }\n\n        function deleteNode(node) {\n            ASSERT(isValidNode(node));\n\n            var parent = coretree.getParent(node);\n            var prefix = '/' + coretree.getRelid(node);\n            ASSERT(parent !== null);\n\n            coretree.deleteProperty(parent, coretree.getRelid(node));\n\n            while (parent) {\n                var overlays = coretree.getChild(parent, OVERLAYS);\n\n                var list = overlayQuery(overlays, prefix);\n                for (var i = 0; i < list.length; ++i) {\n                    var entry = list[i];\n                    overlayRemove(overlays, entry.s, entry.n, entry.t);\n                }\n\n                prefix = '/' + coretree.getRelid(parent) + prefix;\n                parent = coretree.getParent(parent);\n            }\n        }\n\n        function copyNode(node, parent) {\n            ASSERT(isValidNode(node));\n            ASSERT(!parent || isValidNode(parent));\n\n            node = coretree.normalize(node);\n            var newNode;\n\n            if (parent) {\n                var ancestor = coretree.getAncestor(node, parent);\n\n                // cannot copy inside of itself\n                if (ancestor === node) {\n                    return null;\n                }\n\n                newNode = coretree.createChild(parent);\n                coretree.setHashed(newNode, true);\n                coretree.setData(newNode, coretree.copyData(node));\n\n                var ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\n                var ancestorNewPath = coretree.getPath(newNode, ancestor);\n\n                var base = coretree.getParent(node);\n                var baseOldPath = '/' + coretree.getRelid(node);\n                var aboveAncestor = 1;\n\n                while (base) {\n                    var baseOverlays = coretree.getChild(base, OVERLAYS);\n                    var list = overlayQuery(baseOverlays, baseOldPath);\n                    var tempAncestor = coretree.getAncestor(base, ancestor);\n\n                    aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\n\n                    var relativePath = aboveAncestor < 0 ?\n                        coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\n\n                    for (var i = 0; i < list.length; ++i) {\n                        var entry = list[i];\n\n                        if (entry.p) {\n                            ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n                            ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');\n\n                            var source, target, overlays;\n\n                            if (aboveAncestor < 0) {\n                                //below ancestor node - further from root\n                                source = ancestorNewPath + entry.s.substr(baseOldPath.length);\n                                target = coretree.joinPaths(relativePath, entry.t);\n                                overlays = ancestorOverlays;\n                            } else if (aboveAncestor === 0) {\n                                //at ancestor node\n                                var data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\n\n                                overlays = newNode;\n                                while (data.firstLength-- > 0) {\n                                    overlays = coretree.getParent(overlays);\n                                }\n                                overlays = coretree.getChild(overlays, OVERLAYS);\n\n                                source = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\n                                target = data.second;\n                            } else {\n                                //above ancestor node - closer to root\n                                ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n\n                                source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\n                                target = entry.t;\n                                overlays = baseOverlays;\n                            }\n\n                            overlayInsert(overlays, source, entry.n, target);\n                        }\n                    }\n\n                    baseOldPath = '/' + coretree.getRelid(base) + baseOldPath;\n                    base = coretree.getParent(base);\n                }\n            } else {\n                newNode = coretree.createRoot();\n                coretree.setData(newNode, coretree.copyData(node));\n            }\n\n            return newNode;\n        }\n\n        //kecso\n        function copyNodes(nodes, parent) {\n            //copying multiple nodes at once for keeping their internal relations\n            var paths = [],\n                i, j, index, names, pointer,\n                copiedNodes = [],\n                internalRelationPaths = []; // Every single element will be an object with the\n                                            // internally pointing relations and the index of the target.\n\n            for (i = 0; i < nodes.length; i++) {\n                paths.push(coretree.getPath(nodes[i]));\n            }\n\n            for (i = 0; i < nodes.length; i++) {\n                names = getPointerNames(nodes[i]);\n                pointer = {};\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(getPointerPath(nodes[i], names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                internalRelationPaths.push(pointer);\n            }\n\n            //now we use our simple copy\n            for (i = 0; i < nodes.length; i++) {\n                copiedNodes.push(copyNode(nodes[i], parent));\n            }\n\n            //and now back to the relations\n            for (i = 0; i < internalRelationPaths.length; i++) {\n                names = Object.keys(internalRelationPaths[i]);\n                for (j = 0; j < names.length; j++) {\n                    setPointer(copiedNodes[i], names[j], copiedNodes[internalRelationPaths[i][names[j]]]);\n                }\n            }\n\n            return copiedNodes;\n        }\n\n        function moveNode(node, parent) {\n            ASSERT(isValidNode(node) && isValidNode(parent));\n\n            node = coretree.normalize(node);\n            var ancestor = coretree.getAncestor(node, parent);\n\n            // cannot move inside of itself\n            if (ancestor === node) {\n                return null;\n            }\n\n            var base = coretree.getParent(node);\n            var baseOldPath = '/' + coretree.getRelid(node);\n            var aboveAncestor = 1;\n\n            var oldNode = node;\n            node = coretree.getChild(parent, coretree.getRelid(oldNode));\n            if (!coretree.isEmpty(node)) {\n                // we have to change the relid of the node, to fit into its new\n                // place...\n                node = coretree.createChild(parent);\n            }\n            coretree.setHashed(node, true);\n            coretree.setData(node, coretree.copyData(oldNode));\n\n            var ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\n            var ancestorNewPath = coretree.getPath(node, ancestor);\n\n            while (base) {\n                var baseOverlays = coretree.getChild(base, OVERLAYS);\n                var list = overlayQuery(baseOverlays, baseOldPath);\n                var tempAncestor = coretree.getAncestor(base, ancestor);\n\n                aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\n\n                var relativePath = aboveAncestor < 0 ?\n                    coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\n\n                for (var i = 0; i < list.length; ++i) {\n                    var entry = list[i];\n\n                    overlayRemove(baseOverlays, entry.s, entry.n, entry.t);\n\n                    var tmp;\n                    if (!entry.p) {\n                        tmp = entry.s;\n                        entry.s = entry.t;\n                        entry.t = tmp;\n                    }\n\n                    ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n                    ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');\n\n                    var source, target, overlays;\n\n                    if (aboveAncestor < 0) {\n                        //below ancestor node\n                        source = ancestorNewPath + entry.s.substr(baseOldPath.length);\n                        target = coretree.joinPaths(relativePath, entry.t);\n                        overlays = ancestorOverlays;\n                    } else if (aboveAncestor === 0) {\n                        //at ancestor node\n                        var data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\n\n                        overlays = node;\n                        while (data.firstLength-- > 0) {\n                            overlays = coretree.getParent(overlays);\n                        }\n                        overlays = coretree.getChild(overlays, OVERLAYS);\n\n                        source = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\n                        target = data.second;\n                    } else {\n                        //above ancestor node\n                        ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n\n                        source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\n                        target = entry.t;\n                        overlays = baseOverlays;\n                    }\n\n                    if (!entry.p) {\n                        tmp = entry.s;\n                        entry.s = entry.t;\n                        entry.t = tmp;\n\n                        tmp = source;\n                        source = target;\n                        target = tmp;\n                    }\n\n                    //console.log(source, target);\n                    overlayInsert(overlays, source, entry.n, target);\n                }\n\n                baseOldPath = '/' + coretree.getRelid(base) + baseOldPath;\n                base = coretree.getParent(base);\n            }\n\n            deleteNode(oldNode);\n\n            return node;\n        }\n\n        function getChildrenRelids(node) {\n            ASSERT(isValidNode(node));\n\n            return coretree.getKeys(node, isValidRelid);\n        }\n\n        function getChildrenPaths(node) {\n            var path = coretree.getPath(node);\n\n            var relids = getChildrenRelids(node);\n            for (var i = 0; i < relids.length; ++i) {\n                relids[i] = path + '/' + relids[i];\n            }\n\n            return relids;\n        }\n\n        function loadChildren(node) {\n            ASSERT(isValidNode(node));\n\n            var children = coretree.getKeys(node, isValidRelid);\n            for (var i = 0; i < children.length; ++i) {\n                children[i] = coretree.loadChild(node, children[i]);\n            }\n\n            return TASYNC.lift(children);\n        }\n\n        function getPointerNames(node) {\n            ASSERT(isValidNode(node));\n\n            var source = '';\n            var names = [];\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    for (var name in child) {\n                        ASSERT(names.indexOf(name) === -1);\n                        if (isPointerName(name)) {\n                            names.push(name);\n                        }\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return names;\n        }\n\n        function getPointerPath(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(coretree.getPath(node), target);\n            }\n\n            return target;\n        }\n\n        function hasPointer(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child && child[name] !== undefined) {\n                    return true;\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return false;\n        }\n\n        function getOutsidePointerPath(node, name, source) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n            ASSERT(typeof source === 'string');\n\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(coretree.getPath(node), target);\n            }\n\n            return target;\n        }\n\n        function loadPointer(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            var source = '';\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(typeof target === 'string' && node);\n                return coretree.loadByPath(node, target);\n            } else {\n                return null;\n            }\n        }\n\n        function getCollectionNames(node) {\n            ASSERT(isValidNode(node));\n\n            var target = '';\n            var names = [];\n\n            do {\n                var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\n                if (child) {\n                    for (var name in child) {\n                        if (!isPointerName(name) && name !== '_mutable') {\n                            name = name.slice(0, -COLLSUFFIX.length);\n                            if (isPointerName(name) && names.indexOf(name) < 0) {\n                                names.push(name);\n                            }\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return names;\n        }\n\n        function loadCollection(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            name += COLLSUFFIX;\n\n            var collection = [];\n            var target = '';\n\n            do {\n                var child = coretree.getChild(node, OVERLAYS);\n\n                child = coretree.getChild(child, target);\n                if (child) {\n                    var sources = coretree.getProperty(child, name);\n                    if (sources) {\n                        ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                        for (var i = 0; i < sources.length; ++i) {\n                            collection.push(coretree.loadByPath(node, sources[i]));\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return TASYNC.lift(collection);\n        }\n\n        function getCollectionPaths(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            name += COLLSUFFIX;\n\n            var result = [];\n            var target = '';\n\n            do {\n                var child = coretree.getChild(node, OVERLAYS);\n\n                child = coretree.getChild(child, target);\n                if (child) {\n                    var sources = coretree.getProperty(child, name);\n                    if (sources) {\n                        ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                        var prefix = coretree.getPath(node);\n\n                        for (var i = 0; i < sources.length; ++i) {\n                            result.push(coretree.joinPaths(prefix, sources[i]));\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return result;\n        }\n\n        function deletePointer(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n\n            do {\n                var overlays = coretree.getChild(node, OVERLAYS);\n                ASSERT(overlays);\n\n                var target = coretree.getProperty(coretree.getChild(overlays, source), name);\n                if (target !== undefined) {\n                    overlayRemove(overlays, source, name, target);\n                    return true;\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return false;\n        }\n\n        function setPointer(node, name, target) {\n            ASSERT(isValidNode(node) && typeof name === 'string' && (!target || isValidNode(target)));\n\n            deletePointer(node, name);\n\n            if (target) {\n                var ancestor = coretree.getAncestor(node, target);\n\n                var overlays = coretree.getChild(ancestor, OVERLAYS);\n                var sourcePath = coretree.getPath(node, ancestor);\n                var targetPath = coretree.getPath(target, ancestor);\n\n                overlayInsert(overlays, sourcePath, name, targetPath);\n            }\n        }\n\n        function getChildrenHashes(node) {\n            var keys = getChildrenRelids(node),\n                i, hashes = {};\n\n            for (i = 0; i < keys.length; i++) {\n                hashes[keys[i]] = coretree.getChildHash(node, keys[i]);\n            }\n\n            return hashes;\n        }\n\n        // copy everything from coretree\n        var corerel = {};\n        for (var key in coretree) {\n            corerel[key] = coretree[key];\n        }\n\n        corerel.isValidNode = isValidNode;\n        corerel.isValidRelid = isValidRelid;\n\n        corerel.getChildrenRelids = getChildrenRelids;\n        corerel.getChildrenPaths = getChildrenPaths;\n\n        corerel.loadChildren = loadChildren;\n        corerel.createNode = createNode;\n        corerel.deleteNode = deleteNode;\n        corerel.copyNode = copyNode;\n        corerel.copyNodes = copyNodes;\n        corerel.moveNode = moveNode;\n\n        corerel.getAttributeNames = getAttributeNames;\n        corerel.getAttribute = getAttribute;\n        corerel.setAttribute = setAttribute;\n        corerel.delAttribute = delAttribute;\n\n        corerel.getRegistryNames = getRegistryNames;\n        corerel.getRegistry = getRegistry;\n        corerel.setRegistry = setRegistry;\n        corerel.delRegistry = delRegistry;\n\n        corerel.getPointerNames = getPointerNames;\n        corerel.getPointerPath = getPointerPath;\n        corerel.hasPointer = hasPointer;\n        corerel.getOutsidePointerPath = getOutsidePointerPath;\n        corerel.loadPointer = loadPointer;\n        corerel.deletePointer = deletePointer;\n        corerel.setPointer = setPointer;\n        corerel.getCollectionNames = getCollectionNames;\n        corerel.getCollectionPaths = getCollectionPaths;\n        corerel.loadCollection = loadCollection;\n\n        corerel.getCoreTree = function () {\n            return coretree;\n        };\n\n        corerel.getChildrenHashes = getChildrenHashes;\n\n        corerel.overlayInsert = overlayInsert;\n\n        return corerel;\n    }\n\n    return CoreRel;\n});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/core/setcore',['common/util/assert'], function (ASSERT) {\r\n    'use strict';\r\n\r\n    var SETS_ID = '_sets';\r\n    var REL_ID = 'member';\r\n\r\n    function SetCore(innerCore, options) {\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n\r\n        var logger = options.logger.fork('setcore');\r\n        //help functions\r\n        var setModified = function (node) {\r\n            innerCore.setRegistry(node, '_sets_', (innerCore.getRegistry(node, '_sets_') || 0) + 1);\r\n        };\r\n        var getMemberPath = function (node, setElementNode) {\r\n            var ownPath = innerCore.getPath(node),\r\n                memberPath = innerCore.getPointerPath(setElementNode, REL_ID);\r\n\r\n            //TODO this is a hack and should be solved some other way if possible\r\n            ownPath = ownPath.substring(0, ownPath.indexOf('/_'));\r\n\r\n            if (ownPath !== memberPath) {\r\n                return memberPath;\r\n            }\r\n\r\n            //now we should check who really set this member as its own\r\n            while (innerCore.getBase(node) !== null && innerCore.getBase(setElementNode) !== null &&\r\n            innerCore.getRegistry(innerCore.getBase(setElementNode), '_') === '_') {\r\n\r\n                node = innerCore.getBase(node);\r\n                setElementNode = innerCore.getBase(setElementNode);\r\n                ownPath = innerCore.getPath(node);\r\n\r\n                //TODO this is a hack and should be solved some other way if possible\r\n                ownPath = ownPath.substring(0, ownPath.indexOf('/_'));\r\n            }\r\n            memberPath = innerCore.getPointerPath(setElementNode, REL_ID);\r\n\r\n\r\n            return memberPath;\r\n\r\n        };\r\n        var getMemberRelId = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName);\r\n            var elements = innerCore.getChildrenRelids(setNode);\r\n\r\n            for (var i = 0; i < elements.length; i++) {\r\n                if (getMemberPath(node, innerCore.getChild(setNode, elements[i])) === memberPath) {\r\n                    return elements[i];\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        var createNewMemberRelid = function (setNode) {\r\n            var MAX_RELID = Math.pow(2, 31);\r\n            var existingRelIds = innerCore.getChildrenRelids(setNode);\r\n            var relid;\r\n            do {\r\n                relid = Math.floor(Math.random() * MAX_RELID);\r\n            } while (existingRelIds.indexOf(relid) !== -1);\r\n            return '' + relid;\r\n        };\r\n\r\n        var harmonizeMemberData = function (node, setName) {\r\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName),\r\n                base = innerCore.getBase(setNode),\r\n                allMembers = innerCore.getChildrenRelids(setNode),\r\n                ownMembers, inheritedMembers, i, j, path, names, ownMember, inheritedMember, k;\r\n            if (base) {\r\n                harmonizeMemberData(base, setName); //recursively harmonize base members first\r\n                inheritedMembers = innerCore.getChildrenRelids(base);\r\n                ownMembers = [];\r\n                for (i = 0; i < allMembers.length; i++) {\r\n                    if (inheritedMembers.indexOf(allMembers[i]) === -1) {\r\n                        ownMembers.push(allMembers[i]);\r\n                    }\r\n                }\r\n\r\n                for (i = 0; i < ownMembers.length; i++) {\r\n                    ownMember = innerCore.getChild(setNode, ownMembers[i]);\r\n                    path = innerCore.getPointerPath(ownMember, 'member');\r\n                    for (j = 0; j < inheritedMembers.length; j++) {\r\n                        inheritedMember = innerCore.getChild(setNode, inheritedMembers[j]);\r\n                        if (getMemberPath(node, inheritedMember) === path) {\r\n                            //redundancy...\r\n                            names = innerCore.getAttributeNames(ownMember);\r\n                            for (k = 0; k < names.length; k++) {\r\n                                if (innerCore.getAttribute(ownMember, names[k]) !==\r\n                                    innerCore.getAttribute(inheritedMember, names[k])) {\r\n\r\n                                    innerCore.setAttribute(inheritedMember, names[k],\r\n                                        innerCore.getAttribute(ownMember, names[k]));\r\n                                }\r\n                            }\r\n                            names = innerCore.getRegistryNames(ownMember);\r\n                            for (k = 0; k < names.length; k++) {\r\n                                if (innerCore.getRegistry(ownMember, names[k]) !==\r\n                                    innerCore.getRegistry(inheritedMember, names[k])) {\r\n\r\n                                    innerCore.setRegistry(inheritedMember, names[k],\r\n                                        innerCore.getRegistry(ownMember, names[k]));\r\n                                }\r\n                            }\r\n                            innerCore.deleteNode(innerCore.getChild(setNode, ownMembers[i]), true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        //copy lower layer\r\n        var setcore = {};\r\n        for (var i in innerCore) {\r\n            setcore[i] = innerCore[i];\r\n        }\r\n        logger.debug('initialized');\r\n        //adding new functions\r\n        setcore.getSetNumbers = function (node) {\r\n            return this.getSetNames(node).length;\r\n        };\r\n\r\n        setcore.getSetNames = function (node) {\r\n            return innerCore.getPointerNames(innerCore.getChild(node, SETS_ID)) || [];\r\n        };\r\n\r\n        setcore.getPointerNames = function (node) {\r\n            var sorted = [],\r\n                raw = innerCore.getPointerNames(node);\r\n            for (var i = 0; i < raw.length; i++) {\r\n                if (raw[i].indexOf(REL_ID) === -1) {\r\n                    sorted.push(raw[i]);\r\n                }\r\n            }\r\n            return sorted;\r\n        };\r\n\r\n        setcore.getCollectionNames = function (node) {\r\n            var sorted = [],\r\n                raw = innerCore.getCollectionNames(node);\r\n            for (var i = 0; i < raw.length; i++) {\r\n                if (raw[i].indexOf(REL_ID) === -1) {\r\n                    sorted.push(raw[i]);\r\n                }\r\n            }\r\n            return sorted;\r\n        };\r\n\r\n        setcore.getMemberPaths = function (node, setName) {\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName);\r\n            var members = [];\r\n            var elements = innerCore.getChildrenRelids(setNode);\r\n            elements = elements.sort(); //TODO this should be removed at some point\r\n            for (var i = 0; i < elements.length; i++) {\r\n                var path = getMemberPath(node, innerCore.getChild(setNode, elements[i]));\r\n                if (path) {\r\n                    members.push(path);\r\n                }\r\n            }\r\n            return members;\r\n        };\r\n\r\n        setcore.delMember = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            //we only need the path of the member so we allow to enter only it\r\n            if (typeof memberPath !== 'string') {\r\n                memberPath = innerCore.getPath(memberPath);\r\n            }\r\n\r\n            var setMemberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (setMemberRelId) {\r\n                var setMemberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), setMemberRelId);\r\n\r\n                innerCore.deleteNode(setMemberNode, true);\r\n                setModified(node);\r\n            }\r\n        };\r\n\r\n        setcore.addMember = function (node, setName, member) {\r\n            ASSERT(typeof setName === 'string');\r\n            var setsNode = innerCore.getChild(node, SETS_ID);\r\n            //TODO decide if the member addition should really create the set or it should fail...\r\n            if (innerCore.getPointerPath(setsNode, setName) === undefined) {\r\n                setcore.createSet(node, setName);\r\n            }\r\n            harmonizeMemberData(node, setName);\r\n            var setNode = innerCore.getChild(setsNode, setName);\r\n            var setMemberRelId = getMemberRelId(node, setName, setcore.getPath(member));\r\n            if (setMemberRelId === null) {\r\n                var setMember = innerCore.getChild(setNode, createNewMemberRelid(setNode));\r\n                innerCore.setPointer(setMember, 'member', member);\r\n\r\n                //TODO hack, somehow the empty children have been removed during persist\r\n                innerCore.setRegistry(setMember, '_', '_');\r\n                setModified(node);\r\n            }\r\n        };\r\n\r\n        //TODO: Refactor out getMemberNode:\r\n        //TODO: var memberNode = innerCore.getChild(\r\n        //TODO: innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n        setcore.getMemberAttributeNames = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                return innerCore.getAttributeNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n\r\n        setcore.getMemberOwnAttributeNames = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                return innerCore.getOwnAttributeNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n\r\n        setcore.getMemberAttribute = function (node, setName, memberPath, attrName) {\r\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                return innerCore.getAttribute(memberNode, attrName);\r\n            }\r\n        };\r\n\r\n        setcore.setMemberAttribute = function (node, setName, memberPath, attrName, attrValue) {\r\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string' && attrValue !== undefined);\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                innerCore.setAttribute(memberNode, attrName, attrValue);\r\n                setModified(node);\r\n            }\r\n        };\r\n\r\n        setcore.delMemberAttribute = function (node, setName, memberPath, attrName) {\r\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                innerCore.delAttribute(memberNode, attrName);\r\n                setModified(node);\r\n            }\r\n        };\r\n\r\n        setcore.getMemberRegistryNames = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                return innerCore.getRegistryNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n        setcore.getMemberOwnRegistryNames = function (node, setName, memberPath) {\r\n            ASSERT(typeof setName === 'string');\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                return innerCore.getOwnRegistryNames(memberNode);\r\n            }\r\n            return [];\r\n        };\r\n        setcore.getMemberRegistry = function (node, setName, memberPath, regName) {\r\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                return innerCore.getRegistry(memberNode, regName);\r\n            }\r\n        };\r\n        setcore.setMemberRegistry = function (node, setName, memberPath, regName, regValue) {\r\n            ASSERT(typeof setName === 'string' && typeof regName === 'string' && regValue !== undefined);\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                innerCore.setRegistry(memberNode, regName, regValue);\r\n                setModified(node);\r\n            }\r\n        };\r\n        setcore.delMemberRegistry = function (node, setName, memberPath, regName) {\r\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\r\n            harmonizeMemberData(node, setName);\r\n            var memberRelId = getMemberRelId(node, setName, memberPath);\r\n            if (memberRelId) {\r\n                var memberNode = innerCore.getChild(\r\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\r\n\r\n                innerCore.delRegistry(memberNode, regName);\r\n                setModified(node);\r\n            }\r\n        };\r\n        setcore.createSet = function (node, setName) {\r\n            ASSERT(typeof setName === 'string');\r\n            var setsNode = innerCore.getChild(node, SETS_ID),\r\n                setNode = innerCore.getChild(setsNode, setName);\r\n\r\n            //FIXME: hack, somehow the empty children have been removed during persist\r\n            innerCore.setRegistry(setNode, '_', '_');\r\n\r\n            innerCore.setPointer(innerCore.getChild(node, SETS_ID), setName, null);\r\n            setModified(node);\r\n        };\r\n        setcore.deleteSet = function (node, setName) {\r\n            ASSERT(typeof setName === 'string');\r\n            var setsNode = innerCore.getChild(node, SETS_ID),\r\n                setNode = innerCore.getChild(setsNode, setName);\r\n            innerCore.deletePointer(setsNode, setName);\r\n            innerCore.deleteNode(setNode, true);\r\n            setModified(node);\r\n        };\r\n\r\n        setcore.isMemberOf = function (node) {\r\n            //TODO we should find a proper way to do this - or at least some support from lower layers would be fine\r\n            var coll = setcore.getCollectionPaths(node, REL_ID);\r\n            var sets = {};\r\n            for (var i = 0; i < coll.length; i++) {\r\n                var pathArray = coll[i].split('/');\r\n                if (pathArray.indexOf('_meta') === -1) {\r\n                    //now we simply skip META sets...\r\n                    var index = pathArray.indexOf(SETS_ID);\r\n                    if (index > 0 && pathArray.length > index + 1) {\r\n                        //otherwise it is not a real set\r\n                        var ownerPath = pathArray.slice(0, index).join('/');\r\n                        if (sets[ownerPath] === undefined) {\r\n                            sets[ownerPath] = [];\r\n                        }\r\n                        sets[ownerPath].push(pathArray[index + 1]);\r\n                    }\r\n                }\r\n            }\r\n            return sets;\r\n        };\r\n\r\n        /*setcore.getDataForSingleHash = function(node){\r\n         ASSERT(setcore.isValidNode(node));\r\n         var datas = innerCore.getDataForSingleHash(node);\r\n\r\n         //now we should stir all the sets hashes into the node's hash to get changes deep inside\r\n         var names = setcore.getSetNames(node);\r\n         for(var i=0;i<names.length;i++){\r\n         var setNode = setcore.getChild(setcore.getChild(node,SETS_ID),names[i]);\r\n         var memberRelids = setcore.getChildrenRelids(setNode);\r\n         for(var j=0;j<memberRelids.length;j++){\r\n         datas = datas.concat(innerCore.getDataForSingleHash(setcore.getChild(setNode,memberRelids[j])));\r\n         }\r\n         }\r\n\r\n         return datas;\r\n         };*/\r\n\r\n        return setcore;\r\n\r\n    }\r\n\r\n    return SetCore;\r\n});\r\n\r\n\r\n\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/regexp',[], function () {\n    'use strict';\n    var HASH = new RegExp('^#[0-9a-zA-Z_]*$'),\n        BRANCH = new RegExp('^[0-9a-zA-Z_]*$'),\n        RAW_BRANCH = new RegExp('^\\\\*[0-9a-zA-Z_]*$'),// This is how it's stored in mongodb, i.e. with a prefixed *.\n        PROJECT = new RegExp('^(?!system\\\\.)(?!_)[0-9a-zA-Z_]*$'), // project name may not start with system. or _\n\n        GUID = new RegExp('[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}', 'i');\n\n    return {\n        HASH: HASH,\n        BRANCH: BRANCH,\n        RAW_BRANCH: RAW_BRANCH,\n        PROJECT: PROJECT,\n        GUID: GUID\n    };\n});\n\n",
    "/*globals define*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/core/guidcore',[\r\n    'common/util/assert',\r\n    'common/util/guid',\r\n    'common/core/tasync',\r\n    'common/regexp'\r\n], function (ASSERT, GUID, TASYNC, REGEXP) {\r\n\r\n    'use strict';\r\n\r\n    var OWN_GUID = '_relguid';\r\n\r\n    function guidCore(_innerCore, options) {\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n        var logger = options.logger.fork('guidCore');\r\n        //helper functions\r\n        function toInternalGuid(myGuid) {\r\n            return myGuid.replace(/-/g, '');\r\n        }\r\n\r\n        function toExternalGuid(myGuid) {\r\n            var out = myGuid.substr(0, 8) + '-' + myGuid.substr(8, 4) + '-' +\r\n                myGuid.substr(12, 4) + '-' + myGuid.substr(16, 4) + '-' + myGuid.substr(20);\r\n            return out;\r\n        }\r\n\r\n        function guidToArray(guid) {\r\n            if (guid === null || guid === undefined) {\r\n                return [0, 0, 0, 0, 0, 0, 0, 0];\r\n            }\r\n            var array = [];\r\n            for (var i = 0; i < guid.length / 4; i++) {\r\n                array.push(parseInt(guid.substr(4 * i, 4), 16));\r\n            }\r\n            return array;\r\n        }\r\n\r\n        function getRelidGuid(node) {\r\n            //TODO we always should know what structure we should expect as a relid -\r\n            // now we think it is a number so it can be converted to 0xsomething\r\n            var relid = _core.getRelid(node);\r\n            relid = Number(relid);\r\n            if (relid === 'NaN') {\r\n                return null;\r\n            }\r\n            if (relid < 0) {\r\n                relid = relid * (-1);\r\n            }\r\n\r\n            relid = relid.toString(16);\r\n\r\n            //now we should fill up with 0's in the beggining\r\n            while (relid.length < 32) {\r\n                relid = relid + '0'; //TODO we pad to the end so the final result will be more visible during debug\r\n            }\r\n            return relid;\r\n        }\r\n\r\n        function xorGuids(a, b) {\r\n            var arrayA = guidToArray(a);\r\n            var arrayB = guidToArray(b);\r\n\r\n            ASSERT(arrayA.length === arrayB.length);\r\n\r\n            var arrayOut = [];\r\n            for (var i = 0; i < arrayA.length; i++) {\r\n                /*jshint bitwise: false*/\r\n                arrayOut.push(arrayA[i] ^ arrayB[i]);\r\n            }\r\n            for (i = 0; i < arrayOut.length; i++) {\r\n                arrayOut[i] = Number(arrayOut[i]).toString(16);\r\n                var difi = 4 - arrayOut[i].length;\r\n                while (difi > 0) {\r\n                    arrayOut[i] = '0' + arrayOut[i];\r\n                    difi--;\r\n                }\r\n            }\r\n            return arrayOut.join('');\r\n        }\r\n\r\n        var _core = {};\r\n        for (var i in _innerCore) {\r\n            _core[i] = _innerCore[i];\r\n        }\r\n        logger.debug('initialized');\r\n        //new functions\r\n        _core.getMiddleGuid = function (node) {\r\n            var outGuid = _core.getAttribute(node, OWN_GUID);\r\n            var tempnode = _core.getParent(node);\r\n            while (tempnode) {\r\n                outGuid = xorGuids(outGuid, _core.getAttribute(tempnode, OWN_GUID));\r\n                tempnode = _core.getParent(tempnode);\r\n            }\r\n            return outGuid;\r\n        };\r\n\r\n        _core.getGuid = function (node) {\r\n            var middle = _core.getMiddleGuid(node),\r\n                relid = getRelidGuid(node),\r\n                guid = xorGuids(middle, relid);\r\n            return toExternalGuid(guid);\r\n        };\r\n\r\n        _core.setGuid = function (node, guid) {\r\n            ASSERT(REGEXP.GUID.test(guid));\r\n            var children = _core.loadChildren(node);\r\n            return TASYNC.call(function (nodeArray) {\r\n                var newGuid = toInternalGuid(guid);\r\n                //first setting the node's OWN_GUID\r\n                var oldOwn = _core.getAttribute(node, OWN_GUID);\r\n                var parent = _core.getParent(node);\r\n                if (parent) {\r\n                    _core.setAttribute(node, OWN_GUID,\r\n                        xorGuids(newGuid, xorGuids(_core.getMiddleGuid(parent), getRelidGuid(node))));\r\n                } else {\r\n                    _core.setAttribute(node, OWN_GUID, xorGuids(newGuid, getRelidGuid(node)));\r\n                }\r\n                var newOwn = _core.getAttribute(node, OWN_GUID);\r\n                //now modify its children's\r\n                for (var i = 0; i < nodeArray.length; i++) {\r\n                    var oldGuid = _core.getAttribute(nodeArray[i], OWN_GUID);\r\n                    _core.setAttribute(nodeArray[i], OWN_GUID, xorGuids(oldGuid, xorGuids(oldOwn, newOwn)));\r\n                }\r\n\r\n                return;\r\n            }, children);\r\n        };\r\n\r\n        //modified functions\r\n        _core.createNode = function (parameters) {\r\n            parameters = parameters || {};\r\n            var guid = parameters.guid || GUID(),\r\n                parent = parameters.parent;\r\n\r\n            ASSERT(REGEXP.GUID.test(guid));\r\n\r\n            var node = _innerCore.createNode(parameters);\r\n            guid = toInternalGuid(guid);\r\n\r\n            var relguid = '';\r\n            if (parent) {\r\n                relguid = xorGuids(toInternalGuid(_core.getMiddleGuid(_core.getParent(node))),\r\n                    xorGuids(guid, getRelidGuid(node)));\r\n            } else {\r\n                relguid = xorGuids(guid, getRelidGuid(node));\r\n            }\r\n            _innerCore.setAttribute(node, OWN_GUID, relguid);\r\n\r\n            return node;\r\n        };\r\n\r\n        _core.moveNode = function (node, parent) {\r\n            var oldGuid = toInternalGuid(_core.getGuid(node)),\r\n                newNode = _innerCore.moveNode(node, parent);\r\n\r\n            _core.setAttribute(newNode, OWN_GUID, xorGuids(_core.getMiddleGuid(parent),\r\n                xorGuids(oldGuid, getRelidGuid(newNode))));\r\n\r\n            return newNode;\r\n        };\r\n\r\n        _core.copyNode = function (node, parent) {\r\n            var newNode = _innerCore.copyNode(node, parent);\r\n            _core.setAttribute(newNode, OWN_GUID, toInternalGuid(GUID()));\r\n            return newNode;\r\n        };\r\n\r\n        _core.copyNodes = function (nodes, parent) {\r\n            var copiedNodes = _innerCore.copyNodes(nodes, parent),\r\n                i;\r\n            for (i = 0; i < copiedNodes.length; i++) {\r\n                _core.setAttribute(copiedNodes[i], OWN_GUID, toInternalGuid(GUID()));\r\n            }\r\n\r\n            return copiedNodes;\r\n        };\r\n\r\n        return _core;\r\n    }\r\n\r\n    return guidCore;\r\n});\r\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/core/nullpointercore',['common/util/assert'], function (ASSERT) {\r\n    'use strict';\r\n\r\n    var NULLPTR_NAME = '_null_pointer';\r\n    var NULLPTR_RELID = '_nullptr';\r\n\r\n\r\n    function nullPointerCore(_innerCore, options) {\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n        var _core = {},\r\n            logger = options.logger.fork('nullpointercore');\r\n        for (var i in _innerCore) {\r\n            _core[i] = _innerCore[i];\r\n        }\r\n        logger.debug('initialized');\r\n\r\n        //extra functions\r\n        _core.setPointer = function (node, name, target) {\r\n            if (target === null) {\r\n                var nullChild = _innerCore.getChild(node, NULLPTR_RELID);\r\n                _innerCore.setAttribute(nullChild, 'name', NULLPTR_NAME);\r\n                _innerCore.setPointer(node, name, nullChild);\r\n            } else {\r\n                _innerCore.setPointer(node, name, target);\r\n            }\r\n        };\r\n\r\n        _core.getPointerPath = function (node, name) {\r\n            var path = _innerCore.getPointerPath(node, name);\r\n            if (path && path.indexOf(NULLPTR_RELID) !== -1) {\r\n                return null;\r\n            } else {\r\n                return path;\r\n            }\r\n        };\r\n\r\n        _core.loadPointer = function (node, name) {\r\n            var path = _core.getPointerPath(node, name);\r\n            if (path === null) {\r\n                return null;\r\n            } else {\r\n                return _innerCore.loadPointer(node, name);\r\n            }\r\n        };\r\n\r\n        return _core;\r\n    }\r\n\r\n    return nullPointerCore;\r\n});\r\n\r\n\r\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author mmaroti / https://github.com/mmaroti\r\n */\r\n\r\ndefine('common/core/coreunwrap',['common/util/assert', 'common/core/tasync'], function (ASSERT, TASYNC) {\r\n    'use strict';\r\n\r\n    // ----------------- CoreUnwrap -----------------\r\n\r\n    var CoreUnwrap = function (oldcore, options) {\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n        var logger = options.logger.fork('coreunwrap');\r\n\r\n        function checkNode(node) {\r\n            if (node === null || oldcore.isValidNode(node)) {\r\n                return node;\r\n            } else {\r\n                throw new Error('Invalid result node');\r\n            }\r\n        }\r\n\r\n        function checkNodes(nodes) {\r\n            ASSERT(nodes instanceof Array);\r\n\r\n            var i;\r\n            for (i = 0; i < nodes.length; ++i) {\r\n                if (!oldcore.isValidNode(nodes[i])) {\r\n                    throw new Error('Invalid result node array');\r\n                }\r\n            }\r\n\r\n            return nodes;\r\n        }\r\n\r\n        // copy all operations\r\n        var core = {};\r\n        for (var key in oldcore) {\r\n            core[key] = oldcore[key];\r\n        }\r\n        logger.debug('initialized');\r\n        core.loadRoot = TASYNC.unwrap(oldcore.loadRoot);\r\n        core.persist = TASYNC.unwrap(oldcore.persist);\r\n\r\n        // core.loadChild = TASYNC.unwrap(oldcore.loadChild);\r\n        core.loadChild = TASYNC.unwrap(function (node, relid) {\r\n            return TASYNC.call(checkNode, oldcore.loadChild(node, relid));\r\n        });\r\n\r\n        // core.loadByPath = TASYNC.unwrap(oldcore.loadByPath);\r\n        core.loadByPath = TASYNC.unwrap(function (node, path) {\r\n            return TASYNC.call(checkNode, oldcore.loadByPath(node, path));\r\n        });\r\n\r\n        // core.loadChildren = TASYNC.unwrap(oldcore.loadChildren);\r\n        core.loadChildren = TASYNC.unwrap(function (node) {\r\n            return TASYNC.call(checkNodes, oldcore.loadChildren(node));\r\n        });\r\n\r\n        core.loadPointer = TASYNC.unwrap(oldcore.loadPointer);\r\n        core.loadCollection = TASYNC.unwrap(oldcore.loadCollection);\r\n\r\n        core.loadSubTree = TASYNC.unwrap(oldcore.loadSubTree);\r\n        core.loadTree = TASYNC.unwrap(oldcore.loadTree);\r\n\r\n        //core diff async functions\r\n        if (typeof oldcore.generateTreeDiff === 'function') {\r\n            core.generateTreeDiff = TASYNC.unwrap(oldcore.generateTreeDiff);\r\n        }\r\n\r\n        if (typeof oldcore.generateLightTreeDiff === 'function') {\r\n            core.generateLightTreeDiff = TASYNC.unwrap(oldcore.generateLightTreeDiff);\r\n        }\r\n\r\n        if (typeof oldcore.applyTreeDiff === 'function') {\r\n            core.applyTreeDiff = TASYNC.unwrap(oldcore.applyTreeDiff);\r\n        }\r\n\r\n        return core;\r\n    };\r\n\r\n    return CoreUnwrap;\r\n});\r\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author mmaroti / https://github.com/mmaroti\r\n */\r\n\r\ndefine('common/core/coretype',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\r\n    'use strict';\r\n\r\n    // ----------------- CoreType -----------------\r\n\r\n    //FIXME TODO these stuff have been simply copied from lower layer, probably it should be put to some constant place\r\n    var OVERLAYS = 'ovr';\r\n    var COLLSUFFIX = '-inv';\r\n\r\n    var CoreType = function (oldcore, options) {\r\n        // copy all operations\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n        var core = {},\r\n            logger = options.logger.fork('coretype');\r\n        for (var key in oldcore) {\r\n            core[key] = oldcore[key];\r\n        }\r\n        logger.debug('initialized');\r\n        // ----- validity\r\n\r\n        function __test(text, cond) {\r\n            if (!cond) {\r\n                throw new Error(text);\r\n            }\r\n        }\r\n\r\n        function isValidNode(node) {\r\n            try {\r\n                __test('core', oldcore.isValidNode(node));\r\n                __test('base', typeof node.base === 'object');\r\n                return true;\r\n            } catch (error) {\r\n                console.log('Wrong node', error.stack);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        function isFalseNode(node) {\r\n            //TODO this hack should be removed, but now it seems just fine :)\r\n            if (typeof oldcore.getPointerPath(node, 'base') === 'undefined') {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        core.isValidNode = isValidNode;\r\n\r\n        // ----- navigation\r\n\r\n        core.getBase = function (node) {\r\n            ASSERT(isValidNode(node));\r\n\r\n            // TODO: check if base has moved\r\n            return node.base;\r\n        };\r\n\r\n        core.getBaseRoot = function (node) {\r\n            ASSERT(isValidNode(node));\r\n            while (node.base !== null) {\r\n                node = node.base;\r\n            }\r\n\r\n            return node;\r\n        };\r\n\r\n        core.loadRoot = function (hash) {\r\n            return TASYNC.call(__loadRoot2, oldcore.loadRoot(hash));\r\n        };\r\n\r\n        function __loadRoot2(node) {\r\n            ASSERT(typeof node.base === 'undefined' || node.base === null);\r\n            //kecso - TODO it should be undefined, but maybe because of the cache it can be null\r\n\r\n            node.base = null;\r\n            return node;\r\n        }\r\n\r\n        core.loadChild = function (node, relid) {\r\n            var child = null,\r\n                base = core.getBase(node),\r\n                basechild = null;\r\n            if (base) {\r\n                //the parent is inherited\r\n                if (oldcore.getChildrenRelids(base).indexOf(relid) !== -1) {\r\n                    //inherited child\r\n                    if (oldcore.getChildrenRelids(node).indexOf(relid) !== -1) {\r\n                        //but it is overwritten so we should load it\r\n                        child = oldcore.loadChild(node, relid);\r\n                    }\r\n                    basechild = core.loadChild(base, relid);\r\n                    return TASYNC.call(function (b, c, n, r) {\r\n                        if (c) {\r\n                            child = c;\r\n                            child.base = b;\r\n                            return child;\r\n                        } else {\r\n                            child = core.getChild(n, r);\r\n                            core.setHashed(child, true, true);\r\n                            child.base = b;\r\n                            n.children.push(child);\r\n                            n.data[r] = child.data; //FIXME there should be a proper way to do this\r\n                            return child;\r\n                        }\r\n                    }, basechild, child, node, relid);\r\n                }\r\n            }\r\n            //normal child\r\n            return TASYNC.call(__loadBase, oldcore.loadChild(node, relid));\r\n        };\r\n\r\n        core.loadByPath = function (node, path) {\r\n            ASSERT(isValidNode(node));\r\n            ASSERT(path === '' || path.charAt(0) === '/');\r\n            path = path.split('/');\r\n            return loadDescendantByPath(node, path, 1);\r\n        };\r\n        var loadDescendantByPath = function (node, pathArray, index) {\r\n            if (node === null || index === pathArray.length) {\r\n                return node;\r\n            }\r\n\r\n            var child = core.loadChild(node, pathArray[index]);\r\n            return TASYNC.call(loadDescendantByPath, child, pathArray, index + 1);\r\n        };\r\n\r\n        //TODO the pointer loading is totally based upon the loadByPath...\r\n        core.loadPointer = function (node, name) {\r\n            var pointerPath = core.getPointerPath(node, name);\r\n            return TASYNC.call(core.loadByPath, core.getRoot(node), pointerPath);\r\n        };\r\n\r\n        function __loadBase(node) {\r\n            ASSERT(node === null || typeof node.base === 'undefined' || typeof node.base === 'object');\r\n\r\n            if (typeof node.base === 'undefined') {\r\n                if (core.isEmpty(node)) {\r\n                    //empty nodes do not have a base\r\n                    node.base = null;\r\n                    return node;\r\n                } else if (isFalseNode(node)) {\r\n                    var root = core.getRoot(node);\r\n                    oldcore.deleteNode(node);\r\n                    core.persist(root);\r\n                    return null;\r\n                } else {\r\n                    var basepath = oldcore.getPointerPath(node, 'base');\r\n                    ASSERT(basepath !== undefined);\r\n                    if (basepath === null) {\r\n                        node.base = null;\r\n                        return node;\r\n                    } else {\r\n                        return TASYNC.call(__loadBase2, node, core.loadByPath(core.getRoot(node), basepath));\r\n                    }\r\n                }\r\n            } else {\r\n                //TODO can the base change at this point???\r\n                return node;\r\n            }\r\n        }\r\n\r\n        function __loadBase2(node, target) {\r\n            if (typeof node.base !== null && typeof node.base === 'object' &&\r\n                (oldcore.getPath(node.base) === oldcore.getPath(target))) {\r\n                //TODO somehow the object already loaded properly and we do no know about it!!!\r\n                return node;\r\n            } else {\r\n                ASSERT(typeof node.base === 'undefined' || node.base === null); //kecso\r\n\r\n                if (target === null) {\r\n                    node.base = null;\r\n                    return node;\r\n                } else {\r\n                    return TASYNC.call(function (n, b) {\r\n                        n.base = b;\r\n                        return n;\r\n                    }, node, __loadBase(target));\r\n                }\r\n            }\r\n        }\r\n\r\n        core.getChildrenRelids = function (node) {\r\n            var inheritRelIds = node.base === null ? [] : core.getChildrenRelids(core.getBase(node));\r\n            var ownRelIds = oldcore.getChildrenRelids(node);\r\n            for (var i = 0; i < inheritRelIds.length; i++) {\r\n                if (ownRelIds.indexOf(inheritRelIds[i]) === -1) {\r\n                    ownRelIds.push(inheritRelIds[i]);\r\n                }\r\n            }\r\n            return ownRelIds;\r\n        };\r\n\r\n        core.loadChildren = function (node) {\r\n            ASSERT(isValidNode(node));\r\n            var relids = core.getChildrenRelids(node);\r\n            relids = relids.sort(); //TODO this should be temporary\r\n            var children = [];\r\n            for (var i = 0; i < relids.length; i++) {\r\n                children[i] = core.loadChild(node, relids[i]);\r\n            }\r\n            return TASYNC.call(function (n) {\r\n                var newn = [];\r\n                for (var i = 0; i < n.length; i++) {\r\n                    if (n[i] !== null) {\r\n                        newn.push(n[i]);\r\n                    }\r\n                }\r\n                return newn;\r\n            }, TASYNC.lift(children));\r\n        };\r\n\r\n        //collection handling and needed functions\r\n        function _isInheritedChild(node) {\r\n            var parent = core.getParent(node),\r\n                base = core.getBase(node),\r\n                parentBase = parent ? core.getBase(parent) : null,\r\n                baseParent = base ? core.getParent(base) : null;\r\n\r\n            if (baseParent && parentBase && core.getPath(baseParent) === core.getPath(parentBase)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function _getInstanceRoot(node) {\r\n\r\n            while (_isInheritedChild(node)) {\r\n                node = core.getParent(node);\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        //TODO copied function from corerel\r\n        function isPointerName(name) {\r\n            ASSERT(typeof name === 'string');\r\n\r\n            return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\r\n        }\r\n\r\n        function _getInheritedCollectionNames(node) {\r\n            var target = '',\r\n                names = [],\r\n                coretree = core.getCoreTree(),\r\n                startNode = node,\r\n                endNode = _getInstanceRoot(node),\r\n                exit;\r\n\r\n            if (core.getPath(startNode) === core.getPath(endNode)) {\r\n                return names;\r\n            }\r\n\r\n            do {\r\n                startNode = core.getBase(startNode);\r\n                endNode = core.getBase(endNode);\r\n                node = startNode;\r\n                exit = false;\r\n                target = '';\r\n                do {\r\n                    if (core.getPath(node) === core.getPath(endNode)) {\r\n                        exit = true;\r\n                    }\r\n                    var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\r\n                    if (child) {\r\n                        for (var name in child) {\r\n                            if (!isPointerName(name)) {\r\n                                name = name.slice(0, -COLLSUFFIX.length);\r\n                                if (names.indexOf(name) < 0) {\r\n                                    names.push(name);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    target = '/' + coretree.getRelid(node) + target;\r\n                    node = coretree.getParent(node);\r\n                } while (!exit);\r\n            } while (_isInheritedChild(startNode));\r\n\r\n            return names;\r\n        }\r\n\r\n        function _getInheritedCollectionPaths(node, name) {\r\n            var target = '',\r\n                result = [],\r\n                coretree = core.getCoreTree(),\r\n                startNode = node,\r\n                endNode = _getInstanceRoot(node),\r\n                prefixStart = startNode,\r\n                prefixNode = prefixStart,\r\n                exit,\r\n                collName = name + COLLSUFFIX,\r\n                notOverwritten = function (sNode, eNode, source) {\r\n                    var result = true,\r\n                        tNode = sNode,\r\n                        child, target;\r\n\r\n                    while (core.getPath(tNode) !== core.getPath(eNode)) {\r\n                        child = coretree.getChild(tNode, OVERLAYS);\r\n                        child = coretree.getChild(child, source);\r\n                        if (child) {\r\n                            target = coretree.getProperty(child, name);\r\n                            if (target) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                        tNode = core.getBase(tNode);\r\n                    }\r\n\r\n                    return result;\r\n                };\r\n\r\n            if (core.getPath(startNode) === core.getPath(endNode)) {\r\n                return result;\r\n            }\r\n\r\n            do {\r\n                startNode = core.getBase(startNode);\r\n                endNode = core.getBase(endNode);\r\n                node = startNode;\r\n                prefixNode = prefixStart;\r\n                exit = false;\r\n                target = '';\r\n                do {\r\n                    if (core.getPath(node) === core.getPath(endNode)) {\r\n                        exit = true;\r\n                    }\r\n                    var child = coretree.getChild(node, OVERLAYS);\r\n                    child = coretree.getChild(child, target);\r\n                    if (child) {\r\n                        var sources = coretree.getProperty(child, collName);\r\n                        if (sources) {\r\n                            ASSERT(Array.isArray(sources) && sources.length >= 1);\r\n\r\n                            var prefix = coretree.getPath(prefixNode);\r\n\r\n                            for (var i = 0; i < sources.length; ++i) {\r\n                                if (notOverwritten(prefixNode, node, sources[i])) {\r\n                                    result.push(coretree.joinPaths(prefix, sources[i]));\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    target = '/' + coretree.getRelid(node) + target;\r\n                    node = coretree.getParent(node);\r\n                    prefixNode = core.getParent(prefixNode);\r\n                } while (!exit);\r\n            } while (_isInheritedChild(startNode));\r\n\r\n            return result;\r\n        }\r\n\r\n        core.getCollectionNames = function (node) {\r\n            ASSERT(isValidNode(node));\r\n            var checkCollNames = function (draft) {\r\n                    var filtered = [],\r\n                        i, sources;\r\n                    for (i = 0; i < draft.length; i++) {\r\n                        sources = core.getCollectionPaths(node, draft[i]);\r\n                        if (sources.length > 0) {\r\n                            filtered.push(draft[i]);\r\n                        }\r\n                    }\r\n                    return filtered;\r\n                },\r\n                ownNames = oldcore.getCollectionNames(node),\r\n                inhNames = checkCollNames(_getInheritedCollectionNames(node)),\r\n                i;\r\n            for (i = 0; i < ownNames.length; i++) {\r\n                if (inhNames.indexOf(ownNames[i]) < 0) {\r\n                    inhNames.push(ownNames[i]);\r\n                }\r\n            }\r\n\r\n            return inhNames;\r\n        };\r\n\r\n        core.getCollectionPaths = function (node, name) {\r\n            ASSERT(isValidNode(node) && name);\r\n            var ownPaths = oldcore.getCollectionPaths(node, name),\r\n                inhPaths = _getInheritedCollectionPaths(node, name);\r\n\r\n            inhPaths = inhPaths.concat(ownPaths);\r\n\r\n            return inhPaths;\r\n        };\r\n\r\n        core.loadCollection = function (node, name) {\r\n            var root = core.getRoot(node);\r\n            var paths = core.getCollectionPaths(node, name);\r\n\r\n            var nodes = [];\r\n            for (var i = 0; i < paths.length; i++) {\r\n                nodes[i] = core.loadByPath(root, paths[i]);\r\n            }\r\n\r\n            return TASYNC.lift(nodes);\r\n        };\r\n\r\n        // ----- creation\r\n\r\n        core.createNode = function (parameters) {\r\n            parameters = parameters || {};\r\n            var base = parameters.base || null,\r\n                parent = parameters.parent;\r\n\r\n\r\n            ASSERT(!parent || isValidNode(parent));\r\n            ASSERT(!base || isValidNode(base));\r\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\r\n\r\n            var node = oldcore.createNode(parameters);\r\n            node.base = base;\r\n            oldcore.setPointer(node, 'base', base);\r\n\r\n            return node;\r\n        };\r\n\r\n        // ----- properties\r\n\r\n        core.getAttributeNames = function (node) {\r\n            ASSERT(isValidNode(node));\r\n\r\n            var merged = {};\r\n            do {\r\n                var names = oldcore.getAttributeNames(node);\r\n                for (var i = 0; i < names.length; ++i) {\r\n                    if (!(names[i] in merged)) {\r\n                        merged[names[i]] = true;\r\n                    }\r\n                }\r\n\r\n                node = node.base;\r\n            } while (node);\r\n\r\n            return Object.keys(merged);\r\n        };\r\n        core.getOwnAttributeNames = function (node) {\r\n            return oldcore.getAttributeNames(node);\r\n        };\r\n\r\n        core.getRegistryNames = function (node) {\r\n            ASSERT(isValidNode(node));\r\n\r\n            var merged = {};\r\n            do {\r\n                var names = oldcore.getRegistryNames(node);\r\n                for (var i = 0; i < names.length; ++i) {\r\n                    if (!(names[i] in merged)) {\r\n                        merged[names[i]] = true;\r\n                    }\r\n                }\r\n\r\n                node = node.base;\r\n            } while (node);\r\n\r\n            return Object.keys(merged);\r\n        };\r\n        core.getOwnRegistryNames = function (node) {\r\n            return oldcore.getRegistryNames(node);\r\n        };\r\n\r\n        core.getAttribute = function (node, name) {\r\n            ASSERT(isValidNode(node));\r\n            var value;\r\n            do {\r\n                value = oldcore.getAttribute(node, name);\r\n                node = node.base;\r\n            } while (typeof value === 'undefined' && node !== null);\r\n\r\n            return value;\r\n        };\r\n        core.getOwnAttribute = function (node, name) {\r\n            return oldcore.getAttribute(node, name);\r\n        };\r\n\r\n        core.getRegistry = function (node, name) {\r\n            ASSERT(isValidNode(node));\r\n            var value;\r\n            do {\r\n                value = oldcore.getRegistry(node, name);\r\n                node = node.base;\r\n            } while (typeof value === 'undefined' && node !== null);\r\n\r\n            return value;\r\n        };\r\n        core.getOwnRegistry = function (node, name) {\r\n            return oldcore.getRegistry(node, name);\r\n        };\r\n\r\n\r\n        // ----- pointers\r\n\r\n        core.getPointerNames = function (node) {\r\n            ASSERT(isValidNode(node));\r\n\r\n            var merged = {};\r\n            do {\r\n                var names = oldcore.getPointerNames(node);\r\n                for (var i = 0; i < names.length; ++i) {\r\n                    if (!(names[i] in merged)) {\r\n                        merged[names[i]] = true;\r\n                    }\r\n                }\r\n\r\n                node = node.base;\r\n            } while (node);\r\n\r\n            return Object.keys(merged);\r\n        };\r\n        core.getOwnPointerNames = function (node) {\r\n            ASSERT(isValidNode(node));\r\n            return oldcore.getPointerNames(node);\r\n        };\r\n\r\n        core.getPointerPath = function (node, name) {\r\n            ASSERT(isValidNode(node) && typeof name === 'string');\r\n\r\n            var ownPointerPath = oldcore.getPointerPath(node, name);\r\n            if (ownPointerPath !== undefined) {\r\n                return ownPointerPath;\r\n            }\r\n            var source = '',\r\n                target,\r\n                coretree = core.getCoreTree(),\r\n                basePath,\r\n                hasNullTarget = false,\r\n                getProperty = function (node, name) {\r\n                    var property;\r\n                    while (property === undefined && node !== null) {\r\n                        property = coretree.getProperty(node, name);\r\n                        node = core.getBase(node);\r\n                    }\r\n                    return property;\r\n                },\r\n                getSimpleBasePath = function (node) {\r\n                    var path = oldcore.getPointerPath(node, name);\r\n                    if (path === undefined) {\r\n                        if (node.base !== null && node.base !== undefined) {\r\n                            return getSimpleBasePath(node.base);\r\n                        } else {\r\n                            return undefined;\r\n                        }\r\n                    } else {\r\n                        return path;\r\n                    }\r\n                },\r\n                getParentOfBasePath = function (node) {\r\n                    if (node.base) {\r\n                        var parent = core.getParent(node.base);\r\n                        if (parent) {\r\n                            return core.getPath(parent);\r\n                        } else {\r\n                            return undefined;\r\n                        }\r\n                    } else {\r\n                        return undefined;\r\n                    }\r\n                },\r\n                getBaseOfParentPath = function (node) {\r\n                    var parent = core.getParent(node);\r\n                    if (parent) {\r\n                        if (parent.base) {\r\n                            return core.getPath(parent.base);\r\n                        } else {\r\n                            return undefined;\r\n                        }\r\n                    } else {\r\n                        return undefined;\r\n                    }\r\n                },\r\n                getTargetRelPath = function (node, relSource, name) {\r\n                    var ovr = core.getChild(node, 'ovr');\r\n                    var source = core.getChild(ovr, relSource);\r\n                    return getProperty(source, name);\r\n                };\r\n\r\n            basePath = node.base ? getSimpleBasePath(node.base) : undefined;\r\n\r\n            while (node) {\r\n                target = getTargetRelPath(node, source, name);\r\n                if (target !== undefined) {\r\n                    if (target.indexOf('_nullptr') !== -1) {\r\n                        hasNullTarget = true;\r\n                        target = undefined;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                source = '/' + core.getRelid(node) + source;\r\n                if (getParentOfBasePath(node) === getBaseOfParentPath(node)) {\r\n                    node = core.getParent(node);\r\n                } else {\r\n                    node = null;\r\n                }\r\n            }\r\n\r\n\r\n            if (target !== undefined) {\r\n                ASSERT(node);\r\n                target = coretree.joinPaths(oldcore.getPath(node), target);\r\n            }\r\n\r\n            if (typeof target === 'string') {\r\n                return target;\r\n            }\r\n            if (typeof basePath === 'string') {\r\n                return basePath;\r\n            }\r\n            if (hasNullTarget === true) {\r\n                return null;\r\n            }\r\n            return undefined;\r\n\r\n        };\r\n        core.getOwnPointerPath = function (node, name) {\r\n            oldcore.getPointerPath(node, name);\r\n        };\r\n\r\n        core.setBase = function (node, base) {\r\n            ASSERT(isValidNode(node) && (base === undefined || base === null || isValidNode(base)));\r\n            ASSERT(!base || core.getPath(core.getParent(node)) !== core.getPath(base));\r\n            ASSERT(!base || core.getPath(node) !== core.getPath(base));\r\n            if (!!base) {\r\n                //TODO maybe this is not the best way, needs to be double checked\r\n                node.base = base;\r\n                var parent = core.getParent(node),\r\n                    parentBase, baseParent;\r\n                if (parent) {\r\n                    parentBase = core.getBase(parent);\r\n                    baseParent = core.getParent(base);\r\n                    if (core.getPath(parentBase) !== core.getPath(baseParent)) {\r\n                        //we have to set an exact pointer only if it is not inherited child\r\n                        oldcore.setPointer(node, 'base', base);\r\n                    } else {\r\n                        oldcore.deletePointer(node, 'base'); //we remove the pointer just in case\r\n                    }\r\n                } else {\r\n                    //if for some reason the node doesn't have a parent it is surely not an inherited child\r\n                    oldcore.setPointer(node, 'base', base);\r\n                }\r\n            } else {\r\n                oldcore.setPointer(node, 'base', null);\r\n                node.base = null;\r\n            }\r\n        };\r\n\r\n        core.getChild = function (node, relid) {\r\n            ASSERT(isValidNode(node) && (typeof node.base === 'undefined' || typeof node.base === 'object'));\r\n            var child = oldcore.getChild(node, relid);\r\n            if (node.base !== null && node.base !== undefined) {\r\n                if (child.base === null || child.base === undefined) {\r\n                    child.base = core.getChild(node.base, relid);\r\n                }\r\n            } else {\r\n                child.base = null;\r\n            }\r\n            return child;\r\n        };\r\n        core.moveNode = function (node, parent) {\r\n            //TODO we have to check if the move is really allowed!!!\r\n            ASSERT(isValidNode(node) && isValidNode(parent));\r\n            var base = node.base,\r\n                parentBase = parent.base;\r\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\r\n            ASSERT(!parentBase || core.getPath(parentBase) !== core.getPath(node));\r\n\r\n            var moved = oldcore.moveNode(node, parent);\r\n            moved.base = base;\r\n            return moved;\r\n        };\r\n        core.copyNode = function (node, parent) {\r\n            var base = node.base;\r\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\r\n\r\n            var newnode = oldcore.copyNode(node, parent);\r\n            newnode.base = base;\r\n            oldcore.setPointer(newnode, 'base', base);\r\n            return newnode;\r\n        };\r\n        function _inheritedPointerNames(node) {\r\n            var allNames = core.getPointerNames(node),\r\n                ownNames = core.getOwnPointerNames(node),\r\n                names = [],\r\n                i;\r\n\r\n            for (i = 0; i < allNames.length; i++) {\r\n                if (ownNames.indexOf(allNames[i]) === -1) {\r\n                    names.push(allNames[i]);\r\n                }\r\n            }\r\n\r\n            return names;\r\n        }\r\n\r\n        core.copyNodes = function (nodes, parent) {\r\n            var copiedNodes,\r\n                i, j, index, base,\r\n                relations = [],\r\n                names, pointer,\r\n                paths = [];\r\n\r\n            //here we also have to copy the inherited relations which points inside the copy area\r\n            for (i = 0; i < nodes.length; i++) {\r\n                paths.push(core.getPath(nodes[i]));\r\n            }\r\n\r\n            for (i = 0; i < nodes.length; i++) {\r\n                names = _inheritedPointerNames(nodes[i]);\r\n                pointer = {};\r\n                for (j = 0; j < names.length; j++) {\r\n                    index = paths.indexOf(core.getPointerPath(nodes[i], names[j]));\r\n                    if (index !== -1) {\r\n                        pointer[names[j]] = index;\r\n                    }\r\n                }\r\n                relations.push(pointer);\r\n            }\r\n\r\n            //making the actual copy\r\n            copiedNodes = oldcore.copyNodes(nodes, parent);\r\n\r\n            //setting internal-inherited relations\r\n            for (i = 0; i < nodes.length; i++) {\r\n                names = Object.keys(relations[i]);\r\n                for (j = 0; j < names.length; j++) {\r\n                    core.setPointer(copiedNodes[i], names[j], copiedNodes[relations[i][names[j]]]);\r\n                }\r\n            }\r\n\r\n            //setting base relation\r\n            for (i = 0; i < nodes.length; i++) {\r\n                base = nodes[i].base;\r\n                copiedNodes[i].base = base;\r\n                oldcore.setPointer(copiedNodes[i], 'base', base);\r\n            }\r\n\r\n\r\n            return copiedNodes;\r\n        };\r\n\r\n        core.getChildrenPaths = function (node) {\r\n            var path = core.getPath(node);\r\n\r\n            var relids = core.getChildrenRelids(node);\r\n            for (var i = 0; i < relids.length; ++i) {\r\n                relids[i] = path + '/' + relids[i];\r\n            }\r\n\r\n            return relids;\r\n        };\r\n\r\n        core.deleteNode = function (node, technical) {\r\n            //currently we only check if the node is inherited from its parents children\r\n            if (node && (node.base !== null || technical === true)) {\r\n                var parent = core.getParent(node),\r\n                    parentsBase = parent ? core.getBase(node) : null,\r\n                    base = core.getBase(node),\r\n                    basesParent = base ? core.getParent(node) : null;\r\n\r\n                if (parent && parentsBase && base && basesParent) {\r\n                    if (core.getPath(parentsBase) !== core.getPath(basesParent)) {\r\n                        oldcore.deleteNode(node);\r\n                    }\r\n                } else {\r\n                    oldcore.deleteNode(node);\r\n                }\r\n            }\r\n        };\r\n\r\n        core.getTypeRoot = function (node) {\r\n            if (node.base) {\r\n                while (node.base !== null) {\r\n                    node = core.getBase(node);\r\n                }\r\n                return node;\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n\r\n        // -------- kecso\r\n\r\n        return core;\r\n    };\r\n\r\n    return CoreType;\r\n});\r\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n *\r\n * example constraint structure for the outside world:\r\n * {\r\n *  script:string,\r\n *  priority:integer,\r\n *  name:string,\r\n *  message:string\r\n * }\r\n * provided API:\r\n * getConstraint(node,name) -> constraintObj\r\n * setConstraint(node,constraintObj)\r\n * getConstraintNames(node)\r\n * delConstraint(node,name)\r\n */\r\n\r\ndefine('common/core/constraintcore',['common/util/assert'], function (ASSERT) {\r\n    'use strict';\r\n    var CONSTRAINTS_RELID = '_constraints';\r\n    var C_DEF_PRIORITY = 1;\r\n\r\n    function constraintCore(_innerCore, options) {\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n        var _core = {},\r\n            logger = options.logger.fork('constraintcore');\r\n        for (var i in _innerCore) {\r\n            _core[i] = _innerCore[i];\r\n        }\r\n        logger.debug('initialized');\r\n        var createNewConstraintRelId = function (constraintsNode) {\r\n            var max = Math.pow(2, 31);\r\n            var existingRelIds = _innerCore.getChildrenRelids(constraintsNode);\r\n            var relId;\r\n            do {\r\n                relId = Math.floor(Math.random() * max);\r\n            } while (existingRelIds.indexOf(relId) !== -1);\r\n            return '' + relId;\r\n        };\r\n\r\n        var getConstraintRelId = function (constraintsNode, name) {\r\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\r\n            var relId;\r\n            for (var i = 0; i < relIds.length; i++) {\r\n                if (name === _innerCore.getAttribute(_innerCore.getChild(constraintsNode, relIds[i]), 'name')) {\r\n                    relId = relIds[i];\r\n                    break;\r\n                }\r\n            }\r\n            return relId;\r\n        };\r\n        var getRegConstName = function (name) {\r\n            return '_ch#_' + name;\r\n        };\r\n\r\n        _core.getConstraint = function (node, name) {\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\r\n            var constRelId = getConstraintRelId(constraintsNode, name);\r\n            if (constRelId) {\r\n                var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\r\n                return {\r\n                    script: _innerCore.getAttribute(constraintNode, 'script'),\r\n                    priority: _innerCore.getAttribute(constraintNode, 'priority'),\r\n                    info: _innerCore.getAttribute(constraintNode, 'info')\r\n                };\r\n            } else {\r\n                return null;\r\n            }\r\n        };\r\n\r\n        _core.setConstraint = function (node, name, constraintObj) {\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            ASSERT(typeof constraintObj === 'object' && typeof name === 'string');\r\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\r\n            var constRelId = getConstraintRelId(constraintsNode, name);\r\n            if (!constRelId) {\r\n                //we should create a new one\r\n                constRelId = createNewConstraintRelId(constraintsNode);\r\n            }\r\n\r\n            var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\r\n            constraintObj.priority = constraintObj.priority || C_DEF_PRIORITY;\r\n            constraintObj.script = constraintObj.script || 'console.log(\"empty constraint\");';\r\n            constraintObj.info = constraintObj.info || '';\r\n            _innerCore.setAttribute(constraintNode, 'name', name);\r\n            _innerCore.setAttribute(constraintNode, 'script', constraintObj.script);\r\n            _innerCore.setAttribute(constraintNode, 'priority', constraintObj.priority);\r\n            _innerCore.setAttribute(constraintNode, 'info', constraintObj.info);\r\n            _innerCore.setRegistry(node, getRegConstName(name),\r\n                (_innerCore.getRegistry(node, getRegConstName(name)) || 0) + 1);\r\n        };\r\n\r\n        _core.delConstraint = function (node, name) {\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\r\n            var constRelId = getConstraintRelId(constraintsNode, name);\r\n            if (constRelId) {\r\n                var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\r\n                _innerCore.deleteNode(constraintNode, true);\r\n            }\r\n            _innerCore.delRegistry(node, getRegConstName(name));\r\n        };\r\n\r\n        _core.getConstraintNames = function (node) {\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\r\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\r\n            var names = [];\r\n            for (var i = 0; i < relIds.length; i++) {\r\n                names.push(_innerCore.getAttribute(_innerCore.getChild(constraintsNode, relIds[i]), 'name'));\r\n            }\r\n            return names;\r\n        };\r\n\r\n        //TODO this means we always have to have this layer above type/inheritance layer\r\n        _core.getOwnConstraintNames = function (node) {\r\n            ASSERT(_innerCore.isValidNode(node));\r\n            var names = _core.getConstraintNames(node),\r\n                base = _core.getBase(node),\r\n                baseNames = [],\r\n                i, index;\r\n\r\n            if (base) {\r\n                baseNames = _core.getConstraintNames(base);\r\n            }\r\n\r\n            for (i = 0; i < baseNames.length; i++) {\r\n                index = names.indexOf(baseNames[i]);\r\n                if (index !== -1) {\r\n                    names.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            return names;\r\n        };\r\n\r\n        return _core;\r\n    }\r\n\r\n    return constraintCore;\r\n});\r\n\n",
    "//jshint ignore: start\n/* jshint proto: true */\n\n/**\n * jjv.js -- A javascript library to validate json input through a json-schema.\n *\n * Copyright (c) 2013 Alex Cornejo.\n *\n * Redistributable under a MIT-style open source license.\n */\n\n(function () {\n  var clone = function (obj) {\n      // Handle the 3 simple types (string, number, function), and null or undefined\n      if (obj === null || typeof obj !== 'object') return obj;\n      var copy;\n\n      // Handle Date\n      if (obj instanceof Date) {\n          copy = new Date();\n          copy.setTime(obj.getTime());\n          return copy;\n      }\n\n      // handle RegExp\n      if (obj instanceof RegExp) {\n        copy = new RegExp(obj);\n        return copy;\n      }\n\n      // Handle Array\n      if (obj instanceof Array) {\n          copy = [];\n          for (var i = 0, len = obj.length; i < len; i++)\n              copy[i] = clone(obj[i]);\n          return copy;\n      }\n\n      // Handle Object\n      if (obj instanceof Object) {\n          copy = {};\n//           copy = Object.create(Object.getPrototypeOf(obj));\n          for (var attr in obj) {\n              if (obj.hasOwnProperty(attr))\n                copy[attr] = clone(obj[attr]);\n          }\n          return copy;\n      }\n\n      throw new Error(\"Unable to clone object!\");\n  };\n\n  var clone_stack = function (stack) {\n    var stack_last = stack.length-1, key = stack[stack_last].key;\n    var new_stack = stack.slice(0);\n    new_stack[stack_last].object[key] = clone(new_stack[stack_last].object[key]);\n    return new_stack;\n  };\n\n  var copy_stack = function (new_stack, old_stack) {\n    var stack_last = new_stack.length-1, key = new_stack[stack_last].key;\n    old_stack[stack_last].object[key] = new_stack[stack_last].object[key];\n  };\n\n  var handled = {\n    'type': true,\n    'not': true,\n    'anyOf': true,\n    'allOf': true,\n    'oneOf': true,\n    '$ref': true,\n    '$schema': true,\n    'id': true,\n    'exclusiveMaximum': true,\n    'exclusiveMininum': true,\n    'properties': true,\n    'patternProperties': true,\n    'additionalProperties': true,\n    'items': true,\n    'additionalItems': true,\n    'required': true,\n    'default': true,\n    'title': true,\n    'description': true,\n    'definitions': true,\n    'dependencies': true\n  };\n\n  var fieldType = {\n    'null': function (x) {\n      return x === null;\n    },\n    'string': function (x) {\n      return typeof x === 'string';\n    },\n    'boolean': function (x) {\n      return typeof x === 'boolean';\n    },\n    'number': function (x) {\n      return typeof x === 'number' && !isNaN(x);\n    },\n    'integer': function (x) {\n      return typeof x === 'number' && x%1 === 0;\n    },\n    'object': function (x) {\n      return x && typeof x === 'object' && !Array.isArray(x);\n    },\n    'array': function (x) {\n      return Array.isArray(x);\n    },\n    'date': function (x) {\n      return x instanceof Date;\n    }\n  };\n\n  // missing: uri, date-time, ipv4, ipv6\n  var fieldFormat = {\n    'alpha': function (v) {\n      return (/^[a-zA-Z]+$/).test(v);\n    },\n    'alphanumeric': function (v) {\n      return (/^[a-zA-Z0-9]+$/).test(v);\n    },\n    'identifier': function (v) {\n      return (/^[-_a-zA-Z0-9]+$/).test(v);\n    },\n    'hexadecimal': function (v) {\n      return (/^[a-fA-F0-9]+$/).test(v);\n    },\n    'numeric': function (v) {\n      return (/^[0-9]+$/).test(v);\n    },\n    'date-time': function (v) {\n      return !isNaN(Date.parse(v)) && v.indexOf('/') === -1;\n    },\n    'uppercase': function (v) {\n      return v === v.toUpperCase();\n    },\n    'lowercase': function (v) {\n      return v === v.toLowerCase();\n    },\n    'hostname': function (v) {\n      return v.length < 256 && (/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])(\\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9]))*$/).test(v);\n    },\n    'uri': function (v) {\n      return (/[-a-zA-Z0-9@:%_\\+.~#?&//=]{2,256}\\.[a-z]{2,4}\\b(\\/[-a-zA-Z0-9@:%_\\+.~#?&//=]*)?/).test(v);\n    },\n    'email': function (v) { // email, ipv4 and ipv6 adapted from node-validator\n      return (/^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/).test(v);\n    },\n    'ipv4': function (v) {\n      if ((/^(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)\\.(\\d?\\d?\\d)$/).test(v)) {\n        var parts = v.split('.').sort();\n        if (parts[3] <= 255)\n          return true;\n      }\n      return false;\n    },\n    'ipv6': function(v) {\n      return (/^((?=.*::)(?!.*::.+::)(::)?([\\dA-F]{1,4}:(:|\\b)|){5}|([\\dA-F]{1,4}:){6})((([\\dA-F]{1,4}((?!\\3)::|:\\b|$))|(?!\\2\\3)){2}|(((2[0-4]|1\\d|[1-9])?\\d|25[0-5])\\.?\\b){4})$/).test(v);\n     /*  return (/^::|^::1|^([a-fA-F0-9]{1,4}::?){1,7}([a-fA-F0-9]{1,4})$/).test(v); */\n    }\n  };\n\n  var fieldValidate = {\n    'readOnly': function (v, p) {\n      return false;\n    },\n    // ****** numeric validation ********\n    'minimum': function (v, p, schema) {\n      return !(v < p || schema.exclusiveMinimum && v <= p);\n    },\n    'maximum': function (v, p, schema) {\n      return !(v > p || schema.exclusiveMaximum && v >= p);\n    },\n    'multipleOf': function (v, p) {\n      return (v/p)%1 === 0 || typeof v !== 'number';\n    },\n    // ****** string validation ******\n    'pattern': function (v, p) {\n      if (typeof v !== 'string')\n        return true;\n      var pattern, modifiers;\n      if (typeof p === 'string')\n        pattern=p;\n      else {\n        pattern=p[0];\n        modifiers=p[1];\n      }\n      var regex = new RegExp(pattern, modifiers);\n      return regex.test(v);\n    },\n    'minLength': function (v, p) {\n      return v.length >= p || typeof v !== 'string';\n    },\n    'maxLength': function (v, p) {\n      return v.length <= p || typeof v !== 'string';\n    },\n    // ***** array validation *****\n    'minItems': function (v, p) {\n      return v.length >= p || !Array.isArray(v);\n    },\n    'maxItems': function (v, p) {\n      return v.length <= p || !Array.isArray(v);\n    },\n    'uniqueItems': function (v, p) {\n      var hash = {}, key;\n      for (var i = 0, len = v.length; i < len; i++) {\n        key = JSON.stringify(v[i]);\n        if (hash.hasOwnProperty(key))\n          return false;\n        else\n          hash[key] = true;\n      }\n      return true;\n    },\n    // ***** object validation ****\n    'minProperties': function (v, p) {\n      if (typeof v !== 'object')\n        return true;\n      var count = 0;\n      for (var attr in v) if (v.hasOwnProperty(attr)) count = count + 1;\n      return count >= p;\n    },\n    'maxProperties': function (v, p) {\n      if (typeof v !== 'object')\n        return true;\n      var count = 0;\n      for (var attr in v) if (v.hasOwnProperty(attr)) count = count + 1;\n      return count <= p;\n    },\n    // ****** all *****\n    'enum': function (v, p) {\n      var i, len, vs;\n      if (typeof v === 'object') {\n        vs = JSON.stringify(v);\n        for (i = 0, len = p.length; i < len; i++)\n          if (vs === JSON.stringify(p[i]))\n            return true;\n      } else {\n        for (i = 0, len = p.length; i < len; i++)\n          if (v === p[i])\n            return true;\n      }\n      return false;\n    }\n  };\n\n  var normalizeID = function (id) {\n    return id.indexOf(\"://\") === -1 ? id : id.split(\"#\")[0];\n  };\n\n  var resolveURI = function (env, schema_stack, uri) {\n    var curschema, components, hash_idx, name;\n\n    hash_idx = uri.indexOf('#');\n\n    if (hash_idx === -1) {\n      if (!env.schema.hasOwnProperty(uri))\n        return null;\n      return [env.schema[uri]];\n    }\n\n    if (hash_idx > 0) {\n      name = uri.substr(0, hash_idx);\n      uri = uri.substr(hash_idx+1);\n      if (!env.schema.hasOwnProperty(name)) {\n        if (schema_stack && schema_stack[0].id === name)\n          schema_stack = [schema_stack[0]];\n        else\n          return null;\n      } else\n        schema_stack = [env.schema[name]];\n    } else {\n      if (!schema_stack)\n        return null;\n      uri = uri.substr(1);\n    }\n\n    if (uri === '')\n      return [schema_stack[0]];\n\n    if (uri.charAt(0) === '/') {\n      uri = uri.substr(1);\n      curschema = schema_stack[0];\n      components = uri.split('/');\n      while (components.length > 0) {\n        if (!curschema.hasOwnProperty(components[0]))\n          return null;\n        curschema = curschema[components[0]];\n        schema_stack.push(curschema);\n        components.shift();\n      }\n      return schema_stack;\n    } else // FIX: should look for subschemas whose id matches uri\n      return null;\n  };\n\n  var resolveObjectRef = function (object_stack, uri) {\n    var components, object, last_frame = object_stack.length-1, skip_frames, frame, m = /^(\\d+)/.exec(uri);\n\n    if (m) {\n      uri = uri.substr(m[0].length);\n      skip_frames = parseInt(m[1], 10);\n      if (skip_frames < 0 || skip_frames > last_frame)\n        return;\n      frame = object_stack[last_frame-skip_frames];\n      if (uri === '#')\n        return frame.key;\n    } else\n      frame = object_stack[0];\n\n    object = frame.object[frame.key];\n\n    if (uri === '')\n      return object;\n\n    if (uri.charAt(0) === '/') {\n      uri = uri.substr(1);\n      components = uri.split('/');\n      while (components.length > 0) {\n        components[0] = components[0].replace(/~1/g, '/').replace(/~0/g, '~');\n        if (!object.hasOwnProperty(components[0]))\n          return;\n        object = object[components[0]];\n        components.shift();\n      }\n      return object;\n    } else\n      return;\n  };\n\n  var checkValidity = function (env, schema_stack, object_stack, options) {\n    var i, len, count, hasProp, hasPattern;\n    var p, v, malformed = false, objerrs = {}, objerr, objreq, errors = {}, props, matched, isArray;\n    var sl = schema_stack.length-1, schema = schema_stack[sl];\n    var ol = object_stack.length-1, object = object_stack[ol].object, name = object_stack[ol].key, prop = object[name];\n\n    if (schema.hasOwnProperty('$ref')) {\n      schema_stack= resolveURI(env, schema_stack, schema.$ref);\n      if (!schema_stack)\n        return {'$ref': schema.$ref};\n      else\n        return checkValidity(env, schema_stack, object_stack, options);\n    }\n\n    if (schema.hasOwnProperty('type')) {\n      if (typeof schema.type === 'string') {\n        if (options.useCoerce && env.coerceType.hasOwnProperty(schema.type))\n          prop = object[name] = env.coerceType[schema.type](prop);\n        if (!env.fieldType[schema.type](prop))\n          return {'type': schema.type};\n      } else {\n        malformed = true;\n        for (i = 0, len = schema.type.length; i < len && malformed; i++)\n          if (env.fieldType[schema.type[i]](prop))\n            malformed = false;\n        if (malformed)\n          return {'type': schema.type};\n      }\n    }\n\n    if (schema.hasOwnProperty('allOf')) {\n      for (i = 0, len = schema.allOf.length; i < len; i++) {\n        objerr = checkValidity(env, schema_stack.concat(schema.allOf[i]), object_stack, options);\n        if (objerr)\n          return objerr;\n      }\n    }\n\n    if (!options.useCoerce && !options.useDefault && !options.removeAdditional) {\n      if (schema.hasOwnProperty('oneOf')) {\n        for (i = 0, len = schema.oneOf.length, count = 0; i < len; i++) {\n          objerr = checkValidity(env, schema_stack.concat(schema.oneOf[i]), object_stack, options);\n          if (!objerr) {\n            count = count + 1;\n            if (count > 1)\n              break;\n          } else {\n            objerrs = objerr;\n          }\n        }\n        if (count > 1)\n          return {'oneOf': true};\n        else if (count < 1)\n          return objerrs;\n        objerrs = {};\n      }\n\n      if (schema.hasOwnProperty('anyOf')) {\n        for (i = 0, len = schema.anyOf.length; i < len; i++) {\n          objerr = checkValidity(env, schema_stack.concat(schema.anyOf[i]), object_stack, options);\n          if (!objerr)\n            break;\n        }\n        if (objerr)\n          return objerr;\n      }\n\n      if (schema.hasOwnProperty('not')) {\n        objerr = checkValidity(env, schema_stack.concat(schema.not), object_stack, options);\n        if (!objerr)\n          return {'not': true};\n      }\n    } else {\n      if (schema.hasOwnProperty('oneOf')) {\n        for (i = 0, len = schema.oneOf.length, count = 0; i < len; i++) {\n          new_stack = clone_stack(object_stack);\n          objerr = checkValidity(env, schema_stack.concat(schema.oneOf[i]), new_stack, options);\n          if (!objerr) {\n            count = count + 1;\n            if (count > 1)\n              break;\n            else\n              copy_stack(new_stack, object_stack);\n          } else {\n            objerrs = objerr;\n          }\n        }\n        if (count > 1)\n          return {'oneOf': true};\n        else if (count < 1)\n          return objerrs;\n        objerrs = {};\n      }\n\n      if (schema.hasOwnProperty('anyOf')) {\n        for (i = 0, len = schema.anyOf.length; i < len; i++) {\n          new_stack = clone_stack(object_stack);\n          objerr = checkValidity(env, schema_stack.concat(schema.anyOf[i]), new_stack, options);\n          if (!objerr) {\n            copy_stack(new_stack, object_stack);\n            break;\n          }\n        }\n        if (objerr)\n          return objerr;\n      }\n\n      if (schema.hasOwnProperty('not')) {\n        objerr = checkValidity(env, schema_stack.concat(schema.not), clone_stack(object_stack), options);\n        if (!objerr)\n          return {'not': true};\n      }\n    }\n\n    if (schema.hasOwnProperty('dependencies')) {\n      for (p in schema.dependencies)\n        if (schema.dependencies.hasOwnProperty(p) && prop.hasOwnProperty(p)) {\n          if (Array.isArray(schema.dependencies[p])) {\n            for (i = 0, len = schema.dependencies[p].length; i < len; i++)\n              if (!prop.hasOwnProperty(schema.dependencies[p][i])) {\n                return {'dependencies': true};\n              }\n          } else {\n            objerr = checkValidity(env, schema_stack.concat(schema.dependencies[p]), object_stack, options);\n            if (objerr)\n              return objerr;\n          }\n        }\n    }\n\n    if (!Array.isArray(prop)) {\n      props = [];\n      objerrs = {};\n      for (p in prop)\n        if (prop.hasOwnProperty(p))\n          props.push(p);\n\n      if (options.checkRequired && schema.required) {\n        for (i = 0, len = schema.required.length; i < len; i++)\n          if (!prop.hasOwnProperty(schema.required[i])) {\n            objerrs[schema.required[i]] = {'required': true};\n            malformed = true;\n          }\n      }\n\n      hasProp = schema.hasOwnProperty('properties');\n      hasPattern = schema.hasOwnProperty('patternProperties');\n      if (hasProp || hasPattern) {\n        i = props.length;\n        while (i--) {\n          matched = false;\n          if (hasProp && schema.properties.hasOwnProperty(props[i])) {\n            matched = true;\n            objerr = checkValidity(env, schema_stack.concat(schema.properties[props[i]]), object_stack.concat({object: prop, key: props[i]}), options);\n            if (objerr !== null) {\n              objerrs[props[i]] = objerr;\n              malformed = true;\n            }\n          }\n          if (hasPattern) {\n            for (p in schema.patternProperties)\n              if (schema.patternProperties.hasOwnProperty(p) && props[i].match(p)) {\n                matched = true;\n                objerr = checkValidity(env, schema_stack.concat(schema.patternProperties[p]), object_stack.concat({object: prop, key: props[i]}), options);\n                if (objerr !== null) {\n                  objerrs[props[i]] = objerr;\n                  malformed = true;\n                }\n              }\n          }\n          if (matched)\n            props.splice(i, 1);\n        }\n      }\n\n      if (options.useDefault && hasProp && !malformed) {\n        for (p in schema.properties)\n          if (schema.properties.hasOwnProperty(p) && !prop.hasOwnProperty(p) && schema.properties[p].hasOwnProperty('default'))\n            prop[p] = schema.properties[p]['default'];\n      }\n\n      if (options.removeAdditional && hasProp && schema.additionalProperties !== true && typeof schema.additionalProperties !== 'object') {\n        for (i = 0, len = props.length; i < len; i++)\n          delete prop[props[i]];\n      } else {\n        if (schema.hasOwnProperty('additionalProperties')) {\n          if (typeof schema.additionalProperties === 'boolean') {\n            if (!schema.additionalProperties) {\n              for (i = 0, len = props.length; i < len; i++) {\n                objerrs[props[i]] = {'additional': true};\n                malformed = true;\n              }\n            }\n          } else {\n            for (i = 0, len = props.length; i < len; i++) {\n              objerr = checkValidity(env, schema_stack.concat(schema.additionalProperties), object_stack.concat({object: prop, key: props[i]}), options);\n              if (objerr !== null) {\n                objerrs[props[i]] = objerr;\n                malformed = true;\n              }\n            }\n          }\n        }\n      }\n      if (malformed)\n        return {'schema': objerrs};\n    } else {\n      if (schema.hasOwnProperty('items')) {\n        if (Array.isArray(schema.items)) {\n          for (i = 0, len = schema.items.length; i < len; i++) {\n            objerr = checkValidity(env, schema_stack.concat(schema.items[i]), object_stack.concat({object: prop, key: i}), options);\n            if (objerr !== null) {\n              objerrs[i] = objerr;\n              malformed = true;\n            }\n          }\n          if (prop.length > len && schema.hasOwnProperty('additionalItems')) {\n            if (typeof schema.additionalItems === 'boolean') {\n              if (!schema.additionalItems)\n                return {'additionalItems': true};\n            } else {\n              for (i = len, len = prop.length; i < len; i++) {\n                objerr = checkValidity(env, schema_stack.concat(schema.additionalItems), object_stack.concat({object: prop, key: i}), options);\n                if (objerr !== null) {\n                  objerrs[i] = objerr;\n                  malformed = true;\n                }\n              }\n            }\n          }\n        } else {\n          for (i = 0, len = prop.length; i < len; i++) {\n            objerr = checkValidity(env, schema_stack.concat(schema.items), object_stack.concat({object: prop, key: i}), options);\n            if (objerr !== null) {\n              objerrs[i] = objerr;\n              malformed = true;\n            }\n          }\n        }\n      } else if (schema.hasOwnProperty('additionalItems')) {\n        if (typeof schema.additionalItems !== 'boolean') {\n          for (i = 0, len = prop.length; i < len; i++) {\n            objerr = checkValidity(env, schema_stack.concat(schema.additionalItems), object_stack.concat({object: prop, key: i}), options);\n            if (objerr !== null) {\n              objerrs[i] = objerr;\n              malformed = true;\n            }\n          }\n        }\n      }\n      if (malformed)\n        return {'schema': objerrs};\n    }\n\n    for (v in schema) {\n      if (schema.hasOwnProperty(v) && !handled.hasOwnProperty(v)) {\n        if (v === 'format') {\n          if (env.fieldFormat.hasOwnProperty(schema[v]) && !env.fieldFormat[schema[v]](prop, schema, object_stack, options)) {\n            objerrs[v] = true;\n            malformed = true;\n          }\n        } else {\n          if (env.fieldValidate.hasOwnProperty(v) && !env.fieldValidate[v](prop, schema[v].hasOwnProperty('$data') ? resolveObjectRef(object_stack, schema[v].$data) : schema[v], schema, object_stack, options)) {\n            objerrs[v] = true;\n            malformed = true;\n          }\n        }\n      }\n    }\n\n    if (malformed)\n      return objerrs;\n    else\n      return null;\n  };\n\n  var defaultOptions = {\n    useDefault: false,\n    useCoerce: false,\n    checkRequired: true,\n    removeAdditional: false\n  };\n\n  function Environment() {\n    if (!(this instanceof Environment))\n      return new Environment();\n\n    this.coerceType = {};\n    this.fieldType = clone(fieldType);\n    this.fieldValidate = clone(fieldValidate);\n    this.fieldFormat = clone(fieldFormat);\n    this.defaultOptions = clone(defaultOptions);\n    this.schema = {};\n  }\n\n  Environment.prototype = {\n    validate: function (name, object, options) {\n      var schema_stack = [name], errors = null, object_stack = [{object: {'__root__': object}, key: '__root__'}];\n\n      if (typeof name === 'string') {\n        schema_stack = resolveURI(this, null, name);\n        if (!schema_stack)\n          throw new Error('jjv: could not find schema \\'' + name + '\\'.');\n      }\n\n      if (!options) {\n        options = this.defaultOptions;\n      } else {\n        for (var p in this.defaultOptions)\n          if (this.defaultOptions.hasOwnProperty(p) && !options.hasOwnProperty(p))\n            options[p] = this.defaultOptions[p];\n      }\n\n      errors = checkValidity(this, schema_stack, object_stack, options);\n\n      if (errors)\n        return {validation: errors.hasOwnProperty('schema') ? errors.schema : errors};\n      else\n        return null;\n    },\n\n    resolveRef: function (schema_stack, $ref) {\n      return resolveURI(this, schema_stack, $ref);\n    },\n\n    addType: function (name, func) {\n      this.fieldType[name] = func;\n    },\n\n    addTypeCoercion: function (type, func) {\n      this.coerceType[type] = func;\n    },\n\n    addCheck: function (name, func) {\n      this.fieldValidate[name] = func;\n    },\n\n    addFormat: function (name, func) {\n      this.fieldFormat[name] = func;\n    },\n\n    addSchema: function (name, schema) {\n      if (!schema && name) {\n        schema = name;\n        name = undefined;\n      }\n      if (schema.hasOwnProperty('id') && typeof schema.id === 'string' && schema.id !== name) {\n        if (schema.id.charAt(0) === '/')\n          throw new Error('jjv: schema id\\'s starting with / are invalid.');\n        this.schema[normalizeID(schema.id)] = schema;\n      } else if (!name) {\n        throw new Error('jjv: schema needs either a name or id attribute.');\n      }\n      if (name)\n        this.schema[normalizeID(name)] = schema;\n    }\n  };\n\n  // Export for use in server and client.\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n    module.exports = Environment;\n  else if (typeof define === 'function' && define.amd)\n    define('common/util/jjv',[],function () {return Environment;});\n  else\n    window.jjv = Environment;\n})();\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/metacore',[\n    'common/util/assert',\n    'common/core/core',\n    'common/core/tasync',\n    'common/util/jjv',\n    'common/util/canon'\n], function (ASSERT, Core, TASYNC, JsonValidator, CANON) {\n    'use strict';\n\n    // ----------------- CoreType -----------------\n\n    var MetaCore = function (oldcore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        // copy all operations\n        var core = {},\n            logger = options.logger.fork('metacore');\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        var sameNode = function (nodeA, nodeB) {\n            if (core.getPath(nodeA) === core.getPath(nodeB)) {\n                return true;\n            }\n            return false;\n        };\n\n        var realNode = function (node) { //TODO we have to make some more sophisticated distinction\n            if (core.getPath(node).indexOf('_') !== -1) {\n                return false;\n            }\n            return true;\n        };\n\n        var getMetaNode = function (node) {\n            return core.getChild(node, '_meta');\n        };\n        var getMetaChildrenNode = function (node) {\n            return core.getChild(getMetaNode(node), 'children');\n        };\n        var getMetaPointerNode = function (node, name) {\n            var meta = getMetaNode(node),\n                pointerNames = core.getPointerNames(meta) || [];\n            if (pointerNames.indexOf(name) !== -1) {\n                return core.getChild(meta, '_p_' + name);\n            }\n            return null;\n        };\n        var _MetaPointerNode = function (node, name) {\n            //this function always gives back a node, use this if you just want to create the node as well\n            core.setPointer(getMetaNode(node), name, null);\n            return core.getChild(getMetaNode(node), '_p_' + name);\n        };\n\n        var getMetaAspectsNode = function (node) {\n            return core.getChild(getMetaNode(node), 'aspects');\n        };\n        var getMetaAspectNode = function (node, name) {\n            var aspectNode = getMetaAspectsNode(node),\n                names = core.getPointerNames(aspectNode) || [];\n            if (names.indexOf(name) !== -1) {\n                return core.getChild(aspectNode, '_a_' + name);\n            }\n            return null;\n        };\n\n        var _MetaAspectNode = function (node, name) {\n            //this function always gives back a node, use this if you just want to create the node as well\n            var aspectNode = core.getChild(getMetaNode(node), 'aspects');\n\n            core.setPointer(aspectNode, name, null);\n            return core.getChild(aspectNode, '_a_' + name);\n        };\n        //now the additional functions\n        core.isTypeOf = function (node, typeNode) {\n            if (!realNode(node)) {\n                return false;\n            }\n            while (node) {\n                if (sameNode(node, typeNode)) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n            return false;\n        };\n\n        core.isValidChildOf = function (node, parentNode) {\n            if (!realNode(node)) {\n                return true;\n            }\n            var validChildTypePaths = core.getMemberPaths(getMetaChildrenNode(parentNode), 'items') || [];\n            while (node) {\n                if (validChildTypePaths.indexOf(core.getPath(node)) !== -1) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n            return false;\n        };\n\n        core.getValidPointerNames = function (node) {\n            var validNames = core.getPointerNames(getMetaNode(node)) || [],\n                i,\n                validPointerNames = [],\n                metaPointerNode, max;\n            for (i = 0; i < validNames.length; i++) {\n                metaPointerNode = getMetaPointerNode(node, validNames[i]);\n                max = core.getAttribute(metaPointerNode, 'max');\n                if (max === 1) {\n                    //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\n                    validPointerNames.push(validNames[i]);\n                }\n            }\n\n            return validPointerNames;\n        };\n\n        core.getValidSetNames = function (node) {\n            var validNames = core.getPointerNames(getMetaNode(node)) || [],\n                i,\n                validSetNames = [],\n                metaPointerNode, max;\n\n            for (i = 0; i < validNames.length; i++) {\n                metaPointerNode = getMetaPointerNode(node, validNames[i]);\n                max = core.getAttribute(metaPointerNode, 'max');\n                if (max === undefined || max === -1 || max > 1) {\n                    //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\n                    validSetNames.push(validNames[i]);\n                }\n            }\n\n            return validSetNames;\n        };\n\n        core.isValidTargetOf = function (node, source, name) {\n            if (!realNode(source) || node === null) { //we position ourselves over the null-pointer layer\n                return true;\n            }\n            var pointerMetaNode = getMetaPointerNode(source, name);\n            if (pointerMetaNode) {\n                var validTargetTypePaths = core.getMemberPaths(pointerMetaNode, 'items') || [];\n                while (node) {\n                    if (validTargetTypePaths.indexOf(core.getPath(node)) !== -1) {\n                        return true;\n                    }\n                    node = core.getBase(node);\n                }\n            }\n            return false;\n        };\n\n        core.getValidAttributeNames = function (node) {\n            var names = [];\n            if (realNode(node)) {\n                names = core.getAttributeNames(getMetaNode(node)) || [];\n            }\n            return names;\n        };\n\n        core.isValidAttributeValueOf = function (node, name, value) {\n            //currently it only checks the name and the type\n            if (!realNode(node)) {\n                return true;\n            }\n            if (core.getValidAttributeNames(node).indexOf(name) === -1) {\n                return false;\n            }\n            var meta = core.getAttribute(getMetaNode(node), name);\n            switch (meta.type) {\n                case 'boolean':\n                    if (value === true || value === false) {\n                        return true;\n                    }\n                    break;\n                case 'string':\n                case 'asset':\n                    if (typeof value === 'string') {\n                        return true;\n                    }\n                    break;\n                case 'integer':\n                    if (!isNaN(parseInt(value)) && parseFloat(value) === parseInt(value)) {\n                        return true;\n                    }\n                    break;\n                case 'float':\n                    if (!isNaN(parseFloat(value))) {\n                        return true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            return false;\n        };\n\n\n        core.getValidAspectNames = function (node) {\n            return core.getPointerNames(getMetaAspectsNode(node)) || [];\n        };\n\n        //additional meta functions for getting meta definitions\n        core.getJsonMeta = function (node) {\n            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},\n                tempNode,\n                names,\n                pointer,\n                i, j;\n\n            //fill children part\n            tempNode = getMetaChildrenNode(node);\n\n            meta.children.minItems = [];\n            meta.children.maxItems = [];\n            meta.children.items = core.getMemberPaths(tempNode, 'items');\n            for (i = 0; i < meta.children.items.length; i++) {\n                meta.children.minItems.push(\n                    core.getMemberAttribute(tempNode, 'items', meta.children.items[i], 'min') || -1);\n\n                meta.children.maxItems.push(\n                    core.getMemberAttribute(tempNode, 'items', meta.children.items[i], 'max') || -1);\n            }\n            meta.children.min = core.getAttribute(tempNode, 'min');\n            meta.children.max = core.getAttribute(tempNode, 'max');\n\n            //attributes\n            names = core.getValidAttributeNames(node);\n            for (i = 0; i < names.length; i++) {\n                meta.attributes[names[i]] = core.getAttribute(getMetaNode(node), names[i]);\n            }\n\n            //pointers\n            names = core.getPointerNames(getMetaNode(node));\n            for (i = 0; i < names.length; i++) {\n                tempNode = getMetaPointerNode(node, names[i]);\n                pointer = {};\n\n                pointer.items = core.getMemberPaths(tempNode, 'items');\n                pointer.min = core.getAttribute(tempNode, 'min');\n                pointer.max = core.getAttribute(tempNode, 'max');\n                pointer.minItems = [];\n                pointer.maxItems = [];\n\n                for (j = 0; j < pointer.items.length; j++) {\n                    pointer.minItems.push(core.getMemberAttribute(tempNode, 'items', pointer.items[j], 'min') || -1);\n                    pointer.maxItems.push(core.getMemberAttribute(tempNode, 'items', pointer.items[j], 'max') || -1);\n\n                }\n\n                meta.pointers[names[i]] = pointer;\n            }\n\n            //aspects\n            names = core.getValidAspectNames(node);\n\n            for (i = 0; i < names.length; i++) {\n                tempNode = getMetaAspectNode(node, names[i]);\n                meta.aspects[names[i]] = core.getMemberPaths(tempNode, 'items') || [];\n            }\n\n            //constraints\n            names = core.getConstraintNames(node);\n            for (i = 0; i < names.length; i++) {\n                meta.constraints[names[i]] = core.getConstraint(node, names[i]);\n            }\n\n            return meta;\n        };\n\n        var getMetaObjectDiff = function (bigger, smaller) {\n            //TODO this is a specific diff calculation for META rule JSONs\n            var diff = {},\n                names, i,\n                itemedElementDiff = function (bigItem, smallItem) {\n                    var diffItems = {},\n                        diff, i, index, names;\n                    for (i = 0; i < bigItem.items.length; i++) {\n                        if (smallItem.items.indexOf(bigItem.items[i]) === -1) {\n                            diffItems[bigItem.items[i]] = true;\n                        }\n                    }\n                    names = Object.keys(diffItems);\n                    for (i = 0; i < names.length; i++) {\n                        diff = diff || {items: [], minItems: [], maxItems: []};\n                        index = bigItem.items.indexOf(names[i]);\n                        diff.items.push(bigItem.items[index]);\n                        diff.minItems.push(bigItem.minItems[index]);\n                        diff.maxItems.push(bigItem.maxItems[index]);\n\n                    }\n                    if (bigItem.min && ((smallItem.min && bigItem.min !== smallItem.min) || !smallItem.min)) {\n                        diff = diff || {};\n                        diff.min = bigItem.min;\n                    }\n                    if (bigItem.max && ((smallItem.max && bigItem.max !== smallItem.max) || !smallItem.max)) {\n                        diff = diff || {};\n                        diff.max = bigItem.max;\n                    }\n                    return diff || {};\n                };\n            //attributes\n            if (smaller.attributes) {\n                names = Object.keys(bigger.attributes);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.attributes[names[i]]) {\n                        //they both have the attribute - if it differs we keep the whole of the bigger\n                        if (CANON.stringify(smaller.attributes[names[i]] !==\n                            CANON.stringify(bigger.attributes[names[i]]))) {\n\n                            diff.attributes = diff.attributes || {};\n                            diff.attributes[names[i]] = bigger.attributes[names[i]];\n                        }\n                    } else {\n                        diff.attributes = diff.attributes || {};\n                        diff.attributes[names[i]] = bigger.attributes[names[i]];\n                    }\n                }\n            } else if (bigger.attributes) {\n                diff.attributes = bigger.attributes;\n            }\n            //children\n            if (smaller.children) {\n                diff.children = itemedElementDiff(bigger.children, smaller.children);\n                if (Object.keys(diff.children).length < 1) {\n                    delete diff.children;\n                }\n            } else if (bigger.children) {\n                diff.children = bigger.children;\n            }\n            //pointers\n            if (smaller.pointers) {\n                diff.pointers = {};\n                names = Object.keys(bigger.pointers);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.pointers[names[i]]) {\n                        diff.pointers[names[i]] = itemedElementDiff(bigger.pointers[names[i]],\n                            smaller.pointers[names[i]]);\n                        if (Object.keys(diff.pointers[names[i]]).length < 1) {\n                            delete diff.pointers[names[i]];\n                        }\n                    } else {\n                        diff.pointers[names[i]] = bigger.pointers[names[i]];\n                    }\n                }\n            } else if (bigger.pointers) {\n                diff.pointers = bigger.pointers;\n            }\n            if (Object.keys(diff.pointers).length < 1) {\n                delete diff.pointers;\n            }\n            //aspects\n            if (smaller.aspects) {\n                diff.aspects = {};\n                names = Object.keys(bigger.aspects);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.aspects[names[i]]) {\n                        smaller.aspects[names[i]] = smaller.aspects[names[i]].sort();\n                        bigger.aspects[names[i]] = bigger.aspects[names[i]].sort();\n                        if (bigger.aspects[names[i]].length > smaller.aspects[names[i]].length) {\n                            diff.aspects[names[i]] = bigger.aspects[names[i]].slice(smaller.aspects[names[i]].length);\n                        }\n                    } else {\n                        diff.aspects[names[i]] = bigger.aspects[names[i]];\n                    }\n                }\n            } else if (bigger.aspects) {\n                diff.aspects = bigger.aspects;\n            }\n\n            if (Object.keys(diff.aspects).length < 1) {\n                delete diff.aspects;\n            }\n            return diff;\n        };\n\n        core.getOwnJsonMeta = function (node) {\n            var base = core.getBase(node),\n                baseMeta = base ? core.getJsonMeta(base) : {},\n                meta = core.getJsonMeta(node);\n\n            return getMetaObjectDiff(meta, baseMeta);\n        };\n\n        core.clearMetaRules = function (node) {\n            core.deleteNode(getMetaNode(node), true);\n        };\n\n        core.setAttributeMeta = function (node, name, value) {\n            ASSERT(typeof value === 'object' && typeof name === 'string' && name);\n\n            core.setAttribute(getMetaNode(node), name, value);\n        };\n        core.delAttributeMeta = function (node, name) {\n            core.delAttribute(getMetaNode(node), name);\n        };\n        core.getAttributeMeta = function (node, name) {\n            return core.getAttribute(getMetaNode(node), name);\n        };\n\n        core.getValidChildrenPaths = function (node) {\n            return core.getMemberPaths(getMetaChildrenNode(node), 'items');\n        };\n        core.setChildMeta = function (node, child, min, max) {\n            core.addMember(getMetaChildrenNode(node), 'items', child);\n            min = min || -1;\n            max = max || -1;\n            core.setMemberAttribute(getMetaChildrenNode(node), 'items', core.getPath(child), 'min', min);\n            core.setMemberAttribute(getMetaChildrenNode(node), 'items', core.getPath(child), 'max', max);\n        };\n        core.delChildMeta = function (node, childPath) {\n            core.delMember(getMetaChildrenNode(node), 'items', childPath);\n        };\n        core.setChildrenMetaLimits = function (node, min, max) {\n            if (min) {\n                core.setAttribute(getMetaChildrenNode(node), 'min', min);\n            }\n            if (max) {\n                core.setAttribute(getMetaChildrenNode(node), 'max', max);\n            }\n        };\n\n        core.setPointerMetaTarget = function (node, name, target, min, max) {\n            core.addMember(_MetaPointerNode(node, name), 'items', target);\n            min = min || -1;\n            core.setMemberAttribute(_MetaPointerNode(node, name), 'items', core.getPath(target), 'min', min);\n            max = max || -1;\n            core.setMemberAttribute(_MetaPointerNode(node, name), 'items', core.getPath(target), 'max', max);\n        };\n        core.delPointerMetaTarget = function (node, name, targetPath) {\n            var metaNode = getMetaPointerNode(node, name);\n            if (metaNode) {\n                core.delMember(metaNode, 'items', targetPath);\n            }\n        };\n        core.setPointerMetaLimits = function (node, name, min, max) {\n            if (min) {\n                core.setAttribute(_MetaPointerNode(node, name), 'min', min);\n            }\n            if (max) {\n                core.setAttribute(_MetaPointerNode(node, name), 'max', max);\n            }\n        };\n        core.delPointerMeta = function (node, name) {\n            core.deleteNode(_MetaPointerNode(node, name), true);\n            core.deletePointer(getMetaNode(node), name);\n        };\n\n        core.setAspectMetaTarget = function (node, name, target) {\n            core.addMember(_MetaAspectNode(node, name), 'items', target);\n        };\n        core.delAspectMetaTarget = function (node, name, targetPath) {\n            var metaNode = getMetaAspectNode(node, name);\n            if (metaNode) {\n                core.delMember(metaNode, 'items', targetPath);\n            }\n        };\n        core.delAspectMeta = function (node, name) {\n            core.deleteNode(_MetaAspectNode(node, name), true);\n            core.deletePointer(getMetaAspectsNode(node), name);\n        };\n\n        //type related extra query functions\n        var isOnMetaSheet = function (node) {\n            //MetaAspectSet\n            var sets = core.isMemberOf(node);\n\n            if (sets && sets[''] && sets[''].indexOf('MetaAspectSet') !== -1) {\n                //TODO this is all should be global constant values\n                return true;\n            }\n            return false;\n        };\n        core.getBaseType = function (node) {\n            //TODO this functions now uses the fact that we think of META as the MetaSetContainer of the ROOT\n            while (node) {\n                if (isOnMetaSheet(node)) {\n                    return node;\n                }\n                node = core.getBase(node);\n            }\n            return null;\n        };\n        core.isInstanceOf = function (node, name) {\n            //TODO this is name based query - doesn't check the node's own name\n            node = core.getBase(node);\n            while (node) {\n                if (core.getAttribute(node, 'name') === name) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n\n            return false;\n        };\n\n        return core;\n    };\n\n    return MetaCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/coretreeloader',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreTreeLoader -----------------\n\n    var MetaCore = function (innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var core = {},\n            key,\n            logger = options.logger.fork('coretreeloader');\n        for (key in innerCore) {\n            core[key] = innerCore[key];\n        }\n        logger.debug('initialized');\n        //adding load functions\n        core.loadSubTree = function (root) {\n            var loadSubTrees = function (nodes) {\n                for (var i = 0; i < nodes.length; i++) {\n                    nodes[i] = core.loadSubTree(nodes[i]);\n                }\n                return TASYNC.lift(nodes);\n\n            };\n            return TASYNC.call(function (children) {\n                if (children.length < 1) {\n                    return [root];\n                } else {\n                    return TASYNC.call(function (subArrays) {\n                        var nodes = [],\n                            i;\n                        for (i = 0; i < subArrays.length; i++) {\n                            nodes = nodes.concat(subArrays[i]);\n                        }\n                        nodes.unshift(root);\n                        return nodes;\n                    }, loadSubTrees(children));\n                }\n            }, core.loadChildren(root));\n        };\n        core.loadTree = function (rootHash) {\n            return TASYNC.call(core.loadSubTree, core.loadRoot(rootHash));\n        };\n\n        return core;\n    };\n    return MetaCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n// TODO: This files needs refactoring\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/corediff',['common/util/canon', 'common/core/tasync', 'common/util/assert'], function (CANON, TASYNC, ASSERT) {\n    'use strict';\n\n    function diffCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('corediff'),\n            _yetToCompute = {},\n            _DIFF = {},\n            _needChecking = true,\n            _rounds = 0,\n            TODELETESTRING = '*to*delete*',\n            toFrom = {}, //TODO should not be global\n            fromTo = {}, //TODO should not be global\n            _concatResult,\n            _diffMoves = {},\n            _conflictItems = [],\n            _conflictMine,\n            _conflictTheirs,\n            _concatBase,\n            _concatExtension,\n            _concatBaseRemovals,\n            _concatMoves;\n\n        logger.debug('initialized');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n\n        function normalize(obj) {\n            if (!obj) {\n                return obj;\n            }\n            var keys = Object.keys(obj),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                /*if (Array.isArray(obj[keys[i]])) {\n                 if (obj[keys[i]].length === 0) {\n                 delete obj[keys[i]];\n                 }*/\n                if (Array.isArray(obj[keys[i]])) {\n                    //do nothing, leave the array as is\n                } else if (obj[keys[i]] === undefined) {\n                    delete obj[keys[i]]; //there cannot be undefined in the object\n                } else if (typeof obj[keys[i]] === 'object') {\n                    normalize(obj[keys[i]]);\n                    if (obj[keys[i]] && Object.keys(obj[keys[i]]).length === 0) {\n                        delete obj[keys[i]];\n                    }\n                }\n            }\n            keys = Object.keys(obj);\n            if (keys.length === 1) {\n                //it only has the GUID, so the node doesn't changed at all\n                delete obj.guid;\n            }\n        }\n\n        function attrDiff(source, target) {\n            var sNames = _core.getOwnAttributeNames(source),\n                tNames = _core.getOwnAttributeNames(target),\n                i,\n                diff = {};\n\n            for (i = 0; i < sNames.length; i++) {\n                if (tNames.indexOf(sNames[i]) === -1) {\n                    diff[sNames[i]] = TODELETESTRING;\n                }\n            }\n\n            for (i = 0; i < tNames.length; i++) {\n                if (_core.getAttribute(source, tNames[i]) === undefined) {\n                    diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\n                } else {\n                    if (CANON.stringify(_core.getAttribute(source, tNames[i])) !==\n                        CANON.stringify(_core.getAttribute(target, tNames[i]))) {\n\n                        diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        function regDiff(source, target) {\n            var sNames = _core.getOwnRegistryNames(source),\n                tNames = _core.getOwnRegistryNames(target),\n                i,\n                diff = {};\n\n            for (i = 0; i < sNames.length; i++) {\n                if (tNames.indexOf(sNames[i]) === -1) {\n                    diff[sNames[i]] = TODELETESTRING;\n                }\n            }\n\n            for (i = 0; i < tNames.length; i++) {\n                if (_core.getRegistry(source, tNames[i]) === undefined) {\n                    diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\n                } else {\n                    if (CANON.stringify(_core.getRegistry(source, tNames[i])) !==\n                        CANON.stringify(_core.getRegistry(target, tNames[i]))) {\n\n                        diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        function childrenDiff(source, target) {\n            var sRelids = _core.getChildrenRelids(source),\n                tRelids = _core.getChildrenRelids(target),\n                tHashes = _core.getChildrenHashes(target),\n                sHashes = _core.getChildrenHashes(source),\n                i,\n                diff = {added: [], removed: []};\n\n            for (i = 0; i < sRelids.length; i++) {\n                if (tRelids.indexOf(sRelids[i]) === -1) {\n                    diff.removed.push({relid: sRelids[i], hash: sHashes[sRelids[i]]});\n                }\n            }\n\n            for (i = 0; i < tRelids.length; i++) {\n                if (sRelids.indexOf(tRelids[i]) === -1) {\n                    diff.added.push({relid: tRelids[i], hash: tHashes[tRelids[i]]});\n                }\n            }\n\n            return diff;\n\n        }\n\n        function pointerDiff(source, target) {\n            var getPointerData = function (node) {\n                    var data = {},\n                        names = _core.getPointerNames(node),\n                        i;\n                    for (i = 0; i < names.length; i++) {\n                        data[names[i]] = _core.getPointerPath(node, names[i]);\n                    }\n                    return data;\n                },\n                sPointer = getPointerData(source),\n                tPointer = getPointerData(target);\n\n            if (CANON.stringify(sPointer) !== CANON.stringify(tPointer)) {\n                return {source: sPointer, target: tPointer};\n            }\n            return {};\n        }\n\n        function setDiff(source, target) {\n            var getSetData = function (node) {\n                    var data = {},\n                        names, targets, keys, i, j, k;\n\n                    names = _core.getSetNames(node);\n                    for (i = 0; i < names.length; i++) {\n                        data[names[i]] = {};\n                        targets = _core.getMemberPaths(node, names[i]);\n                        for (j = 0; j < targets.length; j++) {\n                            data[names[i]][targets[j]] = {attr: {}, reg: {}};\n                            keys = _core.getMemberOwnAttributeNames(node, names[i], targets[j]);\n                            for (k = 0; k < keys.length; k++) {\n                                data[names[i]][targets[j]].attr[keys[i]] = _core.getMemberAttribute(node,\n                                    names[i], targets[j], keys[i]);\n                            }\n                            keys = _core.getMemberRegistryNames(node, names[i], targets[j]);\n                            for (k = 0; k < keys.length; k++) {\n                                data[names[i]][targets[j]].reg[keys[k]] = _core.getMemberRegistry(node,\n                                    names[i], targets[j], keys[k]);\n                            }\n                        }\n                    }\n\n                    return data;\n\n                },\n                sSet = getSetData(source),\n                tSet = getSetData(target);\n\n            if (CANON.stringify(sSet) !== CANON.stringify(tSet)) {\n                return {source: sSet, target: tSet};\n            }\n            return {};\n        }\n\n        function ovrDiff(source, target) {\n            var getOvrData = function (node) {\n                    var paths, names, i, j,\n                        ovr = _core.getProperty(node, 'ovr') || {},\n                        data = {},\n                        base = _core.getPath(node);\n\n                    paths = Object.keys(ovr);\n                    for (i = 0; i < paths.length; i++) {\n                        if (paths[i].indexOf('_') === -1) {\n                            data[paths[i]] = {};\n                            names = Object.keys(ovr[paths[i]]);\n                            for (j = 0; j < names.length; j++) {\n                                if (ovr[paths[i]][names[j]] === '/_nullptr') {\n                                    data[paths[i]][names[j]] = null;\n                                } else if (names[j].slice(-4) !== '-inv' &&\n                                    ovr[paths[i]][names[j]].indexOf('_') === -1) {\n\n                                    data[paths[i]][names[j]] = _core.joinPaths(base, ovr[paths[i]][names[j]]);\n                                }\n                            }\n                        }\n                    }\n                    return data;\n                },\n                sOvr = getOvrData(source),\n                tOvr = getOvrData(target);\n\n            if (CANON.stringify(sOvr) !== CANON.stringify(tOvr)) {\n                return {source: sOvr, target: tOvr};\n            }\n            return {};\n        }\n\n        function metaDiff(source, target) {\n            var sMeta = _core.getOwnJsonMeta(source),\n                tMeta = _core.getOwnJsonMeta(target);\n            if (CANON.stringify(sMeta) !== CANON.stringify(tMeta)) {\n                return {source: sMeta, target: tMeta};\n            }\n            return {};\n        }\n\n        function combineMoveIntoMetaDiff(diff) {\n            var keys = Object.keys(diff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (_diffMoves[keys[i]]) {\n                    diff[_diffMoves[keys[i]]] = diff[keys[i]];\n                    delete diff[keys[i]];\n                } else if (typeof diff[keys[i]] === 'object') {\n                    combineMoveIntoMetaDiff(diff[keys[i]]);\n                }\n            }\n        }\n\n        function combineMoveIntoPointerDiff(diff) {\n            var keys = Object.keys(diff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (_diffMoves[diff[keys[i]]]) {\n                    diff[keys[i]] = _diffMoves[diff[keys[i]]];\n                }\n            }\n        }\n\n        function finalizeDiff() {\n            finalizeMetaDiff(_DIFF);\n            finalizePointerDiff(_DIFF);\n            finalizeSetDiff(_DIFF);\n            normalize(_DIFF);\n        }\n\n        function finalizeMetaDiff(diff) {\n            //at this point _DIFF is ready and the _diffMoves is complete...\n            var relids = getDiffChildrenRelids(diff),\n                i, sMeta, tMeta;\n            if (diff.meta) {\n                sMeta = diff.meta.source || {};\n                tMeta = diff.meta.target || {};\n                combineMoveIntoMetaDiff(sMeta);\n                diff.meta = diffObjects(sMeta, tMeta);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizeMetaDiff(diff[relids[i]]);\n            }\n        }\n\n        function finalizePointerDiff(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, sPointer, tPointer;\n            if (diff.pointer) {\n                sPointer = diff.pointer.source || {};\n                tPointer = diff.pointer.target || {};\n                /*if(diff.movedFrom && !sPointer.base && tPointer.base){\n                 delete tPointer.base;\n                 }*/\n                combineMoveIntoPointerDiff(sPointer);\n                diff.pointer = diffObjects(sPointer, tPointer);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizePointerDiff(diff[relids[i]]);\n            }\n        }\n\n        function finalizeSetDiff(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, sSet, tSet;\n            if (diff.set) {\n                sSet = diff.set.source || {};\n                tSet = diff.set.target || {};\n                combineMoveIntoMetaDiff(sSet);\n                diff.set = diffObjects(sSet, tSet);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizeSetDiff(diff[relids[i]]);\n            }\n        }\n\n        function isEmptyNodeDiff(diff) {\n            if (\n                Object.keys(diff.children || {}).length > 0 ||\n                Object.keys(diff.attr || {}).length > 0 ||\n                Object.keys(diff.reg || {}).length > 0 ||\n                Object.keys(diff.pointer || {}).length > 0 ||\n                Object.keys(diff.set || {}).length > 0 ||\n                diff.meta\n            ) {\n                return false;\n            }\n            return true;\n        }\n\n        function getPathOfDiff(diff, path) {\n            var pathArray = (path || '').split('/'),\n                i;\n            pathArray.shift();\n            for (i = 0; i < pathArray.length; i++) {\n                diff[pathArray[i]] = diff[pathArray[i]] || {};\n                diff = diff[pathArray[i]];\n            }\n\n            return diff;\n        }\n\n        function extendDiffWithOvr(diff, oDiff) {\n            var i, paths, names, j, tDiff;\n            //first extend sources\n            paths = Object.keys(oDiff.source || {});\n            for (i = 0; i < paths.length; i++) {\n                tDiff = getPathOfDiff(diff, paths[i]);\n                if (tDiff.removed !== true) {\n                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};\n                    names = Object.keys(oDiff.source[paths[i]]);\n                    for (j = 0; j < names.length; j++) {\n                        tDiff.pointer.source[names[j]] = oDiff.source[paths[i]][names[j]];\n                    }\n                }\n            }\n            //then targets\n            paths = Object.keys(oDiff.target || {});\n            for (i = 0; i < paths.length; i++) {\n                tDiff = getPathOfDiff(diff, paths[i]);\n                if (tDiff.removed !== true) {\n                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};\n                    names = Object.keys(oDiff.target[paths[i]]);\n                    for (j = 0; j < names.length; j++) {\n                        tDiff.pointer.target[names[j]] = oDiff.target[paths[i]][names[j]];\n                    }\n                }\n            }\n        }\n\n        function updateDiff(sourceRoot, targetRoot) {\n            var diff = _core.nodeDiff(sourceRoot, targetRoot) || {},\n                oDiff = ovrDiff(sourceRoot, targetRoot),\n                getChild = function (childArray, relid) {\n                    for (var i = 0; i < childArray.length; i++) {\n                        if (_core.getRelid(childArray[i]) === relid) {\n                            return childArray[i];\n                        }\n                    }\n                    return null;\n                };\n            return TASYNC.call(function (sChildren, tChildren) {\n                ASSERT(sChildren.length >= 0 && tChildren.length >= 0);\n\n                var i, child, done, tDiff, guid, base,\n                    childComputationFinished = function (cDiff, relid/*, d*/) {\n                        diff[relid] = cDiff;\n                        return null;\n                    };\n\n                tDiff = diff.children ? diff.children.removed || [] : [];\n                for (i = 0; i < tDiff.length; i++) {\n                    diff.childrenListChanged = true;\n                    child = getChild(sChildren, tDiff[i].relid);\n                    if (child) {\n                        guid = _core.getGuid(child);\n                        diff[tDiff[i].relid] = {guid: guid, removed: true, hash: _core.getHash(child)};\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].from = child;\n                        _yetToCompute[guid].fromExpanded = false;\n                    }\n                }\n\n                tDiff = diff.children ? diff.children.added || [] : [];\n                for (i = 0; i < tDiff.length; i++) {\n                    diff.childrenListChanged = true;\n                    child = getChild(tChildren, tDiff[i].relid);\n                    if (child) {\n                        guid = _core.getGuid(child);\n                        base = _core.getBase(child);\n                        if (base) {\n                            base = _core.getPath(base);\n                        }\n                        diff[tDiff[i].relid] = {\n                            guid: guid,\n                            removed: false,\n                            hash: _core.getHash(child),\n                            pointer: {source: {}, target: {base: base}}\n                        };\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].to = child;\n                        _yetToCompute[guid].toExpanded = false;\n                    }\n                }\n\n                for (i = 0; i < tChildren.length; i++) {\n                    child = getChild(sChildren, _core.getRelid(tChildren[i]));\n                    if (child && _core.getHash(tChildren[i]) !== _core.getHash(child)) {\n                        done = TASYNC.call(childComputationFinished,\n                            updateDiff(child, tChildren[i]), _core.getRelid(child), done);\n                    }\n                }\n                return TASYNC.call(function () {\n                    delete diff.children;\n                    extendDiffWithOvr(diff, oDiff);\n                    normalize(diff);\n                    if (Object.keys(diff).length > 0) {\n                        diff.guid = _core.getGuid(targetRoot);\n                        diff.hash = _core.getHash(targetRoot);\n                        diff.oGuids = gatherObstructiveGuids(targetRoot);\n                        return TASYNC.call(function (finalDiff) {\n                            return finalDiff;\n                        }, fillMissingGuid(targetRoot, '', diff));\n                    } else {\n                        return diff;\n                    }\n\n                }, done);\n            }, _core.loadChildren(sourceRoot), _core.loadChildren(targetRoot));\n        }\n\n        function gatherObstructiveGuids(node) {\n            var result = {},\n                putParents = function (n) {\n                    while (n) {\n                        result[_core.getGuid(n)] = true;\n                        n = _core.getParent(n);\n                    }\n                };\n            while (node) {\n                putParents(node);\n                node = _core.getBase(node);\n            }\n            return result;\n        }\n\n        function fillMissingGuid(root, path, diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i,\n                done,\n                subComputationFinished = function (cDiff, relid) {\n                    diff[relid] = cDiff;\n                    return null;\n                };\n\n            for (i = 0; i < relids.length; i++) {\n                done = TASYNC.call(subComputationFinished,\n                    fillMissingGuid(root, path + '/' + relids[i], diff[relids[i]]), relids[i]);\n            }\n\n            return TASYNC.call(function () {\n                if (diff.guid) {\n                    return diff;\n                } else {\n                    return TASYNC.call(function (child) {\n                        diff.guid = _core.getGuid(child);\n                        diff.hash = _core.getHash(child);\n                        diff.oGuids = gatherObstructiveGuids(child);\n                        return diff;\n                    }, _core.loadByPath(root, path));\n                }\n            }, done);\n        }\n\n        function expandDiff(root, isDeleted) {\n            var diff = {\n                guid: _core.getGuid(root),\n                hash: _core.getHash(root),\n                removed: isDeleted === true\n            };\n            return TASYNC.call(function (children) {\n                var guid;\n                for (var i = 0; i < children.length; i++) {\n                    guid = _core.getGuid(children[i]);\n                    diff[_core.getRelid(children[i])] = {\n                        guid: guid,\n                        hash: _core.getHash(children[i]),\n                        removed: isDeleted === true\n                    };\n\n                    if (isDeleted) {\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].from = children[i];\n                        _yetToCompute[guid].fromExpanded = false;\n                    } else {\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].to = children[i];\n                        _yetToCompute[guid].toExpanded = false;\n                    }\n                }\n                return diff;\n            }, _core.loadChildren(root));\n        }\n\n        function insertIntoDiff(path, diff) {\n            var pathArray = path.split('/'),\n                relid = pathArray.pop(),\n                sDiff = _DIFF,\n                i;\n            pathArray.shift();\n            for (i = 0; i < pathArray.length; i++) {\n                sDiff = sDiff[pathArray[i]];\n            }\n            //sDiff[relid] = diff;\n            sDiff[relid] = mergeObjects(sDiff[relid], diff);\n        }\n\n        function diffObjects(source, target) {\n            var diff = {},\n                sKeys = Object.keys(source),\n                tKeys = Object.keys(target),\n                tDiff, i;\n            for (i = 0; i < sKeys.length; i++) {\n                if (tKeys.indexOf(sKeys[i]) === -1) {\n                    diff[sKeys[i]] = TODELETESTRING;\n                }\n            }\n            for (i = 0; i < tKeys.length; i++) {\n                if (sKeys.indexOf(tKeys[i]) === -1) {\n                    diff[tKeys[i]] = target[tKeys[i]];\n                } else {\n                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\n                        typeof target[tKeys[i]] === 'object' &&\n                        (target[tKeys[i]] !== null && source[tKeys[i]] !== null)) {\n                        tDiff = diffObjects(source[tKeys[i]], target[tKeys[i]]);\n                        if (Object.keys(tDiff).length > 0) {\n                            diff[tKeys[i]] = tDiff;\n                        }\n                    } else if (source[tKeys[i]] !== target[tKeys[i]]) {\n                        diff[tKeys[i]] = target[tKeys[i]];\n                    }\n                }\n            }\n            return diff;\n        }\n\n        function mergeObjects(source, target) {\n            var merged = {},\n                sKeys = Object.keys(source),\n                tKeys = Object.keys(target),\n                i;\n            for (i = 0; i < sKeys.length; i++) {\n                merged[sKeys[i]] = source[sKeys[i]];\n            }\n            for (i = 0; i < tKeys.length; i++) {\n                if (sKeys.indexOf(tKeys[i]) === -1) {\n                    merged[tKeys[i]] = target[tKeys[i]];\n                } else {\n                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\n                        typeof target[tKeys[i]] === 'object' && !(target instanceof Array)) {\n                        merged[tKeys[i]] = mergeObjects(source[tKeys[i]], target[tKeys[i]]);\n                    } else {\n                        merged[tKeys[i]] = target[tKeys[i]];\n                    }\n                }\n            }\n\n            return merged;\n        }\n\n        function removePathFromDiff(diff, path) {\n            var relId, i;\n            if (path === '') {\n                diff = null;\n            } else {\n                path = path.split('/');\n                path.shift();\n                relId = path.pop();\n                for (i = 0; i < path.length; i++) {\n                    diff = diff[path[i]];\n                }\n                delete diff[relId];\n            }\n        }\n\n        function shrinkDiff(rootDiff) {\n            var _shrink = function (diff) {\n                if (diff) {\n                    var keys = getDiffChildrenRelids(diff),\n                        i;\n                    if (typeof diff.movedFrom === 'string') {\n                        removePathFromDiff(rootDiff, diff.movedFrom);\n                    }\n\n                    if (diff.removed !== false || typeof diff.movedFrom === 'string') {\n                        delete diff.hash;\n                    }\n\n                    if (diff.removed === true) {\n                        for (i = 0; i < keys.length; i++) {\n                            delete diff[keys[i]];\n                        }\n                    } else {\n\n                        for (i = 0; i < keys.length; i++) {\n                            _shrink(diff[keys[i]]);\n                        }\n                    }\n                }\n            };\n            _shrink(rootDiff, false);\n        }\n\n        function checkRound() {\n            var guids = Object.keys(_yetToCompute),\n                done, ytc,\n                i,\n                computingMove = function (mDiff, info) {\n                    mDiff.guid = _core.getGuid(info.from);\n                    mDiff.movedFrom = _core.getPath(info.from);\n                    mDiff.ooGuids = gatherObstructiveGuids(info.from);\n                    _diffMoves[_core.getPath(info.from)] = _core.getPath(info.to);\n                    insertAtPath(_DIFF, _core.getPath(info.to), mDiff);\n                    return null;\n                },\n                expandFrom = function (mDiff, info) {\n                    mDiff.hash = _core.getHash(info.from);\n                    mDiff.removed = true;\n                    insertIntoDiff(_core.getPath(info.from), mDiff);\n                    return null;\n                },\n                expandTo = function (mDiff, info) {\n                    if (!mDiff.hash) {\n                        mDiff.hash = _core.getHash(info.to);\n                    }\n                    mDiff.removed = false;\n                    insertIntoDiff(_core.getPath(info.to), mDiff);\n                    return null;\n                };\n\n            if (_needChecking !== true || guids.length < 1) {\n                shrinkDiff(_DIFF);\n                finalizeDiff();\n                return _DIFF;\n            }\n            _needChecking = false;\n            for (i = 0; i < guids.length; i++) {\n                ytc = _yetToCompute[guids[i]];\n                if (ytc.from && ytc.to) {\n                    //move\n                    _needChecking = true;\n                    delete _yetToCompute[guids[i]];\n                    done = TASYNC.call(computingMove, updateDiff(ytc.from, ytc.to), ytc);\n                } else {\n                    if (ytc.from && ytc.fromExpanded === false) {\n                        //expand from\n                        ytc.fromExpanded = true;\n                        _needChecking = true;\n                        done = TASYNC.call(expandFrom, expandDiff(ytc.from, true), ytc);\n                    } else if (ytc.to && ytc.toExpanded === false) {\n                        //expand to\n                        ytc.toExpanded = true;\n                        _needChecking = true;\n                        done = TASYNC.call(expandTo, expandDiff(ytc.to, false), ytc);\n                    }\n                }\n            }\n            return TASYNC.call(function () {\n                return checkRound();\n            }, done);\n        }\n\n        _core.nodeDiff = function (source, target) {\n            var diff = {\n                children: childrenDiff(source, target),\n                attr: attrDiff(source, target),\n                reg: regDiff(source, target),\n                pointer: pointerDiff(source, target),\n                set: setDiff(source, target),\n                meta: metaDiff(source, target)\n            };\n\n            normalize(diff);\n            return isEmptyNodeDiff(diff) ? null : diff;\n        };\n\n        _core.generateTreeDiff = function (sRoot, tRoot) {\n            _yetToCompute = {};\n            _DIFF = {};\n            _diffMoves = {};\n            _needChecking = true;\n            _rounds = 0;\n            return TASYNC.call(function (d) {\n                _DIFF = d;\n                return checkRound();\n            }, updateDiff(sRoot, tRoot));\n        };\n\n        _core.generateLightTreeDiff = function (sRoot, tRoot) {\n            return updateDiff(sRoot, tRoot);\n        };\n\n        function getDiffChildrenRelids(diff) {\n            var keys = Object.keys(diff),\n                i,\n                filteredKeys = [],\n                forbiddenWords = {\n                    guid: true,\n                    hash: true,\n                    attr: true,\n                    reg: true,\n                    pointer: true,\n                    set: true,\n                    meta: true,\n                    removed: true,\n                    movedFrom: true,\n                    childrenListChanged: true,\n                    oGuids: true,\n                    ooGuids: true,\n                    min: true,\n                    max: true\n                };\n            for (i = 0; i < keys.length; i++) {\n                if (!forbiddenWords[keys[i]]) {\n                    filteredKeys.push(keys[i]);\n                }\n            }\n            return filteredKeys;\n        }\n\n        function getMoveSources(diff, path, toFrom, fromTo) {\n            var relids = getDiffChildrenRelids(diff),\n                i;\n\n            for (i = 0; i < relids.length; i++) {\n                getMoveSources(diff[relids[i]], path + '/' + relids[i], toFrom, fromTo);\n            }\n\n            if (typeof diff.movedFrom === 'string') {\n                toFrom[path] = diff.movedFrom;\n                fromTo[diff.movedFrom] = path;\n            }\n        }\n\n        function getAncestor(node, path) {\n            var ownPath = _core.getPath(node),\n                ancestorPath = '',\n                i;\n            path = path.split('/');\n            ownPath = ownPath.split('/');\n            ownPath.shift();\n            path.shift();\n            for (i = 0; i < ownPath.length; i++) {\n                if (ownPath[i] === path[i]) {\n                    ancestorPath = ancestorPath + '/' + ownPath[i];\n                } else {\n                    break;\n                }\n            }\n            ownPath = _core.getPath(node);\n            while (ownPath !== ancestorPath) {\n                node = _core.getParent(node);\n                ownPath = _core.getPath(node);\n            }\n            return node;\n        }\n\n        function setBaseOfNewNode(node, relid, basePath) {\n            //TODO this is a kind of low level hack so maybe there should be another way to do this\n            var ancestor = getAncestor(node, basePath),\n                sourcePath = _core.getPath(node).substr(_core.getPath(ancestor).length),\n                targetPath = basePath.substr(_core.getPath(ancestor).length);\n            sourcePath = sourcePath + '/' + relid;\n            _innerCore.overlayInsert(_core.getChild(ancestor, 'ovr'), sourcePath, 'base', targetPath);\n        }\n\n        function makeInitialContainmentChanges(node, diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, done, child, moved,\n                moving = function (n, di, p, m/*, d*/) {\n                    if (m === true) {\n                        n = _core.moveNode(n, p);\n                    }\n                    return makeInitialContainmentChanges(n, di);\n                };\n\n            for (i = 0; i < relids.length; i++) {\n                moved = false;\n                if (diff[relids[i]].movedFrom) {\n                    //moved node\n                    moved = true;\n                    child = _core.loadByPath(_core.getRoot(node), diff[relids[i]].movedFrom);\n                } else if (diff[relids[i]].removed === false) {\n                    //added node\n                    //first we hack the pointer, then we create the node\n                    if (diff[relids[i]].pointer && diff[relids[i]].pointer.base) {\n                        //we can set base if the node has one, otherwise it is 'inheritance internal' node\n                        setBaseOfNewNode(node, relids[i], diff[relids[i]].pointer.base);\n                    }\n                    if (diff[relids[i]].hash) {\n                        _core.setProperty(node, relids[i], diff[relids[i]].hash);\n                        child = _core.loadChild(node, relids[i]);\n                    } else {\n                        child = _core.getChild(node, relids[i]);\n                        _core.setHashed(child, true);\n                    }\n                } else {\n                    //simple node\n                    child = _core.loadChild(node, relids[i]);\n                }\n\n                done = TASYNC.call(moving, child, diff[relids[i]], node, moved, done);\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyNodeChange(root, path, nodeDiff) {\n            //check for move\n            var node;\n            node = _core.loadByPath(root, path);\n\n            return TASYNC.call(function (n) {\n                var done,\n                    relids = getDiffChildrenRelids(nodeDiff),\n                    i;\n                if (nodeDiff.removed === true) {\n                    _core.deleteNode(n);\n                    return;\n                }\n                applyAttributeChanges(n, nodeDiff.attr || {});\n                applyRegistryChanges(n, nodeDiff.reg || {});\n                done = applyPointerChanges(n, nodeDiff.pointer || {});\n                done = TASYNC.call(applySetChanges, n, nodeDiff.set || {}, done);\n                if (nodeDiff.meta) {\n                    delete nodeDiff.meta.empty;\n                    done = TASYNC.call(applyMetaChanges, n, nodeDiff.meta, done);\n                }\n                for (i = 0; i < relids.length; i++) {\n                    /*done = TASYNC.call(function () {\n                     return null;\n                     }, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]), done);*/\n                    done = TASYNC.join(done, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]));\n                }\n                /*TASYNC.call(function (d) {\n                 return done;\n                 }, done);*/\n                return done;\n            }, node);\n        }\n\n        function applyAttributeChanges(node, attrDiff) {\n            var i, keys;\n            keys = Object.keys(attrDiff);\n            for (i = 0; i < keys.length; i++) {\n                if (attrDiff[keys[i]] === TODELETESTRING) {\n                    _core.delAttribute(node, keys[i]);\n                } else {\n                    _core.setAttribute(node, keys[i], attrDiff[keys[i]]);\n                }\n            }\n        }\n\n        function applyRegistryChanges(node, regDiff) {\n            var i, keys;\n            keys = Object.keys(regDiff);\n            for (i = 0; i < keys.length; i++) {\n                if (regDiff[keys[i]] === TODELETESTRING) {\n                    _core.delRegistry(node, keys[i]);\n                } else {\n                    _core.setRegistry(node, keys[i], regDiff[keys[i]]);\n                }\n            }\n        }\n\n        function setPointer(node, name, target) {\n            var targetNode;\n            if (target === null) {\n                targetNode = null;\n            } else {\n                if (fromTo[target]) {\n                    target = fromTo[target];\n                }\n                targetNode = _core.loadByPath(_core.getRoot(node), target);\n            }\n            return TASYNC.call(function (t) {\n                //TODO watch if handling of base changes!!!\n                _core.setPointer(node, name, t);\n                return;\n            }, targetNode);\n        }\n\n        function applyPointerChanges(node, pointerDiff) {\n            var done,\n                keys = Object.keys(pointerDiff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (pointerDiff[keys[i]] === TODELETESTRING) {\n                    _core.deletePointer(node, keys[i]);\n                } else {\n                    done = setPointer(node, keys[i], pointerDiff[keys[i]]);\n                }\n            }\n\n            return TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n\n        }\n\n        function addMember(node, name, target, data) {\n            var memberAttrSetting = function (diff) {\n                    var keys = _core.getMemberOwnAttributeNames(node, name, target),\n                        i;\n                    for (i = 0; i < keys.length; i++) {\n                        _core.delMemberAttribute(node, name, target, keys[i]);\n                    }\n\n                    keys = Object.keys(diff);\n                    for (i = 0; i < keys.length; i++) {\n                        _core.setMemberAttribute(node, name, target, keys[i], diff[keys[i]]);\n                    }\n                },\n                memberRegSetting = function (diff) {\n                    var keys = _core.getMemberOwnRegistryNames(node, name, target),\n                        i;\n                    for (i = 0; i < keys.length; i++) {\n                        _core.delMemberRegistry(node, name, target, keys[i]);\n                    }\n\n                    keys = Object.keys(diff);\n                    for (i = 0; i < keys.length; i++) {\n                        _core.setMemberRegistry(node, name, target, keys[i], diff[keys[i]]);\n                    }\n                };\n            return TASYNC.call(function (t) {\n                _core.addMember(node, name, t);\n                memberAttrSetting(data.attr || {});\n                memberRegSetting(data.reg || {});\n                return;\n            }, _core.loadByPath(_core.getRoot(node), target));\n        }\n\n        function applySetChanges(node, setDiff) {\n            var done,\n                setNames = Object.keys(setDiff),\n                elements, i, j;\n            for (i = 0; i < setNames.length; i++) {\n                if (setDiff[setNames[i]] === TODELETESTRING) {\n                    _core.deleteSet(node, setNames[i]);\n                } else {\n                    elements = Object.keys(setDiff[setNames[i]]);\n                    for (j = 0; j < elements.length; j++) {\n                        if (setDiff[setNames[i]][elements[j]] === TODELETESTRING) {\n                            _core.delMember(node, setNames[i], elements[j]);\n                        } else {\n                            done = addMember(node, setNames[i], elements[j], setDiff[setNames[i]][elements[j]]);\n                        }\n                    }\n                }\n            }\n\n            return TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n\n        }\n\n        function applyMetaAttributes(node, metaAttrDiff) {\n            var i, keys, newValue;\n            if (metaAttrDiff === TODELETESTRING) {\n                //we should delete all MetaAttributes\n                keys = _core.getValidAttributeNames(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delAttributeMeta(node, keys[i]);\n                }\n            } else {\n                keys = Object.keys(metaAttrDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaAttrDiff[keys[i]] === TODELETESTRING) {\n                        _core.delAttributeMeta(node, keys[i]);\n                    } else {\n                        newValue = jsonConcat(_core.getAttributeMeta(node, keys[i]) || {}, metaAttrDiff[keys[i]]);\n                        _core.setAttributeMeta(node, keys[i], newValue);\n                    }\n                }\n            }\n        }\n\n        function applyMetaConstraints(node, metaConDiff) {\n            var keys, i;\n            if (metaConDiff === TODELETESTRING) {\n                //remove all constraints\n                keys = _core.getConstraintNames(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delConstraint(node, keys[i]);\n                }\n            } else {\n                keys = Object.keys(metaConDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaConDiff[keys[i]] === TODELETESTRING) {\n                        _core.delConstraint(node, keys[i]);\n                    } else {\n                        _core.setConstraint(node, keys[i], jsonConcat(_core.getConstraint(node, keys[i]) || {},\n                            metaConDiff[keys[i]]));\n                    }\n                }\n            }\n        }\n\n        function applyMetaChildren(node, metaChildrenDiff) {\n            var keys, i, done,\n                setChild = function (target, data/*, d*/) {\n                    _core.setChildMeta(node, target, data.min, data.max);\n                };\n            if (metaChildrenDiff === TODELETESTRING) {\n                //remove all valid child\n                keys = _core.getValidChildrenPaths(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delChildMeta(node, keys[i]);\n                }\n            } else {\n                _core.setChildrenMetaLimits(node, metaChildrenDiff.min, metaChildrenDiff.max);\n                delete metaChildrenDiff.max; //TODO we do not need it anymore, but maybe there is a better way\n                delete metaChildrenDiff.min;\n                keys = Object.keys(metaChildrenDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaChildrenDiff[keys[i]] === TODELETESTRING) {\n                        _core.delChildMeta(node, keys[i]);\n                    } else {\n                        done = TASYNC.call(setChild, _core.loadByPath(_core.getRoot(node), keys[i]),\n                            metaChildrenDiff[keys[i]], done);\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaPointers(node, metaPointerDiff) {\n            var names, targets, i, j, done,\n                setPointer = function (name, target, data/*, d*/) {\n                    _core.setPointerMetaTarget(node, name, target, data.min, data.max);\n                };\n            if (metaPointerDiff === TODELETESTRING) {\n                //remove all pointers,sets and their targets\n                names = _core.getValidPointerNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delPointerMeta(node, names[i]);\n                }\n\n                names = _core.getValidSetNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delPointerMeta(node, names[i]);\n                }\n                return;\n            }\n\n            names = Object.keys(metaPointerDiff);\n            for (i = 0; i < names.length; i++) {\n                if (metaPointerDiff[names[i]] === TODELETESTRING) {\n                    _core.delPointerMeta(node, names[i]);\n                } else {\n                    _core.setPointerMetaLimits(node, names[i], metaPointerDiff[names[i]].min,\n                        metaPointerDiff[names[i]].max);\n                    //TODO we do not need it anymore, but maybe there is a better way\n                    delete metaPointerDiff[names[i]].max;\n                    delete metaPointerDiff[names[i]].min;\n                    targets = Object.keys(metaPointerDiff[names[i]]);\n                    for (j = 0; j < targets.length; j++) {\n                        if (metaPointerDiff[names[i]][targets[j]] === TODELETESTRING) {\n                            _core.delPointerMetaTarget(node, names[i], targets[j]);\n                        } else {\n                            done = TASYNC.call(setPointer, names[i], _core.loadByPath(_core.getRoot(node), targets[j]),\n                                metaPointerDiff[names[i]][targets[j]], done);\n                        }\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaAspects(node, metaAspectsDiff) {\n            var names, targets, i, j, done,\n                setAspect = function (name, target/*, d*/) {\n                    _core.setAspectMetaTarget(node, name, target);\n                };\n            if (metaAspectsDiff === TODELETESTRING) {\n                //remove all aspects\n                names = _core.getValidAspectNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delAspectMeta(node, names[i]);\n                }\n                return;\n            }\n\n            names = Object.keys(metaAspectsDiff);\n            for (i = 0; i < names.length; i++) {\n                if (metaAspectsDiff[names[i]] === TODELETESTRING) {\n                    _core.delAspectMeta(node, names[i]);\n                } else {\n                    targets = Object.keys(metaAspectsDiff[names[i]]);\n                    for (j = 0; j < targets.length; j++) {\n                        if (metaAspectsDiff[names[i]][targets[j]] === TODELETESTRING) {\n                            _core.delAspectMetaTarget(node, names[i], targets[j]);\n                        } else {\n                            done = TASYNC.call(setAspect, names[i], _core.loadByPath(_core.getRoot(node), targets[j]),\n                                done);\n                        }\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaChanges(node, metaDiff) {\n            var done;\n            applyMetaAttributes(node, metaDiff.attributes || TODELETESTRING);\n            applyMetaConstraints(node, metaDiff.constraints || TODELETESTRING);\n            done = applyMetaChildren(node, metaDiff.children || TODELETESTRING);\n            done = TASYNC.call(applyMetaPointers, node, metaDiff.pointers || TODELETESTRING, done);\n            done = TASYNC.call(applyMetaAspects, node, metaDiff.aspects || TODELETESTRING, done);\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        _core.applyTreeDiff = function (root, diff) {\n\n            toFrom = {};\n            fromTo = {};\n            getMoveSources(diff, '', toFrom, fromTo);\n\n            return TASYNC.join(makeInitialContainmentChanges(root, diff), applyNodeChange(root, '', diff));\n        };\n\n        function getNodeByGuid(diff, guid) {\n            var relids, i, temp;\n            if (diff.guid === guid) {\n                return diff;\n            }\n\n            relids = getDiffChildrenRelids(diff);\n            for (i = 0; i < relids.length; i++) {\n                temp = getNodeByGuid(diff[relids[i]], guid);\n                if (temp) {\n                    return temp;\n                }\n            }\n            return null;\n        }\n\n        function insertAtPath(diff, path, object) {\n            ASSERT(typeof path === 'string');\n            var i, base, relid, nodepath;\n            if (path === '') {\n                _concatResult = JSON.parse(JSON.stringify(object));\n                return;\n            }\n            nodepath = path.match(/\\/\\/.*\\/\\//) || [];\n            nodepath = nodepath[0] || 'there is no nodepath in the path';\n            path = path.replace(nodepath, '/*nodepath*/');\n            nodepath = nodepath.replace(/\\/\\//g, '/');\n            nodepath = nodepath.slice(0, -1);\n            path = path.split('/');\n            path.shift();\n            if (path.indexOf('*nodepath*') !== -1) {\n                path[path.indexOf('*nodepath*')] = nodepath;\n            }\n            relid = path.pop();\n            base = diff;\n            for (i = 0; i < path.length; i++) {\n                base[path[i]] = base[path[i]] || {};\n                base = base[path[i]];\n            }\n            base[relid] = JSON.parse(JSON.stringify(object));\n            return;\n        }\n\n        //FIXME check if it is really depreciated\n        //function changeMovedPaths(singleNode) {\n        //    var keys, i;\n        //    keys = Object.keys(singleNode);\n        //    for (i = 0; i < keys.length; i++) {\n        //        if (_concatMoves.fromTo[keys[i]]) {\n        //            singleNode[_concatMoves.fromTo[keys[i]]] = singleNode[keys[i]];\n        //            delete singleNode[keys[i]];\n        //            if (typeof singleNode[_concatMoves.fromTo[keys[i]]] === 'object' &&\n        //                singleNode[_concatMoves.fromTo[keys[i]]] !== null) {\n        //\n        //                changeMovedPaths(singleNode[_concatMoves.fromTo[keys[i]]]);\n        //            }\n        //        } else {\n        //            if (typeof singleNode[keys[i]] === 'string' && keys[i] !== 'movedFrom' &&\n        //                _concatMoves.fromTo[singleNode[keys[i]]]) {\n        //\n        //                singleNode[keys[i]] = _concatMoves.fromTo[keys[i]];\n        //            }\n        //\n        //            if (typeof singleNode[keys[i]] === 'object' && singleNode[keys[i]] !== null) {\n        //                changeMovedPaths(singleNode[keys[i]]);\n        //            }\n        //        }\n        //\n        //    }\n        //    if (typeof singleNode === 'object' && singleNode !== null) {\n        //        keys = Object.keys(singleNode);\n        //        for (i = 0; i < keys.length; i++) {\n        //            if (_concatMoves.fromTo[keys[i]]) {\n        //                singleNode[_concatMoves.fromTo[keys[i]]] = singleNode[keys[i]];\n        //                delete singleNode[keys[i]];\n        //            }\n        //        }\n        //    } else if (typeof singleNode === 'string') {\n        //\n        //    }\n        //\n        //}\n\n        function getSingleNode(node) {\n            //removes the children from the node\n            var result = JSON.parse(JSON.stringify(node)),\n                keys = getDiffChildrenRelids(result),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                delete result[keys[i]];\n            }\n            //changeMovedPaths(result);\n            return result;\n        }\n\n        function jsonConcat(base, extension) {\n            var baseKeys = Object.keys(base),\n                extKeys = Object.keys(extension),\n                concat = JSON.parse(JSON.stringify(base)),\n                i;\n            for (i = 0; i < extKeys.length; i++) {\n                if (baseKeys.indexOf(extKeys[i]) === -1) {\n                    concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\n                } else {\n                    if (typeof base[extKeys[i]] === 'object' && typeof extension[extKeys[i]] === 'object') {\n                        concat[extKeys[i]] = jsonConcat(base[extKeys[i]], extension[extKeys[i]]);\n                    } else { //either from value to object or object from value we go with the extension\n                        concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\n                    }\n                }\n            }\n            return concat;\n        }\n\n        //FIXME are we going to use this function\n        //function getConflictByGuid(conflict, guid) {\n        //    var relids, i, result;\n        //    if (conflict.guid === guid) {\n        //        return conflict;\n        //    }\n        //    relids = getDiffChildrenRelids(conflict);\n        //    for (i = 0; i < relids.length; i++) {\n        //        result = getConflictByGuid(conflict[relids[i]], guid);\n        //        if (result) {\n        //            return result;\n        //        }\n        //    }\n        //    return null;\n        //}\n\n        function getPathByGuid(conflict, guid, path) {\n            var relids, i, result;\n            if (conflict.guid === guid) {\n                return path;\n            }\n            relids = getDiffChildrenRelids(conflict);\n            for (i = 0; i < relids.length; i++) {\n                result = getPathByGuid(conflict[relids[i]], guid, path + '/' + relids[i]);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        }\n\n        //now we try a different approach, which maybe more simple\n        function getCommonPathForConcat(path) {\n            if (_concatMoves.getExtensionSourceFromDestination[path]) {\n                path = _concatMoves.getExtensionSourceFromDestination[path];\n            }\n            if (_concatMoves.getBaseDestinationFromSource[path]) {\n                path = _concatMoves.getBaseDestinationFromSource[path];\n            }\n            return path;\n        }\n\n        function getConcatBaseRemovals(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i;\n            if (diff.removed !== true) {\n                if (diff.movedFrom) {\n                    if (_concatBaseRemovals[diff.guid] !== undefined) {\n                        delete _concatBaseRemovals[diff.guid];\n                    } else {\n                        _concatBaseRemovals[diff.guid] = false;\n                    }\n                }\n                for (i = 0; i < relids.length; i++) {\n                    getConcatBaseRemovals(diff[relids[i]]);\n                }\n            } else {\n                if (_concatBaseRemovals[diff.guid] === false) {\n                    delete _concatBaseRemovals[diff.guid];\n                } else {\n                    _concatBaseRemovals[diff.guid] = true;\n                }\n            }\n        }\n\n        function getObstructiveGuids(diffNode) {\n            var result = [],\n                keys, i;\n            keys = Object.keys(diffNode.oGuids || {});\n            for (i = 0; i < keys.length; i++) {\n                if (_concatBaseRemovals[keys[i]]) {\n                    result.push(keys[i]);\n                }\n            }\n            keys = Object.keys(diffNode.ooGuids || {});\n            for (i = 0; i < keys.length; i++) {\n                if (_concatBaseRemovals[keys[i]]) {\n                    result.push(keys[i]);\n                }\n            }\n            return result;\n        }\n\n        function getWhomIObstructGuids(guid) {\n            //this function is needed when the extension contains a deletion where the base did not delete the node\n            var guids = [],\n                checkNode = function (diffNode) {\n                    var relids, i;\n                    if ((diffNode.oGuids && diffNode.oGuids[guid]) || (diffNode.ooGuids && diffNode.ooGuids[guid])) {\n                        guids.push(diffNode.guid);\n                    }\n\n                    relids = getDiffChildrenRelids(diffNode);\n                    for (i = 0; i < relids.length; i++) {\n                        checkNode(diffNode[relids[i]]);\n                    }\n                };\n            checkNode(_concatBase);\n            return guids;\n        }\n\n        function gatherFullNodeConflicts(diffNode, mine, path, opposingPath) {\n            var conflict,\n                opposingConflict,\n                keys, i,\n                createSingleKeyValuePairConflicts = function (pathBase, data) {\n                    var keys, i;\n                    keys = Object.keys(data);\n                    for (i = 0; i < keys.length; i++) {\n                        conflict[pathBase + '/' + keys[i]] = conflict[pathBase + '/' + keys[i]] || {\n                                value: data[keys[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[pathBase + '/' + keys[i]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[pathBase + '/' + keys[i]] = true;\n                    }\n                };\n\n            //setting the conflicts\n            if (mine === true) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n            ASSERT(opposingConflict);\n            //if the node was moved we should make a conflict for the whole node as well\n            if (diffNode.movedFrom) {\n                conflict[path] = conflict[path] || {value: path, conflictingPaths: {}};\n                conflict[path].conflictingPaths[opposingPath] = true;\n                opposingConflict.conflictingPaths[path] = true;\n            }\n            createSingleKeyValuePairConflicts(path + '/attr', diffNode.attr || {});\n            createSingleKeyValuePairConflicts(path + '/reg', diffNode.reg || {});\n            createSingleKeyValuePairConflicts(path + '/pointer', diffNode.pointer || {});\n\n            if (diffNode.set) {\n                if (diffNode.set === TODELETESTRING) {\n                    conflict[path + '/set'] = conflict[path + '/set'] || {value: TODELETESTRING, conflictingPaths: {}};\n                    conflict[path + '/set'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/set'] = true;\n                } else {\n                    keys = Object.keys(diffNode.set);\n                    for (i = 0; i < keys.length; i++) {\n                        if (diffNode.set[keys[i]] === TODELETESTRING) {\n                            conflict[path + '/set/' + keys[i]] = conflict[path + '/set/' + keys[i]] || {\n                                    value: TODELETESTRING,\n                                    conflictingPaths: {}\n                                };\n                            conflict[path + '/set/' + keys[i]].conflictingPaths[opposingPath] = true;\n                            opposingConflict.conflictingPaths[path + '/set/' + keys[i]] = true;\n                        } else {\n                            gatherFullSetConflicts(diffNode.set[keys[i]], mine, path + '/set/' + keys[i], opposingPath);\n                        }\n                    }\n                }\n            }\n\n            if (diffNode.meta) {\n                gatherFullMetaConflicts(diffNode.meta, mine, path + '/meta', opposingPath);\n            }\n\n            //if the opposing item is theirs, we have to recursively go down in our changes\n            if (mine) {\n                keys = getDiffChildrenRelids(diffNode);\n                for (i = 0; i < keys.length; i++) {\n                    gatherFullNodeConflicts(diffNode[keys[i]], true, path + '/' + keys[i], opposingPath);\n                }\n            }\n\n        }\n\n        function gatherFullSetConflicts(diffSet, mine, path, opposingPath) {\n            var relids = getDiffChildrenRelids(diffSet),\n                i, keys, j, conflict, opposingConflict;\n\n            //setting the conflicts\n            if (mine === true) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n            for (i = 0; i < relids.length; i++) {\n                if (diffSet[relids[i]] === TODELETESTRING) {\n                    //single conflict as the element was removed\n                    conflict[path + '/' + relids[i] + '/'] = conflict[path + '/' + relids[i] + '/'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/' + relids[i] + '/'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/' + relids[i] + '/'] = true;\n                } else {\n                    keys = Object.keys(diffSet[relids[i]].attr || {});\n                    for (j = 0; j < keys.length; j++) {\n                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]] =\n                            conflict[path + '/' + relids[i] + '//attr/' + keys[j]] || {\n                                value: diffSet[relids[i]].attr[keys[j]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//attr/' + keys[j]] = true;\n                    }\n                    keys = Object.keys(diffSet[relids[i]].reg || {});\n                    for (j = 0; j < keys.length; j++) {\n                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]] =\n                            conflict[path + '/' + relids[i] + '//reg/' + keys[j]] || {\n                                value: diffSet[relids[i]].reg[keys[j]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//reg/' + keys[j]] = true;\n                    }\n                }\n            }\n        }\n\n        function concatSingleKeyValuePairs(path, base, extension) {\n            var keys, i, temp;\n            keys = Object.keys(extension);\n            for (i = 0; i < keys.length; i++) {\n                temp = extension[keys[i]];\n                if (typeof temp === 'string' && temp !== TODELETESTRING) {\n                    temp = getCommonPathForConcat(temp);\n                }\n                if (base[keys[i]] && CANON.stringify(base[keys[i]]) !== CANON.stringify(temp)) {\n                    //conflict\n                    _conflictMine[path + '/' + keys[i]] = {value: base[keys[i]], conflictingPaths: {}};\n                    _conflictTheirs[path + '/' + keys[i]] = {value: extension[keys[i]], conflictingPaths: {}};\n                    _conflictMine[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;\n                    _conflictTheirs[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;\n                } else {\n                    base[keys[i]] = extension[keys[i]];\n                }\n            }\n        }\n\n        function concatSet(path, base, extension) {\n            var names = Object.keys(extension),\n                members, i, j, memberPath;\n\n            for (i = 0; i < names.length; i++) {\n                if (base[names[i]]) {\n                    if (base[names[i]] === TODELETESTRING) {\n                        if (extension[names[i]] !== TODELETESTRING) {\n                            //whole set conflict\n                            _conflictMine[path + '/' + names[i]] = {value: TODELETESTRING, conflictingPaths: {}};\n                            gatherFullSetConflicts(extension[names[i]],\n                                false, path + '/' + names[i], path + '/' + names[i]);\n                        }\n                    } else {\n                        if (extension[names[i]] === TODELETESTRING) {\n                            //whole set conflict\n                            _conflictTheirs[path + '/' + names[i]] = {value: TODELETESTRING, conflictingPaths: {}};\n                            gatherFullSetConflicts(base[names[i]], true, path + '/' + names[i], path + '/' + names[i]);\n                        } else {\n                            //now we can only have member or sub-member conflicts...\n                            members = getDiffChildrenRelids(extension[names[i]]);\n                            for (j = 0; j < members.length; j++) {\n                                memberPath = getCommonPathForConcat(members[j]);\n                                if (base[names[i]][memberPath]) {\n                                    if (base[names[i]][memberPath] === TODELETESTRING) {\n                                        if (extension[names[i]][members[j]] !== TODELETESTRING) {\n                                            //whole member conflict\n                                            _conflictMine[path + '/' + names[i] + '/' + memberPath + '//'] = {\n                                                value: TODELETESTRING,\n                                                conflictingPaths: {}\n                                            };\n                                            gatherFullNodeConflicts(extension[names[i]][members[j]],\n                                                false,\n                                                path + '/' + names[i] + '/' + memberPath + '//', path +\n                                                '/' + names[i] + '/' + memberPath + '//');\n                                        }\n                                    } else {\n                                        if (extension[names[i]][members[j]] === TODELETESTRING) {\n                                            //whole member conflict\n                                            _conflictTheirs[path + '/' + names[i] + '/' + memberPath + '//'] = {\n                                                value: TODELETESTRING,\n                                                conflictingPaths: {}\n                                            };\n                                            gatherFullNodeConflicts(base[names[i]][memberPath],\n                                                true,\n                                                path + '/' + names[i] + '/' + memberPath + '//', path +\n                                                '/' + names[i] + '/' + memberPath + '//');\n                                        } else {\n                                            if (extension[names[i]][members[j]].attr) {\n                                                if (base[names[i]][memberPath].attr) {\n                                                    concatSingleKeyValuePairs(path + '/' +\n                                                        names[i] + '/' + memberPath + '/' + '/attr',\n                                                        base[names[i]][memberPath].attr,\n                                                        extension[names[i]][members[j]].attr);\n                                                } else {\n                                                    base[names[i]][memberPath].attr =\n                                                        extension[names[i]][members[j]].attr;\n                                                }\n                                            }\n                                            if (extension[names[i]][members[j]].reg) {\n                                                if (base[names[i]][memberPath].reg) {\n                                                    concatSingleKeyValuePairs(path + '/' +\n                                                        names[i] + '/' + memberPath + '/' + '/reg',\n                                                        base[names[i]][memberPath].reg,\n                                                        extension[names[i]][members[j]].reg);\n                                                } else {\n                                                    base[names[i]][memberPath].reg =\n                                                        extension[names[i]][members[j]].reg;\n                                                }\n                                            }\n\n                                        }\n                                    }\n                                } else {\n                                    //concat\n                                    base[names[i]][memberPath] = extension[names[i]][members[j]];\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    //simple concatenation\n                    //TODO the path for members should be replaced here as well...\n                    base[names[i]] = extension[names[i]];\n                }\n            }\n        }\n\n        function gatherFullMetaConflicts(diffMeta, mine, path, opposingPath) {\n            var conflict, opposingConflict,\n                relids, i, j, keys, tPath;\n\n            if (mine) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n\n            if (diffMeta === TODELETESTRING) {\n                conflict[path] = conflict[path] || {value: TODELETESTRING, conflictingPaths: {}};\n                conflict[path].conflictingPaths[opposingPath] = true;\n                opposingConflict.conflictingPaths[path] = true;\n                return; //there is no other conflict\n            }\n\n            //children\n            if (diffMeta.children) {\n                if (diffMeta.children === TODELETESTRING) {\n                    conflict[path + '/children'] = conflict[path + '/children'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/children'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/children'] = true;\n                } else {\n                    if (diffMeta.children.max) {\n                        conflict[path + '/children/max'] = conflict[path + '/children/max'] || {\n                                value: diffMeta.children.max,\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/max'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/max'] = true;\n                    }\n                    if (diffMeta.children.min) {\n                        conflict[path + '/children/min'] = conflict[path + '/children/min'] || {\n                                value: diffMeta.children.min,\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/min'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/min'] = true;\n                    }\n                    relids = getDiffChildrenRelids(diffMeta.children);\n                    for (i = 0; i < relids.length; i++) {\n                        conflict[path + '/children/' + relids[i]] = conflict[path + '/children/' + relids[i]] || {\n                                value: diffMeta.children[relids[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/' + relids[i]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/' + relids[i]] = true;\n                    }\n                }\n            }\n            //attributes\n            if (diffMeta.attributes) {\n                if (diffMeta.attributes === TODELETESTRING) {\n                    conflict[path + '/attributes'] = conflict[path + '/attributes'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/attributes'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/attributes'] = true;\n                } else {\n                    keys = Object.keys(diffMeta.attributes);\n                    for (i = 0; i < keys.length; i++) {\n                        conflict[path + '/attributes/' + keys[i]] = conflict[path + '/attributes/' + keys[i]] || {\n                                value: diffMeta.attributes[keys[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/attributes'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/attributes'] = true;\n                    }\n                }\n            }\n            //pointers\n            if (diffMeta.pointers) {\n                if (diffMeta.pointers === TODELETESTRING) {\n                    conflict[path + '/pointers'] = conflict[path + '/pointers'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/pointers'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/pointers'] = true;\n                } else {\n                    keys = Object.keys(diffMeta.pointers);\n                    for (i = 0; i < keys.length; i++) {\n                        if (diffMeta.pointers[keys[i]] === TODELETESTRING) {\n                            conflict[path + '/pointers/' + keys[i]] = conflict[path + '/pointers/' + keys[i]] || {\n                                    value: TODELETESTRING,\n                                    conflictingPaths: {}\n                                };\n                            conflict[path + '/pointers/' + keys[i]].conflictingPaths[opposingPath] = true;\n                            opposingConflict.conflictingPaths[path + '/pointers/' + keys[i]] = true;\n                        } else {\n                            if (diffMeta.pointers[keys[i]].max) {\n                                conflict[path + '/pointers/' + keys[i] + '/max'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/max'] || {\n                                        value: diffMeta.pointers[keys[i]].max,\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/max'].conflictingPaths[opposingPath] = true;\n                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/max'] = true;\n                            }\n                            if (diffMeta.pointers[keys[i]].min) {\n                                conflict[path + '/pointers/' + keys[i] + '/min'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/min'] || {\n                                        value: diffMeta.pointers[keys[i]].min,\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/min'].conflictingPaths[opposingPath] = true;\n                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/min'] = true;\n                            }\n                            relids = getDiffChildrenRelids(diffMeta.pointers[keys[i]]);\n                            for (j = 0; j < relids.length; j++) {\n                                tPath = getCommonPathForConcat(relids[j]);\n                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] || {\n                                        value: diffMeta.pointers[keys[i]][relids[j]],\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'].\n                                    conflictingPaths[opposingPath] = true;\n                                opposingConflict.\n                                    conflictingPaths[path + '/pointers/' + keys[i] + '/' + tPath + '//'] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            //aspects\n            //TODO\n        }\n\n        function concatMeta(path, base, extension) {\n            var keys, i, tPath, j, paths, t2Path,\n                mergeMetaItems = function (bPath, bData, eData) {\n                    var bKeys, tKeys, i, tPath, t2Path;\n                    //delete checks\n                    if (bData === TODELETESTRING || eData === TODELETESTRING) {\n                        if (CANON.stringify(bData) !== CANON.stringify(eData)) {\n                            _conflictMine[bPath] = _conflictMine[bPath] || {value: bData, conflictingPaths: {}};\n                            _conflictMine[bPath].conflictingPaths[bPath] = true;\n                            _conflictTheirs[bPath] = _conflictTheirs[bPath] || {value: eData, conflictingPaths: {}};\n                            _conflictTheirs[bPath].conflictingPaths[bPath] = true;\n                        }\n                    } else {\n                        //max\n                        if (eData.max) {\n                            if (bData.max && bData.max !== eData.max) {\n                                tPath = bPath + '/max';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData.max,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData.max,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData.max = eData.max;\n                            }\n                        }\n                        //min\n                        if (eData.min) {\n                            if (bData.min && bData.min !== eData.min) {\n                                tPath = bPath + '/min';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData.min,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData.min,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData.max = eData.min;\n                            }\n                        }\n                        //targets\n                        bKeys = getDiffChildrenRelids(bData);\n                        tKeys = getDiffChildrenRelids(eData);\n                        for (i = 0; i < tKeys.length; i++) {\n                            tPath = getCommonPathForConcat(tKeys[i]);\n                            if (bKeys.indexOf(tPath) !== -1 && CANON.stringify(bData[tPath]) !==\n                                CANON.stringify(eData[tKeys[i]])) {\n\n                                t2Path = tPath;\n                                tPath = bPath + '/' + tPath + '//';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData[t2Path],\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData[tKeys[i]],\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData[tPath] = eData[tKeys[i]];\n                            }\n                        }\n                    }\n                };\n            if (CANON.stringify(base) !== CANON.stringify(extension)) {\n                if (base === TODELETESTRING) {\n                    _conflictMine[path] = _conflictMine[path] || {value: TODELETESTRING, conflictingPaths: {}};\n                    gatherFullMetaConflicts(extension, false, path, path);\n                } else {\n                    if (extension === TODELETESTRING) {\n                        _conflictTheirs[path] = _conflictTheirs[path] || {\n                                value: TODELETESTRING,\n                                conflictingPaths: {}\n                            };\n                        gatherFullMetaConflicts(base, true, path, path);\n                    } else {\n                        //now check for sub-meta conflicts\n\n                        //children\n                        if (extension.children) {\n                            if (base.children) {\n                                mergeMetaItems(path + '/children', base.children, extension.children);\n                            } else {\n                                //we just simply merge the extension's\n                                base.children = extension.children;\n                            }\n                        }\n                        //pointers\n                        if (extension.pointers) {\n                            if (base.pointers) {\n                                //complete deletion\n                                if (base.pointers === TODELETESTRING || extension.pointers === TODELETESTRING) {\n                                    if (CANON.stringify(base.pointers) !== CANON.stringify(extension.pointers)) {\n                                        tPath = path + '/pointers';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.pointers,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.pointers,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.pointers);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.pointers[keys[i]]) {\n                                            mergeMetaItems(path + '/pointers/' + keys[i], base.pointers[keys[i]],\n                                                extension.pointers[keys[i]]);\n                                        } else {\n                                            base.pointers[keys[i]] = extension.pointers[keys[i]];\n                                        }\n                                    }\n                                }\n                            } else {\n                                base.pointers = extension.pointers;\n                            }\n                        }\n                        //attributes\n                        if (extension.attributes) {\n                            if (base.attributes) {\n                                if (extension.attributes === TODELETESTRING || base.attributes === TODELETESTRING) {\n                                    if (CANON.stringify(base.attributes) !== CANON.stringify(extension.attributes)) {\n                                        tPath = path + '/attributes';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.attributes,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.attributes,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.attributes);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.attributes[keys[i]]) {\n                                            if (extension.attributes[keys[i]] === TODELETESTRING ||\n                                                base.attributes[keys[i]] === TODELETESTRING) {\n\n                                                if (CANON.stringify(base.attributes[keys[i]]) !==\n                                                    CANON.stringify(extension.attributes[keys[i]])) {\n\n                                                    tPath = path + '/attributes/' + [keys[i]];\n                                                    _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                            value: base.attributes[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                            value: extension.attributes[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                }\n                                            } else {\n                                                concatSingleKeyValuePairs(path + '/attributes/' + keys[i],\n                                                    base.attributes[keys[i]], extension.attributes[keys[i]]);\n                                            }\n                                        } else {\n                                            base.attributes[keys[i]] = extension.attributes[keys[i]];\n                                        }\n                                    }\n\n                                }\n                            } else {\n                                base.attributes = extension.attributes;\n                            }\n                        }\n\n                        //aspects\n                        if (extension.aspects) {\n                            if (base.aspects) {\n                                if (extension.aspects === TODELETESTRING || base.aspects === TODELETESTRING) {\n                                    if (CANON.stringify(base.aspects) !== CANON.stringify(extension.aspects)) {\n                                        tPath = path + '/aspects';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.aspects,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.aspects,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.aspects);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.aspects[keys[i]]) {\n                                            if (extension.aspects[keys[i]] === TODELETESTRING ||\n                                                base.aspects[keys[i]] === TODELETESTRING) {\n                                                if (CANON.stringify(base.aspects[keys[i]]) !==\n                                                    CANON.stringify(extension.aspects[keys[i]])) {\n                                                    tPath = path + '/aspects/' + keys[i];\n                                                    _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                            value: base.aspects[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                            value: extension.aspects[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                }\n                                            } else {\n                                                paths = Object.keys(extension.aspects[keys[i]]);\n                                                for (j = 0; j < paths.length; j++) {\n                                                    tPath = getCommonPathForConcat(paths[j]);\n                                                    if (base.aspects[keys[i]][tPath]) {\n                                                        if (CANON.stringify(base.aspects[keys[i]][tPath]) !==\n                                                            CANON.stringify(extension.aspects[keys[i]][paths[j]])) {\n                                                            t2Path = tPath;\n                                                            tPath = path + '/aspects/' + keys[i] + '/' + tPath + '//';\n                                                            _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                                    value: base.aspects[keys[i]][t2Path],\n                                                                    conflictingPaths: {}\n                                                                };\n                                                            _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                            _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                                    value: extension.aspects[keys[i]][paths[j]],\n                                                                    conflictingPaths: {}\n                                                                };\n                                                            _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                        }\n                                                    } else {\n                                                        base.aspects[keys[i]][tPath] =\n                                                            extension.aspects[keys[i]][paths[j]];\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            base.aspects[keys[i]] = extension.aspects[keys[i]];\n                                        }\n                                    }\n                                }\n                            } else {\n                                base.aspects = extension.aspects;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function tryToConcatNodeChange(extNode, path) {\n            var guid = extNode.guid,\n                oGuids = getObstructiveGuids(extNode),\n                baseNode = getNodeByGuid(_concatBase, guid),\n                basePath = getPathByGuid(_concatBase, guid, ''),\n                i, tPath,\n                relids = getDiffChildrenRelids(extNode);\n\n\n            if (extNode.removed === true) {\n                if (baseNode && baseNode.removed !== true) {\n                    tPath = basePath + '/removed';\n                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {value: true, conflictingPaths: {}};\n                    oGuids = getWhomIObstructGuids(guid);\n                    ASSERT(oGuids.length > 0);\n                    for (i = 0; i < oGuids.length; i++) {\n                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);\n                        basePath = getPathByGuid(_concatBase, oGuids[i], '');\n                        gatherFullNodeConflicts(baseNode, true, basePath, tPath);\n                    }\n                } else {\n                    //we simply concat the deletion\n                    insertAtPath(_concatBase, path, extNode);\n                }\n            } else {\n                if (oGuids.length > 0) {\n                    for (i = 0; i < oGuids.length; i++) {\n                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);\n                        basePath = getPathByGuid(_concatBase, oGuids[i], '');\n                        _conflictMine[basePath + '/removed'] = _conflictMine[basePath + '/removed'] || {\n                                value: true,\n                                conflictingPaths: {}\n                            };\n                        gatherFullNodeConflicts(extNode, false, path, basePath + '/removed');\n                    }\n                } else if (baseNode) {\n                    //here we are able to check the sub-node conflicts\n                    //check double moves - we do not care if they moved under the same parent\n                    if (extNode.movedFrom) {\n                        if (baseNode.movedFrom && path !== basePath) {\n                            _conflictMine[basePath] = _conflictMine[basePath] || {\n                                    value: 'move',\n                                    conflictingPaths: {}\n                                };\n                            _conflictTheirs[path] = _conflictTheirs[path] || {value: 'move', conflictingPaths: {}};\n                            _conflictMine[basePath].conflictingPaths[path] = true;\n                            _conflictTheirs[path].conflictingPaths[basePath] = true;\n                            //we keep the node where it is, but synchronize the paths\n                            path = basePath;\n                        } else if (path !== basePath) {\n                            //first we move the base object to its new path\n                            //we copy the moved from information right here\n                            baseNode.movedFrom = extNode.movedFrom;\n                            insertAtPath(_concatBase, path, baseNode);\n                            removePathFromDiff(_concatBase, basePath);\n                            baseNode = getNodeByGuid(_concatBase, guid);\n                            basePath = getPathByGuid(_concatBase, guid, '');\n                            ASSERT(path === basePath);\n                        }\n                    }\n\n                    ASSERT(basePath === path || baseNode.movedFrom === path);\n                    path = basePath; //the base was moved\n\n\n                    //and now the sub-node conflicts\n                    if (extNode.attr) {\n                        if (baseNode.attr) {\n                            concatSingleKeyValuePairs(path + '/attr', baseNode.attr, extNode.attr);\n                        } else {\n                            insertAtPath(_concatBase, path + '/attr', extNode.attr);\n                        }\n                    }\n                    if (extNode.reg) {\n                        if (baseNode.reg) {\n                            concatSingleKeyValuePairs(path + '/reg', baseNode.reg, extNode.reg);\n                        } else {\n                            insertAtPath(_concatBase, path + '/reg', extNode.reg);\n                        }\n                    }\n                    if (extNode.pointer) {\n                        if (baseNode.pointer) {\n                            concatSingleKeyValuePairs(path + '/pointer', baseNode.pointer, extNode.pointer);\n                        } else {\n                            insertAtPath(_concatBase, path + '/pointer', extNode.pointer);\n                        }\n                    }\n                    if (extNode.set) {\n                        if (baseNode.set) {\n                            concatSet(path + '/set', baseNode.set, extNode.set);\n                        } else {\n                            insertAtPath(_concatBase, path + '/set', extNode.set);\n                        }\n                    }\n                    if (extNode.meta) {\n                        if (baseNode.meta) {\n                            concatMeta(path + '/meta', baseNode.meta, extNode.meta);\n                        } else {\n                            insertAtPath(_concatBase, path + '/meta', extNode.meta);\n                        }\n                    }\n                } else {\n                    //there is no basenode so we can concat the whole node\n                    insertAtPath(_concatBase, path, getSingleNode(extNode));\n                }\n            }\n\n            //here comes the recursion\n            for (i = 0; i < relids.length; i++) {\n                tryToConcatNodeChange(extNode[relids[i]], path + '/' + relids[i]);\n            }\n\n        }\n\n        function generateConflictItems() {\n            var items = [],\n                keys, i, j, conflicts;\n            keys = Object.keys(_conflictMine);\n\n            for (i = 0; i < keys.length; i++) {\n                conflicts = Object.keys(_conflictMine[keys[i]].conflictingPaths || {});\n                ASSERT(conflicts.length > 0);\n                for (j = 0; j < conflicts.length; j++) {\n                    items.push({\n                        selected: 'mine',\n                        mine: {\n                            path: keys[i],\n                            info: keys[i].replace(/\\//g, ' / '),\n                            value: _conflictMine[keys[i]].value\n                        },\n                        theirs: {\n                            path: conflicts[j],\n                            info: conflicts[j].replace(/\\//g, ' / '),\n                            value: _conflictTheirs[conflicts[j]].value\n                        }\n                    });\n                }\n            }\n            return items;\n        }\n\n        function harmonizeConflictPaths(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                keys, i, members, j;\n\n            keys = Object.keys(diff.pointer || {});\n            for (i = 0; i < keys.length; i++) {\n                diff.pointer[keys[i]] = getCommonPathForConcat(diff.pointer[keys[i]]);\n            }\n            keys = Object.keys(diff.set || {});\n            for (i = 0; i < keys.length; i++) {\n                members = Object.keys(diff.set[keys[i]] || {});\n                for (j = 0; j < members.length; j++) {\n                    if (members[j] !== getCommonPathForConcat(members[j])) {\n                        diff.set[keys[i]][getCommonPathForConcat(members[j])] = diff.set[keys[i]][members[j]];\n                        delete diff.set[keys[i]][members[j]];\n                    }\n                }\n            }\n\n            //TODO we have to do the meta as well\n            for (i = 0; i < relids.length; i++) {\n                harmonizeConflictPaths(diff[relids[i]]);\n            }\n        }\n\n        _core.tryToConcatChanges = function (base, extension) {\n            var result = {};\n            _conflictItems = [];\n            _conflictMine = {};\n            _conflictTheirs = {};\n            _concatBase = base;\n            _concatExtension = extension;\n            _concatBaseRemovals = {};\n            _concatMoves = {\n                getBaseSourceFromDestination: {},\n                getBaseDestinationFromSource: {},\n                getExtensionSourceFromDestination: {},\n                getExtensionDestinationFromSource: {}\n            };\n            getMoveSources(base,\n                '', _concatMoves.getBaseSourceFromDestination, _concatMoves.getBaseDestinationFromSource);\n            getMoveSources(extension,\n                '', _concatMoves.getExtensionSourceFromDestination, _concatMoves.getExtensionDestinationFromSource);\n            getConcatBaseRemovals(base);\n            tryToConcatNodeChange(_concatExtension, '');\n\n            result.items = generateConflictItems();\n            result.mine = _conflictMine;\n            result.theirs = _conflictTheirs;\n            result.merge = _concatBase;\n            harmonizeConflictPaths(result.merge);\n            return result;\n        };\n\n        function depthOfPath(path) {\n            ASSERT(typeof path === 'string');\n            return path.split('/').length;\n        }\n\n        function resolveMoves(resolveObject) {\n            var i, moves = {},\n                filteredItems = [],\n                path,\n                moveBaseOfPath = function (path) {\n                    var keys = Object.keys(moves),\n                        i, maxDepth = -1,\n                        base = null;\n                    for (i = 0; i < keys.length; i++) {\n                        if (path.indexOf(keys[i]) === 1 && depthOfPath(keys[i]) > maxDepth) {\n                            base = keys[i];\n                            maxDepth = depthOfPath(keys[i]);\n                        }\n                    }\n                    return base;\n                };\n            for (i = 0; i < resolveObject.items.length; i++) {\n                if (resolveObject.items[i].selected === 'theirs' && resolveObject.items[i].theirs.value === 'move') {\n                    moves[resolveObject.items[i].mine.path] = resolveObject.items[i].theirs.path;\n                    //and we also make the move\n                    insertAtPath(resolveObject.merge,\n                        resolveObject.items[i].theirs.path,\n                        getPathOfDiff(resolveObject.merge, resolveObject.items[i].mine.path));\n                    removePathFromDiff(resolveObject.merge, resolveObject.items[i].mine.path);\n                } else {\n                    filteredItems.push(resolveObject.items[i]);\n                }\n            }\n            resolveObject.items = filteredItems;\n\n            //in a second run we modify all sub-path of the moves paths\n            for (i = 0; i < resolveObject.items.length; i++) {\n                if (resolveObject.items[i].selected === 'theirs') {\n                    path = moveBaseOfPath(resolveObject.items[i].theirs.path);\n                    if (path) {\n                        resolveObject.items[i].theirs.path =\n                            resolveObject.items[i].theirs.path.replace(path, moves[path]);\n                    }\n                    path = moveBaseOfPath(resolveObject.items[i].mine.path);\n                    if (path) {\n                        resolveObject.items[i].mine.path = resolveObject.items[i].mine.path.replace(path, moves[path]);\n                    }\n                }\n            }\n        }\n\n        _core.applyResolution = function (conflictObject) {\n            //we apply conflict items to the merge and return it as a diff\n            var i;\n            resolveMoves(conflictObject);\n            for (i = 0; i < conflictObject.items.length; i++) {\n                if (conflictObject.items[i].selected !== 'mine') {\n                    removePathFromDiff(conflictObject.merge, conflictObject.items[i].mine.path);\n                    insertAtPath(conflictObject.merge,\n                        conflictObject.items[i].theirs.path, conflictObject.items[i].theirs.value);\n                }\n            }\n\n            return conflictObject.merge;\n        };\n\n\n        //we remove some low level functions as they should not be used on high level\n        delete _core.overlayInsert;\n\n        return _core;\n    }\n\n    return diffCore;\n});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/core/core',[\r\n    'common/core/corerel',\r\n    'common/core/setcore',\r\n    'common/core/guidcore',\r\n    'common/core/nullpointercore',\r\n    'common/core/coreunwrap',\r\n    'common/core/coretype',\r\n    'common/core/constraintcore',\r\n    'common/core/coretree',\r\n    'common/core/metacore',\r\n    'common/core/coretreeloader',\r\n    'common/core/corediff'\r\n], function (CoreRel, Set, Guid, NullPtr, UnWrap, Type, Constraint, CoreTree, MetaCore, TreeLoader, CoreDiff) {\r\n    'use strict';\r\n\r\n    function Core(storage, options) {\r\n        var core,\r\n            coreLayers = [];\r\n        coreLayers.push(CoreRel);\r\n        coreLayers.push(NullPtr);\r\n        coreLayers.push(Type);\r\n        coreLayers.push(NullPtr);\r\n        coreLayers.push(Set);\r\n        coreLayers.push(Guid);\r\n        coreLayers.push(Constraint);\r\n        coreLayers.push(MetaCore);\r\n        coreLayers.push(CoreDiff);\r\n        coreLayers.push(TreeLoader);\r\n        if (options.usertype !== 'tasync') {\r\n            coreLayers.push(UnWrap);\r\n        }\r\n\r\n        core = coreLayers.reduce(function (inner, Class) {\r\n            return new Class(inner, options);\r\n        }, new CoreTree(storage, options));\r\n\r\n        return core;\r\n    }\r\n\r\n    return Core;\r\n});\r\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/storage/client',['common/util/assert', 'common/util/guid'], function (ASSERT, GUID) {\n    'use strict';\n\n    function Database(options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        ASSERT(typeof options.globConf === 'object');\n        var gmeConfig = options.globConf,\n            logger = options.logger.fork('client');\n\n        options.type = options.type || 'browser';\n\n        var _hostAddress = null;\n        if (options.type === 'browser') {\n            if (window.__karma__) {\n                // TRICKY: karma uses web sockets too, we need to use the gme server's port\n                _hostAddress = window.location.protocol + '//localhost:' + gmeConfig.server.port;\n            } else {\n                _hostAddress = options.host || window.location.protocol + '//' + window.location.host;\n            }\n        } else {\n            _hostAddress = options.host + ':' + gmeConfig.server.port;\n        }\n\n        logger.debug('hostAddress:', _hostAddress);\n\n        var socketConnected = false,\n            socket = null,\n            status = null,\n            reconnect = false,\n            getDbStatusCallbacks = {},\n            callbacks = {},\n            getBranchHashCallbacks = {},\n            IO = null,\n            projects = {},\n            references = {},\n            ERROR_DISCONNECTED = 'The socket.io is disconnected',\n            ERROR_TIMEOUT = 'no valid response arrived in time',\n            STATUS_NETWORK_DISCONNECTED = 'socket.io is disconnected';\n\n        function clearDbCallbacks() {\n            var myCallbacks = [];\n            for (var i in getDbStatusCallbacks) {\n                myCallbacks.push(getDbStatusCallbacks[i]);\n                clearTimeout(getDbStatusCallbacks[i].to);\n            }\n            getDbStatusCallbacks = {};\n            for (i = 0; i < myCallbacks.length; i++) {\n                myCallbacks[i].cb(null, status);\n            }\n        }\n\n        function clearCallbacks() {\n            var myCallbacks = [];\n            for (var i in callbacks) {\n                myCallbacks.push(callbacks[i]);\n                clearTimeout(callbacks[i].to);\n            }\n            callbacks = {};\n            for (i = 0; i < myCallbacks.length; i++) {\n                myCallbacks[i].cb(ERROR_DISCONNECTED);\n            }\n        }\n\n        function reSendGetBranches() {\n            //this function should be called after reconnecting\n            for (var i in getBranchHashCallbacks) {\n                projects[getBranchHashCallbacks[i].project].getBranchHash(i, getBranchHashCallbacks[i].oldhash,\n                    getBranchHashCallbacks[i].cb);\n            }\n        }\n\n        function callbackTimeout(guid) {\n            var cb = null,\n                oldhash = '';\n            if (callbacks[guid]) {\n                cb = callbacks[guid].cb;\n                delete callbacks[guid];\n                cb(new Error(ERROR_TIMEOUT));\n            } else if (getDbStatusCallbacks[guid]) {\n                cb = getDbStatusCallbacks[guid].cb;\n                delete getDbStatusCallbacks[guid];\n                cb(null, status);\n            } else if (getBranchHashCallbacks[guid]) {\n                cb = getBranchHashCallbacks[guid].cb;\n                oldhash = getBranchHashCallbacks[guid].oldhash;\n                delete getBranchHashCallbacks[guid];\n                cb(new Error(ERROR_TIMEOUT), null, null);\n            }\n        }\n\n        function registerProject(id, name) {\n            if (!references[name]) {\n                references[name] = [];\n            }\n            if (references[name].indexOf(id) === -1) {\n                references[name].push(id);\n            }\n        }\n\n        function unRegisterProject(id, name) {\n            // var result = false; TODO: use one return statement here\n            if (references[name]) {\n                var index = references[name].indexOf(id);\n                if (index > -1) {\n                    references[name].splice(index, 1);\n                    if (references[name].length === 0) {\n                        delete references[name];\n                        return true;\n                    } else {\n                        return false;\n                    }\n                } else {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        function openDatabase(callback) {\n            ASSERT(typeof callback === 'function');\n\n            if (socket) {\n                if (socketConnected) {\n                    callback(null);\n                } else {\n                    //we should try to reconnect\n                    callback(null);\n                    //socket.socket.reconnect();\n                }\n            } else {\n                var guid = GUID(),\n                    firstConnection = true;\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n\n                var ioReady = function () {\n                    var socketIoOpts = JSON.parse(JSON.stringify(gmeConfig.socketIO)); // Copy these values.\n                    if (options.webGMESessionId) {\n                        socketIoOpts.query = 'webGMESessionId=' + options.webGMESessionId;\n                        //FIXME: options.webGMESessionId will be undefined in some cases\n                    }\n                    socket = IO.connect(_hostAddress, socketIoOpts);\n\n                    socket.on('connect', function () {\n                        socketConnected = true;\n                        if (firstConnection) {\n                            firstConnection = false;\n                            socket.emit('openDatabase', function (err) {\n                                if (!err) {\n                                    socket.emit('getDatabaseStatus', null, function (err, newstatus) {\n                                        if (!err && newstatus) {\n                                            status = newstatus;\n                                        }\n                                        if (callbacks[guid]) {\n                                            clearTimeout(callbacks[guid].to);\n                                            delete callbacks[guid];\n                                            callback(err);\n                                        }\n                                    });\n                                } else {\n                                    socket.emit('disconnect');\n                                    socket = null;\n                                    if (callbacks[guid]) {\n                                        clearTimeout(callbacks[guid].to);\n                                        delete callbacks[guid];\n                                        callback(err);\n                                    }\n                                }\n                            });\n                        } else {\n                            socket.emit('getDatabaseStatus', status, function (err, newstatus) {\n                                if (!err && newstatus) {\n                                    status = newstatus;\n                                    clearDbCallbacks();\n                                    reSendGetBranches();\n                                }\n                            });\n                        }\n                    });\n\n                    socket.on('error', function (err) {\n                        callback(err);\n                    });\n\n                    socket.on('disconnect', function () {\n                        status = STATUS_NETWORK_DISCONNECTED;\n                        socketConnected = false;\n                        clearDbCallbacks();\n                        clearCallbacks();\n                        //socket.socket.reconnect();\n                    });\n                };\n\n                if (options.type === 'browser') {\n                    require([_hostAddress + '/socket.io/socket.io.js'], function (io) {\n                        IO = io || window.io;\n                        ioReady();\n                    });\n                } else {\n                    require(['socket.io-client'], function (io) {\n                        IO = io;\n                        ioReady();\n                    });\n                }\n            }\n        }\n\n        function closeDatabase(callback) {\n            callback = callback || function () {\n            };\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('closeDatabase', function (err) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err);\n                    }\n\n                    // FIXME: how to disconnect properly ???\n                    //if (socketConnected && Object.keys(references).length === 0) {\n                    //    socketConnected = false;\n                    //    socket.disconnect();\n                    //}\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function fsyncDatabase(callback, projectName) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('fsyncDatabase', projectName, function (err) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function getDatabaseStatus(oldstatus, callback) {\n            ASSERT(typeof callback === 'function');\n            if (status !== oldstatus) {\n                callback(null, status);\n            } else {\n                var guid = GUID();\n                getDbStatusCallbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                if (status !== STATUS_NETWORK_DISCONNECTED) {\n                    socket.emit('getDatabaseStatus', oldstatus, function (err, newstatus) {\n                        if (!err && newstatus) {\n                            status = newstatus;\n                        }\n                        if (callbacks[guid]) {\n                            clearTimeout(getDbStatusCallbacks[guid].to);\n                            delete getDbStatusCallbacks[guid];\n                            callback(err, newstatus);\n                            //TODO why this common error check is missing and what was redo meant???\n                            /*commonErrorCheck(err, function (err2, needRedo) {\n                             if (needRedo) {\n                             getDatabaseStatus(oldstatus, callback);\n                             } else {\n                             callback(err2, newstatus);\n                             }\n                             });*/\n                        }\n                    });\n                }\n            }\n        }\n\n        function getProjectNames(callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('getProjectNames', function (err, names) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, names);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function getAllowedProjectNames(callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('getAllowedProjectNames', function (err, names) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, names);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function getAuthorizationInfo(name, callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('getAuthorizationInfo', name, function (err, authInfo) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, authInfo);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function deleteProject(project, callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('deleteProject', project, function (err) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function getNextServerEvent(latestGuid, callback) {\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('getNextServerEvent', latestGuid, function (err, newGuid, eventParams) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, newGuid, eventParams);\n                    }\n                });\n            }\n        }\n\n        function openProject(project, callback) {\n            ASSERT(typeof callback === 'function');\n            var ownId = GUID();\n            if (projects[project]) {\n                registerProject(ownId, project);\n                callback(null, projects[project]);\n            } else {\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('openProject', project, function (err) {\n                        if (!err) {\n                            registerProject(ownId, project);\n                            if (callbacks[guid]) {\n                                clearTimeout(callbacks[guid].to);\n                                delete callbacks[guid];\n                                projects[project] = {\n                                    fsyncDatabase: fsync,\n                                    getDatabaseStatus: getDatabaseStatus,\n                                    closeProject: closeProject,\n                                    loadObject: loadObject,\n                                    insertObject: insertObject,\n                                    getInfo: getInfo,\n                                    setInfo: setInfo,\n                                    findHash: findHash,\n                                    dumpObjects: dumpObjects,\n                                    getBranchNames: getBranchNames,\n                                    getBranchHash: getBranchHash,\n                                    setBranchHash: setBranchHash,\n                                    getCommits: getCommits,\n                                    makeCommit: makeCommit,\n                                    getCommonAncestorCommit: getCommonAncestorCommit,\n                                    ID_NAME: '_id'\n                                };\n                                callback(null, projects[project]);\n                            }\n                        } else {\n                            callback(err, null);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            //functions\n            function fsync(callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    flushSaveBucket();\n                    socket.emit('fsyncDatabase', project, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function getDatabaseStatus(oldstatus, callback) {\n                ASSERT(typeof callback === 'function');\n                if (status !== oldstatus) {\n                    callback(null, status);\n                } else {\n                    var guid = GUID();\n                    getDbStatusCallbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    if (socketConnected) {\n                        socket.emit('getDatabaseStatus', oldstatus, function (err, newstatus) {\n                            if (getDbStatusCallbacks[guid]) {\n                                clearTimeout(getDbStatusCallbacks[guid].to);\n                                delete getDbStatusCallbacks[guid];\n                                if (!err && newstatus) {\n                                    status = newstatus;\n                                }\n                                callback(err, newstatus);\n                            }\n                        });\n                    }\n                }\n            }\n\n            function closeProject(callback) {\n                callback = callback || function () {\n                };\n                if (unRegisterProject(ownId, project)) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('closeProject', project, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(null);\n                }\n            }\n\n            function _loadObject(hash, callback) {\n                socket.emit('loadObject', project, hash, callback);\n            }\n\n            function loadObject(hash, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    if (loadBucketSize === 0) {\n                        ++loadBucketSize;\n                        loadBucket.push({hash: hash, cb: callback});\n                        loadBucketTimer = setTimeout(function () {\n                            var myBucket = loadBucket;\n                            loadBucket = [];\n                            loadBucketTimer = null;\n                            loadBucketSize = 0;\n                            loadObjects(myBucket);\n                        }, 10);\n                    } else if (loadBucketSize === 99) {\n                        loadBucket.push({hash: hash, cb: callback});\n                        var myBucket = loadBucket;\n                        loadBucket = [];\n                        clearTimeout(loadBucketTimer);\n                        loadBucketTimer = null;\n                        loadBucketSize = 0;\n                        loadObjects(myBucket);\n                    } else {\n                        loadBucket.push({hash: hash, cb: callback});\n                        ++loadBucketSize;\n                    }\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            var loadBucket = [],\n                loadBucketSize = 0,\n                loadBucketTimer;\n\n            function loadObjects(hashedObjects) {\n                var hashes = {},\n                    i;\n                for (i = 0; i < hashedObjects.length; i++) {\n                    hashes[hashedObjects[i].hash] = true;\n                }\n                hashes = Object.keys(hashes);\n                socket.emit('loadObjects', project, hashes, function (err, results) {\n                    for (i = 0; i < hashedObjects.length; i++) {\n                        hashedObjects[i].cb(err, results[hashedObjects[i].hash]);\n                    }\n                });\n\n            }\n\n            function insertObject(object, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    if (saveBucket.length === 0) {\n                        saveBucket.push({object: object, cb: callback});\n                        saveBucketTimer = setTimeout(function () {\n                            flushSaveBucket();\n                        }, 10);\n                    } else if (saveBucket.length === 99) {\n                        saveBucket.push({object: object, cb: callback});\n                        flushSaveBucket();\n                    } else {\n                        saveBucket.push({object: object, cb: callback});\n                    }\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            var saveBucket = [],\n                saveBucketTimer;\n\n            function flushSaveBucket() {\n                var myBucket = saveBucket;\n                saveBucket = [];\n                try {\n                    clearTimeout(saveBucketTimer);\n                } catch (e) {\n                    //TODO there is no task to do here\n                }\n                saveBucketTimer = null;\n                if (myBucket.length > 0) {\n                    insertObjects(myBucket);\n                }\n            }\n\n            function insertObjects(objects) {\n                var storeObjects = [],\n                    i;\n                for (i = 0; i < objects.length; i++) {\n                    storeObjects.push(objects[i].object);\n                }\n                socket.emit('insertObjects', project, storeObjects, function (err) {\n                    for (i = 0; i < objects.length; i++) {\n                        objects[i].cb(err);\n                    }\n                });\n            }\n\n            function _insertObject(object, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('insertObject', project, object, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function getInfo(callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('getInfo', project, function (err, info) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err, info);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function setInfo(info, callback) {\n                ASSERT(typeof info === 'object' && typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('setInfo', project, info, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function findHash(beginning, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('findHash', project, beginning, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function dumpObjects(callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('dumpObjects', project, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function getBranchNames(callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('getBranchNames', project, function (err, names) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err, names);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function getBranchHash(branch, oldhash, callback) {\n                ASSERT(typeof callback === 'function');\n                var guid = GUID();\n                if (getBranchHashCallbacks[branch]) {\n                    //internal hack for recalling\n                    guid = branch;\n                    branch = getBranchHashCallbacks[guid].branch;\n                } else {\n                    getBranchHashCallbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid),\n                        branch: branch,\n                        oldhash: oldhash,\n                        project: project\n                    };\n                }\n\n                if (socketConnected) {\n                    socket.emit('getBranchHash', project, branch, oldhash, function (err, newhash, forkedhash) {\n                        if (getBranchHashCallbacks[guid]) {\n                            clearTimeout(getBranchHashCallbacks[guid].to);\n                            delete getBranchHashCallbacks[guid];\n                            callback(err, newhash, forkedhash);\n                        }\n                    });\n                }\n\n            }\n\n            function setBranchHash(branch, oldhash, newhash, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    flushSaveBucket();\n                    socket.emit('setBranchHash', project, branch, oldhash, newhash, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function getCommits(before, number, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('getCommits', project, before, number, function (err, commits) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err, commits);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function makeCommit(parents, roothash, msg, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('makeCommit', project, parents, roothash, msg, function (err) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n\n            function getCommonAncestorCommit(commitA, commitB, callback) {\n                ASSERT(typeof callback === 'function');\n                if (socketConnected) {\n                    var guid = GUID();\n                    callbacks[guid] = {\n                        cb: callback,\n                        to: setTimeout(callbackTimeout, gmeConfig.storage.timeout, guid)\n                    };\n                    socket.emit('getCommonAncestorCommit', project, commitA, commitB, function (err, commit) {\n                        if (callbacks[guid]) {\n                            clearTimeout(callbacks[guid].to);\n                            delete callbacks[guid];\n                            callback(err, commit);\n                        }\n                    });\n                } else {\n                    callback(new Error(ERROR_DISCONNECTED));\n                }\n            }\n        }\n\n        function simpleRequest(parameters, callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, 100 * gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('simpleRequest', parameters, function (err, resId) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, resId);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function simpleResult(resultId, callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, 100 * gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('simpleResult', resultId, function (err, result) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, result);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function simpleQuery(workerId, parameters, callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, 100 * gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('simpleQuery', workerId, parameters, function (err, result) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, result);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        function getToken(callback) {\n            ASSERT(typeof callback === 'function');\n            if (socketConnected) {\n                var guid = GUID();\n                callbacks[guid] = {\n                    cb: callback,\n                    to: setTimeout(callbackTimeout, 100 * gmeConfig.storage.timeout, guid)\n                };\n                socket.emit('getToken', function (err, result) {\n                    if (callbacks[guid]) {\n                        clearTimeout(callbacks[guid].to);\n                        delete callbacks[guid];\n                        callback(err, result);\n                    }\n                });\n            } else {\n                callback(new Error(ERROR_DISCONNECTED));\n            }\n        }\n\n        return {\n            openDatabase: openDatabase,\n            closeDatabase: closeDatabase,\n            fsyncDatabase: fsyncDatabase,\n            getDatabaseStatus: getDatabaseStatus,\n            getProjectNames: getProjectNames,\n            getAllowedProjectNames: getAllowedProjectNames,\n            getAuthorizationInfo: getAuthorizationInfo,\n            deleteProject: deleteProject,\n            openProject: openProject,\n            simpleRequest: simpleRequest,\n            simpleResult: simpleResult,\n            simpleQuery: simpleQuery,\n            getNextServerEvent: getNextServerEvent,\n            getToken: getToken\n        };\n    }\n\n    return Database;\n});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/storage/failsafe',['common/util/assert'], function (ASSERT) {\r\n    'use strict';\r\n    var BRANCH_OBJ_ID = '*branch*'; // MAGIC CONSTANT\r\n    var BRANCH_STATES = {  // MAGIC CONSTANT\r\n        SYNC: 'sync',\r\n        FORKED: 'forked',\r\n        DISCONNECTED: 'disconnected',\r\n        AHEAD: 'ahead'\r\n    };\r\n\r\n    function Database(_database, options) {\r\n        ASSERT(typeof _database === 'object');\r\n        ASSERT(typeof options === 'object');\r\n        ASSERT(typeof options.logger !== 'undefined');\r\n        ASSERT(typeof options.globConf === 'object');\r\n        var gmeConfig = options.globConf;\r\n        //logger = options.logger.fork('failsafe');\r\n\r\n        var exceptionErrors = [],\r\n            fsId = 'FS', // MAGIC CONSTANT\r\n            dbId = 'noID', // MAGIC CONSTANT\r\n            SEPARATOR = '$', // MAGIC CONSTANT\r\n            STATUS_CONNECTED = 'connected', // MAGIC CONSTANT\r\n            pendingStorage = {},\r\n            storage = null;\r\n\r\n        function loadPending() {\r\n            for (var i = 0; i < storage.length; i++) {\r\n                if (storage.key(i).indexOf(fsId) === 0) {\r\n                    var keyArray = storage.key(i).split(SEPARATOR);\r\n                    ASSERT(keyArray.length === 4);\r\n                    if (keyArray[1] === dbId) {\r\n                        var object = JSON.parse(storage.getItem(storage.key(i)));\r\n                        pendingStorage[keyArray[2]] = object;\r\n                    }\r\n                }\r\n            }\r\n            for (i in pendingStorage) {\r\n                if (!pendingStorage[i][BRANCH_OBJ_ID]) {\r\n                    pendingStorage[i][BRANCH_OBJ_ID] = {};\r\n                }\r\n            }\r\n        }\r\n\r\n        function savePending() {\r\n            //TODO maybe some check would be good, but not necessarily\r\n            for (var i in pendingStorage) {\r\n                storage.setItem(fsId + SEPARATOR + dbId + SEPARATOR + i, JSON.stringify(pendingStorage[i]));\r\n            }\r\n        }\r\n\r\n        function openDatabase(callback) {\r\n            if (gmeConfig.storage.failSafe === 'local' && localStorage) {\r\n                storage = localStorage;\r\n            } else if (gmeConfig.storage.failSafe === 'session' && sessionStorage) {\r\n                storage = sessionStorage;\r\n            } else if (gmeConfig.storage.failSafe === 'memory') {\r\n                storage = {\r\n                    length: 0,\r\n                    keys: [],\r\n                    data: {},\r\n                    getItem: function (key) {\r\n                        ASSERT(typeof key === 'string');\r\n                        return this.data[key];\r\n                    },\r\n                    setItem: function (key, object) {\r\n                        ASSERT(typeof key === 'string' && typeof object === 'string');\r\n                        this.data[key] = object;\r\n                        this.keys.push(key);\r\n                        this.length++;\r\n                    },\r\n                    key: function (index) {\r\n                        return this.keys[index];\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (storage) {\r\n                loadPending();\r\n                setInterval(savePending, gmeConfig.storage.failSafeFrequency);\r\n                _database.openDatabase(callback);\r\n            } else {\r\n                callback(new Error('cannot initialize fail safe storage'));\r\n            }\r\n        }\r\n\r\n        function openProject(projectName, callback) {\r\n            var project = null;\r\n            var inSync = true;\r\n            _database.openProject(projectName, function (err, proj) {\r\n                if (!err && proj) {\r\n                    project = proj;\r\n                    if (!pendingStorage[projectName]) {\r\n                        pendingStorage[projectName] = {};\r\n                        pendingStorage[projectName][BRANCH_OBJ_ID] = {};\r\n                    }\r\n                    callback(null, {\r\n                        fsyncDatabase: project.fsyncDatabase,\r\n                        getDatabaseStatus: project.getDatabaseStatus,\r\n                        closeProject: project.closeProject,\r\n                        loadObject: loadObject,\r\n                        insertObject: insertObject,\r\n                        getInfo: project.getInfo,\r\n                        setInfo: project.setInfo,\r\n                        findHash: project.findHash,\r\n                        dumpObjects: project.dumpObjects,\r\n                        getBranchNames: getBranchNames,\r\n                        getBranchHash: getBranchHash,\r\n                        setBranchHash: setBranchHash,\r\n                        getCommits: project.getCommits,\r\n                        makeCommit: project.makeCommit,\r\n                        getCommonAncestorCommit: project.getCommonAncestorCommit,\r\n                        ID_NAME: project.ID_NAME\r\n                    });\r\n                } else {\r\n                    callback(err, project);\r\n                }\r\n            });\r\n\r\n            function synchronise(callback) {\r\n                if (pendingStorage[projectName]) {\r\n                    var objects = [];\r\n                    var count = 0;\r\n                    var savingObject = function (object, cb) {\r\n                        project.insertObject(object, function (err) {\r\n                            if (err) {\r\n                                if (!pendingStorage[projectName]) {\r\n                                    pendingStorage[projectName] = {};\r\n                                }\r\n                                pendingStorage[projectName][object._id] = object;\r\n                            }\r\n                            cb();\r\n                        });\r\n                    };\r\n                    var objectProcessed = function () {\r\n                        if (--count === 0) {\r\n                            callback();\r\n                        }\r\n                    };\r\n\r\n                    for (var i in pendingStorage[projectName]) {\r\n                        if (i !== BRANCH_OBJ_ID) {\r\n                            objects.push(pendingStorage[projectName][i]);\r\n                        }\r\n                    }\r\n                    var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID];\r\n                    pendingStorage[projectName] = {};\r\n                    pendingStorage[projectName][BRANCH_OBJ_ID] = branchObj;\r\n\r\n                    //synchronizing the branches\r\n                    var aheadBranches = [];\r\n                    for (i in pendingStorage[projectName][BRANCH_OBJ_ID]) {\r\n                        if (pendingStorage[projectName][BRANCH_OBJ_ID][i].state === BRANCH_STATES.DISCONNECTED) {\r\n                            if (pendingStorage[projectName][BRANCH_OBJ_ID][i].local.length > 0) {\r\n                                pendingStorage[projectName][BRANCH_OBJ_ID][i].state = BRANCH_STATES.AHEAD;\r\n                                //we try to save our local head\r\n                                aheadBranches.push(i);\r\n                            } else {\r\n                                pendingStorage[projectName][BRANCH_OBJ_ID][i].state = BRANCH_STATES.SYNC;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    count = objects.length + aheadBranches.length;\r\n                    for (i = 0; i < aheadBranches.length; i++) {\r\n                        synchroniseBranch(aheadBranches[i], objectProcessed);\r\n                    }\r\n                    for (i = 0; i < objects.length; i++) {\r\n                        savingObject(objects[i], objectProcessed);\r\n                    }\r\n                    if (objects.length === 0) {\r\n                        callback();\r\n                    }\r\n                } else {\r\n                    callback();\r\n                }\r\n            }\r\n\r\n            function synchroniseBranch(branchname, callback) {\r\n                var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID][branchname];\r\n                project.getBranchHash(branchname, branchObj.local[0], function (err, newhash /*, forked*/) {\r\n                    if (!err && newhash) {\r\n                        var index = branchObj.unackedSentHashes.indexOf(newhash);\r\n                        if (index !== -1) {\r\n                            // the server will catch up eventually...\r\n                        } else if (branchObj.local.indexOf(newhash) !== -1) {\r\n                            project.setBranchHash(branchname, newhash, branchObj.local[0], callback);\r\n                        } else {\r\n                            //we forked\r\n                            branchObj.state = BRANCH_STATES.FORKED;\r\n                            branchObj.fork = newhash;\r\n                            callback(null);\r\n                        }\r\n                    } else {\r\n                        callback(err);\r\n                    }\r\n                });\r\n            }\r\n\r\n            function errorMode() {\r\n                if (inSync) {\r\n                    inSync = false;\r\n                    for (var i in pendingStorage[projectName][BRANCH_OBJ_ID]) {\r\n                        if (pendingStorage[projectName][BRANCH_OBJ_ID][i].state !== BRANCH_STATES.FORKED) {\r\n                            pendingStorage[projectName][BRANCH_OBJ_ID][i].state = BRANCH_STATES.DISCONNECTED;\r\n                        }\r\n                    }\r\n                    var checkIfAvailable = function (err, newstate) {\r\n                        if (newstate === STATUS_CONNECTED) {\r\n                            synchronise(function () {\r\n                                inSync = true;\r\n                            });\r\n                        } else {\r\n                            project.getDatabaseStatus(newstate, checkIfAvailable);\r\n                        }\r\n                    };\r\n                    project.getDatabaseStatus(null, checkIfAvailable);\r\n                }\r\n            }\r\n\r\n            function loadObject(hash, callback) {\r\n                project.loadObject(hash, function (err, object) {\r\n                    if (!err && object) {\r\n                        callback(null, object);\r\n                    } else {\r\n                        errorMode();\r\n                        if (exceptionErrors.indexOf(err) !== -1) {\r\n                            callback(err, object);\r\n                        } else {\r\n                            if (pendingStorage[projectName] && pendingStorage[projectName][hash]) {\r\n                                callback(null, pendingStorage[projectName][hash]);\r\n                            } else {\r\n                                callback(err, object);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            function insertObject(object, callback) {\r\n                project.insertObject(object, function (err) {\r\n                    if (err) {\r\n                        errorMode();\r\n                        if (exceptionErrors.indexOf(err) !== -1) {\r\n                            callback(err);\r\n                        } else {\r\n                            //TODO have to check if the id is already taken...\r\n                            if (!pendingStorage[projectName]) {\r\n                                pendingStorage[projectName] = {};\r\n                            }\r\n                            pendingStorage[projectName][object._id] = object;\r\n                            callback(null);\r\n                        }\r\n                    } else {\r\n                        callback(err);\r\n                    }\r\n                });\r\n            }\r\n\r\n            function getBranchNames(callback) {\r\n                project.getBranchNames(function (err, names) {\r\n                    //we need the locally stored names either way\r\n                    var locals = {};\r\n                    for (var i in pendingStorage[projectName][BRANCH_OBJ_ID]) {\r\n                        if (pendingStorage[projectName][BRANCH_OBJ_ID][i].local.length > 0) {\r\n                            locals[i] = pendingStorage[projectName][BRANCH_OBJ_ID][i].local[0];\r\n                        } else if (pendingStorage[projectName][BRANCH_OBJ_ID][i].fork === null &&\r\n                            pendingStorage[projectName][BRANCH_OBJ_ID][i].remote !== null) {\r\n\r\n                            locals[i] = pendingStorage[projectName][BRANCH_OBJ_ID][i].remote;\r\n                        }\r\n                    }\r\n\r\n                    if (err) {\r\n                        errorMode();\r\n                        if (exceptionErrors.indexOf(err) !== -1) {\r\n                            callback(err);\r\n                        } else {\r\n                            callback(null, locals);\r\n                        }\r\n                    } else {\r\n                        for (i in names) {\r\n                            if (!locals[i]) {\r\n                                locals[i] = names[i];\r\n                            } else if (locals[i] === pendingStorage[projectName][BRANCH_OBJ_ID][i].remote) {\r\n                                locals[i] = names[i];\r\n                            }\r\n                        }\r\n                        callback(err, locals);\r\n                    }\r\n                });\r\n            }\r\n\r\n            function getBranchHash(branch, oldhash, callback) {\r\n                if (!pendingStorage[projectName][BRANCH_OBJ_ID][branch]) {\r\n                    pendingStorage[projectName][BRANCH_OBJ_ID][branch] = {\r\n                        local: [],\r\n                        fork: null,\r\n                        state: BRANCH_STATES.SYNC,\r\n                        remote: null\r\n                    };\r\n                }\r\n                var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID][branch];\r\n\r\n                if (branchObj.state === BRANCH_STATES.SYNC || branchObj.state === BRANCH_STATES.AHEAD) {\r\n                    project.getBranchHash(branch, oldhash, function (err, newhash, forkedhash) {\r\n                        if (!err && newhash) {\r\n                            branchObj.remote = newhash;\r\n                        }\r\n                        switch (branchObj.state) {\r\n                            case BRANCH_STATES.SYNC:\r\n                                callback(err, newhash, forkedhash);\r\n                                break;\r\n                            case BRANCH_STATES.AHEAD:\r\n                                if (err) {\r\n                                    callback(err, newhash, forkedhash);\r\n                                } else {\r\n                                    var index = branchObj.unackedSentHashes.indexOf(newhash);\r\n                                    if (newhash && index !== -1) {\r\n                                        callback(err, newhash, forkedhash);\r\n                                    } else {\r\n                                        //we forked!!!\r\n                                        branchObj.state = BRANCH_STATES.FORKED;\r\n                                        branchObj.fork = newhash;\r\n                                        callback(null, branchObj.local[0], branchObj.fork);\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case BRANCH_STATES.DISCONNECTED:\r\n                                callback(null, branchObj.local[0], branchObj.fork);\r\n                                break;\r\n                            default://forked\r\n                                callback(null, branchObj.local[0], branchObj.fork);\r\n                                break;\r\n                        }\r\n                    });\r\n                } else {\r\n                    //served locally\r\n                    ASSERT((branchObj.local[0] && branchObj.local[0] !== '') || branchObj.remote);\r\n                    var myhash = null;\r\n                    if (branchObj.local[0]) {\r\n                        myhash = branchObj.local[0];\r\n                    } else {\r\n                        myhash = branchObj.remote;\r\n                    }\r\n\r\n                    if (myhash === oldhash) {\r\n                        setTimeout(function () {\r\n                            callback(null, oldhash, branchObj.fork);\r\n                        }, gmeConfig.storage.timeout);\r\n                    } else {\r\n                        callback(null, myhash, branchObj.fork);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            function setBranchHash(branch, oldhash, newhash, callback) {\r\n                ASSERT(typeof oldhash === 'string' && typeof newhash === 'string');\r\n                if (!pendingStorage[projectName][BRANCH_OBJ_ID][branch]) {\r\n                    pendingStorage[projectName][BRANCH_OBJ_ID][branch] = {\r\n                        local: [],\r\n                        fork: null,\r\n                        state: BRANCH_STATES.SYNC\r\n                    };\r\n                }\r\n                var branchObj = pendingStorage[projectName][BRANCH_OBJ_ID][branch];\r\n\r\n                var returnFunction = function (err) {\r\n                    if (!err) {\r\n                        var index = branchObj.local.indexOf(newhash);\r\n                        // setBranchHash may return out of order, so this will not hold:\r\n                        // ASSERT(index !== -1 || branchObj.state === BRANCH_STATES.SYNC);\r\n                        if (index !== -1) {\r\n                            branchObj.local.splice(index, branchObj.local.length - index);\r\n                        }\r\n                        index = branchObj.unackedSentHashes.indexOf(newhash);\r\n                        if (index !== -1) {\r\n                            branchObj.unackedSentHashes.splice(index + 1, branchObj.unackedSentHashes.length);\r\n                        }\r\n                        if (branchObj.local.length === 0) {\r\n                            branchObj.state = BRANCH_STATES.SYNC;\r\n                        }\r\n                    } else {\r\n                        /*//we go to disconnected state\r\n                         ASSERT(branchObj.local.length > 0);\r\n                         if(branchObj.state !== BRANCH_STATES.DISCONNECTED){\r\n                         branchObj.state = BRANCH_STATES.DISCONNECTED;\r\n                         var reSyncBranch = function(err,newhash,forkedhash){\r\n                         if(!err && newhash){\r\n                         if(branchObj.local.indexOf(newhash) === -1){\r\n                         //we forked\r\n                         branchObj.fork = newhash;\r\n                         branchObj.state = BRANCH_STATES.FORKED;\r\n                         } else {\r\n                         setBranchHash(branch,newhash,branchObj.local[0],function(){});\r\n                         }\r\n                         } else {\r\n                         //timeout or something not correct, so we should retry\r\n                         project.getBranchHash(branch,branchObj.local[0],reSyncBranch);\r\n                         }\r\n                         };\r\n                         project.getBranchHash(branch,branchObj.local[0],reSyncBranch);\r\n                         }*/\r\n                        //we have ancountered an error\r\n                        errorMode();\r\n                    }\r\n                };\r\n\r\n                switch (branchObj.state) {\r\n                    case BRANCH_STATES.SYNC:\r\n                        ASSERT(branchObj.local.length === 0);\r\n                        branchObj.state = BRANCH_STATES.AHEAD;\r\n                        branchObj.local = [newhash, oldhash];\r\n                        branchObj.unackedSentHashes = [newhash, oldhash];\r\n                        project.setBranchHash(branch, oldhash, newhash, returnFunction);\r\n                        callback(null);\r\n                        return;\r\n                    case BRANCH_STATES.AHEAD:\r\n                        ASSERT(branchObj.local.length > 0);\r\n                        if (oldhash === branchObj.local[0]) {\r\n                            branchObj.local.unshift(newhash);\r\n                            branchObj.unackedSentHashes.unshift(newhash);\r\n                            project.setBranchHash(branch, oldhash, newhash, returnFunction);\r\n                            callback(null);\r\n                        } else {\r\n                            callback(new Error('branch hash mismatch'));\r\n                        }\r\n                        return;\r\n                    case BRANCH_STATES.DISCONNECTED:\r\n                        /*ASSERT(branchObj.local.length > 0 || branchObj.remote);\r\n                         if(oldhash === branchObj.local[0] || oldhash === branchObj.remote){\r\n                         if(branchObj.local.length === 0){\r\n                         branchObj.local = [newhash,oldhash];\r\n                         } else {\r\n                         branchObj.local.unshift(newhash);\r\n                         }\r\n                         callback(null);\r\n                         } else {\r\n                         callback(new Error('branch hash mismatch'));\r\n                         }*/\r\n                        if (branchObj.local.length === 0) {\r\n                            branchObj.local = [newhash, oldhash];\r\n                            callback(null);\r\n                        } else {\r\n                            if (oldhash === branchObj.local[0]) {\r\n                                branchObj.local.unshift(newhash);\r\n                                callback(null);\r\n                            } else {\r\n                                callback(new Error('branch hash mismatch'));\r\n                            }\r\n                        }\r\n                        return;\r\n                    default: //BRANCH_STATES.FORKED\r\n                        ASSERT(branchObj.local.length > 0 && branchObj.fork);\r\n                        if (oldhash === branchObj.local[0]) {\r\n                            if (branchObj.fork === newhash) {\r\n                                //clearing the forked leg\r\n                                branchObj.fork = null;\r\n                                branchObj.state = BRANCH_STATES.SYNC;\r\n                                branchObj.local = [];\r\n                            } else {\r\n                                branchObj.local.unshift(newhash);\r\n                            }\r\n                            callback(null);\r\n                        } else {\r\n                            callback(new Error('branch hash mismatch'));\r\n                        }\r\n                        return;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            openDatabase: openDatabase,\r\n            closeDatabase: _database.closeDatabase,\r\n            fsyncDatabase: _database.fsyncDatabase,\r\n            getProjectNames: _database.getProjectNames,\r\n            getAllowedProjectNames: _database.getAllowedProjectNames,\r\n            getAuthorizationInfo: _database.getAuthorizationInfo,\r\n            getDatabaseStatus: _database.getDatabaseStatus,\r\n            openProject: openProject,\r\n            deleteProject: _database.deleteProject,\r\n            simpleRequest: _database.simpleRequest,\r\n            simpleResult: _database.simpleResult,\r\n            simpleQuery: _database.simpleQuery,\r\n            getNextServerEvent: _database.getNextServerEvent,\r\n            getToken: _database.getToken\r\n        };\r\n    }\r\n\r\n    return Database;\r\n});\r\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/storage/cache',['common/util/assert'], function (ASSERT) {\n    'use strict';\n\n    var Lock = function () {\n        var waiters = [];\n\n        return {\n            lock: function (func) {\n                waiters.push(func);\n                if (waiters.length === 1) {\n                    func();\n                }\n            },\n\n            unlock: function () {\n                waiters.shift();\n                if (waiters.length >= 1) {\n                    var func = waiters[0];\n                    func();\n                }\n            }\n        };\n    };\n\n    var Database = function (database, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        ASSERT(typeof options.globConf === 'object');\n        var gmeConfig = options.globConf,\n            logger = options.logger.fork('cache');\n        logger.debug('Initializing');\n        ASSERT(typeof database === 'object' && typeof gmeConfig === 'object');\n\n        var projects = {};\n        var dlock = new Lock();\n\n        function openProject(name, callback) {\n            ASSERT(typeof name === 'string' && typeof callback === 'function');\n\n            logger.debug('openProject', {metadata: {name: name}});\n\n            dlock.lock(function () {\n                if (typeof projects[name] !== 'undefined') {\n                    projects[name].reopenProject(callback);\n                    dlock.unlock();\n                } else {\n                    database.openProject(name, function (err, project) {\n                        if (err) {\n                            callback(err);\n                        } else {\n                            project = wrapProject(name, project);\n                            projects[name] = project;\n                            project.reopenProject(callback);\n                        }\n                        dlock.unlock();\n                    });\n                }\n            });\n        }\n\n        function closeDatabase(callback) {\n            logger.debug('closeDatabase');\n\n            dlock.lock(function () {\n                var n;\n                for (n in projects) {\n                    projects[n].abortProject();\n                }\n                projects = {};\n                database.closeDatabase(callback);\n                dlock.unlock();\n            });\n        }\n\n        function deleteProject(name, callback) {\n            logger.debug('deleteProject', {metadata: {name: name}});\n\n            if (typeof projects[name] !== 'undefined') {\n                projects[name].deleteProject();\n            }\n\n            database.deleteProject(name, callback);\n        }\n\n        function wrapProject(name, project) {\n            var ID_NAME = project.ID_NAME;\n\n            var refcount = 0;\n            var missing = {};\n            var backup = {};\n            var cache = {};\n            var cacheSize = 0;\n\n            var wrapLogger = logger.fork('wrapProject:' + name);\n            wrapLogger.debug('Initializing');\n\n            function tryFreeze(o) {\n                try {\n                    Object.freeze(o);\n                }\n                catch (e) {\n                    //TODO find the proper answer why this can occur\n                    return;\n                }\n            }\n\n            function maybeFreeze(o) {\n                if (o !== null && typeof o === 'object') {\n                    deepFreeze(o);\n                }\n            }\n\n            var deepFreeze = function (obj) {\n                ASSERT(typeof obj === 'object');\n\n                tryFreeze(obj);\n\n                var key;\n                for (key in obj) {\n                    maybeFreeze(obj[key]);\n                }\n            };\n            if (gmeConfig.debug === false) {\n                deepFreeze = function () {\n                };\n            }\n\n            function cacheInsert(key, obj) {\n                ASSERT(typeof cache[key] === 'undefined' && obj[ID_NAME] === key);\n                wrapLogger.debug('cacheInsert', {metadata: key});\n\n                deepFreeze(obj);\n                cache[key] = obj;\n\n                if (++cacheSize >= gmeConfig.storage.cache) {\n                    backup = cache;\n                    cache = {};\n                    cacheSize = 0;\n                }\n            }\n\n            function loadObject(key, callback) {\n                ASSERT(typeof key === 'string' && typeof callback === 'function');\n                ASSERT(project !== null);\n                wrapLogger.debug('loadObject', {metadata: key});\n\n                var obj = cache[key];\n                if (typeof obj === 'undefined') {\n                    obj = backup[key];\n                    if (typeof obj === 'undefined') {\n                        obj = missing[key];\n                        if (typeof obj === 'undefined') {\n                            obj = [callback];\n                            missing[key] = obj;\n                            project.loadObject(key, function (err, obj2) {\n                                ASSERT(typeof obj2 === 'object' || typeof obj2 === 'undefined');\n\n                                if (obj.length !== 0) {\n                                    ASSERT(missing[key] === obj);\n\n                                    delete missing[key];\n                                    if (!err && obj2) {\n                                        cacheInsert(key, obj2);\n                                    }\n\n                                    var cb;\n                                    while ((cb = obj.pop())) {\n                                        cb(err, obj2);\n                                    }\n                                }\n                            });\n                        } else {\n                            obj.push(callback);\n                        }\n                        return;\n                    } else {\n                        cacheInsert(key, obj);\n                    }\n                }\n\n                ASSERT(typeof obj === 'object' && obj !== null && obj[ID_NAME] === key);\n                callback(null, obj);\n            }\n\n            function insertObject(obj, callback) {\n                ASSERT(typeof obj === 'object' && obj !== null && typeof callback === 'function');\n                wrapLogger.debug('insertObject');\n\n                var key = obj[ID_NAME];\n                ASSERT(typeof key === 'string');\n\n                if (typeof cache[key] !== 'undefined') {\n                    callback(null);\n                    return;\n                } else {\n                    var item = backup[key];\n                    cacheInsert(key, obj);\n\n                    if (typeof item !== 'undefined') {\n                        callback(null);\n                        return;\n                    } else {\n                        item = missing[key];\n                        if (typeof item !== 'undefined') {\n                            delete missing[key];\n\n                            var cb;\n                            while ((cb = item.pop())) {\n                                cb(null, obj);\n                            }\n                        }\n                    }\n                }\n\n                project.insertObject(obj, callback);\n            }\n\n            function abortProject(callback) {\n                wrapLogger.debug('abortProject');\n\n                if (project !== null) {\n                    var p = project;\n                    project = null;\n                    delete projects[name];\n                    deleteProject();\n                    p.closeProject(callback);\n                } else if (typeof callback === 'function') {\n                    callback(null);\n                }\n            }\n\n            function closeProject(callback) {\n                wrapLogger.debug('closeProject', {metadata: {refcount: refcount}});\n\n                if (refcount >= 1) {\n                    if (--refcount === 0) {\n                        abortProject(callback);\n                    } else if (typeof callback === 'function') {\n                        callback(null);\n                    }\n                } else {\n                    wrapLogger.warn('closeProject was called more times than open project');\n                    // nothing to close\n                    callback(null);\n                }\n            }\n\n            function deleteProject() {\n                var key, callbacks, cb, err = new Error('cache closed');\n                wrapLogger.debug('deleteProject');\n\n                for (key in missing) {\n                    callbacks = missing[key];\n                    while ((cb = callbacks.pop())) {\n                        cb(err);\n                    }\n                }\n\n                missing = {};\n                backup = {};\n                cache = {};\n                cacheSize = 0;\n            }\n\n            function reopenProject(callback) {\n                ASSERT(project !== null && refcount >= 0 && typeof callback === 'function');\n                wrapLogger.debug('reopenProject');\n\n                var cacheProject = {};\n                for (var key in project) {\n                    if (project.hasOwnProperty(key)) {\n                        cacheProject[key] = project[key];\n                    }\n                }\n                if (gmeConfig.storage.cache !== 0) {\n                    cacheProject.loadObject = loadObject;\n                    cacheProject.insertObject = insertObject;\n                }\n                cacheProject.closeProject = closeProject;\n\n                ++refcount;\n                callback(null, cacheProject);\n            }\n\n            return {\n                reopenProject: reopenProject,\n                abortProject: abortProject,\n                deleteProject: deleteProject\n            };\n        }\n\n        logger.debug('Ready');\n        return {\n            openDatabase: database.openDatabase,\n            closeDatabase: closeDatabase,\n            fsyncDatabase: database.fsyncDatabase,\n            getDatabaseStatus: database.getDatabaseStatus,\n            getProjectNames: database.getProjectNames,\n            getAllowedProjectNames: database.getAllowedProjectNames,\n            getAuthorizationInfo: database.getAuthorizationInfo,\n            openProject: openProject,\n            deleteProject: deleteProject,\n            simpleRequest: database.simpleRequest,\n            simpleResult: database.simpleResult,\n            simpleQuery: database.simpleQuery,\n            getNextServerEvent: database.getNextServerEvent,\n            getToken: database.getToken\n        };\n    };\n\n    return Database;\n});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/storage/commit',[\r\n    'common/util/assert',\r\n    'common/util/key',\r\n    'common/regexp'\r\n], function (ASSERT, GENKEY, REGEXP) {\r\n    'use strict';\r\n\r\n    function Database(_database, _options) {\r\n        ASSERT(typeof _database === 'object');\r\n        ASSERT(typeof _options === 'object');\r\n        ASSERT(typeof _options.globConf === 'object');\r\n        ASSERT(typeof _options.logger !== 'undefined');\r\n\r\n        var gmeConfig = _options.globConf,\r\n            logger = _options.logger.fork('commit');\r\n\r\n        logger.debug('Initializing');\r\n\r\n        function openProject(projectName, callback) {\r\n\r\n            var _project = null,\r\n                projectLogger = logger.fork('project:' + projectName);\r\n            projectLogger.debug('Initializing');\r\n\r\n            _database.openProject(projectName, function (err, proj) {\r\n                if (!err && proj) {\r\n                    _project = proj;\r\n                    callback(null, {\r\n                        fsyncDatabase: _project.fsyncDatabase,\r\n                        closeProject: _project.closeProject,\r\n                        loadObject: _project.loadObject,\r\n                        insertObject: _project.insertObject,\r\n                        getInfo: _project.getInfo,\r\n                        setInfo: _project.setInfo,\r\n                        findHash: _project.findHash,\r\n                        dumpObjects: _project.dumpObjects,\r\n                        getBranchNames: _project.getBranchNames,\r\n                        getBranchHash: _project.getBranchHash,\r\n                        setBranchHash: _project.setBranchHash,\r\n                        getCommits: _project.getCommits,\r\n                        getCommonAncestorCommit: _project.getCommonAncestorCommit,\r\n                        makeCommit: makeCommit,\r\n                        setUser: setUser,\r\n                        ID_NAME: _project.ID_NAME\r\n                    });\r\n                } else {\r\n                    callback(err, proj);\r\n                }\r\n            });\r\n\r\n            function makeCommit(parents, roothash, msg, callback) {\r\n                projectLogger.debug('makeCommit', {metadata: arguments});\r\n                ASSERT(REGEXP.HASH.test(roothash));\r\n                ASSERT(typeof callback === 'function');\r\n\r\n                parents = parents || [];\r\n                msg = msg || 'n/a';\r\n\r\n                var commitObj = {\r\n                    root: roothash,\r\n                    parents: parents,\r\n                    updater: [_options.user],\r\n                    time: (new Date()).getTime(),\r\n                    message: msg,\r\n                    type: 'commit'\r\n                };\r\n\r\n                var id = '#' + GENKEY(commitObj, gmeConfig);\r\n                commitObj[_project.ID_NAME] = id;\r\n\r\n                _project.insertObject(commitObj, function (err) {\r\n                    if (err) {\r\n                        callback(err);\r\n                    } else {\r\n                        callback(null, id);\r\n                    }\r\n                });\r\n\r\n                return id;\r\n            }\r\n\r\n            function setUser(userId) {\r\n                projectLogger.debug('setUser', {metadata: arguments});\r\n\r\n                if (typeof userId === 'string') {\r\n                    _options.user = userId;\r\n                }\r\n            }\r\n\r\n            projectLogger.debug('Ready');\r\n        }\r\n\r\n        logger.debug('Ready');\r\n\r\n        return {\r\n            openDatabase: _database.openDatabase,\r\n            closeDatabase: _database.closeDatabase,\r\n            fsyncDatabase: _database.fsyncDatabase,\r\n            getProjectNames: _database.getProjectNames,\r\n            getAllowedProjectNames: _database.getAllowedProjectNames,\r\n            getAuthorizationInfo: _database.getAuthorizationInfo,\r\n            getDatabaseStatus: _database.getDatabaseStatus,\r\n            openProject: openProject,\r\n            deleteProject: _database.deleteProject,\r\n            simpleRequest: _database.simpleRequest,\r\n            simpleResult: _database.simpleResult,\r\n            simpleQuery: _database.simpleQuery,\r\n            getNextServerEvent: _database.getNextServerEvent,\r\n            getToken: _database.getToken\r\n        };\r\n    }\r\n\r\n    return Database;\r\n});\r\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/storage/clientstorage',[\r\n    'common/storage/client',\r\n    'common/storage/failsafe',\r\n    'common/storage/cache',\r\n    'common/storage/commit'\r\n], function (Client, Failsafe, Cache, Commit) {\r\n\r\n    'use strict';\r\n\r\n    function client(options) {\r\n        //return  new Log(new Commit(new Cache(new Failsafe(new Client(options),options),options),options),options);\r\n        return new Commit(new Cache(new Failsafe(new Client(options), options), options), options);\r\n    }\r\n\r\n    return client;\r\n});\r\n\r\n\r\n\n",
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nwindow.debug = exports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Use chrome.storage.local if we are in an app\n */\n\nvar storage;\n\nif (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')\n  storage = chrome.storage.local;\nelse\n  storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      storage.removeItem('debug');\n    } else {\n      storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n},{\"./debug\":2}],2:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":3}],3:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}]},{},[1]);\n\ndefine(\"debug\", function(){});\n\n",
    "/*globals define, debug*/\n/*jshint node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/logger',['debug'], function (_debug) {\n    'use strict';\n    // Separate namespaces using ',' a leading '-' will disable the namespace.\n    // Each part takes a regex.\n    //      ex: localStorage.debug = '*,-socket\\.io*,-engine\\.io*'\n    //      will log all but socket.io and engine.io\n    function createLogger(name, options) {\n        var log = typeof debug === 'undefined' ? _debug(name) : debug(name),\n            level,\n            levels = {\n                silly: 0,\n                input: 1,\n                verbose: 2,\n                prompt: 3,\n                debug: 4,\n                info: 5,\n                data: 6,\n                help: 7,\n                warn: 8,\n                error: 9\n            };\n        if (!options) {\n            throw new Error('options required in logger');\n        }\n        if (options.hasOwnProperty('level') === false) {\n            throw new Error('options.level required in logger');\n        }\n        level = levels[options.level];\n        if (typeof level === 'undefined') {\n            level = levels.info;\n        }\n\n        log.debug = function () {\n            if (log.enabled && level <= levels.debug) {\n                if (console.debug) {\n                    log.log = console.debug.bind(console);\n                } else {\n                    log.log = console.log.bind(console);\n                }\n                log.apply(this, arguments);\n            }\n        };\n        log.info = function () {\n            if (log.enabled && level <= levels.info) {\n                log.log = console.info.bind(console);\n                log.apply(this, arguments);\n            }\n        };\n        log.warn = function () {\n            if (log.enabled && level <= levels.warn) {\n                log.log = console.warn.bind(console);\n                log.apply(this, arguments);\n            }\n        };\n        log.error = function () {\n            if (log.enabled && level <= levels.error) {\n                log.log = console.error.bind(console);\n                log.apply(this, arguments);\n            } else {\n                console.error.apply(console, arguments);\n            }\n        };\n\n        log.fork = function (forkName, useForkName) {\n            forkName = useForkName ? forkName : name + ':' + forkName;\n            return createLogger(forkName, options);\n        };\n\n        log.forkWithOptions = function (_name, _options) {\n            return createLogger(_name, _options);\n        };\n\n        return log;\n    }\n\n    function createWithGmeConfig(name, gmeConfig) {\n        return createLogger(name, gmeConfig.client.log);\n    }\n\n    return {\n        create: createLogger,\n        createWithGmeConfig: createWithGmeConfig\n    };\n});\n",
    "/*globals define*/\r\n/*jshint browser: true, node:true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/util/url',[],function () {\r\n    'use strict';\r\n\r\n    function decodeUrl(url) {\r\n        var start = url.indexOf('%');\r\n        while (start > -1) {\r\n            var char = String.fromCharCode(parseInt(url.substr(start + 1, 2), 16));\r\n            url = url.replace(url.substr(start, 3), char);\r\n            start = url.indexOf('%');\r\n        }\r\n        return url;\r\n    }\r\n\r\n    function parseCookie(cookie) {\r\n        cookie = decodeUrl(cookie);\r\n        var parsed = {};\r\n        var elements = cookie.split(/[;,] */);\r\n        for (var i = 0; i < elements.length; i++) {\r\n            var pair = elements[i].split('=');\r\n            parsed[pair[0]] = pair[1];\r\n        }\r\n        return parsed;\r\n    }\r\n\r\n    function removeSpecialChars(text) {\r\n        text = text.replace(/%23/g, '#');\r\n        text = text.replace(/%26/g, '&');\r\n        text = text.replace(/%2f/g, '/');\r\n        text = text.replace(/%2F/g, '/');\r\n        return text;\r\n    }\r\n\r\n    function addSpecialChars(text) {\r\n        if (text === undefined) {\r\n            return text;\r\n        }\r\n        text = text.replace(/#/g, '%23');\r\n        text = text.replace(/&/g, '%26');\r\n        text = text.replace(/\\//g, '%2F');\r\n        return text;\r\n    }\r\n\r\n    function urlToRefObject(url) {\r\n        return {\r\n            $ref: url\r\n        };\r\n    }\r\n\r\n    return {\r\n        decodeUrl: decodeUrl,\r\n        parseCookie: parseCookie,\r\n        removeSpecialChars: removeSpecialChars,\r\n        addSpecialChars: addSpecialChars,\r\n        urlToRefObject: urlToRefObject\r\n    };\r\n});\r\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\n\r\ndefine('common/core/users/meta',[], function () {\r\n    'use strict';\r\n\r\n    function metaStorage() {\r\n        var _core = null,\r\n            _nodes = null,\r\n            _save = function () {\r\n            },\r\n            _initialized = false;\r\n\r\n        function initialize(core, nodes, save) {\r\n            _core = core;\r\n            _nodes = nodes;\r\n            _save = save;\r\n            _initialized = true;\r\n        }\r\n\r\n        function isValidMeta(/*meta*/) {\r\n            /*if( typeof meta === 'object'){\r\n             if(\r\n             //children\r\n             typeof meta.children === 'object' &&\r\n             (meta.children.types === null || typeof meta.children.types === 'array') &&\r\n             (typeof meta.children.min === 'undefined' || typeof meta.children.min === 'number') &&\r\n             (typeof meta.children.max === 'undefined' || typeof meta.children.max === 'number')){\r\n\r\n             //attributes\r\n             }\r\n             }\r\n\r\n             return false;*/\r\n            //TODO implement it :)\r\n            return true;\r\n        }\r\n\r\n        //function isValidAttributeSchema(atrSchema) {\r\n        //    //TODO implement :)\r\n        //    return true;\r\n        //}\r\n\r\n        //TODO this may change\r\n        function pathToRefObject(path) {\r\n            var ref = {};\r\n            ref.$ref = path;\r\n            return ref;\r\n        }\r\n\r\n        //TODO this may change\r\n        function refObjectToPath(ref) {\r\n            if (typeof ref.$ref === 'string') {\r\n                return ref.$ref/*.substring(1)*/;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        //getter setter functions\r\n        function getMeta(path) {\r\n            var i, j,\r\n                meta = {children: {}, attributes: {}, pointers: {}, aspects: {}};\r\n\r\n            if (_nodes === null || _nodes === undefined) {\r\n                return meta;\r\n            }\r\n            var node = _nodes[path] || null;\r\n            if (!node) {\r\n                return null;\r\n            }\r\n\r\n            var metaNode = _core.getChild(node, '_meta');\r\n            var childrenNode = _core.getChild(metaNode, 'children');\r\n            //children\r\n            meta.children = {};\r\n            meta.children.minItems = [];\r\n            meta.children.maxItems = [];\r\n            meta.children.items = _core.getMemberPaths(childrenNode, 'items');\r\n            for (i = 0; i < meta.children.items.length; i++) {\r\n                meta.children.minItems.push(\r\n                    _core.getMemberAttribute(childrenNode, 'items', meta.children.items[i], 'min') || -1);\r\n\r\n                meta.children.maxItems.push(\r\n                    _core.getMemberAttribute(childrenNode, 'items', meta.children.items[i], 'max') || -1);\r\n\r\n                meta.children.items[i] = pathToRefObject(meta.children.items[i]);\r\n            }\r\n            meta.children.min = _core.getAttribute(childrenNode, 'min');\r\n            meta.children.max = _core.getAttribute(childrenNode, 'max');\r\n\r\n            //attributes - they are simple json objects from our point of view\r\n            var atrNames = _core.getAttributeNames(metaNode);\r\n            for (i = 0; i < atrNames.length; i++) {\r\n                meta.attributes[atrNames[i]] = JSON.parse(JSON.stringify(\r\n                    _core.getAttribute(metaNode, atrNames[i])));\r\n            }\r\n\r\n            //pointers and pointer lists\r\n            var pointerNames = _core.getPointerNames(metaNode) || [];\r\n            for (i = 0; i < pointerNames.length; i++) {\r\n                var pointerNode = _core.getChild(metaNode, '_p_' + pointerNames[i]);\r\n                var pointer = {};\r\n                pointer.items = _core.getMemberPaths(pointerNode, 'items');\r\n                pointer.min = _core.getAttribute(pointerNode, 'min');\r\n                pointer.max = _core.getAttribute(pointerNode, 'max');\r\n                pointer.minItems = [];\r\n                pointer.maxItems = [];\r\n\r\n                for (j = 0; j < pointer.items.length; j++) {\r\n                    pointer.minItems.push(\r\n                        _core.getMemberAttribute(pointerNode, 'items', pointer.items[j], 'min') || -1);\r\n\r\n                    pointer.maxItems.push(\r\n                        _core.getMemberAttribute(pointerNode, 'items', pointer.items[j], 'max') || -1);\r\n\r\n                    pointer.items[j] = pathToRefObject(pointer.items[j]);\r\n\r\n                }\r\n\r\n                meta.pointers[pointerNames[i]] = pointer;\r\n            }\r\n\r\n            //aspects\r\n            var aspectsNode = _core.getChild(metaNode, 'aspects');\r\n            var aspectNames = _core.getPointerNames(aspectsNode);\r\n            if (aspectNames.length > 0) {\r\n                meta.aspects = {};\r\n                for (i = 0; i < aspectNames.length; i++) {\r\n                    var aspectNode = _core.getChild(aspectsNode, '_a_' + aspectNames[i]);\r\n                    meta.aspects[aspectNames[i]] = {items: []};\r\n                    var items = _core.getMemberPaths(aspectNode, 'items');\r\n                    for (j = 0; j < items.length; j++) {\r\n                        meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return meta;\r\n        }\r\n\r\n        function setMeta(path, meta) {\r\n            var i,\r\n                j,\r\n                aspectNode,\r\n                targetPath;\r\n            if (!isValidMeta) {\r\n                return;\r\n            }\r\n            var node = _nodes[path] || null;\r\n            if (node) {\r\n                var metaNode = _core.getChild(node, '_meta');\r\n                _core.deleteNode(metaNode, true);\r\n                metaNode = _core.getChild(node, '_meta');\r\n                if (meta.children) {\r\n                    var childrenNode = _core.getChild(metaNode, 'children');\r\n                    if (meta.children.items && meta.children.items.length) {\r\n                        if (meta.children.min) {\r\n                            _core.setAttribute(childrenNode, 'min', meta.children.min);\r\n                        }\r\n                        if (meta.children.max) {\r\n                            _core.setAttribute(childrenNode, 'max', meta.children.max);\r\n                        }\r\n\r\n                        for (i = 0; i < meta.children.items.length; i++) {\r\n                            targetPath = refObjectToPath(meta.children.items[i]);\r\n                            if (typeof targetPath === 'string' && _nodes[targetPath]) {\r\n                                _core.addMember(childrenNode, 'items', _nodes[targetPath]);\r\n                                if (meta.children.minItems[i] !== -1) {\r\n                                    _core.setMemberAttribute(childrenNode, 'items', targetPath, 'min',\r\n                                        meta.children.minItems[i]);\r\n                                }\r\n                                if (meta.children.maxItems[i] !== -1) {\r\n                                    _core.setMemberAttribute(childrenNode, 'items', targetPath, 'max',\r\n                                        meta.children.maxItems[i]);\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                    } else {\r\n                        _core.deleteNode(childrenNode, true);\r\n                    }\r\n                }\r\n\r\n                if (meta.attributes) {\r\n                    for (i in meta.attributes) {\r\n                        _core.setAttribute(metaNode, i, meta.attributes[i]);\r\n                    }\r\n                }\r\n\r\n                if (meta.pointers) {\r\n                    for (i in meta.pointers) {\r\n                        _core.setPointer(metaNode, i, null);\r\n                        var pointerNode = _core.getChild(metaNode, '_p_' + i);\r\n                        if (meta.pointers[i].items && meta.pointers[i].items.length) {\r\n                            if (meta.pointers[i].min) {\r\n                                _core.setAttribute(pointerNode, 'min', meta.pointers[i].min);\r\n                            }\r\n                            if (meta.pointers[i].max) {\r\n                                _core.setAttribute(pointerNode, 'max', meta.pointers[i].max);\r\n                            }\r\n\r\n                            for (j = 0; j < meta.pointers[i].items.length; j++) {\r\n                                targetPath = refObjectToPath(meta.pointers[i].items[j]);\r\n                                if (typeof targetPath === 'string' && _nodes[targetPath]) {\r\n                                    _core.addMember(pointerNode, 'items', _nodes[targetPath]);\r\n                                    if (meta.pointers[i].minItems[j] !== -1) {\r\n                                        _core.setMemberAttribute(pointerNode, 'items', targetPath, 'min',\r\n                                            meta.pointers[i].minItems[j]);\r\n                                    }\r\n                                    if (meta.pointers[i].maxItems[j] !== -1) {\r\n                                        _core.setMemberAttribute(pointerNode, 'items', targetPath, 'max',\r\n                                            meta.pointers[i].maxItems[j]);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (meta.aspects) {\r\n                    var aspectsNode = _core.getChild(metaNode, 'aspects'),\r\n                        aspectNames = [];\r\n                    for (i in meta.aspects) {\r\n                        _core.setPointer(aspectsNode, i, null);\r\n                        aspectNode = _core.getChild(aspectsNode, '_a_' + i);\r\n                        if (meta.aspects[i].items) {\r\n                            for (j = 0; j < meta.aspects[i].items.length; j++) {\r\n                                var member = _nodes[refObjectToPath(meta.aspects[i].items[j])];\r\n                                if (member) {\r\n                                    _core.addMember(aspectNode, 'items', member);\r\n                                }\r\n                            }\r\n                        }\r\n                        aspectNames.push(i);\r\n                    }\r\n                    if (aspectNames.length > 0) {\r\n                        meta.aspects = {};\r\n                        for (i = 0; i < aspectNames.length; i++) {\r\n                            aspectNode = _core.getChild(aspectsNode, '_a_' + aspectNames[i]);\r\n                            meta.aspects[aspectNames[i]] = {items: []};\r\n                            var items = _core.getMemberPaths(aspectNode, 'items');\r\n                            for (j = 0; j < items.length; j++) {\r\n                                meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var metaEvent = _core.getRegistry(node, '_meta_event_') || 0;\r\n                _core.setRegistry(node, '_meta_event_', metaEvent + 1);\r\n                _save('setMeta(' + path + ')');\r\n            }\r\n        }\r\n\r\n\r\n        //validation functions\r\n        function getBaseChain(path) {\r\n            var chain = [];\r\n            var node = _nodes[path];\r\n            if (node) {\r\n                while (node !== null) {\r\n                    chain.push(_core.getPath(node));\r\n                    node = _core.getBase(node);\r\n                }\r\n            }\r\n            return chain;\r\n        }\r\n\r\n        function isTypeOf(path, typePath) {\r\n            var node = _nodes[path];\r\n            if (node) {\r\n                var chain = getBaseChain(path);\r\n                if (chain.indexOf(typePath) !== -1) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isValidTypeOfArray(path, typePathArray) {\r\n            var i = 0,\r\n                isGood = false;\r\n            while (i < typePathArray.length && isGood === false) {\r\n                isGood = isTypeOf(path, typePathArray[i]);\r\n                i++;\r\n            }\r\n            return isGood;\r\n        }\r\n\r\n        function isValidChild(path, childPath) {\r\n            var node = _nodes[path];\r\n            var child = _nodes[childPath];\r\n            if (node && child) {\r\n                var metaNode = _core.getChild(node, '_meta');\r\n                var childrenNode = _core.getChild(metaNode, 'children');\r\n                var items = _core.getMemberPaths(childrenNode, 'items');\r\n                return isValidTypeOfArray(childPath, items);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isValidTarget(path, name, targetPath) {\r\n            var node = _nodes[path];\r\n            var target = _nodes[targetPath];\r\n            if (node && target) {\r\n                var meta = _core.getChild(node, '_meta');\r\n                var pointer = _core.getChild(meta, '_p_' + name);\r\n                var items = _core.getMemberPaths(pointer, 'items');\r\n                return isValidTypeOfArray(targetPath, items);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function isValidAttribute(/*path, name, attribute*/) {\r\n            //TODO we should check against schema\r\n            return true;\r\n        }\r\n\r\n        function getValidChildrenTypes(path) {\r\n            var node = _nodes[path];\r\n            if (node) {\r\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node, '_meta'), 'children'), 'items');\r\n            }\r\n            return [];\r\n        }\r\n\r\n        function getValidTargetTypes(path, name) {\r\n            var node = _nodes[path];\r\n            if (node) {\r\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node, '_meta'), '_p_' + name), 'items');\r\n            }\r\n            return [];\r\n        }\r\n\r\n        function hasOwnMetaRules(path) {\r\n            var node = _nodes[path];\r\n            if (node) {\r\n                var own = getMeta(path);\r\n                var base = getMeta(_core.getPath(_core.getBase(node)));\r\n                return own === base;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function filterValidTarget(path, name, paths) {\r\n            var targets = [];\r\n            for (var i = 0; i < paths.length; i++) {\r\n                if (isValidTarget(path, name, paths[i])) {\r\n                    targets.push(paths[i]);\r\n                }\r\n            }\r\n            return targets;\r\n        }\r\n\r\n        function getOwnValidChildrenTypes(path) {\r\n            var node = _nodes[path];\r\n            var items = [];\r\n            if (node) {\r\n                var own = getValidChildrenTypes(path);\r\n                var base = getValidChildrenTypes(_core.getPath(_core.getBase(node)));\r\n                for (var i = 0; i < own.length; i++) {\r\n                    if (base.indexOf(own[i]) === -1) {\r\n                        items.push(own[i]);\r\n                    }\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n\r\n        function getOwnValidTargetTypes(path, name) {\r\n            var node = _nodes[path];\r\n            var items = [];\r\n            if (node) {\r\n                var own = getValidTargetTypes(path, name);\r\n                var base = getValidTargetTypes(_core.getPath(_core.getBase(node)), name);\r\n                for (var i = 0; i < own.length; i++) {\r\n                    if (base.indexOf(own[i]) === -1) {\r\n                        items.push(own[i]);\r\n                    }\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n\r\n        function getValidAttributeNames(path) {\r\n            var rawMeta = getMeta(path),\r\n                names = [];\r\n            if (rawMeta) {\r\n                for (var i in rawMeta.attributes) {\r\n                    names.push(i);\r\n                }\r\n            }\r\n            return names;\r\n        }\r\n\r\n        function getOwnValidAttributeNames(path) {\r\n            var names = [],\r\n                node = _nodes[path];\r\n\r\n            if (node) {\r\n                var own = getValidAttributeNames(path);\r\n                var base = getValidAttributeNames(_core.getPath(_core.getBase(node)));\r\n                for (var i = 0; i < own.length; i++) {\r\n                    if (base.indexOf(own[i]) === -1) {\r\n                        names.push(own[i]);\r\n                    }\r\n                }\r\n            }\r\n            return names;\r\n        }\r\n\r\n        function indexOfPathInRefObjArray(array, path) {\r\n            var index = 0;\r\n            while (index < array.length) {\r\n                if (path === refObjectToPath(array[index])) {\r\n                    return index;\r\n                }\r\n                index++;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        function getChildrenMeta(path) {\r\n            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                var childrenMeta = {};\r\n                childrenMeta.min = rawMeta.children.min;\r\n                childrenMeta.max = rawMeta.children.max;\r\n                childrenMeta.items = rawMeta.children.items;\r\n                if (childrenMeta.items !== null) {\r\n                    for (var i = 0; i < childrenMeta.items.length; i++) {\r\n                        var child = {};\r\n                        child.id = refObjectToPath(childrenMeta.items[i]);\r\n                        if (rawMeta.children.minItems) {\r\n                            child.min = rawMeta.children.minItems[i] === -1 ? undefined : rawMeta.children.minItems[i];\r\n                        }\r\n                        if (rawMeta.children.maxItems) {\r\n                            child.max = rawMeta.children.maxItems[i] === -1 ? undefined : rawMeta.children.maxItems[i];\r\n                        }\r\n\r\n                        childrenMeta.items[i] = child;\r\n                    }\r\n                }\r\n\r\n                return childrenMeta;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function getChildrenMetaAttribute(path/*, attrName*/) {\r\n            var childrenMeta = getChildrenMeta(path);\r\n            if (childrenMeta) {\r\n                return childrenMeta.attrName;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function setChildrenMetaAttribute(path, attrName, value) {\r\n            if (attrName !== 'items') {\r\n                var rawMeta = getMeta(path);\r\n                rawMeta.children[attrName] = value;\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function getValidChildrenItems(path) {\r\n            var childrenMeta = getChildrenMeta(path);\r\n            if (childrenMeta) {\r\n                return childrenMeta.items;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function updateValidChildrenItem(path, newTypeObj) {\r\n            var i,\r\n                rawMeta;\r\n            if (newTypeObj && newTypeObj.id) {\r\n                rawMeta = getMeta(path);\r\n                if (rawMeta) {\r\n                    if (rawMeta.children.minItems === null || rawMeta.children.minItems === undefined) { //TODO: use ! ?\r\n                        rawMeta.children.minItems = [];\r\n                        for (i = 0; i < rawMeta.children.items.length; i++) {\r\n                            rawMeta.children.minItems.push(-1);\r\n                        }\r\n                    }\r\n                    if (rawMeta.children.maxItems === null || rawMeta.children.maxItems === undefined) { //TODO: use ! ?\r\n                        rawMeta.children.maxItems = [];\r\n                        for (i = 0; i < rawMeta.children.items.length; i++) {\r\n                            rawMeta.children.maxItems.push(-1);\r\n                        }\r\n                    }\r\n                    var refObj = pathToRefObject(newTypeObj.id);\r\n                    var index = indexOfPathInRefObjArray(rawMeta.children.items, newTypeObj.id);\r\n                    if (index === -1) {\r\n                        index = rawMeta.children.items.length;\r\n                        rawMeta.children.items.push(refObj);\r\n                        rawMeta.children.minItems.push(-1);\r\n                        rawMeta.children.maxItems.push(-1);\r\n                    }\r\n                    // jshint expr:true\r\n                    (newTypeObj.min === null || newTypeObj.min === undefined) ?\r\n                        rawMeta.children.minItems[index] = -1 : rawMeta.children.minItems[index] = newTypeObj.min;\r\n\r\n                    (newTypeObj.max === null || newTypeObj.max === undefined) ?\r\n                        rawMeta.children.maxItems[index] = -1 : rawMeta.children.maxItems[index] = newTypeObj.max;\r\n                    // jshint expr:false\r\n                    setMeta(path, rawMeta);\r\n                }\r\n            }\r\n        }\r\n\r\n        function removeValidChildrenItem(path, typeId) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                //var refObj = pathToRefObject(typeId);\r\n                var index = indexOfPathInRefObjArray(rawMeta.children.items, typeId);\r\n                if (index !== -1) {\r\n                    rawMeta.children.items.splice(index, 1);\r\n                    if (rawMeta.children.minItems) {\r\n                        rawMeta.children.minItems.splice(index, 1);\r\n                    }\r\n                    if (rawMeta.children.maxItems) {\r\n                        rawMeta.children.maxItems.splice(index, 1);\r\n                    }\r\n                    setMeta(path, rawMeta);\r\n                }\r\n            }\r\n        }\r\n\r\n        function getAttributeSchema(path, name) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                if (rawMeta.attributes[name]) {\r\n                    return rawMeta.attributes[name];\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function setAttributeSchema(path, name, schema) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                //TODO check schema validity - but it is also viable to check it only during setMeta\r\n                rawMeta.attributes[name] = schema;\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function removeAttributeSchema(path, name) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                delete rawMeta.attributes[name];\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function getPointerMeta(path, name) {\r\n            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta && rawMeta.pointers[name]) {\r\n                var pointerMeta = {};\r\n                pointerMeta.min = rawMeta.pointers[name].min;\r\n                pointerMeta.max = rawMeta.pointers[name].max;\r\n                pointerMeta.items = rawMeta.pointers[name].items;\r\n                if (pointerMeta.items !== null) {\r\n                    for (var i = 0; i < pointerMeta.items.length; i++) {\r\n                        var child = {};\r\n                        child.id = refObjectToPath(pointerMeta.items[i]);\r\n                        if (rawMeta.pointers[name].minItems) {\r\n                            child.min = rawMeta.pointers[name].minItems[i] === -1 ?\r\n                                undefined : rawMeta.pointers[name].minItems[i]; //FIXME: avoid assigning undefined\r\n                        }\r\n                        if (rawMeta.pointers[name].maxItems) {\r\n                            child.max = rawMeta.pointers[name].maxItems[i] === -1 ?\r\n                                undefined : rawMeta.pointers[name].maxItems[i]; //FIXME: avoid assigning undefined\r\n                        }\r\n                        pointerMeta.items[i] = child;\r\n                    }\r\n                }\r\n                return pointerMeta;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function getValidTargetItems(path, name) {\r\n            var pointerMeta = getPointerMeta(path, name);\r\n            if (pointerMeta) {\r\n                return pointerMeta.items;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function updateValidTargetItem(path, name, targetObj) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta && targetObj && targetObj.id) {\r\n                var pointer = rawMeta.pointers[name] || null;\r\n                if (pointer === null) {\r\n                    rawMeta.pointers[name] = {items: [], minItems: [], maxItems: []};\r\n                    pointer = rawMeta.pointers[name];\r\n                }\r\n                var refObj = pathToRefObject(targetObj.id);\r\n                var index = indexOfPathInRefObjArray(pointer.items, targetObj.id);\r\n                if (index === -1) {\r\n                    index = pointer.items.length;\r\n                    pointer.items.push(refObj);\r\n                    pointer.minItems.push(-1);\r\n                    pointer.maxItems.push(-1);\r\n                }\r\n                // jshint expr:true\r\n                (targetObj.min === null || targetObj.min === undefined) ?\r\n                    pointer.minItems[index] = -1 : pointer.minItems[index] = targetObj.min;\r\n\r\n                (targetObj.max === null || targetObj.max === undefined) ?\r\n                    pointer.maxItems[index] = -1 : pointer.maxItems[index] = targetObj.max;\r\n                // jshint expr:false\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function removeValidTargetItem(path, name, targetId) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                var pointer = rawMeta.pointers[name] || null;\r\n                if (pointer !== null) {\r\n                    //var refObj = pathToRefObject(targetId);\r\n                    var index = indexOfPathInRefObjArray(pointer.items, targetId);\r\n                    if (index !== -1) {\r\n                        pointer.items.splice(index, 1);\r\n                        if (pointer.minItems) {\r\n                            pointer.minItems.splice(index, 1);\r\n                        }\r\n                        if (pointer.maxItems) {\r\n                            pointer.maxItems.splice(index, 1);\r\n                        }\r\n                        setMeta(path, rawMeta);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function deleteMetaPointer(path, name) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                delete rawMeta.pointers[name];\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function setPointerMeta(path, name, meta) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                var pointer = rawMeta.pointers[name] || null;\r\n                if (pointer === null) {\r\n                    rawMeta.pointers[name] = {items: [], minItems: [], maxItems: []};\r\n                    pointer = rawMeta.pointers[name];\r\n                }\r\n                pointer.min = meta.min;\r\n                pointer.max = meta.max;\r\n                if (meta.items && meta.items.length) {\r\n                    for (var i = 0; i < meta.items.length; i++) {\r\n                        pointer.items.push(pathToRefObject(meta.items[i].id));\r\n                        pointer.minItems.push(meta.items[i].min || -1);\r\n                        pointer.maxItems.push(meta.items[i].max || -1);\r\n                    }\r\n                }\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function setChildrenMeta(path, name, meta) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                var children = rawMeta.children;\r\n\r\n                children.min = meta.min;\r\n                children.max = meta.max;\r\n                if (meta.items && meta.items.length) {\r\n                    for (var i = 0; i < meta.items.length; i++) {\r\n                        children.items.push(pathToRefObject(meta.items[i].id));\r\n                        children.minItems.push(meta.items[i].min || -1);\r\n                        children.maxItems.push(meta.items[i].max || -1);\r\n                    }\r\n                }\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function getMetaAspectNames(path) {\r\n            var rawMeta = getMeta(path),\r\n                names = [];\r\n\r\n            if (rawMeta && rawMeta.aspects) {\r\n                for (var i in rawMeta.aspects) {\r\n                    names.push(i);\r\n                }\r\n            }\r\n            return names;\r\n        }\r\n\r\n        function getOwnMetaAspectNames(path) {\r\n            var names = getMetaAspectNames(path),\r\n                ownNames = [];\r\n            if (_nodes[path]) {\r\n                var baseNames = getMetaAspectNames(_core.getPath(_core.getBase(_nodes[path])));\r\n                for (var i = 0; i < names.length; i++) {\r\n                    if (baseNames.indexOf(names[i]) === -1) {\r\n                        ownNames.push(names[i]);\r\n                    }\r\n                }\r\n            }\r\n            return ownNames;\r\n        }\r\n\r\n        function getMetaAspect(path, name) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                if (rawMeta.aspects[name]) {\r\n                    var aspect = {items: []};\r\n                    for (var i = 0; i < rawMeta.aspects[name].items.length; i++) {\r\n                        aspect.items.push(refObjectToPath(rawMeta.aspects[name].items[i]));\r\n                    }\r\n                    if (aspect.items.length === 0) {\r\n                        delete aspect.items;\r\n                    }\r\n                    return aspect;\r\n                }\r\n                return null;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function setMetaAspect(path, name, aspect) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n\r\n                rawMeta.aspects = rawMeta.aspects || {};\r\n                rawMeta.aspects[name] = {items: []};\r\n                for (var i = 0; i < aspect.items.length; i++) {\r\n                    rawMeta.aspects[name].items.push(pathToRefObject(aspect.items[i]));\r\n                }\r\n                setMeta(path, rawMeta);\r\n            }\r\n        }\r\n\r\n        function getAspectTerritoryPattern(path, name) {\r\n            var aspect = getMetaAspect(path, name);\r\n            if (aspect !== null) {\r\n                aspect.children = 1; //TODO now it is fixed, maybe we can change that in the future\r\n                return aspect;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        function deleteMetaAspect(path, name) {\r\n            var rawMeta = getMeta(path);\r\n            if (rawMeta) {\r\n                if (rawMeta.aspects && rawMeta.aspects[name]) {\r\n                    delete rawMeta.aspects[name];\r\n                    setMeta(path, rawMeta);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            refObjectToPath: refObjectToPath,\r\n            pathToRefObject: pathToRefObject,\r\n\r\n\r\n            initialize: initialize,\r\n            getMeta: getMeta,\r\n            setMeta: setMeta,\r\n            isTypeOf: isTypeOf,\r\n            hasOwnMetaRules: hasOwnMetaRules,\r\n\r\n            //containment\r\n            isValidChild: isValidChild,\r\n            getChildrenMeta: getChildrenMeta,\r\n            setChildrenMeta: setChildrenMeta,\r\n            getChildrenMetaAttribute: getChildrenMetaAttribute,\r\n            setChildrenMetaAttribute: setChildrenMetaAttribute,\r\n            getValidChildrenTypes: getValidChildrenTypes,\r\n            getOwnValidChildrenTypes: getOwnValidChildrenTypes,\r\n            getValidChildrenItems: getValidChildrenItems,\r\n            updateValidChildrenItem: updateValidChildrenItem,\r\n            removeValidChildrenItem: removeValidChildrenItem,\r\n\r\n            //attribute\r\n            isValidAttribute: isValidAttribute,\r\n            getAttributeSchema: getAttributeSchema,\r\n            setAttributeSchema: setAttributeSchema,\r\n            removeAttributeSchema: removeAttributeSchema,\r\n            getValidAttributeNames: getValidAttributeNames,\r\n            getOwnValidAttributeNames: getOwnValidAttributeNames,\r\n\r\n            //pointer\r\n            isValidTarget: isValidTarget,\r\n            getPointerMeta: getPointerMeta,\r\n            setPointerMeta: setPointerMeta,\r\n            getValidTargetItems: getValidTargetItems,\r\n            getValidTargetTypes: getValidTargetTypes,\r\n            getOwnValidTargetTypes: getOwnValidTargetTypes,\r\n            filterValidTarget: filterValidTarget,\r\n            updateValidTargetItem: updateValidTargetItem,\r\n            removeValidTargetItem: removeValidTargetItem,\r\n            deleteMetaPointer: deleteMetaPointer,\r\n\r\n            //aspect\r\n            getMetaAspectNames: getMetaAspectNames,\r\n            getOwnMetaAspectNames: getOwnMetaAspectNames,\r\n            getMetaAspect: getMetaAspect,\r\n            setMetaAspect: setMetaAspect,\r\n            getAspectTerritoryPattern: getAspectTerritoryPattern,\r\n            deleteMetaAspect: deleteMetaAspect\r\n\r\n        };\r\n    }\r\n\r\n    return metaStorage;\r\n});\r\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/tojson',['common/core/users/meta', 'common/util/url'], function (BaseMeta, URL) {\n    'use strict';\n\n    var META = new BaseMeta(),\n        _refTypes = {\n            url: 'url',\n            path: 'path',\n            guid: 'guid'\n        };\n\n    var changeRefObjects = function (refType, urlPrefix, object, core, root, callback) {\n        var i;\n        if (typeof object === 'object') {\n            var needed = 0,\n                neededNames = [],\n                error = null;\n            for (i in object) { // TODO: use key here instead\n                if (object[i] !== null && typeof object[i] === 'object') {\n                    needed++;\n                    neededNames.push(i);\n                }\n            }\n            if (needed > 0) {\n                for (i = 0; i < neededNames.length; i++) {\n                    if (object[neededNames[i]].$ref) {\n                        //reference object\n                        pathToRefObjAsync(refType, urlPrefix, object[neededNames[i]].$ref/*.substring(1)*/,\n                            core, root,\n                            function (err, refObj) {\n                                error = error || err;\n                                object[neededNames[i]] = refObj;\n                                if (--needed === 0) {\n                                    callback(error);\n                                }\n                            }\n                        );\n                    } else {\n                        changeRefObjects(refType, urlPrefix, object[neededNames[i]], core, root, function (err) {\n                            error = error || err;\n                            if (--needed === 0) {\n                                callback(error);\n                            }\n                        });\n                    }\n                }\n            } else {\n                callback(null);\n            }\n        } else {\n            callback(null);\n        }\n    };\n\n    var pathToRefObj = function (refType, urlPrefix, path) {\n        var result;\n        switch (refType) {\n            case _refTypes.url:\n                if (path === null) {\n                    result = URL.urlToRefObject(null);\n                } else {\n                    result = URL.urlToRefObject(urlPrefix + '&path=' + URL.addSpecialChars(path));\n                }\n                break;\n            case _refTypes.path:\n                result = URL.urlToRefObject(path);\n                break;\n            default:\n                result = URL.urlToRefObject(null);\n                break;\n        }\n\n        return result;\n    };\n\n    var getParentRefObject = function (refType, urlPrefix, core, node) {\n        var parent = core.getParent(node),\n            path = null,\n            result;\n\n        if (parent) {\n            path = core.getPath(parent);\n        }\n        switch (refType) {\n            case _refTypes.url:\n                if (path === null) {\n                    result = URL.urlToRefObject(null);\n                } else {\n                    result = URL.urlToRefObject(urlPrefix + '&path=' + URL.addSpecialChars(path));\n                }\n                break;\n            case _refTypes.path:\n                result = URL.urlToRefObject(path);\n                break;\n            case _refTypes.guid:\n                if (path === null) {\n                    result = URL.urlToRefObject(null);\n                } else {\n                    var refObj = URL.urlToRefObject(path);\n                    refObj.GUID = core.getGuid(parent);\n                    result = refObj;\n                }\n                break;\n        }\n\n        return result;\n    };\n\n    var pathToRefObjAsync = function (refType, urlPrefix, path, core, root, callback) {\n        switch (refType) {\n            case _refTypes.url:\n                if (path === null) {\n                    callback(null, URL.urlToRefObject(null));\n                }\n                callback(null, URL.urlToRefObject(urlPrefix + '&path=' + URL.addSpecialChars(path)));\n                break;\n            case _refTypes.path:\n                callback(null, URL.urlToRefObject(path));\n                break;\n            case _refTypes.guid:\n                core.loadByPath(root, path, function (err, node) {\n                    if (err) {\n                        callback(err, null);\n                    } else {\n                        var refObj = URL.urlToRefObject(path);\n                        refObj.GUID = core.getGuid(node);\n                        callback(null, refObj);\n                    }\n                });\n                break;\n            default:\n                callback(null, URL.urlToRefObject(null));\n        }\n    };\n\n    var getChildrenGuids = function (core, node, callback) {\n        var GUIDHash = {};\n        core.loadChildren(node, function (err, children) {\n            if (err) {\n                callback(err, null);\n            } else {\n                for (var i = 0; i < children.length; i++) {\n                    GUIDHash[core.getPath(children[i])] = core.getGuid(children[i]);\n                }\n                callback(null, GUIDHash);\n            }\n        });\n    };\n\n    var getMetaOfNode = function (core, node, urlPrefix, refType, callback) {\n        var meta = META.getMeta(core.getPath(node));\n        changeRefObjects(refType, urlPrefix, meta, core, core.getRoot(node), function (err) {\n            callback(err, meta);\n        });\n    };\n\n    var getChildrenOfNode = function (core, node, urlPrefix, refType, callback) {\n        if (refType === _refTypes.guid) {\n            getChildrenGuids(core, node, function (err, gHash) {\n                if (err) {\n                    callback(err);\n                } else {\n                    //TODO possibly it needs some ordering\n                    var children = [];\n                    for (var i in gHash) {\n                        var refObj = URL.urlToRefObject(i);\n                        refObj.GUID = gHash[i];\n                        children.push(refObj);\n                    }\n                    callback(null, children);\n                }\n            });\n        } else {\n            var paths = core.getChildrenPaths(node);\n            var children = [];\n            for (var i = 0; i < paths.length; i++) {\n                children.push(pathToRefObj(refType, urlPrefix, paths[i]));\n            }\n            callback(null, children);\n        }\n    };\n\n    var getSetAttributesAndRegistry = function (core, node, setName, setOwnerPath, callback) {\n        var path = core.getPath(node),\n            i;\n        core.loadByPath(core.getRoot(node), setOwnerPath, function (err, owner) {\n            if (err) {\n                callback(err);\n            } else {\n                if (owner) {\n                    var atrAndReg = {attributes: {}, registry: {}};\n                    var names = core.getMemberAttributeNames(owner, setName, path);\n                    for (i = 0; i < names.length; i++) {\n                        atrAndReg.attributes[names[i]] = core.getMemberAttribute(owner, setName, path, names[i]);\n                    }\n                    names = core.getMemberRegistryNames(owner, setName, path);\n                    for (i = 0; i < names.length; i++) {\n                        atrAndReg.registry[names[i]] = core.getMemberRegistry(owner, setName, path, names[i]);\n                    }\n                    callback(null, atrAndReg);\n                } else {\n                    callback('internal error', null);\n                }\n            }\n        });\n    };\n\n    var getMemberAttributesAndRegistry = function (core, node, setName, memberPath) {\n        var retObj = {attributes: {}, registry: {}},\n            names,\n            i;\n        names = core.getMemberAttributeNames(node, setName, memberPath);\n        for (i = 0; i < names.length; i++) {\n            retObj.attributes[names[i]] = core.getMemberAttribute(node, setName, memberPath, names[i]);\n        }\n        names = core.getMemberRegistryNames(node, setName, memberPath);\n        for (i = 0; i < names.length; i++) {\n            retObj.registry[names[i]] = core.getMemberRegistry(node, setName, memberPath, names[i]);\n        }\n        return retObj;\n    };\n\n    var getSetsOfNode = function (core, node, urlPrefix, refType, callback) {\n        var setsInfo = {};\n        var createOneSetInfo = function (setName, callback) {\n            var needed,\n                members = (core.getMemberPaths(node, setName)).sort(), //TODO Remove the sort part at some point\n                info = {from: [], to: [], set: true},\n                i,\n                error = null,\n                containers = [],\n                collectSetInfo = function (nodePath, container, callback) {\n                    if (container === true) {\n                        pathToRefObjAsync(refType, urlPrefix, nodePath, core, core.getRoot(node),\n                            function (err, refObj) {\n                                if (!err && refObj !== undefined && refObj !== null) {\n                                    getSetAttributesAndRegistry(core, node, setName, nodePath,\n                                        function (err, atrAndReg) {\n                                            if (atrAndReg) {\n                                                for (var j in atrAndReg) {\n                                                    refObj[j] = atrAndReg[j];\n                                                }\n                                            }\n                                            callback(err, refObj);\n                                        }\n                                    );\n                                } else {\n                                    callback(err, null);\n                                }\n                            }\n                        );\n                    } else {\n                        //member\n                        pathToRefObjAsync(refType, urlPrefix, nodePath, core, core.getRoot(node),\n                            function (err, refObj) {\n                                if (refObj !== undefined && refObj !== null) {\n                                    var atrAndReg = getMemberAttributesAndRegistry(core, node, setName, nodePath);\n                                    for (var j in atrAndReg) {\n                                        refObj[j] = atrAndReg[j];\n                                    }\n                                    callback(err, refObj);\n                                }\n                            }\n                        );\n                    }\n                };\n\n            for (i in memberOfInfo) {\n                if (memberOfInfo[i].indexOf(setName) !== -1) {\n                    containers.push(i);\n                }\n            }\n\n            needed = members.length + containers.length;\n            if (needed > 0) {\n                for (i = 0; i < members.length; i++) {\n                    collectSetInfo(members[i], false, function (err, refObj) {\n                        error = error || err;\n                        if (refObj !== undefined && refObj !== null) {\n                            info.to.push(refObj);\n                        }\n\n                        if (--needed === 0) {\n                            if (error === null) {\n                                setsInfo[setName] = info;\n                            }\n                            callback(error);\n                        }\n                    });\n                }\n\n                for (i = 0; i < containers.length; i++) {\n                    collectSetInfo(containers[i], true, function (err, refObj) {\n                        error = error || err;\n                        if (refObj !== undefined && refObj !== null) {\n                            info.from.push(refObj);\n                        }\n\n                        if (--needed === 0) {\n                            if (error === null) {\n                                setsInfo[setName] = info;\n                            }\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback(null);\n            }\n        };\n\n        var tArray = core.getSetNames(node),\n            memberOfInfo = core.isMemberOf(node),\n            i, j, needed, error = null;\n        for (j in memberOfInfo) {\n            for (i = 0; i < memberOfInfo[j].length; i++) {\n                if (tArray.indexOf(memberOfInfo[j][i]) === -1) {\n                    tArray.push(memberOfInfo[j][i]);\n                }\n            }\n        }\n        needed = tArray.length;\n        if (needed > 0) {\n            for (i = 0; i < tArray.length; i++) {\n                createOneSetInfo(tArray[i], function (err) {\n                    error = error || err;\n                    if (--needed === 0) {\n                        callback(error, setsInfo);\n                    }\n                });\n            }\n        } else {\n            callback(null, setsInfo);\n        }\n    };\n\n    var getPointersGUIDs = function (core, node, callback) {\n        var gHash = {},\n            pointerNames = core.getPointerNames(node),\n            collectionNames = core.getCollectionNames(node),\n            needed = pointerNames.length + collectionNames.length,\n            error = null,\n            i;\n        if (needed > 0) {\n            //pointers\n            for (i = 0; i < pointerNames.length; i++) {\n                core.loadPointer(node, pointerNames[i], function (err, pointer) {\n                    error = error || err;\n                    if (pointer) {\n                        if (gHash[core.getPath(pointer)] === undefined) {\n                            gHash[core.getPath(pointer)] = core.getGuid(pointer);\n                        }\n                    }\n\n                    if (--needed === 0) {\n                        callback(error, gHash);\n                    }\n                });\n            }\n            //collections\n            for (i = 0; i < collectionNames.length; i++) {\n                core.loadCollection(node, collectionNames[i], function (err, collection) {\n                    error = error || err;\n                    if (collection) {\n                        for (var j = 0; j < collection.length; j++) {\n                            if (gHash[core.getPath(collection[j])] === undefined) {\n                                gHash[core.getPath(collection[j])] = core.getGuid(collection[j]);\n                            }\n                        }\n                    }\n\n                    if (--needed === 0) {\n                        callback(error, gHash);\n                    }\n                });\n            }\n        } else {\n            callback(error, gHash);\n        }\n    };\n\n    var getPointersOfNode = function (core, node, urlPrefix, refType, callback) {\n        var GUIDHash = {};\n        var getRefObj = function (path) {\n            if (refType === _refTypes.guid) {\n                var refObj = URL.urlToRefObject(path);\n                refObj.GUID = GUIDHash[path];\n                return refObj;\n            } else {\n                return pathToRefObj(refType, urlPrefix, path);\n            }\n        };\n        var initialized = function () {\n            var pointers = {},\n                tArray = core.getPointerNames(node),\n                t2Array = core.getCollectionNames(node),\n                i, j;\n            for (i = 0; i < t2Array.length; i++) {\n                if (tArray.indexOf(t2Array[i]) === -1) {\n                    tArray.push(t2Array[i]);\n                }\n            }\n            for (i = 0; i < tArray.length; i++) {\n                var coll = core.getCollectionPaths(node, tArray[i]);\n                var pointer = {to: [], from: [], set: false},\n                    pPath = core.getPointerPath(node, tArray[i]);\n                if (pPath !== undefined) {\n                    pointer.to.push(getRefObj(pPath));\n                }\n                for (j = 0; j < coll.length; j++) {\n                    pointer.from.push(getRefObj(coll[j]));\n                }\n                pointers[tArray[i]] = pointer;\n            }\n            callback(null, pointers);\n        };\n\n        //start\n        if (refType === _refTypes.guid) {\n            getPointersGUIDs(core, node, function (err, gHash) {\n                if (err) {\n                    callback(err, null);\n                } else {\n                    GUIDHash = gHash;\n                    initialized();\n                }\n            });\n        } else {\n            initialized();\n        }\n    };\n\n    var getOwnPartOfNode = function (core, node) {\n        var own = {attributes: [], registry: [], pointers: []};\n        own.attributes = core.getOwnAttributeNames(node);\n        own.registry = core.getOwnRegistryNames(node);\n        own.pointers = core.getOwnPointerNames(node);\n        return own;\n    };\n\n    var getJsonNode = function (core, node, urlPrefix, refType, callback) {\n        var nodes = {},\n            tArray,\n            i,\n            jNode;\n\n        if (refType === _refTypes.guid && typeof core.getGuid !== 'function') {\n            callback(new Error('cannot provide GUIDs'), null);\n        }\n\n        nodes[core.getPath(node)] = node;\n        META.initialize(core, nodes, function () {\n            //TODO: is this asynchronous?\n        });\n\n        jNode = {\n            meta: {},\n            children: [],\n            attributes: {},\n            pointers: {},\n            registry: {}\n        };\n\n\n        //basic parts of the node\n        //GUID\n        if (typeof core.getGuid === 'function') {\n            jNode.GUID = core.getGuid(node);\n        }\n        //RELID\n        jNode.RELID = core.getRelid(node);\n        //registry entries\n        tArray = core.getRegistryNames(node);\n        for (i = 0; i < tArray.length; i++) {\n            jNode.registry[tArray[i]] = core.getRegistry(node, tArray[i]);\n        }\n        //attribute entries\n        tArray = core.getAttributeNames(node);\n        for (i = 0; i < tArray.length; i++) {\n            jNode.attributes[tArray[i]] = core.getAttribute(node, tArray[i]);\n        }\n\n        //own part of the node\n        jNode.OWN = getOwnPartOfNode(core, node);\n\n        //reference to parent\n        jNode.parent = getParentRefObject(refType, urlPrefix, core, node);\n\n\n        //now calling the relational parts\n        var needed = 4,\n            error = null;\n        getChildrenOfNode(core, node, urlPrefix, refType, function (err, children) {\n            error = error || err;\n            jNode.children = children;\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n        getMetaOfNode(core, node, urlPrefix, refType, function (err, meta) {\n            error = error || err;\n            jNode.meta = meta;\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n        getPointersOfNode(core, node, urlPrefix, refType, function (err, pointers) {\n            error = error || err;\n            for (var i in pointers) {\n                jNode.pointers[i] = pointers[i];\n            }\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n        getSetsOfNode(core, node, urlPrefix, refType, function (err, sets) {\n            error = error || err;\n            for (var i in sets) {\n                jNode.pointers[i] = sets[i];\n            }\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n    };\n\n    return getJsonNode;\n});\n\n",
    "!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define('lib/superagent/superagent-1.1.0',[],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.superagent=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root = 'undefined' == typeof window\n  ? this\n  : window;\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n    && ('file:' != root.location.protocol || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status || 1223 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(err || new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"})\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n  err.crossDomain = true;\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = function(e){\n        e.percent = e.loaded / e.total * 100;\n        self.emit('progress', e);\n      };\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var serialize = request.serialize[this.getHeader('Content-Type')];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n  xhr.send(data);\n  return this;\n};\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.del = function(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n},{\"emitter\":2,\"reduce\":3}],2:[function(require,module,exports){\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n},{}],3:[function(require,module,exports){\n\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n},{}]},{},[1])(1)\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('client/js/client/undoredo',[], function () {\n    'use strict';\n    function UndoRedo(_client) {\n        var\n            currentModification = null,\n            canDoUndo = false,\n            canDoRedo = false,\n            currentTarget = null,\n            addModification = function (commitHash, info) {\n                var newElement = {\n                    previous: currentModification,\n                    commit: commitHash,\n                    info: info,\n                    next: null\n                };\n                if (currentModification) {\n                    currentModification.next = newElement;\n                }\n                currentModification = newElement;\n            },\n            undo = function (branch, callback) {\n                var from, to, project;\n                if (canDoUndo && currentModification && currentModification.previous) {\n                    project = _client.getProjectObject();\n                    from = currentModification.commit;\n                    to = currentModification.previous.commit;\n                    currentModification = currentModification.previous;\n                    currentTarget = to;\n                    project.setBranchHash(branch, from, to, callback);\n                } else {\n                    callback(new Error('unable to execute undo'));\n                }\n            },\n            redo = function (branch, callback) {\n                var from, to, project;\n                if (canDoRedo && currentModification && currentModification.next) {\n                    project = _client.getProjectObject();\n                    from = currentModification.commit;\n                    to = currentModification.next.commit;\n                    currentModification = currentModification.next;\n                    currentTarget = to;\n                    project.setBranchHash(branch, from, to, callback);\n                } else {\n                    callback(new Error('unable to execute redo'));\n                }\n            },\n            clean = function () {\n                currentModification = null;\n                canDoUndo = false;\n                canDoRedo = false;\n            },\n            checkStatus = function () {\n                return {\n                    undo: currentModification ? currentModification.previous !== null &&\n                    currentModification.previous !== undefined : false,\n                    redo: currentModification ? currentModification.next !== null &&\n                    currentModification.next !== undefined : false\n                };\n            },\n            isCurrentTarget = function (commitHash) {\n                if (currentTarget === commitHash) {\n                    currentTarget = null;\n                    return true;\n                }\n                return false;\n            };\n\n        _client.addEventListener(_client.events.UNDO_AVAILABLE, function (client, parameters) {\n            canDoUndo = parameters === true;\n        });\n        _client.addEventListener(_client.events.REDO_AVAILABLE, function (client, parameters) {\n            canDoRedo = parameters === true;\n        });\n        return {\n            undo: undo,\n            redo: redo,\n            addModification: addModification,\n            clean: clean,\n            checkStatus: checkStatus,\n            isCurrentTarget: isCurrentTarget\n        };\n\n    }\n\n    return UndoRedo;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('client/js/client/gmeNodeGetter',['common/core/users/tojson'], function (toJson) {\n    'use strict';\n\n    //getNode\n    function getNode(_id, _clientGlobal) {\n\n\n        function getParentId() {\n            //just for sure, as it may missing from the cache\n            return _clientGlobal.functions.storeNode(_clientGlobal.core.getParent(_clientGlobal.nodes[_id].node));\n        }\n\n        function getId() {\n            return _id;\n        }\n\n        function getGuid() {\n            return _clientGlobal.core.getGuid(_clientGlobal.nodes[_id].node);\n        }\n\n        function getChildrenIds() {\n            return _clientGlobal.core.getChildrenPaths(_clientGlobal.nodes[_id].node);\n        }\n\n        function getBaseId() {\n            var base = _clientGlobal.core.getBase(_clientGlobal.nodes[_id].node);\n            if (base) {\n                return _clientGlobal.functions.storeNode(base);\n            } else {\n                return null;\n            }\n\n        }\n\n        function getInheritorIds() {\n            return [];\n        }\n\n        function getAttribute(name) {\n            return _clientGlobal.core.getAttribute(_clientGlobal.nodes[_id].node, name);\n        }\n\n        function getOwnAttribute(name) {\n            return _clientGlobal.core.getOwnAttribute(_clientGlobal.nodes[_id].node, name);\n        }\n\n        function getEditableAttribute(name) {\n            var value = _clientGlobal.core.getAttribute(_clientGlobal.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getOwnEditableAttribute(name) {\n            var value = _clientGlobal.core.getOwnAttribute(_clientGlobal.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getRegistry(name) {\n            return _clientGlobal.core.getRegistry(_clientGlobal.nodes[_id].node, name);\n        }\n\n        function getOwnRegistry(name) {\n            return _clientGlobal.core.getOwnRegistry(_clientGlobal.nodes[_id].node, name);\n        }\n\n        function getEditableRegistry(name) {\n            var value = _clientGlobal.core.getRegistry(_clientGlobal.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getOwnEditableRegistry(name) {\n            var value = _clientGlobal.core.getOwnRegistry(_clientGlobal.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getPointer(name) {\n            //return _core.getPointerPath(_nodes[_id].node,name);\n            if (name === 'base') {\n                //base is a special case as it complicates with inherited children\n                return {to: _clientGlobal.core.getPath(_clientGlobal.core.getBase(_clientGlobal.nodes[_id].node)),\n                    from: []};\n            }\n            return {to: _clientGlobal.core.getPointerPath(_clientGlobal.nodes[_id].node, name), from: []};\n        }\n\n        function getOwnPointer(name) {\n            return {to: _clientGlobal.core.getOwnPointerPath(_clientGlobal.nodes[_id].node, name), from: []};\n        }\n\n        function getPointerNames() {\n            return _clientGlobal.core.getPointerNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getOwnPointerNames() {\n            return _clientGlobal.core.getOwnPointerNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getAttributeNames() {\n            return _clientGlobal.core.getAttributeNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getOwnAttributeNames() {\n            return _clientGlobal.core.getOwnAttributeNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getRegistryNames() {\n            return _clientGlobal.core.getRegistryNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getOwnRegistryNames() {\n            return _clientGlobal.core.getOwnRegistryNames(_clientGlobal.nodes[_id].node);\n        }\n\n        //SET\n        function getMemberIds(setid) {\n            return _clientGlobal.core.getMemberPaths(_clientGlobal.nodes[_id].node, setid);\n        }\n\n        function getSetNames() {\n            return _clientGlobal.core.getSetNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getMemberAttributeNames(setid, memberid) {\n            return _clientGlobal.core.getMemberAttributeNames(_clientGlobal.nodes[_id].node, setid, memberid);\n        }\n\n        function getMemberAttribute(setid, memberid, name) {\n            return _clientGlobal.core.getMemberAttribute(_clientGlobal.nodes[_id].node, setid, memberid, name);\n        }\n\n        function getEditableMemberAttribute(setid, memberid, name) {\n            var attr = _clientGlobal.core.getMemberAttribute(_clientGlobal.nodes[_id].node, setid, memberid, name);\n            if (attr !== null && attr !== undefined) {\n                return JSON.parse(JSON.stringify(attr));\n            }\n            return null;\n        }\n\n        function getMemberRegistryNames(setid, memberid) {\n            return _clientGlobal.core.getMemberRegistryNames(_clientGlobal.nodes[_id].node, setid, memberid);\n        }\n\n        function getMemberRegistry(setid, memberid, name) {\n            return _clientGlobal.core.getMemberRegistry(_clientGlobal.nodes[_id].node, setid, memberid, name);\n        }\n\n        function getEditableMemberRegistry(setid, memberid, name) {\n            var attr = _clientGlobal.core.getMemberRegistry(_clientGlobal.nodes[_id].node, setid, memberid, name);\n            if (attr !== null && attr !== undefined) {\n                return JSON.parse(JSON.stringify(attr));\n            }\n            return null;\n        }\n\n        //META\n        function getValidChildrenTypes() {\n            //return getMemberIds('ValidChildren');\n            return _clientGlobal.META.getValidChildrenTypes(_id);\n        }\n\n        //constraint functions\n        function getConstraintNames() {\n            return _clientGlobal.core.getConstraintNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getOwnConstraintNames() {\n            return _clientGlobal.core.getOwnConstraintNames(_clientGlobal.nodes[_id].node);\n        }\n\n        function getConstraint(name) {\n            return _clientGlobal.core.getConstraint(_clientGlobal.nodes[_id].node, name);\n        }\n\n        function printData() {\n            //probably we will still use it for test purposes, but now it goes officially\n            // into printing the node's json representation\n            toJson(_clientGlobal.core, _clientGlobal.nodes[_id].node, '', 'guid', function (err, jNode) {\n                _clientGlobal.logger.debug('node in JSON format[status = ', err, ']:', jNode);\n            });\n        }\n\n        function toString() {\n            return _clientGlobal.core.getAttribute(_clientGlobal.nodes[_id].node, 'name') + ' (' + _id + ')';\n        }\n\n        function getCollectionPaths(name) {\n            return _clientGlobal.core.getCollectionPaths(_clientGlobal.nodes[_id].node, name);\n        }\n\n        if (_clientGlobal.nodes[_id]) {\n            return {\n                getParentId: getParentId,\n                getId: getId,\n                getGuid: getGuid,\n                getChildrenIds: getChildrenIds,\n                getBaseId: getBaseId,\n                getInheritorIds: getInheritorIds,\n                getAttribute: getAttribute,\n                getEditableAttribute: getEditableAttribute,\n                getRegistry: getRegistry,\n                getEditableRegistry: getEditableRegistry,\n                getOwnAttribute: getOwnAttribute,\n                getOwnEditableAttribute: getOwnEditableAttribute,\n                getOwnRegistry: getOwnRegistry,\n                getOwnEditableRegistry: getOwnEditableRegistry,\n                getPointer: getPointer,\n                getPointerNames: getPointerNames,\n                getAttributeNames: getAttributeNames,\n                getRegistryNames: getRegistryNames,\n                getOwnAttributeNames: getOwnAttributeNames,\n                getOwnRegistryNames: getOwnRegistryNames,\n                getOwnPointer: getOwnPointer,\n                getOwnPointerNames: getOwnPointerNames,\n\n                //SetFunctions\n                getMemberIds: getMemberIds,\n                getSetNames: getSetNames,\n                getMemberAttributeNames: getMemberAttributeNames,\n                getMemberAttribute: getMemberAttribute,\n                getEditableMemberAttribute: getEditableMemberAttribute,\n                getMemberRegistryNames: getMemberRegistryNames,\n                getMemberRegistry: getMemberRegistry,\n                getEditableMemberRegistry: getEditableMemberRegistry,\n\n                //META functions\n                getValidChildrenTypes: getValidChildrenTypes,\n\n                //constraint functions\n                getConstraintNames: getConstraintNames,\n                getOwnConstraintNames: getOwnConstraintNames,\n                getConstraint: getConstraint,\n\n                printData: printData,\n                toString: toString,\n\n                getCollectionPaths: getCollectionPaths\n\n            };\n        }\n\n        return null;\n\n    }\n\n    return getNode;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('client/js/client/gmeNodeSetter',[], function () {\n    'use strict';\n    function gmeNodeSetter(_clientGlobal) {\n\n        function setAttributes(path, name, value, msg) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.setAttribute(_clientGlobal.nodes[path].node, name, value);\n                msg = msg || 'setAttribute(' + path + ',' + name + ',' + value + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function delAttributes(path, name, msg) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.delAttribute(_clientGlobal.nodes[path].node, name);\n                msg = msg || 'delAttribute(' + path + ',' + name + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function setRegistry(path, name, value, msg) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.setRegistry(_clientGlobal.nodes[path].node, name, value);\n                msg = msg || 'setRegistry(' + path + ',' + ',' + name + ',' + value + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function delRegistry(path, name, msg) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.delRegistry(_clientGlobal.nodes[path].node, name);\n                msg = msg || 'delRegistry(' + path + ',' + ',' + name + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function copyMoreNodes(parameters, msg) {\n            var pathestocopy = [],\n                i,\n                j,\n                newNode;\n\n            if (typeof parameters.parentId === 'string' && _clientGlobal.nodes[parameters.parentId] &&\n                typeof _clientGlobal.nodes[parameters.parentId].node === 'object') {\n                for (i in parameters) {\n                    if (i !== 'parentId') {\n                        pathestocopy.push(i);\n                    }\n                }\n\n                msg = msg || 'copyMoreNodes(' + pathestocopy + ',' + parameters.parentId + ')';\n                if (pathestocopy.length < 1) {\n                    // empty on purpose\n                } else if (pathestocopy.length === 1) {\n                    newNode = _clientGlobal.core.copyNode(_clientGlobal.nodes[pathestocopy[0]].node,\n                        _clientGlobal.nodes[parameters.parentId].node);\n                    _clientGlobal.functions.storeNode(newNode);\n                    if (parameters[pathestocopy[0]]) {\n                        for (j in parameters[pathestocopy[0]].attributes) {\n                            if (parameters[pathestocopy[0]].attributes.hasOwnProperty(j)) {\n                                _clientGlobal.core.setAttribute(newNode, j, parameters[pathestocopy[0]].attributes[j]);\n                            }\n                        }\n                        for (j in parameters[pathestocopy[0]].registry) {\n                            if (parameters[pathestocopy[0]].registry.hasOwnProperty(j)) {\n                                _clientGlobal.core.setRegistry(newNode, j, parameters[pathestocopy[0]].registry[j]);\n                            }\n                        }\n                    }\n                    _clientGlobal.functions.saveRoot(msg);\n                } else {\n                    copyMoreNodesAsync(pathestocopy, parameters.parentId, function (err, copyarr) {\n                        var i,\n                            j;\n                        if (err) {\n                            //rollBackModification();\n                            _clientGlobal.logger.error(err);\n                        } else {\n                            for (i in copyarr) {\n                                if (copyarr.hasOwnProperty(i) && parameters[i]) {\n                                    for (j in parameters[i].attributes) {\n                                        if (parameters[i].attributes.hasOwnProperty(j)) {\n                                            _clientGlobal.core.setAttribute(copyarr[i], j, parameters[i].attributes[j]);\n                                        }\n                                    }\n                                    for (j in parameters[i].registry) {\n                                        if (parameters[i].registry.hasOwnProperty(j)) {\n                                            _clientGlobal.core.setRegistry(copyarr[i], j, parameters[i].registry[j]);\n                                        }\n                                    }\n                                }\n                            }\n                            _clientGlobal.functions.saveRoot(msg);\n                        }\n                    });\n                }\n            } else {\n                _clientGlobal.logger.error('wrong parameters for copy operation - denied -');\n            }\n        }\n\n        function copyMoreNodesAsync(nodePaths, parentPath, callback) {\n            var i,\n                tempFrom,\n                tempTo,\n                helpArray,\n                subPathArray,\n                parent,\n                returnArray,\n                checkPaths = function () {\n                    var i,\n                        result = true;\n\n                    for (i = 0; i < nodePaths.length; i += 1) {\n                        result = result && (_clientGlobal.nodes[nodePaths[i]] &&\n                            typeof _clientGlobal.nodes[nodePaths[i]].node === 'object');\n                    }\n                    return result;\n                };\n\n            if (_clientGlobal.nodes[parentPath] &&\n                typeof _clientGlobal.nodes[parentPath].node === 'object' && checkPaths()) {\n                helpArray = {};\n                subPathArray = {};\n                parent = _clientGlobal.nodes[parentPath].node;\n                returnArray = {};\n\n                //creating the 'from' object\n                tempFrom = _clientGlobal.core.createNode({\n                    parent: parent,\n                    base: _clientGlobal.core.getTypeRoot(_clientGlobal.nodes[nodePaths[0]].node)\n                });\n                //and moving every node under it\n                for (i = 0; i < nodePaths.length; i += 1) {\n                    helpArray[nodePaths[i]] = {};\n                    helpArray[nodePaths[i]].origparent =\n                        _clientGlobal.core.getParent(_clientGlobal.nodes[nodePaths[i]].node);\n                    helpArray[nodePaths[i]].tempnode =\n                        _clientGlobal.core.moveNode(_clientGlobal.nodes[nodePaths[i]].node, tempFrom);\n                    subPathArray[_clientGlobal.core.getRelid(helpArray[nodePaths[i]].tempnode)] = nodePaths[i];\n                    delete _clientGlobal.nodes[nodePaths[i]];\n                }\n\n                //do the copy\n                tempTo = _clientGlobal.core.copyNode(tempFrom, parent);\n\n                //moving back the temporary source\n                for (i = 0; i < nodePaths.length; i += 1) {\n                    helpArray[nodePaths[i]].node = _clientGlobal.core.moveNode(helpArray[nodePaths[i]].tempnode,\n                        helpArray[nodePaths[i]].origparent);\n                    _clientGlobal.functions.storeNode(helpArray[nodePaths[i]].node);\n                }\n\n                //gathering the destination nodes\n                _clientGlobal.core.loadChildren(tempTo, function (err, children) {\n                    var newNode;\n\n                    if (!err && children && children.length > 0) {\n                        for (i = 0; i < children.length; i += 1) {\n                            if (subPathArray[_clientGlobal.core.getRelid(children[i])]) {\n                                newNode = _clientGlobal.core.moveNode(children[i], parent);\n                                _clientGlobal.functions.storeNode(newNode);\n                                returnArray[subPathArray[_clientGlobal.core.getRelid(children[i])]] = newNode;\n                            } else {\n                                _clientGlobal.logger.error('635 - should never happen!!!');\n                            }\n                        }\n                        _clientGlobal.core.deleteNode(tempFrom);\n                        _clientGlobal.core.deleteNode(tempTo);\n                        callback(null, returnArray);\n                    } else {\n                        //clean up the mess and return\n                        _clientGlobal.core.deleteNode(tempFrom);\n                        _clientGlobal.core.deleteNode(tempTo);\n                        callback(err, {});\n                    }\n                });\n            }\n        }\n\n        function moveMoreNodes(parameters) {\n            var pathsToMove = [],\n                returnParams = {},\n                i,\n                j,\n                newNode;\n\n            for (i in parameters) {\n                if (parameters.hasOwnProperty(i)) {\n                    if (i !== 'parentId') {\n                        pathsToMove.push(i);\n                    }\n                }\n            }\n\n            if (pathsToMove.length > 0 &&\n                typeof parameters.parentId === 'string' &&\n                _clientGlobal.nodes[parameters.parentId] &&\n                typeof _clientGlobal.nodes[parameters.parentId].node === 'object') {\n                for (i = 0; i < pathsToMove.length; i += 1) {\n                    if (_clientGlobal.nodes[pathsToMove[i]] &&\n                        typeof _clientGlobal.nodes[pathsToMove[i]].node === 'object') {\n                        newNode = _clientGlobal.core.moveNode(_clientGlobal.nodes[pathsToMove[i]].node,\n                            _clientGlobal.nodes[parameters.parentId].node);\n                        returnParams[pathsToMove[i]] = _clientGlobal.core.getPath(newNode);\n                        if (parameters[pathsToMove[i]].attributes) {\n                            for (j in parameters[pathsToMove[i]].attributes) {\n                                if (parameters[pathsToMove[i]].attributes.hasOwnProperty(j)) {\n                                    _clientGlobal.core.setAttribute(newNode,\n                                        j, parameters[pathsToMove[i]].attributes[j]);\n                                }\n                            }\n                        }\n                        if (parameters[pathsToMove[i]].registry) {\n                            for (j in parameters[pathsToMove[i]].registry) {\n                                if (parameters[pathsToMove[i]].registry.hasOwnProperty(j)) {\n                                    _clientGlobal.core.setRegistry(newNode,\n                                        j, parameters[pathsToMove[i]].registry[j]);\n                                }\n                            }\n                        }\n\n                        delete _clientGlobal.nodes[pathsToMove[i]];\n                        _clientGlobal.functions.storeNode(newNode, true);\n                    }\n                }\n            }\n\n            return returnParams;\n        }\n\n        function createChildren(parameters, msg) {\n            //TODO we also have to check out what is happening with the sets!!!\n            var result = {},\n                paths = [],\n                nodes = [],\n                node,\n                parent = _clientGlobal.nodes[parameters.parentId].node,\n                names, i, j, index, pointer,\n                newChildren = [],\n                relations = [];\n\n            //to allow 'meaningfull' instantiation of multiple objects\n            // we have to recreate the internal relations - except the base\n            paths = Object.keys(parameters);\n            paths.splice(paths.indexOf('parentId'), 1);\n            for (i = 0; i < paths.length; i++) {\n                node = _clientGlobal.nodes[paths[i]].node;\n                nodes.push(node);\n                pointer = {};\n                names = _clientGlobal.core.getPointerNames(node);\n                index = names.indexOf('base');\n                if (index !== -1) {\n                    names.splice(index, 1);\n                }\n\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(_clientGlobal.core.getPointerPath(node, names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                relations.push(pointer);\n            }\n\n            //now the instantiation\n            for (i = 0; i < nodes.length; i++) {\n                newChildren.push(_clientGlobal.core.createNode({parent: parent, base: nodes[i]}));\n            }\n\n            //now for the storage and relation setting\n            for (i = 0; i < paths.length; i++) {\n                //attributes\n                names = Object.keys(parameters[paths[i]].attributes || {});\n                for (j = 0; j < names.length; j++) {\n                    _clientGlobal.core.setAttribute(newChildren[i],\n                        names[j], parameters[paths[i]].attributes[names[j]]);\n                }\n                //registry\n                names = Object.keys(parameters[paths[i]].registry || {});\n                for (j = 0; j < names.length; j++) {\n                    _clientGlobal.core.setRegistry(newChildren[i],\n                        names[j], parameters[paths[i]].registry[names[j]]);\n                }\n\n                //relations\n                names = Object.keys(relations[i]);\n                for (j = 0; j < names.length; j++) {\n                    _clientGlobal.core.setPointer(newChildren[i], names[j], newChildren[relations[i][names[j]]]);\n                }\n\n                //store\n                result[paths[i]] = _clientGlobal.functions.storeNode(newChildren[i]);\n\n            }\n\n            msg = msg || 'createChildren(' + JSON.stringify(result) + ')';\n            _clientGlobal.functions.saveRoot(msg);\n            return result;\n        }\n\n        //TODO should be removed as there is no user or public API related to this function\n        //function deleteNode(path, msg) {\n        //  if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n        //    _clientGlobal.core.deleteNode(_clientGlobal.nodes[path].node);\n        //    //delete _clientGlobal.nodes[path];\n        //    msg = msg || 'deleteNode(' + path + ')';\n        //    saveRoot(msg);\n        //  }\n        //}\n\n        function delMoreNodes(paths, msg) {\n            if (_clientGlobal.core) {\n                for (var i = 0; i < paths.length; i++) {\n                    if (_clientGlobal.nodes[paths[i]] && typeof _clientGlobal.nodes[paths[i]].node === 'object') {\n                        _clientGlobal.core.deleteNode(_clientGlobal.nodes[paths[i]].node);\n                        //delete _clientGlobal.nodes[paths[i]];\n                    }\n                }\n                msg = msg || 'delMoreNodes(' + paths + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function createChild(parameters, msg) {\n            var newID;\n\n            if (_clientGlobal.core) {\n                if (typeof parameters.parentId === 'string' && _clientGlobal.nodes[parameters.parentId] &&\n                    typeof _clientGlobal.nodes[parameters.parentId].node === 'object') {\n                    var baseNode = null;\n                    if (_clientGlobal.nodes[parameters.baseId]) {\n                        baseNode = _clientGlobal.nodes[parameters.baseId].node || baseNode;\n                    }\n                    var child = _clientGlobal.core.createNode({\n                        parent: _clientGlobal.nodes[parameters.parentId].node,\n                        base: baseNode,\n                        guid: parameters.guid,\n                        relid: parameters.relid\n                    });\n                    if (parameters.position) {\n                        _clientGlobal.core.setRegistry(child,\n                            'position',\n                            {\n                                x: parameters.position.x || 100,\n                                y: parameters.position.y || 100\n                            });\n                    } else {\n                        _clientGlobal.core.setRegistry(child, 'position', {x: 100, y: 100});\n                    }\n                    _clientGlobal.functions.storeNode(child);\n                    newID = _clientGlobal.core.getPath(child);\n                    msg = msg || 'createChild(' + parameters.parentId + ',' + parameters.baseId + ',' + newID + ')';\n                    _clientGlobal.functions.saveRoot(msg);\n                }\n            }\n\n            return newID;\n        }\n\n        function makePointer(id, name, to, msg) {\n            if (to === null) {\n                _clientGlobal.core.setPointer(_clientGlobal.nodes[id].node, name, to);\n            } else {\n\n\n                _clientGlobal.core.setPointer(_clientGlobal.nodes[id].node, name, _clientGlobal.nodes[to].node);\n            }\n\n            msg = msg || 'makePointer(' + id + ',' + name + ',' + to + ')';\n            _clientGlobal.functions.saveRoot(msg);\n        }\n\n        function delPointer(path, name, msg) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.deletePointer(_clientGlobal.nodes[path].node, name);\n                msg = msg || 'delPointer(' + path + ',' + name + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n\n        //MGAlike - set functions\n        function addMember(path, memberpath, setid, msg) {\n            if (_clientGlobal.nodes[path] &&\n                _clientGlobal.nodes[memberpath] &&\n                typeof _clientGlobal.nodes[path].node === 'object' &&\n                typeof _clientGlobal.nodes[memberpath].node === 'object') {\n                _clientGlobal.core.addMember(_clientGlobal.nodes[path].node,\n                    setid, _clientGlobal.nodes[memberpath].node);\n                msg = msg || 'addMember(' + path + ',' + memberpath + ',' + setid + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function removeMember(path, memberpath, setid, msg) {\n            if (_clientGlobal.nodes[path] &&\n                typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.delMember(_clientGlobal.nodes[path].node, setid, memberpath);\n                msg = msg || 'removeMember(' + path + ',' + memberpath + ',' + setid + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function setMemberAttribute(path, memberpath, setid, name, value, msg) {\n            if (_clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.setMemberAttribute(_clientGlobal.nodes[path].node, setid, memberpath, name, value);\n                msg = msg ||\n                    'setMemberAttribute(' + path + ',' + memberpath + ',' + setid + ',' + name + ',' + value +\n                    ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function delMemberAttribute(path, memberpath, setid, name, msg) {\n            if (_clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.delMemberAttribute(_clientGlobal.nodes[path].node, setid, memberpath, name);\n                msg = msg || 'delMemberAttribute(' + path + ',' + memberpath + ',' + setid + ',' + name + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function setMemberRegistry(path, memberpath, setid, name, value, msg) {\n            if (_clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.setMemberRegistry(_clientGlobal.nodes[path].node, setid, memberpath, name, value);\n                msg = msg ||\n                    'setMemberRegistry(' + path + ',' + memberpath + ',' + setid + ',' + name + ',' + value + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function delMemberRegistry(path, memberpath, setid, name, msg) {\n            if (_clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.delMemberRegistry(_clientGlobal.nodes[path].node, setid, memberpath, name);\n                msg = msg || 'delMemberRegistry(' + path + ',' + memberpath + ',' + setid + ',' + name + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function createSet(path, setid, msg) {\n            if (_clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.createSet(_clientGlobal.nodes[path].node, setid);\n                msg = msg || 'createSet(' + path + ',' + setid + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function deleteSet(path, setid, msg) {\n            if (_clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.deleteSet(_clientGlobal.nodes[path].node, setid);\n                msg = msg || 'deleteSet(' + path + ',' + setid + ')';\n                _clientGlobal.functions.saveRoot(msg);\n            }\n        }\n\n        function setBase(path, basepath) {\n            /*if (_clientGlobal.core &&\n             _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n             _clientGlobal.core.setRegistry(_clientGlobal.nodes[path].node,'base',basepath);\n             saveRoot('setBase('+path+','+basepath+')');\n             }*/\n            if (_clientGlobal.core &&\n                _clientGlobal.nodes[path] &&\n                typeof _clientGlobal.nodes[path].node === 'object' &&\n                _clientGlobal.nodes[basepath] &&\n                typeof _clientGlobal.nodes[basepath].node === 'object') {\n                _clientGlobal.core.setBase(_clientGlobal.nodes[path].node, _clientGlobal.nodes[basepath].node);\n                _clientGlobal.functions.saveRoot('setBase(' + path + ',' + basepath + ')');\n            }\n        }\n\n        function delBase(path) {\n            /*if (_clientGlobal.core &&\n             _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n             _clientGlobal.core.delRegistry(_clientGlobal.nodes[path].node,'base');\n             saveRoot('delBase('+path+')');\n             }*/\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.setBase(_clientGlobal.nodes[path].node, null);\n                _clientGlobal.functions.saveRoot('delBase(' + path + ')');\n            }\n        }\n\n\n        _clientGlobal.nodeSetter = {\n            setAttributes: setAttributes,\n            delAttributes: delAttributes,\n            setRegistry: setRegistry,\n            delRegistry: delRegistry,\n            copyMoreNodes: copyMoreNodes,\n            moveMoreNodes: moveMoreNodes,\n            delMoreNodes: delMoreNodes,\n            createChild: createChild,\n            createChildren: createChildren,\n            makePointer: makePointer,\n            delPointer: delPointer,\n            addMember: addMember,\n            removeMember: removeMember,\n            setMemberAttribute: setMemberAttribute,\n            delMemberAttribute: delMemberAttribute,\n            setMemberRegistry: setMemberRegistry,\n            delMemberRegistry: delMemberRegistry,\n            createSet: createSet,\n            deleteSet: deleteSet,\n\n            setBase: setBase,\n            delBase: delBase,\n        };\n    }\n\n    return gmeNodeSetter;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('client/js/client/commitCache',[], function () {\n    'use strict';\n\n    function commitCache(_clientGlobal) {\n        var _cache = {},\n            _timeOrder = [];\n\n        function clearCache() {\n            _cache = {};\n            _timeOrder = [];\n        }\n\n        function addCommit(commitObject) {\n            var index;\n\n            if (!_cache[commitObject._id]) {\n                _cache[commitObject._id] = commitObject;\n                index = 0;\n                while (index < _timeOrder.length && _cache[_timeOrder[index]].time > commitObject.time) {\n                    index++;\n                }\n                _timeOrder.splice(index, 0, commitObject._id);\n            }\n        }\n\n        function getNCommitsFrom(commitHash, number, callback) {\n            var fillCache,\n                returnNCommitsFromHash,\n                cacheFilled,\n                index;\n\n            fillCache = function (time, number, cb) {\n                _clientGlobal.project.getCommits(time, number, function (err, commits) {\n                    var i;\n                    if (!err && commits) {\n                        for (i = 0; i < commits.length; i++) {\n                            addCommit(commits[i]);\n                        }\n                        cb(null);\n                    } else {\n                        //we cannot get new commits from the server\n                        //we should use our very own ones\n                        cb(null);\n                    }\n                });\n            };\n            returnNCommitsFromHash = function (hash, num, cb) {\n                //now we should have all the commits in place\n                var index = _timeOrder.indexOf(hash),\n                    commits = [];\n                if (index > -1 || hash === null) {\n                    if (hash === null) {\n                        index = 0;\n                    } else {\n                        index++;\n\n                    }\n                    while (commits.length < num && index < _timeOrder.length) {\n                        commits.push(_cache[_timeOrder[index]]);\n                        index++;\n                    }\n                    cb(null, commits);\n                } else {\n                    cb('cannot found starting commit');\n                }\n            };\n            cacheFilled = function (err) {\n                if (err) {\n                    callback(err);\n                } else {\n                    returnNCommitsFromHash(commitHash, number, callback);\n                }\n            };\n\n\n            if (commitHash) {\n                if (_cache[commitHash]) {\n                    //we can be lucky :)\n                    index = _timeOrder.indexOf(commitHash);\n                    if (_timeOrder.length > index + number) {\n                        //we are lucky\n                        cacheFilled(null);\n                    } else {\n                        //not that lucky\n                        fillCache(_cache[_timeOrder[_timeOrder.length - 1]].time,\n                            number - (_timeOrder.length - (index + 1)),\n                            cacheFilled);\n                    }\n                } else {\n                    //we are not lucky enough so we have to download the commit\n                    _clientGlobal.project.loadObject(commitHash, function (err, commitObject) {\n                        if (!err && commitObject) {\n                            addCommit(commitObject);\n                            fillCache(commitObject.time, number, cacheFilled);\n                        } else {\n                            callback(err);\n                        }\n                    });\n                }\n            } else {\n                //initial call\n                fillCache((new Date()).getTime(), number, cacheFilled);\n            }\n        }\n\n        function newCommit(commitHash) {\n            if (_cache[commitHash]) {\n                return;\n            }\n\n            _clientGlobal.project.loadObject(commitHash, function (err, commitObj) {\n                if (!err && commitObj) {\n                    addCommit(commitObj);\n                }\n\n            });\n        }\n\n        _clientGlobal.commitCache = {\n            getNCommitsFrom: getNCommitsFrom,\n            clearCache: clearCache,\n            newCommit: newCommit\n        };\n    }\n\n    return commitCache;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\n\n//TODO this functionality will be refactored sooon\ndefine('client/js/client/serverEventer',[], function () {\n    'use strict';\n\n    function serverEventer(_clientGlobal) {\n        var lastGuid = '',\n            nextServerEvent = function (err, guid, parameters) {\n                lastGuid = guid || lastGuid;\n                if (!err && parameters) {\n                    switch (parameters.type) {\n                        case 'PROJECT_CREATED':\n                            _clientGlobal.eDispatcher.dispatchEvent(_clientGlobal.events.SERVER_PROJECT_CREATED,\n                                parameters.project);\n                            break;\n                        case 'PROJECT_DELETED':\n                            _clientGlobal.eDispatcher.dispatchEvent(_clientGlobal.events.SERVER_PROJECT_DELETED,\n                                parameters.project);\n                            break;\n                        case 'BRANCH_CREATED':\n                            _clientGlobal.eDispatcher.dispatchEvent(_clientGlobal.events.SERVER_BRANCH_CREATED,\n                                {\n                                    project: parameters.project,\n                                    branch: parameters.branch,\n                                    commit: parameters.commit\n                                });\n                            break;\n                        case 'BRANCH_DELETED':\n                            _clientGlobal.eDispatcher.dispatchEvent(_clientGlobal.events.SERVER_BRANCH_DELETED,\n                                {\n                                    project: parameters.project,\n                                    branch: parameters.branch\n                                });\n                            break;\n                        case 'BRANCH_UPDATED':\n                            _clientGlobal.eDispatcher.dispatchEvent(_clientGlobal.events.SERVER_BRANCH_UPDATED,\n                                {\n                                    project: parameters.project,\n                                    branch: parameters.branch,\n                                    commit: parameters.commit\n                                });\n                            break;\n                    }\n                    return _clientGlobal.db.getNextServerEvent(lastGuid, nextServerEvent);\n                } else {\n                    setTimeout(function () {\n                        return _clientGlobal.db.getNextServerEvent(lastGuid, nextServerEvent);\n                    }, 1000);\n                }\n            };\n        _clientGlobal.db.getNextServerEvent(lastGuid, nextServerEvent);\n    }\n    \n    return serverEventer;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('client/js/client/addon',[], function () {\n    'use strict';\n\n    function AddOn(_clientGlobal) {\n        var _addOns = {},\n            _constraintCallback = function () {\n            };\n        //addOn functions\n        function startAddOn(name) {\n            if (_addOns[name] === undefined) {\n                _addOns[name] = 'loading';\n                _clientGlobal.db.simpleRequest({\n                        command: 'connectedWorkerStart',\n                        workerName: name,\n                        project: _clientGlobal.projectName,\n                        branch: _clientGlobal.branch\n                    },\n                    function (err, id) {\n                        if (err) {\n                            _clientGlobal.logger.error('starting addon failed ' + err);\n                            delete _addOns[name];\n                            return _clientGlobal.logger.error(err);\n                        }\n\n                        _clientGlobal.logger.debug('started addon ' + name + ' ' + id);\n                        _addOns[name] = id;\n                    });\n            }\n\n        }\n\n        function queryAddOn(name, query, callback) {\n            if (!_addOns[name] || _addOns[name] === 'loading') {\n                return callback(new Error('no such addOn is ready for queries'));\n            }\n            _clientGlobal.db.simpleQuery(_addOns[name], query, callback);\n        }\n\n        function stopAddOn(name, callback) {\n            if (_addOns[name] && _addOns[name] !== 'loading') {\n                _clientGlobal.db.simpleResult(_addOns[name], callback);\n                delete _addOns[name];\n            } else {\n                callback(_addOns[name] ? new Error('addon loading') : null);\n            }\n        }\n\n        //generic project related addOn handling\n        function updateRunningAddOns(root) {\n            var i,\n                neededAddOns,\n                runningAddOns,\n                callback = function (err) {\n                    _clientGlobal.logger.error(err);\n                };\n\n            if (_clientGlobal.gmeConfig.addOn.enable === true) {\n                neededAddOns = _clientGlobal.core.getRegistry(root, 'usedAddOns');\n                runningAddOns = getRunningAddOnNames();\n                neededAddOns = neededAddOns ? neededAddOns.split(' ') : [];\n                for (i = 0; i < neededAddOns.length; i += 1) {\n                    if (!_addOns[neededAddOns[i]]) {\n                        startAddOn(neededAddOns[i]);\n                    }\n                }\n                for (i = 0; i < runningAddOns.length; i += 1) {\n                    if (neededAddOns.indexOf(runningAddOns[i]) === -1) {\n                        stopAddOn(runningAddOns[i], callback);\n                    }\n                }\n            }\n        }\n\n        function stopRunningAddOns() {\n            var i,\n                keys,\n                callback;\n\n            if (_clientGlobal.gmeConfig.addOn.enable === true) {\n                keys = Object.keys(_addOns);\n                callback = function (err) {\n                    if (err) {\n                        _clientGlobal.logger.error('stopAddOn' + err);\n                    }\n                };\n\n                for (i = 0; i < keys.length; i++) {\n                    stopAddOn(keys[i], callback);\n                }\n            }\n        }\n\n        function getRunningAddOnNames() {\n            var i,\n                names = [],\n                keys = Object.keys(_addOns);\n            for (i = 0; i < keys.length; i++) {\n                if (_addOns[keys[i]] !== 'loading') {\n                    names.push(keys[i]);\n                }\n            }\n            return names;\n        }\n\n        //core addOns\n        //history\n        function getDetailedHistoryAsync(callback) {\n            if (_addOns.hasOwnProperty('HistoryAddOn') && _addOns.HistoryAddOn !== 'loading') {\n                queryAddOn('HistoryAddOn', {}, callback);\n            } else {\n                callback(new Error('history information is not available'));\n            }\n        }\n\n        //constraint\n        function validateProjectAsync(callback) {\n            callback = callback || _constraintCallback || function (/*err, result*/) {\n                };\n            if (_addOns.hasOwnProperty('ConstraintAddOn') && _addOns.ConstraintAddOn !== 'loading') {\n                queryAddOn('ConstraintAddOn', {querytype: 'checkProject'}, callback);\n            } else {\n                callback(new Error('constraint checking is not available'));\n            }\n        }\n\n        function validateModelAsync(path, callback) {\n            callback = callback || _constraintCallback || function (/* err, result */) {\n                };\n            if (_addOns.hasOwnProperty('ConstraintAddOn') && _addOns.ConstraintAddOn !== 'loading') {\n                queryAddOn('ConstraintAddOn', {querytype: 'checkModel', path: path}, callback);\n            } else {\n                callback(new Error('constraint checking is not available'));\n            }\n        }\n\n        function validateNodeAsync(path, callback) {\n            callback = callback || _constraintCallback || function (/* err, result */) {\n                };\n            if (_addOns.hasOwnProperty('ConstraintAddOn') && _addOns.ConstraintAddOn !== 'loading') {\n                queryAddOn('ConstraintAddOn', {querytype: 'checkNode', path: path}, callback);\n            } else {\n                callback(new Error('constraint checking is not available'));\n            }\n        }\n\n        function setValidationCallback(cFunction) {\n            if (typeof cFunction === 'function' || cFunction === null) {\n                _constraintCallback = cFunction;\n            }\n        }\n\n        //core addOns end\n\n        _clientGlobal.addOn = {\n            startAddOn: startAddOn,\n            queryAddOn: queryAddOn,\n            stopAddOn: stopAddOn,\n            updateRunningAddOns: updateRunningAddOns,\n            stopRunningAddOns: stopRunningAddOns,\n            getDetailedHistoryAsync: getDetailedHistoryAsync,\n            validateProjectAsync: validateProjectAsync,\n            validateModelAsync: validateModelAsync,\n            validateNodeAsync: validateNodeAsync,\n            setValidationCallback: setValidationCallback\n        };\n    }\n\n    return AddOn;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/serialization',['common/util/assert'], function (ASSERT) {\n\n    'use strict';\n    var _nodes = {},\n        _core = null,\n        _pathToGuidMap = {},\n        _guidKeys = [], //ordered list of GUIDs\n        _extraBasePaths = {},\n        _export = {},\n        _import = {},\n        _newNodeGuids = [],\n        _removedNodeGuids = [],\n        _updatedNodeGuids = [],\n        _log = '';\n\n    function log(txt) {\n        if (_log) {\n            _log += '\\n' + txt;\n        } else {\n            _log = '' + txt;\n        }\n    }\n\n    function exportLibrary(core, libraryRoot, callback) {\n        //initialization\n        _core = core;\n        _nodes = {};\n        _pathToGuidMap = {};\n        _guidKeys = [];\n        _extraBasePaths = {};\n        _export = {};\n\n        //loading all library element\n        gatherNodesSlowly(libraryRoot, function (err) {\n            if (err) {\n                return callback(err);\n            }\n\n            _guidKeys = _guidKeys.sort();\n            gatherAncestors(); //collecting the 'external' base classes - probably we should avoid these\n\n            var keys = Object.keys(_extraBasePaths),\n                i;\n            _export.bases = {};\n            for (i = 0; i < keys.length; i++) {\n                _export.bases[_extraBasePaths[keys[i]]] = keys[i];\n            }\n\n            //_export.bases = _extraBasePaths;\n            // we save this info alongside with the library export, to be on the safe side\n\n            _export.root = getLibraryRootInfo(libraryRoot);\n            _export.relids = getRelIdInfo();\n            _export.containment = {};\n            fillContainmentTree(libraryRoot, _export.containment);\n            _export.nodes = getNodesData();\n\n            //we export MetaSheet info only if not the whole project is exported!!!\n            _export.metaSheets = core.getParent(libraryRoot) ? getMetaSheetInfo(_core.getRoot(libraryRoot)) : {};\n\n            callback(null, _export);\n\n        });\n    }\n\n    function getMetaSheetInfo(root) {\n        var getMemberRegistry = function (setname, memberpath) {\n                var names = _core.getMemberRegistryNames(root, setname, memberpath),\n                    i,\n                    registry = {};\n                for (i = 0; i < names.length; i++) {\n                    registry[names[i]] = _core.getMemberRegistry(root, setname, memberpath, names[i]);\n                }\n                return registry;\n            },\n            getMemberAttributes = function (setname, memberpath) {\n                var names = _core.getMemberAttributeNames(root, setname, memberpath),\n                    i,\n                    attributes = {};\n                for (i = 0; i < names.length; i++) {\n                    attributes[names[i]] = _core.getMemberAttribute(root, setname, memberpath, names[i]);\n                }\n                return attributes;\n            },\n            getRegistryEntry = function (setname) {\n                var index = registry.length;\n\n                while (--index >= 0) {\n                    if (registry[index].SetID === setname) {\n                        return registry[index];\n                    }\n                }\n                return {};\n            },\n            sheets = {},\n            registry = _core.getRegistry(root, 'MetaSheets'),\n            keys = _core.getSetNames(root),\n            elements, guid,\n            i,\n            j;\n\n        for (i = 0; i < keys.length; i++) {\n            if (keys[i].indexOf('MetaAspectSet') === 0) {\n                elements = _core.getMemberPaths(root, keys[i]);\n                for (j = 0; j < elements.length; j++) {\n                    guid = _pathToGuidMap[elements[j]] || _extraBasePaths[elements[j]];\n                    if (guid) {\n                        sheets[keys[i]] = sheets[keys[i]] || {};\n                        sheets[keys[i]][guid] = {\n                            registry: getMemberRegistry(keys[i], elements[j]),\n                            attributes: getMemberAttributes(keys[i], elements[j])\n                        };\n                    }\n                }\n\n                if (sheets[keys[i]] && keys[i] !== 'MetaAspectSet') {\n                    //we add the global registry values as well\n                    sheets[keys[i]].global = getRegistryEntry(keys[i]);\n                }\n            }\n        }\n        console.log('sheets', sheets);\n        return sheets;\n    }\n\n    function importMetaSheetInfo(root) {\n        var setMemberAttributesAndRegistry = function (setname, memberguid) {\n                var attributes = oldSheets[setname][memberguid].attributes || {},\n                    registry = oldSheets[setname][memberguid].registry || {},\n                    keys = Object.keys(attributes),\n                    i;\n\n                for (i = 0; i < keys.length; i++) {\n                    _core.setMemberAttribute(root, setname, _core.getPath(_nodes[memberguid]), keys[i],\n                        attributes[keys[i]]);\n                }\n                keys = Object.keys(registry);\n                for (i = 0; i < keys.length; i++) {\n                    _core.setMemberRegistry(root, setname, _core.getPath(_nodes[memberguid]), keys[i],\n                        registry[keys[i]]);\n                }\n            },\n            updateSheet = function (name) {\n                //the removed object should be already removed...\n                //if some element is extra in the place of import, then it stays untouched\n                var oldMemberGuids = Object.keys(oldSheets[name]),\n                    i;\n                oldMemberGuids.splice(oldMemberGuids.indexOf('global'), 1);\n                for (i = 0; i < oldMemberGuids.length; i++) {\n                    _core.addMember(root, name, _nodes[oldMemberGuids[i]]);\n                    setMemberAttributesAndRegistry(name, oldMemberGuids[i]);\n                }\n            },\n            addSheet = function (name) {\n                var registry = JSON.parse(JSON.stringify(_core.getRegistry(root, 'MetaSheets')) || {}),\n                    i,\n                    memberpath,\n                    memberguids = Object.keys(oldSheets[name]);\n\n                memberguids.splice(memberguids.indexOf('global'), 1);\n\n                if (name !== 'MetaAspectSet') {\n                    registry.push(oldSheets[name].global);\n                    _core.setRegistry(root, 'MetaSheets', registry);\n                }\n\n                _core.createSet(root, name);\n                for (i = 0; i < memberguids.length; i++) {\n                    memberpath = _core.getPath(_nodes[memberguids[i]]);\n                    _core.addMember(root, name, _nodes[memberguids[i]]);\n                    setMemberAttributesAndRegistry(name, memberguids[i]);\n                }\n            },\n            oldSheets = _import.metaSheets || {},\n            newSheets = _export.metaSheets || {},\n            oldSheetNames = Object.keys(oldSheets),\n            newSheetNames = Object.keys(newSheets),\n            i;\n\n        for (i = 0; i < oldSheetNames.length; i++) {\n            if (newSheetNames.indexOf(oldSheetNames[i]) !== -1) {\n                updateSheet(oldSheetNames[i]);\n            } else {\n                addSheet(oldSheetNames[i]);\n            }\n        }\n    }\n\n    function getLibraryRootInfo(node) {\n        return {\n            path: _core.getPath(node),\n            guid: _core.getGuid(node)\n        };\n    }\n\n    function gatherNodesSlowly(node, callback) {\n        _core.loadSubTree(node, function (err, nodes) {\n            var guid, i;\n            if (!err && nodes) {\n                for (i = 0; i < nodes.length; i++) {\n                    guid = _core.getGuid(nodes[i]);\n                    _nodes[guid] = nodes[i];\n                    _guidKeys.push(guid);\n                    _pathToGuidMap[_core.getPath(nodes[i])] = guid;\n                }\n                callback(null);\n            } else {\n                callback(err);\n            }\n        });\n    }\n\n    function gatherAncestors() {\n        //this function inserts the needed base classes which were not included in the library\n        var i, base, guid;\n        for (i = 0; i < _guidKeys.length; i++) {\n            base = _nodes[_guidKeys[i]];\n            while (base !== null) {\n                guid = _core.getGuid(base);\n                if (!_nodes[guid]) {\n                    _nodes[guid] = base;\n                    _extraBasePaths[_core.getPath(base)] = guid;\n                } else if (_guidKeys.indexOf(guid) === -1) {\n                    _extraBasePaths[_core.getPath(base)] = guid;\n                }\n                base = _core.getBase(base);\n            }\n        }\n    }\n\n    function pathsToSortedGuidList(pathsList) { //it will also filter out not wanted elements\n        var i, guids = [];\n        for (i = 0; i < pathsList.length; i++) {\n            if (_pathToGuidMap[pathsList[i]]) {\n                guids.push(_pathToGuidMap[pathsList[i]]);\n            }\n        }\n        return guids.sort();\n    }\n\n    function fillContainmentTree(node, myTreeObject) {\n        var childrenGuids = pathsToSortedGuidList(_core.getChildrenPaths(node)),\n            i;\n        for (i = 0; i < childrenGuids.length; i++) {\n            myTreeObject[childrenGuids[i]] = {};\n            fillContainmentTree(_nodes[childrenGuids[i]], myTreeObject[childrenGuids[i]]);\n        }\n    }\n\n    function getRelIdInfo() {\n        var i,\n            relIdInfo = {};\n        for (i = 0; i < _guidKeys.length; i++) {\n            relIdInfo[_guidKeys[i]] = _core.getRelid(_nodes[_guidKeys[i]]);\n        }\n        return relIdInfo;\n    }\n\n    function getNodesData() {\n        var data = {},\n            i;\n        for (i = 0; i < _guidKeys.length; i++) {\n            data[_guidKeys[i]] = getNodeData(_nodes[_guidKeys[i]]);\n        }\n        return data;\n    }\n\n    function getNodeData(node) {\n        /*{\n         //only the ones defined on this level\n         attributes:{name:value},\n         base:GUID,\n         registry:{name:value},\n         parent:GUID,\n         pointers:{name:targetGuid},\n         sets:{name:[{guid:GUID,attributes:{name:value},registy:{name:value}}]}\n         meta:{}\n         }*/\n        return {\n            attributes: getAttributesOfNode(node),\n            base: _core.getBase(node) ? _core.getGuid(_core.getBase(node)) : null,\n            meta: pathsToGuids(JSON.parse(JSON.stringify(_core.getOwnJsonMeta(node)) || {})),\n            parent: _core.getParent(node) ? _core.getGuid(_core.getParent(node)) : null,\n            pointers: getPointersOfNode(node),\n            registry: getRegistryOfNode(node),\n            sets: getSetsOfNode(node),\n            constraints: getConstraintsOfNode(node)\n        };\n    }\n\n    function baseGuid(path) {\n        /*var keys = Object.keys(_extraBasePaths),\n         i;\n         for(i=0;i<keys.length;i++){\n         if(_extraBasePaths[keys[i]] === path){\n         return keys[i];\n         }\n         }\n         return null;*/\n        return _extraBasePaths[path];\n    }\n\n    var sortMultipleArrays = function () {\n        var index = getSortedIndex(arguments[0]);\n        for (var j = 0; j < arguments.length; j++) {\n            var _arr = arguments[j].slice();\n            for (var i = 0; i < _arr.length; i++) {\n                arguments[j][i] = _arr[index[i]];\n            }\n        }\n    };\n\n    var getSortedIndex = function (arr) {\n        var index = [];\n        for (var i = 0; i < arr.length; i++) {\n            index.push(i);\n        }\n        index = index.sort((function (arr) {\n            return function (a, b) {\n                return ((arr[a] > arr[b]) ? 1 : ((arr[a] < arr[b]) ? -1 : 0));\n            };\n        })(arr));\n        return index;\n    };\n\n    function pathsToGuids(jsonObject) {\n        if (jsonObject && typeof jsonObject === 'object') {\n            var keys = Object.keys(jsonObject),\n                i, j, k, toDelete, tArray;\n\n            for (i = 0; i < keys.length; i++) {\n                if (keys[i] === 'items') {\n                    //here comes the transformation itself\n                    toDelete = [];\n                    for (j = 0; j < jsonObject.items.length; j++) {\n                        if (_pathToGuidMap[jsonObject.items[j]]) {\n                            jsonObject.items[j] = _pathToGuidMap[jsonObject.items[j]];\n                        } else if (baseGuid(jsonObject.items[j])) {\n                            jsonObject.items[j] = baseGuid(jsonObject.items[j]);\n                        } else {\n                            toDelete.push(j);\n                        }\n                    }\n\n                    if (toDelete.length > 0) {\n                        toDelete = toDelete.sort();\n                        toDelete = toDelete.reverse();\n                        for (j = 0; j < toDelete.length; j++) {\n                            jsonObject.items.splice(toDelete[j], 1);\n                            jsonObject.minItems.splice(toDelete[j], 1);\n                            jsonObject.maxItems.splice(toDelete[j], 1);\n                        }\n                    }\n                    sortMultipleArrays(jsonObject.items, jsonObject.minItems, jsonObject.maxItems);\n                } else if (keys[i] === 'aspects') {\n                    //aspects are a bunch of named path list, so we have to handle them separately\n                    tArray = Object.keys(jsonObject[keys[i]]);\n                    for (j = 0; j < tArray.length; j++) {\n                        //here comes the transformation itself\n                        toDelete = [];\n                        for (k = 0; k < jsonObject.aspects[tArray[j]].length; k++) {\n                            if (_pathToGuidMap[jsonObject.aspects[tArray[j]][k]]) {\n                                jsonObject.aspects[tArray[j]][k] = _pathToGuidMap[jsonObject.aspects[tArray[j]][k]];\n                            } else if (baseGuid(jsonObject.aspects[tArray[j]][k])) {\n                                jsonObject.aspects[tArray[j]][k] = baseGuid(jsonObject.aspects[tArray[j]][k]);\n                            } else {\n                                toDelete.push(k);\n                            }\n                        }\n\n                        if (toDelete.length > 0) {\n                            toDelete = toDelete.sort();\n                            toDelete = toDelete.reverse();\n                            for (k = 0; k < toDelete.length; k++) {\n                                jsonObject.aspects[tArray[j]].splice(toDelete[k], 1);\n                            }\n                        }\n\n                        jsonObject.aspects[tArray[j]] = jsonObject.aspects[tArray[j]].sort();\n\n                    }\n                } else {\n                    if (typeof jsonObject[keys[i]] === 'object') {\n                        jsonObject[keys[i]] = pathsToGuids(jsonObject[keys[i]]);\n                    }\n                }\n            }\n\n        }\n        return jsonObject;\n    }\n\n    function getAttributesOfNode(node) {\n        var names = _core.getOwnAttributeNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getAttribute(node, names[i]);\n        }\n        return result;\n    }\n\n    function getRegistryOfNode(node) {\n        var names = _core.getOwnRegistryNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getRegistry(node, names[i]);\n        }\n        return result;\n    }\n\n    function getConstraintsOfNode(node) {\n        var names = _core.getOwnConstraintNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getConstraint(node, names[i]);\n        }\n        return result;\n    }\n\n    function getPointersOfNode(node) {\n        var names = _core.getOwnPointerNames(node).sort(),\n            i,\n            result = {},\n            target;\n        for (i = 0; i < names.length; i++) {\n            target = _core.getPointerPath(node, names[i]);\n            if (_pathToGuidMap[target] || baseGuid(target) || target === null) {\n                result[names[i]] = _pathToGuidMap[target] || baseGuid(target) || null;\n            }\n        }\n        return result;\n    }\n\n    function getOwnMemberPaths(node, setName) {\n        var base = _core.getBase(node),\n            baseMembers = base === null ? [] : _core.getMemberPaths(base, setName),\n            members = _core.getMemberPaths(node, setName),\n            ownMembers = [],\n            i;\n        for (i = 0; i < members.length; i++) {\n            if (baseMembers.indexOf(members[i]) === -1) {\n                ownMembers.push(members[i]);\n            }\n        }\n        return ownMembers;\n    }\n\n    function getSetsOfNode(node) {\n        var names = _core.getSetNames(node).sort(),\n            i, j, k,\n            result = {},\n            targetGuids,\n            attributeNames,\n            registryNames,\n            memberInfo,\n            path;\n        for (i = 0; i < names.length; i++) {\n            targetGuids = pathsToSortedGuidList(getOwnMemberPaths(node, names[i]));\n            result[names[i]] = [];\n            for (j = 0; j < targetGuids.length; j++) {\n                path = _core.getPath(_nodes[targetGuids[j]]);\n                memberInfo = {\n                    attributes: {},\n                    guid: targetGuids[j],\n                    registry: {}\n                };\n\n                //attributes\n                attributeNames = _core.getMemberAttributeNames(node, names[i], path).sort();\n                for (k = 0; k < attributeNames.length; k++) {\n                    memberInfo.attributes[attributeNames[k]] =\n                        _core.getMemberAttribute(node, names[i], path, attributeNames[k]);\n                }\n\n                //registry\n                registryNames = _core.getMemberRegistryNames(node, names[i], path).sort();\n                for (k = 0; k < registryNames.length; k++) {\n                    memberInfo.registry[registryNames[k]] =\n                        _core.getMemberRegistry(node, names[i], path, registryNames[k]);\n                }\n\n                result[names[i]].push(memberInfo);\n            }\n        }\n        return result;\n    }\n\n    function logId(nodes, id) {\n        var txtId = id + '';\n        if (nodes[id] && nodes[id].attributes && nodes[id].attributes.name) {\n            txtId = nodes[id].attributes.name + '(' + id + ')';\n        }\n\n        return txtId;\n    }\n\n    function loadImportBases(guids, root, callback) {\n        var needed = [],\n            error = null,\n            stillToGo = 0,\n            i,\n            guidList = Object.keys(guids),\n            loadBase = function (guid, path, cb) {\n                _core.loadByPath(root, path, function (err, node) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    if (_core.getGuid(node) !== guid) {\n                        return cb('GUID mismatch');\n                    }\n\n                    _nodes[guid] = node;\n                    cb(null);\n                });\n            };\n\n        for (i = 0; i < guidList.length; i++) {\n            if (_nodes[guidList[i]] === undefined) {\n                needed.push(guidList[i]);\n            }\n        }\n\n        if (needed.length > 0) {\n            stillToGo = needed.length;\n            for (i = 0; i < needed.length; i++) {\n                loadBase(needed[i], guids[needed[i]], function (err) {\n                    error = error || err;\n                    if (--stillToGo === 0) {\n                        callback(error);\n                    }\n                });\n            }\n        } else {\n            return callback(null);\n        }\n\n    }\n\n    function importLibrary(core, originLibraryRoot, updatedLibraryJson, callback) {\n        _core = core;\n        _import = updatedLibraryJson;\n        _newNodeGuids = [];\n        _updatedNodeGuids = [];\n        _removedNodeGuids = [];\n        _log = '';\n\n        synchronizeRoots(originLibraryRoot, _import.root.guid);\n        exportLibrary(core, originLibraryRoot, function (err) {\n            //we do not need the returned json object as that is stored in our global _export variable\n            if (err) {\n                return callback(err);\n            }\n\n            //now we will search for the bases of the import and load them\n            loadImportBases(_import.bases, _core.getRoot(originLibraryRoot), function (err) {\n                if (err) {\n                    return callback(err);\n                }\n\n                //now we fill the insert/update/remove lists of GUIDs\n                var oldkeys = Object.keys(_export.nodes),\n                    newkeys = Object.keys(_import.nodes),\n                    i;\n\n                //TODO now we make three rounds although one would be sufficient on ordered lists\n                for (i = 0; i < oldkeys.length; i++) {\n                    if (newkeys.indexOf(oldkeys[i]) === -1) {\n                        log('node ' + logId(_export.nodes, oldkeys[i]) +\n                        ', all of its sub-types and its children will be removed');\n\n                        _removedNodeGuids.push(oldkeys[i]);\n                    }\n                }\n\n                for (i = 0; i < oldkeys.length; i++) {\n                    if (newkeys.indexOf(oldkeys[i]) !== -1) {\n                        log('node ' + logId(_export.nodes, oldkeys[i]) + ' will be updated');\n                        _updatedNodeGuids.push(oldkeys[i]);\n                    }\n                }\n\n                for (i = 0; i < newkeys.length; i++) {\n                    if (oldkeys.indexOf(newkeys[i]) === -1) {\n                        log('node ' + logId(_import.nodes, newkeys[i]) + ' will be added');\n                        _newNodeGuids.push(newkeys[i]);\n                    }\n                }\n\n                //Now we normalize the removedGUIDs by containment and remove them\n                var toDelete = [],\n                    parent;\n                for (i = 0; i < _removedNodeGuids.length; i++) {\n                    parent = _core.getParent(_nodes[_removedNodeGuids[i]]);\n                    if (parent && _removedNodeGuids.indexOf(_core.getGuid(parent)) === -1) {\n                        toDelete.push(_removedNodeGuids[i]);\n                    }\n                }\n                //and as a final step we remove all that is needed\n                for (i = 0; i < toDelete.length; i++) {\n                    _core.deleteNode(_nodes[toDelete[i]]);\n                }\n\n                //as a second step we should deal with the updated nodes\n                //we should go among containment hierarchy\n                updateNodes(_import.root.guid, null, _import.containment);\n\n                //now update inheritance chain\n                //we assume that our inheritance chain comes from the FCO and that it is identical everywhere\n                updateInheritance();\n\n                //now we can add or modify the relations of the nodes - we go along the hierarchy chain\n                updateRelations();\n\n                //finally we need to update the meta rules of each node - again along the containment hierarchy\n                updateMetaRules(_import.root.guid, _import.containment);\n\n                //after everything is done we try to synchronize the metaSheet info\n                importMetaSheetInfo(_core.getRoot(originLibraryRoot));\n\n                callback(null, _log);\n            });\n        });\n    }\n\n    function synchronizeRoots(oldRoot, newGuid) {\n        _core.setGuid(oldRoot, newGuid);\n    }\n\n    //it will update the modified nodes and create the new ones regarding their place in the hierarchy chain\n    function updateNodes(guid, parent, containmentTreeObject) {\n        if (_updatedNodeGuids.indexOf(guid) !== -1) {\n            updateNode(guid, parent);\n        }\n\n        var keys = Object.keys(containmentTreeObject),\n            i,\n            node = _nodes[guid],\n            relid;\n\n        for (i = 0; i < keys.length; i++) {\n            if (_updatedNodeGuids.indexOf(keys[i]) === -1) {\n                relid = _import.relids[keys[i]];\n                if (_core.getChildrenRelids(node).indexOf(relid) !== -1) {\n                    relid = undefined;\n                }\n                //this child is a new one so we should create\n                _nodes[keys[i]] = _core.createNode({parent: node, guid: keys[i], relid: relid});\n                addNode(keys[i]);\n            }\n            updateNodes(keys[i], node, containmentTreeObject[keys[i]]);\n        }\n    }\n\n    function updateRegistry(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n\n        keys = _core.getOwnRegistryNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delRegistry(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.registry);\n        for (i = 0; i < keys.length; i++) {\n            _core.setRegistry(node, keys[i], jsonNode.registry[keys[i]]);\n        }\n    }\n\n    function updateAttributes(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n\n        keys = _core.getOwnAttributeNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delAttribute(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.attributes);\n        for (i = 0; i < keys.length; i++) {\n            _core.setAttribute(node, keys[i], jsonNode.attributes[keys[i]]);\n        }\n    }\n\n    function updateConstraints(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n        keys = _core.getOwnConstraintNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delConstraint(node, keys[i]);\n        }\n\n        keys = Object.keys(jsonNode.constraints || {});\n        for (i = 0; i < keys.length; i++) {\n            _core.setConstraint(node, keys[i], jsonNode.constraints[keys[i]]);\n        }\n    }\n\n    //this function does not cover relations - it means only attributes and registry have been updated here\n    function updateNode(guid, parent) {\n        //first we check if the node have to be moved\n        var node = _nodes[guid];\n\n        if (parent && _core.getParent(node) && _core.getGuid(parent) !== _core.getGuid(_core.getParent(node))) {\n            //parent changed so it has to be moved...\n            _nodes[guid] = _core.moveNode(node, parent);\n        }\n\n        updateAttributes(guid);\n        updateRegistry(guid);\n        updateConstraints(guid);\n    }\n\n    //this function doesn't not cover relations - so only attributes and registry have been taken care of here\n    function addNode(guid) {\n        //at this point we assume that an empty vessel has been already created and part of the _nodes\n        updateAttributes(guid);\n        updateRegistry(guid);\n        updateConstraints(guid);\n    }\n\n    function getInheritanceBasedGuidOrder() {\n        var inheritanceOrdered = Object.keys(_import.nodes).sort(),\n            i = 0,\n            baseGuid,\n            baseIndex;\n\n        while (i < inheritanceOrdered.length) {\n            baseGuid = _import.nodes[inheritanceOrdered[i]].base;\n            if (baseGuid) {\n                baseIndex = inheritanceOrdered.indexOf(baseGuid);\n                if (baseIndex > i) {\n                    inheritanceOrdered.splice(baseIndex, 1);\n                    inheritanceOrdered.splice(i, 0, baseGuid);\n                } else {\n                    ++i;\n                }\n            } else {\n                ++i;\n            }\n        }\n        return inheritanceOrdered;\n    }\n\n    function updateRelations() {\n        var guids = getInheritanceBasedGuidOrder(),\n            i;\n        for (i = 0; i < guids.length; i++) {\n            updateNodeRelations(guids[i]);\n        }\n    }\n\n    function updateNodeRelations(guid) {\n        // Although it is possible that we set the base pointer at this point\n        // we should go through inheritance just to be sure.\n        var node = _nodes[guid],\n            jsonNode = _import.nodes[guid],\n            keys, i, j, k, target, memberGuid;\n\n        //pointers\n        keys = _core.getOwnPointerNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.deletePointer(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.pointers);\n        for (i = 0; i < keys.length; i++) {\n            target = jsonNode.pointers[keys[i]];\n            if (target === null) {\n                _core.setPointer(node, keys[i], null);\n            } else if (_nodes[target] && _removedNodeGuids.indexOf(target) === -1) {\n                _core.setPointer(node, keys[i], _nodes[target]);\n            } else {\n                console.log('error handling needed???!!!???');\n            }\n        }\n\n        //sets\n        keys = _core.getSetNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.deleteSet(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.sets);\n        for (i = 0; i < keys.length; i++) {\n            //for every set we create it, go through its members...\n            _core.createSet(node, keys[i]);\n            for (j = 0; j < jsonNode.sets[keys[i]].length; j++) {\n                memberGuid = jsonNode.sets[keys[i]][j].guid;\n                if (_nodes[memberGuid]) {\n                    _core.addMember(node, keys[i], _nodes[memberGuid]);\n                    for (k in jsonNode.sets[keys[i]][j].attributes) {\n                        _core.setMemberAttribute(node, keys[i], _core.getPath(_nodes[memberGuid]), k,\n                            jsonNode.sets[keys[i]][j].attributes[k]);\n                    }\n                    for (k in jsonNode.sets[keys[i]][j].registry) {\n                        _core.setMemberRegistry(node, keys[i], _core.getPath(_nodes[memberGuid]), k,\n                            jsonNode.sets[keys[i]][j].registry[k]);\n                    }\n                }\n            }\n        }\n    }\n\n    function updateInheritance() {\n        var i,\n            guidList = Object.keys(_import.nodes),\n            base;\n        for (i = 0; i < guidList.length; i++) {\n            base = _core.getBase(_nodes[guidList[i]]);\n            if ((base && _core.getGuid(base) !== _import.nodes[guidList[i]].base) ||\n                (base === null && _import.nodes[guidList[i]].base !== null)) {\n\n                updateNodeInheritance(guidList[i]);\n            }\n        }\n    }\n\n    function updateNodeInheritance(guid) {\n        _core.setBase(_nodes[guid], _nodes[_import.nodes[guid].base]);\n    }\n\n    function updateMetaRules(guid, containmentTreeObject) {\n\n        var keys, i;\n\n        updateMeta(guid);\n\n        keys = Object.keys(containmentTreeObject);\n        for (i = 0; i < keys.length; i++) {\n            updateMetaRules(keys[i], containmentTreeObject[keys[i]]);\n        }\n    }\n\n    function updateMeta(guid) {\n        _core.clearMetaRules(_nodes[guid]);\n\n        updateAttributeMeta(guid);\n        updateChildrenMeta(guid);\n        updatePointerMeta(guid);\n        updateAspectMeta(guid);\n        updateConstraintMeta(guid);\n    }\n\n    function updateAttributeMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.attributes || {},\n            node = _nodes[guid],\n            keys, i;\n\n        keys = Object.keys(jsonMeta);\n        for (i = 0; i < keys.length; i++) {\n            _core.setAttributeMeta(node, keys[i], jsonMeta[keys[i]]);\n        }\n    }\n\n    function updateChildrenMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.children || {items: [], minItems: [], maxItems: []},\n            i;\n        ASSERT(jsonMeta.items.length === jsonMeta.minItems.length &&\n        jsonMeta.minItems.length === jsonMeta.maxItems.length);\n\n        _core.setChildrenMetaLimits(_nodes[guid], jsonMeta.min, jsonMeta.max);\n        for (i = 0; i < jsonMeta.items.length; i++) {\n            _core.setChildMeta(_nodes[guid], _nodes[jsonMeta.items[i]], jsonMeta.minItems[i], jsonMeta.maxItems[i]);\n        }\n    }\n\n    function updatePointerMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.pointers || {},\n            keys = Object.keys(jsonMeta),\n            i, j;\n\n        for (i = 0; i < keys.length; i++) {\n            ASSERT(jsonMeta[keys[i]].items.length === jsonMeta[keys[i]].minItems.length &&\n            jsonMeta[keys[i]].maxItems.length === jsonMeta[keys[i]].minItems.length);\n\n            for (j = 0; j < jsonMeta[keys[i]].items.length; j++) {\n                _core.setPointerMetaTarget(_nodes[guid], keys[i], _nodes[jsonMeta[keys[i]].items[j]],\n                    jsonMeta[keys[i]].minItems[j], jsonMeta[keys[i]].maxItems[j]);\n            }\n            _core.setPointerMetaLimits(_nodes[guid], keys[i], jsonMeta[keys[i]].min, jsonMeta[keys[i]].max);\n        }\n    }\n\n    function updateAspectMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.aspects || {},\n            keys = Object.keys(jsonMeta),\n            i, j;\n\n        for (i = 0; i < keys.length; i++) {\n            for (j = 0; j < jsonMeta[keys[i]].length; j++) {\n                _core.setAspectMetaTarget(_nodes[guid], keys[i], _nodes[jsonMeta[keys[i]][j]]);\n            }\n        }\n    }\n\n    function updateConstraintMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.constraints || {},\n            keys = Object.keys(jsonMeta),\n            i;\n\n        for (i = 0; i < keys.length; i++) {\n            _core.setConstraint(_nodes[guid], keys[i], jsonMeta[keys[i]]);\n        }\n    }\n\n    return {\n        export: exportLibrary,\n        import: importLibrary\n    };\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/dump',['common/core/users/tojson', 'common/util/url'], function (toJson, URL) {\n    'use strict';\n\n    var _refTypes = {\n            url: 'url',\n            path: 'path',\n            guid: 'guid'\n        },\n        _cache = {},\n        _rootPath = '',\n        _refType = 'url',\n        _core = null;\n\n    var isRefObject = function (obj) {\n        if (obj && typeof obj.$ref === 'string') {\n            return true;\n        }\n        return false;\n    };\n\n    var getRefObjectPath = function (obj) {\n        var result = null;\n        if (isRefObject(obj) === true) {\n            var refValue = obj.$ref;\n            switch (_refType) {\n                case _refTypes.url:\n                    if (refValue === null) {\n                        result = null;\n                    } else {\n                        refValue = refValue.split('/');\n                        result = URL.removeSpecialChars(refValue[refValue.length - 1]);\n                    }\n                    break;\n                case _refTypes.path:\n                case _refTypes.guid:\n                    result = refValue;\n                    break;\n                default:\n                    result = null;\n                    break;\n            }\n        }\n\n        return result;\n    };\n\n    var refToRelRefObj = function (path, refObj) {\n        if (_cache[path]) {\n            refObj.$ref = _cache[path];\n        } else {\n            refObj = {$ref: null};\n        }\n    };\n\n    var isSubordinate = function (path) {\n        if (path.indexOf(_rootPath) === 0) {\n            return true;\n        }\n        return false;\n    };\n\n    var dumpChildren = function (node, dumpObject, urlPrefix, relPath, callback) {\n        var needed = dumpObject.children.length;\n        if (needed > 0) {\n            _core.loadChildren(node, function (err, children) {\n                if (err) {\n                    callback(err);\n                } else {\n                    if (children === null || children === undefined || !children.length > 0) { //FIXME: Indeed jshint\n                        callback(new Error('invalid children info found'));\n                    } else {\n                        var setChildJson = function (child, cb) {\n                            toJson(_core, child, urlPrefix, _refType, function (err, jChild) {\n                                if (err) {\n                                    cb(err);\n                                } else {\n                                    if (jChild) {\n                                        var childRelPath,\n                                            childPath = _core.getPath(child);\n                                        for (var j = 0; j < dumpObject.children.length; j++) {\n                                            if (childPath === getRefObjectPath(dumpObject.children[j])) {\n                                                childRelPath = relPath + '/children[' + j + ']';\n                                                _cache[childPath] = childRelPath;\n                                                dumpObject.children[j] = jChild;\n                                                break;\n                                            }\n                                        }\n                                        dumpChildren(child, dumpObject.children[j], urlPrefix, childRelPath, cb);\n                                    }\n                                }\n                            });\n                        };\n                        var error = null;\n\n                        for (var i = 0; i < children.length; i++) {\n                            setChildJson(children[i], function (err) {\n                                error = error || err;\n                                if (--needed === 0) {\n                                    callback(error);\n                                }\n                            }); //FIXME\n                        }\n                    }\n                }\n            });\n        } else {\n            callback(null);\n        }\n    };\n    var checkForInternalReferences = function (dumpObject) {\n        if (typeof dumpObject === 'object') {\n            for (var i in dumpObject) {\n                if (typeof dumpObject[i] === 'object') {\n                    if (isRefObject(dumpObject[i])) {\n                        var path = getRefObjectPath(dumpObject[i]);\n                        if (isSubordinate(path)) {\n                            refToRelRefObj(path, dumpObject[i]);\n                        }\n                    } else {\n                        checkForInternalReferences(dumpObject[i]);\n                    }\n                }\n            }\n        }\n    };\n\n    var dumpJsonNode = function (core, node, urlPrefix, refType, callback) {\n        _cache = {};\n        _core = core;\n        _rootPath = core.getPath(node);\n        _refType = refType;\n\n        //TODO this needs to be done in another way\n        toJson(core, node, urlPrefix, _refType, function (err, jDump) {\n            if (err) {\n                callback(err, null);\n            } else {\n                if (jDump) {\n                    _cache[_rootPath] = '#';\n                }\n                dumpChildren(node, jDump, urlPrefix, _cache[_rootPath], function (err) {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        checkForInternalReferences(jDump);\n                        callback(null, jDump);\n                    }\n                });\n            }\n        });\n    };\n\n    return dumpJsonNode;\n});\n\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * This import will only enter the outgoing relations and the internal ones.\n * This import will try to import an array of objects as well as a single object.\n * Although this import also assumes that there is no loop in the references so it can simply wait for\n *\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/copyimport',['common/core/users/meta'], function (BaseMeta) {\n    'use strict';\n    var _core = null,\n        _root = null,\n        _cache = {},\n        _underImport = {},\n        _internalRefHash = {},\n        META = new BaseMeta();\n\n    function internalRefCreated(intPath, node) {\n        _cache[_core.getPath(node)] = node;\n        _internalRefHash[intPath] = _core.getPath(node);\n        var callbacks = _underImport[intPath] || [];\n        delete _underImport[intPath];\n        for (var i = 0; i < callbacks.length; i++) {\n            callbacks[i](null, node);\n        }\n    }\n\n    function objectLoaded(error, node) {\n        if (error === null) {\n            _cache[_core.getPath(node)] = node;\n        }\n\n        var callbacks = _underImport[_core.getPath(node)] || [];\n        delete _underImport[_core.getPath(node)];\n        for (var i = 0; i < callbacks.length; i++) {\n            callbacks[i](error, node);\n        }\n    }\n\n    //function isInternalReference(refObj) {\n    //    if (refObj && typeof refObj.$ref === 'string') {\n    //        if (refObj.$ref.indexOf('#') === 0) {\n    //            return true;\n    //        }\n    //    }\n    //    return false;\n    //}\n\n    function getReferenceNode(refObj, callback) {\n        //we allow the internal references and the\n        if (refObj && typeof refObj.$ref === 'string') {\n            if (refObj.$ref.indexOf('#') === 0) {\n                //we assume that it is an internal reference\n                if (_internalRefHash[refObj.$ref] !== undefined) {\n                    callback(null, _cache[_internalRefHash[refObj.$ref]]);\n                } else if (_underImport[refObj.$ref] !== undefined) {\n                    _underImport[refObj.$ref].push(callback);\n                } else {\n                    //TODO we should check if the loading order is really finite this way\n                    _underImport[refObj.$ref] = [callback];\n                }\n            } else if (refObj.$ref === null) {\n                callback(null, null);\n            } else {\n                if (_cache[refObj.$ref]) {\n                    callback(null, _cache[refObj.$ref]);\n                } else if (_underImport[refObj.$ref]) {\n                    _underImport[refObj.$ref].push(callback);\n                } else {\n                    _underImport[refObj.$ref] = [callback];\n                    _core.loadByPath(_root, refObj.$ref, function (err, node) {\n                        if (err) {\n                            objectLoaded(err, null);\n                        } else {\n                            if (refObj.GUID) {\n                                if (refObj.GUID === _core.getGuid(node)) {\n                                    objectLoaded(err, node);\n                                } else {\n                                    objectLoaded('GUID mismatch', node);\n                                }\n                            } else {\n                                objectLoaded(err, node);\n                            }\n                        }\n                    });\n                }\n            }\n        } else {\n            callback(null, null);\n        }\n    }\n\n    function importChildren(node, jNode, pIntPath, callback) {\n        if (jNode && jNode.children && jNode.children.length) {\n            var needed = jNode.children.length;\n\n            if (needed > 0) {\n                var error = null;\n                for (var i = 0; i < jNode.children.length; i++) {\n                    importNode(jNode.children[i], node, pIntPath + '/children[' + i + ']', function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    }); //FIXME\n                }\n            } else {\n                callback(null);\n            }\n\n        } else {\n            callback(null); //TODO maybe we should be more strict\n        }\n    }\n\n    function importAttributes(node, jNode) {\n        if (typeof jNode.attributes === 'object') {\n            for (var i in jNode.attributes) {\n                _core.setAttribute(node, i, jNode.attributes[i]);\n            }\n        }\n    }\n\n    function importRegistry(node, jNode) {\n        if (typeof jNode.registry === 'object') {\n            for (var i in jNode.registry) {\n                _core.setRegistry(node, i, jNode.registry[i]);\n            }\n        }\n    }\n\n    function importPointer(node, jNode, pName, callback) {\n        if (jNode.pointers[pName].to && jNode.pointers[pName].to.length > 0) {\n            var needed = jNode.pointers[pName].to.length,\n                i,\n                error = null;\n\n            for (i = 0; i < jNode.pointers[pName].to.length; i++) {\n                getReferenceNode(jNode.pointers[pName].to[i], function (err, target) {\n                    error = error || err;\n                    if (target !== undefined) {\n                        _core.setPointer(node, pName, target);\n                    }\n\n                    if (--needed === 0) {\n                        callback(error);\n                    }\n                }); //FIXME\n            }\n\n        } else {\n            callback(null);\n        }\n    }\n\n    function importSet(node, jNode, sName, callback) {\n        if (jNode.pointers[sName].to && jNode.pointers[sName].to.length > 0) {\n            var needed = 0,\n                i,\n                key,\n                importSetRegAndAtr = function (sOwner, sMember, atrAndReg) {\n                    _core.addMember(sOwner, sName, sMember);\n                    var mPath = _core.getPath(sMember);\n                    atrAndReg.attributes = atrAndReg.attributes || {};\n                    for (key in atrAndReg.attributes) {\n                        _core.setMemberAttribute(sOwner, sName, mPath, key, atrAndReg.attributes[key]);\n                    }\n                    atrAndReg.registry = atrAndReg.registry || {};\n                    for (key in atrAndReg.registry) {\n                        _core.setMemberRegistry(sOwner, sName, mPath, key, atrAndReg.registry[key]);\n                    }\n                },\n                importSetReference = function (isTo, index, cb) {\n                    var jObj = isTo === true ? jNode.pointers[sName].to[index] : jNode.pointers[sName].from[index];\n                    getReferenceNode(jObj, function (err, sNode) {\n                        if (err) {\n                            cb(err);\n                        } else {\n                            if (sNode) {\n                                var sOwner = isTo === true ? node : sNode,\n                                    sMember = isTo === true ? sNode : node;\n                                importSetRegAndAtr(sOwner, sMember, jObj);\n                            }\n                            cb(null);\n                        }\n                    });\n                },\n                error = null;\n\n            _core.createSet(node, sName);\n            needed = jNode.pointers[sName].to.length;\n            for (i = 0; i < jNode.pointers[sName].to.length; i++) {\n                importSetReference(true, i, function (err) {\n                    error = error || err;\n                    if (--needed === 0) {\n                        callback(error);\n                    }\n                }); //FIXME\n            }\n        } else {\n            callback(null); //TODO now we just simply try to ignore faulty data import\n        }\n    }\n\n    //function _importSet(node, jNode, sName, callback) {\n    //    if (jNode.pointers[sName].to) {\n    //        var needed = 0,\n    //            importSetRegAndAtr = function (sOwner, sMember, atrAndReg) {\n    //                _core.addMember(sOwner, sName, sMember);\n    //                var mPath = _core.getPath(sMember);\n    //                atrAndReg.attributes = atrAndReg.attributes || {};\n    //                for (var i in atrAndReg.attributes) {\n    //                    _core.setMemberAttribute(sOwner, sName, mPath, i, atrAndReg.attributes[i]);\n    //                }\n    //                atrAndReg.registry = atrAndReg.registry || {};\n    //                for (var i in atrAndReg.registry) {\n    //                    _core.setMemberRegistry(sOwner, sName, mPath, i, atrAndReg.registry[i]);\n    //                }\n    //            },\n    //            importSetReference = function (isTo, index, cb) {\n    //                var jObj = isTo === true ? jNode.pointers[sName].to[index] : jNode.pointers[sName].from[index];\n    //                getReferenceNode(jObj, function (err, sNode) {\n    //                    if (err) {\n    //                        cb(err);\n    //                    } else {\n    //                        if (sNode) {\n    //                            var sOwner = isTo === true ? node : sNode,\n    //                                sMember = isTo === true ? sNode : node;\n    //                            importSetRegAndAtr(sOwner, sMember, jObj);\n    //                        }\n    //                        cb(null);\n    //                    }\n    //                });\n    //            },\n    //            error = null;\n    //\n    //        if (jNode.pointers[sName].to.length > 0) {\n    //            needed += jNode.pointers[sName].to.length;\n    //            _core.createSet(node, sName);\n    //        }\n    //\n    //        if (needed > 0) {\n    //            for (var i = 0; i < jNode.pointers[sName].to.length; i++) {\n    //                importSetReference(true, i, function (err) {\n    //                    error = error || err;\n    //                    if (--needed === 0) {\n    //                        callback(error);\n    //                    }\n    //                });\n    //            }\n    //        } else {\n    //            callback(null);\n    //        }\n    //    } else {\n    //        callback(null); //TODO now we just simply try to ignore faulty data import\n    //    }\n    //}\n\n    function importRelations(node, jNode, callback) {\n        //TODO now se use the pointer's 'set' attribute to decide if it is a set or a pointer really\n        var pointers = [],\n            sets = [],\n            needed = 0,\n            error = null,\n            i;\n        if (typeof jNode.pointers !== 'object') {\n            callback(null); //TODO should we drop an error???\n        } else {\n            for (i in jNode.pointers) {\n                if (jNode.pointers[i].set === true) {\n                    sets.push(i);\n                } else {\n                    pointers.push(i);\n                }\n            }\n\n            needed = sets.length + pointers.length;\n\n            if (needed > 0) {\n                for (i = 0; i < pointers.length; i++) {\n                    importPointer(node, jNode, pointers[i], function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n                for (i = 0; i < sets.length; i++) {\n                    importSet(node, jNode, sets[i], function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback(null);\n            }\n        }\n    }\n\n    function importMeta(node, jNode, callback) {\n\n        //TODO now this function searches the whole meta data for reference objects and load them, then call setMeta\n        var loadReference = function (refObj, cb) {\n                getReferenceNode(refObj, function (err, rNode) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        if (rNode) {\n                            refObj.$ref = _core.getPath(rNode);\n                        }\n                        cb(null);\n                    }\n                });\n            },\n            loadMetaReferences = function (jObject, cb) {\n                var needed = 0,\n                    i,\n                    error = null;\n                for (i in jObject) {\n                    if (jObject[i] !== null && typeof jObject[i] === 'object') {\n                        needed++;\n                    }\n                }\n\n                if (needed > 0) {\n                    for (i in jObject) {\n                        if (jObject[i] !== null && typeof jObject[i] === 'object') {\n                            if (jObject[i].$ref) {\n                                loadReference(jObject[i], function (err) {\n                                    error = error || err;\n                                    if (--needed === 0) {\n                                        cb(error);\n                                    }\n                                });\n                            } else {\n                                loadMetaReferences(jObject[i], function (err) {\n                                    error = error || err;\n                                    if (--needed === 0) {\n                                        cb(error);\n                                    }\n                                });\n                            }\n                        }\n                    }\n                } else {\n                    cb(error);\n                }\n            };\n\n        loadMetaReferences(jNode.meta || {}, function (err) {\n            if (err) {\n                callback(err);\n            } else {\n                META.setMeta(_core.getPath(node), jNode.meta || {});\n                callback(null);\n            }\n        });\n    }\n\n    function importRoot(jNode, callback) {\n        //first we create the root node itself, then the other parts of the function is pretty much like the importNode\n\n        _root = _core.createNode();\n        internalRefCreated('#', _root);\n        importAttributes(_root, jNode);\n        importRegistry(_root, jNode);\n        importChildren(_root, jNode, '#', function (err) {\n            if (err) {\n                callback(err);\n            } else {\n                importRelations(_root, jNode, function (err) {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        importMeta(_root, jNode, function (err) {\n                            callback(err, _root);\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    function importNode(jNode, parentNode, intPath, callback) {\n        //return callback('not implemented');\n        //first we have to get the base of the node\n        if (jNode.pointers && jNode.pointers.base && jNode.pointers.base.to) {\n            getReferenceNode(jNode.pointers.base.to[0], function (err, base) {\n                if (err) {\n                    callback(err);\n                } else {\n                    //now we are ready to create the node itself\n                    var node = _core.createNode({base: base, parent: parentNode});\n                    internalRefCreated(intPath, node);\n                    importAttributes(node, jNode);\n                    importRegistry(node, jNode);\n                    importChildren(node, jNode, intPath, function (err) {\n                        if (err) {\n                            callback(err);\n                        } else {\n                            importRelations(node, jNode, function (err) {\n                                if (err) {\n                                    callback(err);\n                                } else {\n                                    importMeta(node, jNode, callback);\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        } else {\n            callback('wrong import format: base info is wrong');\n        }\n    }\n\n    function importing(core, parent, jNode, callback) {\n        _core = core;\n        _cache = {};\n        _underImport = {};\n        _internalRefHash = {};\n        META.initialize(_core, _cache, function () {\n        });\n\n        if (jNode.length) {\n            //multiple objects\n            if (parent) {\n                var needed = jNode.length,\n                    error = null;\n                _cache[core.getPath(parent)] = parent;\n                _root = core.getRoot(parent);\n                for (var i = 0; i < jNode.length; i++) {\n                    importNode(jNode[i], parent, '#[' + i + ']', function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback('no parent given!!!');\n            }\n        } else {\n            //single object\n            if (parent) {\n                _cache[core.getPath(parent)] = parent;\n                _root = core.getRoot(parent);\n                importNode(jNode, parent, '#', callback);\n            } else {\n                importRoot(jNode, callback);\n            }\n        }\n    }\n\n    return importing;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * this type of import is for merge purposes\n * it tries to import not only the outgoing relations but the incoming ones as well\n * it also tries to keep both the GUID and the relid's\n * if it finds the same guid in the same place then it overwrites the node with the imported one!!!\n * it not searches for GUID!!! so be careful when to use this method\n *\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/import',['common/core/users/meta'], function (BaseMeta) {\n    'use strict';\n    var _core = null,\n        _root = null,\n        _cache = {},\n        _underImport = {},\n        _internalRefHash = {},\n        META = new BaseMeta();\n\n    function internalRefCreated(intPath, node) {\n        _cache[_core.getPath(node)] = node;\n        _internalRefHash[intPath] = _core.getPath(node);\n        var callbacks = _underImport[intPath] || [];\n        delete _underImport[intPath];\n        for (var i = 0; i < callbacks.length; i++) {\n            callbacks[i](null, node);\n        }\n    }\n\n    function objectLoaded(error, node) {\n        if (error === null) {\n            _cache[_core.getPath(node)] = node;\n        }\n\n        var callbacks = _underImport[_core.getPath(node)] || [];\n        delete _underImport[_core.getPath(node)];\n        for (var i = 0; i < callbacks.length; i++) {\n            callbacks[i](error, node);\n        }\n    }\n\n    function isInternalReference(refObj) {\n        if (refObj && typeof refObj.$ref === 'string') {\n            if (refObj.$ref.indexOf('#') === 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function getReferenceNode(refObj, callback) {\n        //we allow the internal references and the\n        if (refObj && typeof refObj.$ref === 'string') {\n            if (refObj.$ref.indexOf('#') === 0) {\n                //we assume that it is an internal reference\n                if (_internalRefHash[refObj.$ref] !== undefined) {\n                    callback(null, _cache[_internalRefHash[refObj.$ref]]);\n                } else if (_underImport[refObj.$ref] !== undefined) {\n                    _underImport[refObj.$ref].push(callback);\n                } else {\n                    //TODO we should check if the loading order is really finite this way\n                    _underImport[refObj.$ref] = [callback];\n                }\n            } else if (refObj.$ref === null) {\n                callback(null, null);\n            } else {\n                if (_cache[refObj.$ref]) {\n                    callback(null, _cache[refObj.$ref]);\n                } else if (_underImport[refObj.$ref]) {\n                    _underImport[refObj.$ref].push(callback);\n                } else {\n                    _underImport[refObj.$ref] = [callback];\n                    _core.loadByPath(_root, refObj.$ref, function (err, node) {\n                        if (err) {\n                            objectLoaded(err, null);\n                        } else {\n                            if (refObj.GUID) {\n                                if (refObj.GUID === _core.getGuid(node)) {\n                                    objectLoaded(err, node);\n                                } else {\n                                    objectLoaded('GUID mismatch', node);\n                                }\n                            } else {\n                                objectLoaded(err, node);\n                            }\n                        }\n                    });\n                }\n            }\n        } else {\n            callback(null, null);\n        }\n    }\n\n    function importChildren(node, jNode, pIntPath, callback) {\n        if (jNode && jNode.children && jNode.children.length) {\n            var needed = jNode.children.length;\n\n            if (needed > 0) {\n                var error = null;\n                for (var i = 0; i < jNode.children.length; i++) {\n                    importNode(jNode.children[i], node, pIntPath + '/children[' + i + ']', true, function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback(null);\n            }\n\n        } else {\n            callback(null); //TODO maybe we should be more strict\n        }\n    }\n\n    function importAttributes(node, jNode) {\n        if (typeof jNode.attributes === 'object') {\n            var names = Object.keys(jNode.attributes);\n            if (jNode.OWN) {\n                names = jNode.OWN.attributes;\n            }\n\n            for (var i = 0; i < names.length; i++) {\n                var value = jNode.attributes[names[i]];\n                if (value !== undefined) {\n                    _core.setAttribute(node, names[i], value);\n                }\n            }\n        }\n    }\n\n    function importRegistry(node, jNode) {\n        if (typeof jNode.registry === 'object') {\n            var names = Object.keys(jNode.registry);\n            if (jNode.OWN) {\n                names = jNode.OWN.registry;\n            }\n\n            for (var i = 0; i < names.length; i++) {\n                var value = jNode.registry[names[i]];\n                if (value !== undefined) {\n                    _core.setRegistry(node, names[i], value);\n                }\n            }\n        }\n    }\n\n    function importPointer(node, jNode, pName, callback) {\n        if (jNode.pointers[pName].to && jNode.pointers[pName].from) {\n            var needed = jNode.pointers[pName].to.length + jNode.pointers[pName].from.length,\n                i,\n                error = null;\n            var ownPointer = true;\n            if (jNode.OWN) {\n                if (jNode.OWN.pointers.indexOf(pName) === -1) {\n                    ownPointer = false;\n                    needed -= jNode.pointers[pName].to.length;\n                }\n            }\n            if (needed === 0) {\n                callback(null);\n            } else {\n                if (ownPointer) {\n                    for (i = 0; i < jNode.pointers[pName].to.length; i++) {\n                        getReferenceNode(jNode.pointers[pName].to[i], function (err, target) {\n                            error = error || err;\n                            _core.setPointer(node, pName, target);\n\n                            if (--needed === 0) {\n                                callback(error);\n                            }\n                        });\n                    }\n                }\n\n                for (i = 0; i < jNode.pointers[pName].from.length; i++) {\n                    if (!isInternalReference(jNode.pointers[pName].from[i])) {\n                        getReferenceNode(jNode.pointers[pName].from[i], function (err, source) {\n                            error = error || err;\n                            if (source) {\n                                _core.setPointer(source, pName, node);\n                            }\n\n                            if (--needed === 0) {\n                                callback(error);\n                            }\n                        });\n                    } else {\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    }\n                }\n            }\n        } else {\n            callback(null);\n        }\n    }\n\n    function importSet(node, jNode, sName, callback) {\n        if (jNode.pointers[sName].to && jNode.pointers[sName].from) {\n            var needed = 0,\n                i,\n                importSetRegAndAtr = function (sOwner, sMember, atrAndReg) {\n                    _core.addMember(sOwner, sName, sMember);\n                    var mPath = _core.getPath(sMember);\n                    atrAndReg.attributes = atrAndReg.attributes || {};\n                    for (i in atrAndReg.attributes) {\n                        _core.setMemberAttribute(sOwner, sName, mPath, i, atrAndReg.attributes[i]);\n                    }\n                    atrAndReg.registry = atrAndReg.registry || {};\n                    for (i in atrAndReg.registry) {\n                        _core.setMemberRegistry(sOwner, sName, mPath, i, atrAndReg.registry[i]);\n                    }\n                },\n                importSetReference = function (isTo, index, cb) {\n                    var jObj = isTo === true ? jNode.pointers[sName].to[index] : jNode.pointers[sName].from[index];\n                    getReferenceNode(jObj, function (err, sNode) {\n                        if (err) {\n                            cb(err);\n                        } else {\n                            if (sNode) {\n                                var sOwner = isTo === true ? node : sNode,\n                                    sMember = isTo === true ? sNode : node;\n                                importSetRegAndAtr(sOwner, sMember, jObj);\n                            }\n                            cb(null);\n                        }\n                    });\n                },\n                error = null;\n\n            if (jNode.pointers[sName].to.length > 0) {\n                needed += jNode.pointers[sName].to.length;\n                _core.createSet(node, sName);\n            }\n            if (jNode.pointers[sName].from.length > 0) {\n                needed += jNode.pointers[sName].from.length;\n            }\n\n            if (needed > 0) {\n                for (i = 0; i < jNode.pointers[sName].to.length; i++) {\n                    importSetReference(true, i, function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n                for (i = 0; i < jNode.pointers[sName].from.length; i++) {\n                    importSetReference(false, i, function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback(null);\n            }\n        } else {\n            callback(null); //TODO now we just simply try to ignore faulty data import\n        }\n    }\n\n    function importRelations(node, jNode, callback) {\n        //TODO now se use the pointer's 'set' attribute to decide if it is a set or a pointer really\n        var pointers = [],\n            sets = [],\n            needed = 0,\n            error = null,\n            i;\n        if (typeof jNode.pointers !== 'object') {\n            callback(null); //TODO should we drop an error???\n        } else {\n            for (i in jNode.pointers) {\n                if (jNode.pointers[i].set === true) {\n                    sets.push(i);\n                } else {\n                    pointers.push(i);\n                }\n            }\n\n            needed = sets.length + pointers.length;\n\n            if (needed > 0) {\n                for (i = 0; i < pointers.length; i++) {\n                    importPointer(node, jNode, pointers[i], function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n                for (i = 0; i < sets.length; i++) {\n                    importSet(node, jNode, sets[i], function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback(null);\n            }\n        }\n    }\n\n    function importMeta(node, jNode, callback) {\n        //TODO now this function searches the whole meta data for reference objects and load them, then call setMeta\n        var loadReference = function (refObj, cb) {\n                getReferenceNode(refObj, function (err, rNode) {\n                    if (err) {\n                        cb(err);\n                    } else {\n                        if (rNode) {\n                            refObj.$ref = _core.getPath(rNode);\n                        }\n                        cb(null);\n                    }\n                });\n            },\n            loadMetaReferences = function (jObject, cb) {\n                var needed = 0,\n                    i,\n                    error = null;\n                for (i in jObject) {\n                    if (jObject[i] !== null && typeof jObject[i] === 'object') {\n                        needed++;\n                    }\n                }\n\n                if (needed > 0) {\n                    for (i in jObject) {\n                        if (jObject[i] !== null && typeof jObject[i] === 'object') {\n                            if (jObject[i].$ref) {\n                                loadReference(jObject[i], function (err) {\n                                    error = error || err;\n                                    if (--needed === 0) {\n                                        cb(error);\n                                    }\n                                });\n                            } else {\n                                loadMetaReferences(jObject[i], function (err) {\n                                    error = error || err;\n                                    if (--needed === 0) {\n                                        cb(error);\n                                    }\n                                });\n                            }\n                        }\n                    }\n                } else {\n                    cb(error);\n                }\n            };\n\n        loadMetaReferences(jNode.meta || {}, function (err) {\n            if (err) {\n                callback(err);\n            } else {\n                META.setMeta(_core.getPath(node), jNode.meta || {});\n                callback(null);\n            }\n        });\n    }\n\n    function importRoot(jNode, callback) {\n        //first we create the root node itself, then the other parts of the function is pretty much like the importNode\n        _root = _core.createNode({guid: jNode.GUID});\n        internalRefCreated('#', _root);\n        importAttributes(_root, jNode);\n        importRegistry(_root, jNode);\n        importChildren(_root, jNode, '#', function (err) {\n            if (err) {\n                callback(err);\n            } else {\n                importRelations(_root, jNode, function (err) {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        importMeta(_root, jNode, function (err) {\n                            callback(err, _root);\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    //function clearOldNode(relid, guid, parentNode, callback) {\n    //    var relids = _core.getChildrenRelids(parentNode);\n    //    if (relids.indexOf(relid) !== -1) {\n    //        _core.loadChild(parentNode, relid, function (err, oldChild) {\n    //            if (err) {\n    //                callback(err);\n    //            } else {\n    //                if (_core.getGuid(oldChild) === guid) {\n    //                    var root = _core.getRoot(oldChild);\n    //                    _core.deleteNode(oldChild);\n    //                    _core.persist(root, function () {\n    //                        callback(null);\n    //                    });\n    //                } else {\n    //                    callback(null);\n    //                }\n    //            }\n    //        });\n    //    } else {\n    //        callback(null);\n    //    }\n    //}\n\n    function getEmptyNode(jNode, parentNode, baseNode, noClear, callback) {\n        var relids = _core.getChildrenRelids(parentNode),\n            returnNewNode = function () {\n                var node = _core.createNode({base: baseNode, parent: parentNode, relid: jNode.RELID, guid: jNode.GUID});\n                callback(null, node);\n            };\n        if (relids.indexOf(jNode.RELID) !== -1) {\n            _core.loadChild(parentNode, jNode.RELID, function (err, oldChild) {\n                if (err) {\n                    callback(err, null);\n                } else {\n                    if (_core.getGuid(oldChild) === jNode.GUID) {\n                        if (noClear === true) {\n                            callback(null, oldChild);\n                        } else {\n                            var root = _core.getRoot(oldChild);\n                            _core.deleteNode(oldChild);\n                            _core.persist(root, function () {\n                                returnNewNode();\n                            });\n                        }\n                    } else {\n                        returnNewNode();\n                    }\n                }\n            });\n        } else {\n            returnNewNode();\n        }\n    }\n\n    function importNode(jNode, parentNode, intPath, noClear, callback) {\n        //first we have to get the base of the node\n        if (jNode.pointers && jNode.pointers.base && jNode.pointers.base.to) {\n            getReferenceNode(jNode.pointers.base.to[0], function (err, base) {\n                if (err) {\n                    callback(err);\n                } else {\n                    getEmptyNode(jNode, parentNode, base, noClear, function (err, node) {\n                        if (err) {\n                            callback(err);\n                        } else {\n                            internalRefCreated(intPath, node);\n                            importAttributes(node, jNode);\n                            importRegistry(node, jNode);\n                            importChildren(node, jNode, intPath, function (err) {\n                                if (err) {\n                                    callback(err);\n                                } else {\n                                    importRelations(node, jNode, function (err) {\n                                        if (err) {\n                                            callback(err);\n                                        } else {\n                                            importMeta(node, jNode, function (err) {\n                                                callback(err);\n                                            });\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n            });\n        } else {\n            callback('wrong import format: base info is wrong');\n        }\n    }\n\n    function importing(core, parent, jNode, callback) {\n        _core = core;\n        _cache = {};\n        _underImport = {};\n        _internalRefHash = {};\n        META.initialize(_core, _cache, function () {\n        });\n\n        if (jNode.length) {\n            //multiple objects\n            if (parent) {\n                var needed = jNode.length,\n                    error = null;\n                _cache[core.getPath(parent)] = parent;\n                _root = core.getRoot(parent);\n                for (var i = 0; i < jNode.length; i++) {\n                    importNode(jNode[i], parent, '#[' + i + ']', false, function (err) {\n                        error = error || err;\n                        if (--needed === 0) {\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback('no parent given!!!');\n            }\n        } else {\n            //single object\n            if (parent) {\n                _cache[core.getPath(parent)] = parent;\n                _root = core.getRoot(parent);\n                importNode(jNode, parent, '#', false, callback);\n            } else {\n                importRoot(jNode, callback);\n            }\n        }\n    }\n\n    return importing;\n});\n\n\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('client/js/client/requests',['common/util/assert',\n    'common/core/users/serialization',\n    'common/core/users/dump',\n    'common/core/users/copyimport',\n    'common/core/users/import',\n    'common/util/url'\n], function (ASSERT,\n             Serialization,\n             dump,\n             importing,\n             mergeImport,\n             URL) {\n    'use strict';\n    var ROOT_PATH = '';\n\n    function Requests(_clientGlobal) {\n        function getAvailableProjectsAsync(callback) {\n            if (_clientGlobal.db) {\n                _clientGlobal.db.getProjectNames(callback);\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function getViewableProjectsAsync(callback) {\n            if (_clientGlobal.db) {\n                _clientGlobal.db.getAllowedProjectNames(callback);\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function getProjectAuthInfoAsync(projectname, callback) {\n            if (_clientGlobal.db) {\n                _clientGlobal.db.getAuthorizationInfo(projectname, callback);\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function getFullProjectListAsync(callback) {\n            _clientGlobal.db.getProjectNames(function (err, names) {\n                var wait,\n                    fullList = {},\n                    getProjectAuthInfo,\n                    i,\n                    projectAuthInfoResponse = function (/*err*/) {\n                        wait -= 1;\n                        if (wait === 0) {\n                            callback(null, fullList);\n                        }\n                    };\n\n                if (!err && names) {\n                    wait = names.length || 0;\n                    if (wait > 0) {\n                        getProjectAuthInfo = function (name, cb) {\n                            _clientGlobal.db.getAuthorizationInfo(name, function (err, authObj) {\n                                if (!err && authObj) {\n                                    fullList[name] = authObj;\n                                }\n                                cb(err);\n                            });\n                        };\n\n                        for (i = 0; i < names.length; i += 1) {\n                            getProjectAuthInfo(names[i], projectAuthInfoResponse);\n                        }\n                    } else {\n                        callback(null, {});\n                    }\n                } else {\n                    callback(err, {});\n                }\n            });\n        }\n\n        function getFullProjectsInfoAsync(callback) {\n            _clientGlobal.db.simpleRequest({command: 'getAllProjectsInfo'}, function (err, id) {\n                if (err) {\n                    return callback(err);\n                }\n                _clientGlobal.db.simpleResult(id, callback);\n            });\n        }\n\n        function setProjectInfoAsync(projectId, info, callback) {\n            _clientGlobal.db.simpleRequest({\n                    command: 'setProjectInfo',\n                    projectId: projectId,\n                    info: info\n                },\n                function (err, rId) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    _clientGlobal.db.simpleResult(rId, callback);\n                });\n        }\n\n        function getProjectInfoAsync(projectId, callback) {\n            _clientGlobal.db.simpleRequest({command: 'getProjectInfo', projectId: projectId}, function (err, rId) {\n                if (err) {\n                    return callback(err);\n                }\n                _clientGlobal.db.simpleResult(rId, callback);\n            });\n        }\n\n        function getAllInfoTagsAsync(callback) {\n            _clientGlobal.db.simpleRequest({command: 'getAllInfoTags'}, function (err, rId) {\n                if (err) {\n                    return callback(err);\n                }\n                _clientGlobal.db.simpleResult(rId, callback);\n            });\n        }\n\n        function createGenericBranchAsync(project, branch, commit, callback) {\n            _clientGlobal.db.simpleRequest({\n                    command: 'setBranch',\n                    project: project,\n                    branch: branch,\n                    old: '',\n                    new: commit\n                },\n                function (err, id) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    _clientGlobal.db.simpleResult(id, callback);\n                });\n        }\n\n        function deleteGenericBranchAsync(project, branch, commit, callback) {\n            _clientGlobal.db.simpleRequest({\n                    command: 'setBranch',\n                    project: project,\n                    branch: branch,\n                    old: commit,\n                    new: ''\n                },\n                function (err, id) {\n                    if (err) {\n                        return callback(err);\n                    }\n                    _clientGlobal.db.simpleResult(id, callback);\n                });\n        }\n\n        function getDumpURL(parameters) {\n            parameters.output = parameters.output || 'dump_url.out';\n            return plainUrl(parameters);\n        }\n\n        function createEmptyProject(project, callback) {\n            var core = _clientGlobal.functions.getNewCore(project,\n                    _clientGlobal.gmeConfig, _clientGlobal.logger.fork('createEmptyProject')),\n                root = core.createNode(),\n                rootHash = '',\n                commitHash = '';\n            core.persist(root, function (/* err */) {\n                rootHash = core.getHash(root);\n                commitHash = project.makeCommit([], rootHash, 'project creation commit', function (/* err */) {\n                    project.setBranchHash('master', '', commitHash, function (err) {\n                        callback(err, commitHash);\n                    });\n                });\n            });\n\n        }\n\n        function exportItems(paths, callback) {\n            var nodes = [];\n            for (var i = 0; i < paths.length; i++) {\n                if (_clientGlobal.nodes[paths[i]]) {\n                    nodes.push(_clientGlobal.nodes[paths[i]].node);\n                } else {\n                    callback('invalid node');\n                    return;\n                }\n            }\n\n            _clientGlobal.db.simpleRequest({\n                    command: 'dumpMoreNodes',\n                    name: _clientGlobal.projectName,\n                    hash: _clientGlobal.root.current || _clientGlobal.core.getHash(_clientGlobal.nodes[ROOT_PATH].node),\n                    nodes: paths\n                },\n                function (err, resId) {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        _clientGlobal.db.simpleResult(resId, callback);\n                    }\n                });\n        }\n\n        function getExportItemsUrlAsync(paths, filename, callback) {\n            _clientGlobal.db.simpleRequest({\n                    command: 'dumpMoreNodes',\n                    name: _clientGlobal.projectName,\n                    hash: _clientGlobal.root.current || _clientGlobal.core.getHash(_clientGlobal.nodes[ROOT_PATH].node),\n                    nodes: paths\n                },\n                function (err, resId) {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        callback(null,\n                            window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' +\n                            resId + '/' + filename);\n                    }\n                });\n        }\n\n        function getExportLibraryUrlAsync(libraryRootPath, filename, callback) {\n            var command = {};\n            command.command = 'exportLibrary';\n            command.name = _clientGlobal.projectName;\n            command.hash = _clientGlobal.root.current ||\n                _clientGlobal.core.getHash(_clientGlobal.nodes[ROOT_PATH].node);\n            command.path = libraryRootPath;\n            if (command.name && command.hash) {\n                _clientGlobal.db.simpleRequest(command, function (err, resId) {\n                    if (err) {\n                        callback(err);\n                    } else {\n                        callback(null,\n                            window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' +\n                            resId + '/' + filename);\n                    }\n                });\n            } else {\n                callback(new Error('there is no open project!'));\n            }\n        }\n\n        function updateLibraryAsync(libraryRootPath, newLibrary, callback) {\n            Serialization.import(_clientGlobal.core,\n                _clientGlobal.nodes[libraryRootPath].node, newLibrary, function (err, log) {\n                    if (err) {\n                        return callback(err);\n                    }\n\n                    _clientGlobal.functions.saveRoot('library update done\\nlogs:\\n' + log, callback);\n                }\n            );\n        }\n\n        function addLibraryAsync(libraryParentPath, newLibrary, callback) {\n            _clientGlobal.functions.startTransaction('creating library as a child of ' + libraryParentPath);\n            var libraryRoot = _clientGlobal.nodeSetter.createChild({\n                parentId: libraryParentPath,\n                baseId: null\n            }, 'library placeholder');\n            Serialization.import(_clientGlobal.core,\n                _clientGlobal.nodes[libraryRoot].node, newLibrary, function (err, log) {\n                    if (err) {\n                        return callback(err);\n                    }\n\n                    _clientGlobal.functions.completeTransaction('library update done\\nlogs:\\n' + log, callback);\n                }\n            );\n        }\n\n        function dumpNodeAsync(path, callback) {\n            if (_clientGlobal.nodes[path]) {\n                dump(_clientGlobal.core, _clientGlobal.nodes[path].node, '', 'guid', callback);\n            } else {\n                callback('unknown object', null);\n            }\n        }\n\n        function importNodeAsync(parentPath, jNode, callback) {\n            var node = null;\n            if (_clientGlobal.nodes[parentPath]) {\n                node = _clientGlobal.nodes[parentPath].node;\n            }\n            importing(_clientGlobal.core, _clientGlobal.nodes[parentPath].node, jNode, function (err) {\n                if (err) {\n                    callback(err);\n                } else {\n                    _clientGlobal.functions.saveRoot('importNode under ' + parentPath, callback);\n                }\n            });\n        }\n\n        function mergeNodeAsync(parentPath, jNode, callback) {\n            var node = null;\n            if (_clientGlobal.nodes[parentPath]) {\n                node = _clientGlobal.nodes[parentPath].node;\n            }\n            mergeImport(_clientGlobal.core, _clientGlobal.nodes[parentPath].node, jNode, function (err) {\n                if (err) {\n                    callback(err);\n                } else {\n                    _clientGlobal.functions.saveRoot('importNode under ' + parentPath, callback);\n                }\n            });\n        }\n\n        function createProjectFromFileAsync(projectname, jProject, callback) {\n            //TODO somehow the export / import should contain the INFO field\n            // so the tags and description could come from it\n            createProjectAsync(projectname, {}, function (/*err*/) {\n                selectProjectAsync(projectname, function (/*err*/) {\n                    Serialization.import(_clientGlobal.core, _clientGlobal.root.object, jProject, function (err) {\n                        if (err) {\n                            return callback(err);\n                        }\n\n                        _clientGlobal.functions.saveRoot('library has been updated...', callback);\n                    });\n                });\n            });\n        }\n\n        function selectProjectAsync(projectname, callback) {\n            if (_clientGlobal.db) {\n                if (projectname === _clientGlobal.projectName) {\n                    callback(null);\n                } else {\n                    _clientGlobal.functions.closeOpenedProject(function (/*err*/) {\n                        //TODO what can we do with the error??\n                        _clientGlobal.functions.openProject(projectname, function (err) {\n                            //TODO is there a meaningful error which we should propagate towards user???\n                            if (!err) {\n                                _clientGlobal.functions.reLaunchUsers();\n                            }\n                            callback(err);\n                        });\n                    });\n                }\n            } else {\n                callback(new Error('there is no open database connection!!!'));\n            }\n        }\n\n        function plainUrl(parameters) {\n            //setting the default values\n            parameters.command = parameters.command || 'etf';\n            parameters.path = parameters.path || '';\n            parameters.project = parameters.project || _clientGlobal.projectName;\n\n            if (!parameters.root && !parameters.branch && !parameters.commit) {\n                if (_clientGlobal.root.current) {\n                    parameters.root = _clientGlobal.root.current;\n                } else if (_clientGlobal.nodes && _clientGlobal.nodes[ROOT_PATH]) {\n                    parameters.root = _clientGlobal.core.getHash(_clientGlobal.nodes[ROOT_PATH].node);\n                } else {\n                    parameters.branch = _clientGlobal.branch || 'master';\n                }\n            }\n\n            //now we compose the URL\n            if (window && window.location) {\n                var address = window.location.protocol + '//' + window.location.host + '/rest/' +\n                    parameters.command + '?';\n                address += '&project=' + URL.addSpecialChars(parameters.project);\n                if (parameters.root) {\n                    address += '&root=' + URL.addSpecialChars(parameters.root);\n                } else {\n                    if (parameters.commit) {\n                        address += '&commit=' + URL.addSpecialChars(parameters.commit);\n                    } else {\n                        address += '&branch=' + URL.addSpecialChars(parameters.branch);\n                    }\n                }\n\n                address += '&path=' + URL.addSpecialChars(parameters.path);\n\n                if (parameters.output) {\n                    address += '&output=' + URL.addSpecialChars(parameters.output);\n                }\n\n                return address;\n            }\n\n            return null;\n\n        }\n\n        function createProjectAsync(projectname, projectInfo, callback) {\n            if (_clientGlobal.db) {\n                getAvailableProjectsAsync(function (err, names) {\n                    if (!err && names) {\n                        if (names.indexOf(projectname) === -1) {\n                            _clientGlobal.db.openProject(projectname, function (err, p) {\n                                if (!err && p) {\n                                    createEmptyProject(p, function (err, commit) {\n                                        if (!err && commit) {\n                                            //TODO currently this is just a hack\n                                            p.setInfo(projectInfo || {\n                                                    visibleName: projectname,\n                                                    description: 'project in webGME',\n                                                    tags: {}\n                                                }, function (err) {\n                                                callback(err);\n                                            });\n                                        } else {\n                                            callback(err);\n                                        }\n                                    });\n                                } else {\n                                    callback(err);\n                                }\n                            });\n                        } else {\n                            //TODO maybe the selectProjectAsync could be called :)\n                            callback('the project already exists!');\n                        }\n                    } else {\n                        callback(err);\n                    }\n                });\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n\n        }\n\n        function deleteProjectAsync(projectname, callback) {\n            if (_clientGlobal.db) {\n                if (projectname === _clientGlobal.projectName) {\n                    _clientGlobal.functions.closeOpenedProject();\n                }\n                _clientGlobal.db.deleteProject(projectname, callback);\n\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        //branching functionality\n        function getBranchesAsync(callback) {\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                    _clientGlobal.project.getBranchNames(function (err, names) {\n                        var missing = 0,\n                            branchArray = [],\n                            error = null,\n                            getBranchValues,\n                            i,\n                            element;\n\n                        if (!err && names) {\n                            getBranchValues = function (name) {\n                                _clientGlobal.project.getBranchHash(name, '#hack', function (err, newhash, forked) {\n                                    if (!err && newhash) {\n                                        element = {name: name, commitId: newhash};\n                                        if (forked) {\n                                            element.sync = false;\n                                        } else {\n                                            element.sync = true;\n                                        }\n                                        branchArray.push(element);\n                                    } else {\n                                        error = error || err;\n                                    }\n\n                                    missing -= 1;\n                                    if (missing === 0) {\n                                        callback(error, branchArray);\n                                    }\n                                });\n                            };\n\n                            for (i in names) {\n                                missing += 1;\n                            }\n\n                            if (missing > 0) {\n                                for (i in names) {\n                                    getBranchValues(i);\n                                }\n                            } else {\n                                callback(null, branchArray);\n                            }\n                        } else {\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no opened database connection!'));\n            }\n        }\n\n        function selectCommitAsync(hash, callback) {\n            //this should proxy to branch selection and viewer functions\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                    _clientGlobal.functions.viewerCommit(hash, callback);\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function selectBranchAsync(branch, callback) {\n            var waiting = 1,\n                error = null,\n                innerCallback = function (err) {\n                    error = error || err;\n                    if (--waiting === 0) {\n                        callback(error);\n                    }\n                };\n\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                            _clientGlobal.addOn.stopRunningAddOns();\n                            _clientGlobal.functions.branchWatcher(branch, innerCallback);\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function getCommitsAsync(commitHash, number, callback) {\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                    ASSERT(_clientGlobal.commitCache);\n                    if (commitHash === undefined) {\n                        commitHash = null;\n                    }\n                    _clientGlobal.commitCache.getNCommitsFrom(commitHash, number, callback);\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function createBranchAsync(branchName, commitHash, callback) {\n            //it doesn't changes anything, just creates the new branch\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                    _clientGlobal.project.setBranchHash(branchName, '', commitHash, callback);\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        function deleteBranchAsync(branchName, callback) {\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                    _clientGlobal.project.getBranchHash(branchName, '', function (err, newhash, forkedhash) {\n                        if (!err && newhash) {\n                            if (forkedhash) {\n                                _clientGlobal.project.setBranchHash(branchName, newhash, forkedhash, function (err) {\n                                    if (!err) {\n                                        _clientGlobal.functions.changeBranchState(_clientGlobal.branchStates.SYNC);\n                                    }\n                                    callback(err);\n                                });\n                            } else {\n                                _clientGlobal.project.setBranchHash(branchName, newhash, '', callback);\n                            }\n                        } else {\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n        return {\n            getAvailableProjectsAsync: getAvailableProjectsAsync,\n            getViewableProjectsAsync: getViewableProjectsAsync,\n            getFullProjectListAsync: getFullProjectListAsync,\n            getProjectAuthInfoAsync: getProjectAuthInfoAsync,\n            createProjectAsync: createProjectAsync,\n            selectProjectAsync: selectProjectAsync,\n            deleteProjectAsync: deleteProjectAsync,\n            getBranchesAsync: getBranchesAsync,\n            selectCommitAsync: selectCommitAsync,\n            getCommitsAsync: getCommitsAsync,\n            createBranchAsync: createBranchAsync,\n            deleteBranchAsync: deleteBranchAsync,\n            selectBranchAsync: selectBranchAsync,\n//JSON functions\n            exportItems: exportItems,\n            getExportItemsUrlAsync: getExportItemsUrlAsync,\n            //getExternalInterpreterConfigUrlAsync: getExternalInterpreterConfigUrlAsync,\n            dumpNodeAsync: dumpNodeAsync,\n            importNodeAsync: importNodeAsync,\n            mergeNodeAsync: mergeNodeAsync,\n            createProjectFromFileAsync: createProjectFromFileAsync,\n            getDumpURL: getDumpURL,\n            getExportLibraryUrlAsync: getExportLibraryUrlAsync,\n            updateLibraryAsync: updateLibraryAsync,\n            addLibraryAsync: addLibraryAsync,\n            getFullProjectsInfoAsync: getFullProjectsInfoAsync,\n            createGenericBranchAsync: createGenericBranchAsync,\n            deleteGenericBranchAsync: deleteGenericBranchAsync,\n            setProjectInfoAsync: setProjectInfoAsync,\n            getProjectInfoAsync: getProjectInfoAsync,\n            getAllInfoTagsAsync: getAllInfoTagsAsync\n        };\n    }\n\n    return Requests;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('client/js/client/index',[\n    'common/util/assert',\n    'common/EventDispatcher',\n    'common/util/guid',\n    'common/core/core',\n    'common/storage/clientstorage',\n    'js/logger',\n    'common/util/url',\n    'common/core/users/meta',\n    'common/core/users/tojson',\n    'common/core/tasync',\n    'superagent',\n    './undoredo',\n    './gmeNodeGetter',\n    './gmeNodeSetter',\n    './commitCache',\n    './serverEventer',\n    './addon',\n    './requests'\n], function (ASSERT,\n             EventDispatcher,\n             GUID,\n             Core,\n             Storage,\n             Logger,\n             URL,\n             BaseMeta,\n             toJson,\n             TASYNC,\n             superagent,\n             UndoRedo,\n             getNode,\n             gmeNodeSetter,\n             createCommitCache,\n             serverEventer,\n             createAddOn,\n             Requests) {\n\n    'use strict';\n\n    var ROOT_PATH = '';\n\n    function COPY(object) {\n        if (object) {\n            return JSON.parse(JSON.stringify(object));\n        }\n        return null;\n    }\n\n\n    function getNewCore(project, gmeConfig, logger) {\n        //return new NullPointerCore(new DescriptorCore(new SetCore(new GuidCore(new Core(project)))));\n        // FIXME: why usertype is nodejs when it is running from the browser?\n        var options = {usertype: 'nodejs', globConf: gmeConfig, logger: logger.fork('core')};\n        return new Core(project, options);\n    }\n\n    function Client(gmeConfig) {\n\n        function storeNode(node /*, basic */) {\n            var path;\n            //basic = basic || true;\n            if (node) {\n                path = _clientGlobal.core.getPath(node);\n                _metaNodes[path] = node;\n                if (_clientGlobal.nodes[path]) {\n                    //TODO we try to avoid this\n                } else {\n                    _clientGlobal.nodes[path] = {node: node, hash: ''/*,incomplete:true,basic:basic*/};\n                    //TODO this only needed when real eventing will be reintroduced\n                    //_inheritanceHash[path] = getInheritanceChain(node);\n                }\n                return path;\n            }\n            return null;\n        }\n\n        function saveRoot(msg, callback) {\n            var newRootHash,\n                newCommitHash;\n\n            callback = callback || function () {\n                };\n            if (!_viewer && !_readOnlyProject) {\n                if (_msg) {\n                    _msg += '\\n' + msg;\n                } else {\n                    _msg += msg;\n                }\n                if (!_inTransaction) {\n                    ASSERT(_clientGlobal.project && _clientGlobal.core && _clientGlobal.branch);\n                    _clientGlobal.core.persist(_clientGlobal.nodes[ROOT_PATH].node, function (/*err*/) {\n                    });\n                    newRootHash = _clientGlobal.core.getHash(_clientGlobal.nodes[ROOT_PATH].node);\n                    newCommitHash = _clientGlobal.project.makeCommit([_recentCommits[0]],\n                        newRootHash, _msg, function (/*err*/) {\n                            //TODO now what??? - could we end up here?\n                        });\n                    _msg = '';\n                    addCommit(newCommitHash);\n                    _selfCommits[newCommitHash] = true;\n                    _redoer.addModification(newCommitHash, '');\n                    _clientGlobal.project.setBranchHash(_clientGlobal.branch,\n                        _recentCommits[1], _recentCommits[0], function (err) {\n                            //TODO now what??? - could we screw up?\n                            loading(newRootHash);\n                            callback(err);\n                        });\n                    //loading(newRootHash);\n                }\n            } else {\n                _msg = '';\n                callback(null);\n            }\n        }\n\n        function closeOpenedProject(callback) {\n            var returning,\n                project;\n\n            callback = callback || function () {\n                };\n            returning = function (e) {\n                var oldProjName = _clientGlobal.projectName;\n                _clientGlobal.projectName = null;\n                _inTransaction = false;\n                _clientGlobal.core = null;\n                _clientGlobal.nodes = {};\n                _metaNodes = {};\n                //_commitObject = null;\n                _patterns = {};\n                _msg = '';\n                _recentCommits = [];\n                _clientGlobal.root.current = null;\n                _clientGlobal.root.previous = null;\n                _viewer = false;\n                _readOnlyProject = false;\n                _loadNodes = {};\n                _loadError = 0;\n                _offline = false;\n                cleanUsersTerritories();\n                if (oldProjName) {\n                    //otherwise there were no open project at all\n                    _self.dispatchEvent(_self.events.PROJECT_CLOSED, oldProjName);\n                }\n\n                callback(e);\n            };\n            if (_clientGlobal.branch) {\n                //otherwise the branch will not 'change'\n                _self.dispatchEvent(_self.events.BRANCH_CHANGED, null);\n            }\n            _clientGlobal.branch = null;\n            if (_clientGlobal.project) {\n                project = _clientGlobal.project;\n                _clientGlobal.project = null;\n                project.closeProject(function (err) {\n                    //TODO what if for some reason we are in transaction???\n                    returning(err);\n                });\n            } else {\n                returning(null);\n            }\n        }\n\n        function viewerCommit(hash, callback) {\n            //no project change\n            //we stop watching branch\n            //we create the core\n            //we use the existing territories\n            //we set viewer mode, so there will be no modification allowed to send to server...\n            _clientGlobal.branch = null;\n            _viewer = true;\n            _recentCommits = [hash];\n            _self.dispatchEvent(_self.events.BRANCH_CHANGED, _clientGlobal.branch);\n            _clientGlobal.project.loadObject(hash, function (err, commitObj) {\n                if (!err && commitObj) {\n                    loading(commitObj.root, callback);\n                } else {\n                    logger.error('Cannot view given ' + hash + ' commit as it\\'s root cannot be loaded! [' +\n                        JSON.stringify(err) + ']');\n                    callback(err || new Error('commit object cannot be found!'));\n                }\n            });\n        }\n\n        function startTransaction(msg) {\n            if (_clientGlobal.core) {\n                _inTransaction = true;\n                msg = msg || 'startTransaction()';\n                saveRoot(msg);\n            }\n        }\n\n        function completeTransaction(msg, callback) {\n            _inTransaction = false;\n            if (_clientGlobal.core) {\n                msg = msg || 'completeTransaction()';\n                saveRoot(msg, callback);\n            }\n        }\n\n        function branchWatcher(branch, callback) {\n            ASSERT(_clientGlobal.project);\n            callback = callback || function () {\n                };\n            var myCallback = function (err) {\n                myCallback = function () {\n                };\n                callback(err);\n            };\n            var redoerNeedsClean = true;\n            var branchHashUpdated = function (err, newhash, forked) {\n                var doUpdate = false;\n                if (branch === _clientGlobal.branch && !_offline) {\n                    if (!err && typeof newhash === 'string') {\n                        if (newhash === '') {\n                            logger.warn('The current branch ' + branch + ' have been deleted!');\n                            //we should open a viewer with our current commit...\n                            var latestCommit = _recentCommits[0];\n                            viewerCommit(latestCommit, function (err) {\n                                if (err) {\n                                    logger.error('Current branch ' + branch +\n                                        ' have been deleted, and unable to open the latest commit ' +\n                                        latestCommit + '! [' + JSON.stringify(err) + ']');\n                                }\n                            });\n                        } else {\n                            if (_redoer.isCurrentTarget(newhash)) {\n                                addCommit(newhash);\n                                doUpdate = true;\n                            } else if (!_selfCommits[newhash] || redoerNeedsClean) {\n                                redoerNeedsClean = false;\n                                _redoer.clean();\n                                _redoer.addModification(newhash, 'branch initial');\n                                _selfCommits = {};\n                                _selfCommits[newhash] = true;\n                                doUpdate = true;\n                                addCommit(newhash);\n                            }\n                            var redoInfo = _redoer.checkStatus(),\n                                canUndo = false,\n                                canRedo = false;\n\n                            if (_selfCommits[newhash]) {\n                                if (redoInfo.undo) {\n                                    canUndo = true;\n                                }\n                                if (redoInfo.redo) {\n                                    canRedo = true;\n                                }\n                            }\n\n                            _self.dispatchEvent(_self.events.UNDO_AVAILABLE, canUndo);\n                            _self.dispatchEvent(_self.events.REDO_AVAILABLE, canRedo);\n\n                            if (doUpdate) {\n                                _clientGlobal.project.loadObject(newhash, function (err, commitObj) {\n                                    if (!err && commitObj) {\n                                        loading(commitObj.root, myCallback);\n                                    } else {\n                                        setTimeout(function () {\n                                            _clientGlobal.project.loadObject(newhash, function (err, commitObj) {\n                                                if (!err && commitObj) {\n                                                    loading(commitObj.root, myCallback);\n                                                } else {\n                                                    logger.error('second load try failed on commit!!!', err);\n                                                }\n                                            });\n                                        }, 1000);\n                                    }\n                                });\n                            }\n\n                            //branch status update\n                            if (_offline) {\n                                changeBranchState(_self.branchStates.OFFLINE);\n                            } else {\n                                if (forked) {\n                                    changeBranchState(_self.branchStates.FORKED);\n                                }\n                            }\n\n                            //FIXME should kill the branch watcher gracefully as it is possible now to get a callback,\n                            // but the branch is already closed here - actually the whole project is closed\n                            return (branch === _clientGlobal.branch &&\n                            _clientGlobal.db &&\n                            _clientGlobal.project) ? _clientGlobal.project.getBranchHash(branch,\n                                _recentCommits[0],\n                                branchHashUpdated) : null;\n                        }\n                    } else {\n                        myCallback(null);\n                        return _clientGlobal.project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\n                    }\n                } else {\n                    myCallback(null);\n                }\n            };\n\n            if (_clientGlobal.branch === branch) {\n                if (_offline) {\n                    _viewer = false;\n                    _offline = false;\n                    changeBranchState(_self.branchStates.SYNC);\n                    _clientGlobal.project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\n                } else {\n                    callback(null);\n                }\n            } else {\n                _clientGlobal.branch = branch;\n                _viewer = false;\n                _offline = false;\n                _recentCommits = [''];\n                _self.dispatchEvent(_self.events.BRANCH_CHANGED, _clientGlobal.branch);\n                changeBranchState(_self.branchStates.SYNC);\n                _clientGlobal.project.getBranchHash(branch, _recentCommits[0], branchHashUpdated);\n            }\n        }\n\n        function reLaunchUsers() {\n            var i;\n            for (i in _users) {\n                if (_users.hasOwnProperty(i)) {\n                    if (_users[i].UI.reLaunch) {\n                        _users[i].UI.reLaunch();\n                    }\n                }\n            }\n        }\n\n        function openProject(name, callback) {\n            //this function cannot create new project\n            ASSERT(_clientGlobal.db);\n            var waiting = 1,\n                innerCallback = function (err) {\n                    error = error || err;\n                    if (--waiting === 0) {\n                        if (error) {\n                            logger.error('The branch ' + firstName + ' of project ' + name +\n                                ' cannot be selected! [' + JSON.stringify(error) + ']');\n                        }\n                        callback(error);\n                    }\n                },\n                firstName = null,\n                error = null;\n            _clientGlobal.db.getProjectNames(function (err, names) {\n                if (err) {\n                    return callback(err);\n                }\n                if (names.indexOf(name) !== -1) {\n                    _clientGlobal.db.openProject(name, function (err, p) {\n                        if (!err && p) {\n                            _clientGlobal.db.getAuthorizationInfo(name, function (err, authInfo) {\n                                _readOnlyProject = authInfo ? (authInfo.write === true ? false : true) : true;\n                                _clientGlobal.project = p;\n                                _clientGlobal.projectName = name;\n                                _inTransaction = false;\n                                _clientGlobal.nodes = {};\n                                _metaNodes = {};\n                                _clientGlobal.core = getNewCore(_clientGlobal.project,\n                                    gmeConfig, logger.fork('project' + name));\n                                _clientGlobal.META.initialize(_clientGlobal.core, _metaNodes, saveRoot);\n                                if (_clientGlobal.commitCache) {\n                                    _clientGlobal.commitCache.clearCache();\n                                } else {\n                                    createCommitCache(_clientGlobal); //attaches itself to the global\n                                }\n                                _self.dispatchEvent(_self.events.PROJECT_OPENED, _clientGlobal.projectName);\n\n                                //check for master or any other branch\n                                _clientGlobal.project.getBranchNames(function (err, names) {\n                                    if (!err && names) {\n\n                                        if (names.master) {\n                                            firstName = 'master';\n                                        } else {\n                                            firstName = Object.keys(names)[0] || null;\n                                        }\n\n                                        if (firstName) {\n                                            _clientGlobal.addOn.stopRunningAddOns();\n                                            branchWatcher(firstName, innerCallback);\n                                        } else {\n                                            //we should try the latest commit\n                                            viewLatestCommit(callback);\n                                        }\n                                    } else {\n                                        //we should try the latest commit\n                                        viewLatestCommit(callback);\n                                    }\n                                });\n                            });\n                        } else {\n                            logger.error('The project ' + name + ' cannot be opened! [' + JSON.stringify(err) +\n                                ']');\n                            callback(err);\n                        }\n                    });\n                } else {\n                    callback(new Error('there is no such project'));\n                }\n\n            });\n        }\n\n        function changeBranchState(newstate) {\n            if (_clientGlobal.branchState !== newstate) {\n                _clientGlobal.branchState = newstate;\n                _self.dispatchEvent(_self.events.BRANCHSTATUS_CHANGED, _clientGlobal.branchState);\n            }\n        }\n\n        var _self = this,\n            logger = Logger.create('gme:client', gmeConfig.client.log),\n            _metaNodes = {},\n            _inTransaction = false,\n            _users = {},\n            _patterns = {},\n            _networkStatus = '',\n            _msg = '',\n            _recentCommits = [],\n            _viewer = false,\n            _readOnlyProject = false,\n            _loadNodes = {},\n            _loadError = 0,\n            _offline = false,\n            _networkWatcher = null,\n            _TOKEN = null,\n        //_changeTree = null,\n            _gHash = 0,\n            _redoer = null,\n            _selfCommits = {},\n            _configuration = {},\n            AllPlugins,\n            AllDecorators,\n            eventDispatcher,\n            i,\n            _clientGlobal = {\n                gmeConfig: gmeConfig,\n                logger: logger,\n                core: null,\n                branch: null,\n                branchState: null,\n                projectName: null,\n                root: {\n                    current: null,\n                    previous: null,\n                    object: null\n                },\n                nodes: {},\n                project: null,\n                db: null,\n                META: new BaseMeta(),\n                functions: {\n                    toJson: toJson,\n                    storeNode: storeNode,\n                    saveRoot: saveRoot,\n                    getNewCore: getNewCore,\n                    closeOpenedProject: closeOpenedProject,\n                    viewerCommit: viewerCommit,\n                    startTransaction: startTransaction,\n                    completeTransaction: completeTransaction,\n                    branchWatcher: branchWatcher, //refactor this\n                    reLaunchUsers: reLaunchUsers,\n                    openProject: openProject,\n                    changeBranchState: changeBranchState\n                }\n            },\n            _clientAPI = {},\n            _requests = new Requests(_clientGlobal);\n\n        gmeNodeSetter(_clientGlobal); //this attaches itself to the global object\n        createAddOn(_clientGlobal); //this attaches itself to the global\n\n        if (window) {\n            _configuration.host = window.location.protocol + '//' + window.location.host;\n        } else {\n            //TODO: Is this ever applicable?\n            _configuration.host = '';\n        }\n        // FIXME: These are asynchronous\n        superagent.get('/listAllPlugins')\n            .end(function (err, res) {\n                if (res.status === 200) {\n                    AllPlugins = res.body.allPlugins;\n                    logger.debug('/listAllPlugins', AllPlugins);\n                } else {\n                    logger.error('/listAllPlugins failed', err);\n                }\n            });\n\n        superagent.get('/listAllDecorators')\n            .end(function (err, res) {\n                if (res.status === 200) {\n                    AllDecorators = res.body.allDecorators;\n                    logger.debug('/listAllDecorators', AllDecorators);\n                } else {\n                    logger.error('/listAllDecorators failed', err);\n                }\n            });\n\n        //default configuration\n        //FIXME: Are these gme options or not??\n        _configuration.autoreconnect = true; // MAGIC NUMBERS\n        _configuration.reconndelay = 1000; // MAGIC NUMBERS\n        _configuration.reconnamount = 1000; // MAGIC NUMBERS\n        _configuration.autostart = false; // MAGIC NUMBERS\n\n        //TODO remove the usage of jquery\n        //$.extend(_self, new EventDispatcher());\n        eventDispatcher = new EventDispatcher();\n        for (i in eventDispatcher) {\n            _self[i] = eventDispatcher[i];\n        }\n        _clientGlobal.eDispatcher = _self; //propagating dispatching functionality\n\n        _self.events = {\n            NETWORKSTATUS_CHANGED: 'NETWORKSTATUS_CHANGED',\n            BRANCHSTATUS_CHANGED: 'BRANCHSTATUS_CHANGED',\n            BRANCH_CHANGED: 'BRANCH_CHANGED',\n            PROJECT_CLOSED: 'PROJECT_CLOSED',\n            PROJECT_OPENED: 'PROJECT_OPENED',\n\n            SERVER_PROJECT_CREATED: 'SERVER_PROJECT_CREATED',\n            SERVER_PROJECT_DELETED: 'SERVER_PROJECT_DELETED',\n            SERVER_BRANCH_CREATED: 'SERVER_BRANCH_CREATED',\n            SERVER_BRANCH_UPDATED: 'SERVER_BRANCH_UPDATED',\n            SERVER_BRANCH_DELETED: 'SERVER_BRANCH_DELETED',\n\n            UNDO_AVAILABLE: 'UNDO_AVAILABLE',\n            REDO_AVAILABLE: 'REDO_AVAILABLE'\n        };\n\n        _clientGlobal.events = _self.events; //propagating the event names\n\n        _self.networkStates = {\n            CONNECTED: 'connected',\n            DISCONNECTED: 'socket.io is disconnected'\n        };\n\n        _self.branchStates = {\n            SYNC: 'inSync',\n            FORKED: 'forked',\n            OFFLINE: 'offline'\n        };\n\n        _clientGlobal.branchStates = _self.branchStates;\n\n        function getUserId() {\n            var cookies = URL.parseCookie(document.cookie);\n            if (cookies.webgme) {\n                return cookies.webgme;\n            } else {\n                return 'n/a';\n            }\n        }\n\n        //FIXME remove TESTING\n        function newDatabase() {\n            var storageOptions = {\n                    logger: Logger.create('gme:client:storage', gmeConfig.client.log),\n                    host: _configuration.host\n                },\n                protocolStr;\n\n            if (typeof TESTING === 'undefined') {\n                storageOptions.user = getUserId();\n            } else {\n                protocolStr = gmeConfig.server.https.enable ? 'https' : 'http';\n\n                storageOptions.type = 'node';\n                storageOptions.host = protocolStr + '://127.0.0.1';\n                storageOptions.user = 'TEST';\n            }\n\n            storageOptions.globConf = gmeConfig;\n            return new Storage(storageOptions);\n        }\n\n        function connect() {\n            //this is when the user force to go online on network level\n            //TODO implement :) - but how, there is no such function on the storage's API\n            if (_clientGlobal.db) {\n                _clientGlobal.db.openDatabase(function (/*err*/) {\n                });\n            }\n        }\n\n        //branch handling functions\n        function goOffline() {\n            //TODO stop watching the branch changes\n            _offline = true;\n            changeBranchState(_self.branchStates.OFFLINE);\n        }\n\n        function goOnline() {\n            //TODO we should try to update the branch with our latest commit\n            //and 'restart' listening to branch changes\n            if (_offline) {\n                _clientGlobal.addOn.stopRunningAddOns();\n                branchWatcher(_clientGlobal.branch);\n            }\n        }\n\n        function addCommit(commitHash) {\n            _clientGlobal.commitCache.newCommit(commitHash);\n            _recentCommits.unshift(commitHash);\n            if (_recentCommits.length > 100) {\n                _recentCommits.pop();\n            }\n        }\n\n\n        function tokenWatcher() {\n            var token = null,\n                refreshToken = function () {\n                    _clientGlobal.db.getToken(function (err, t) {\n                        if (!err) {\n                            token = t || '_';\n                        }\n                    });\n                },\n                getToken = function () {\n                    return token;\n                };\n\n            setInterval(refreshToken, 10000); //maybe it could be configurable\n            refreshToken();\n\n            return {\n                getToken: getToken\n            };\n        }\n\n        function networkWatcher() {\n            _networkStatus = '';\n            //FIXME: Are these gme options or not??\n\n            var frequency = 10,\n                running = true,\n                stop = function () {\n                    running = false;\n                },\n                checking = false,\n                reconnecting = function (finished) {\n                    var connecting = false,\n                        counter = 0,\n                        frequency = _configuration.reconndelay || 10,\n                        timerId = setInterval(function () {\n                            if (!connecting) {\n                                connecting = true;\n                                _clientGlobal.db.openDatabase(function (err) {\n                                    connecting = false;\n                                    if (!err) {\n                                        //we are back!\n                                        clearInterval(timerId);\n                                        return finished(null);\n                                    }\n                                    if (++counter === _configuration.reconnamount) {\n                                        //we failed, stop trying\n                                        clearInterval(timerId);\n                                        return finished(err);\n                                    }\n                                });\n                            }\n                        }, frequency);\n                },\n                checkId = setInterval(function () {\n                    if (!checking) {\n                        checking = true;\n                        _clientGlobal.db.getDatabaseStatus(_networkStatus, function (err, newStatus) {\n                            if (running) {\n                                if (_networkStatus !== newStatus) {\n                                    _networkStatus = newStatus;\n                                    _self.dispatchEvent(_self.events.NETWORKSTATUS_CHANGED, _networkStatus);\n                                    if (_networkStatus === _self.networkStates.DISCONNECTED &&\n                                        _configuration.autoreconnect) {\n                                        reconnecting(function (err) {\n                                            checking = false;\n                                            if (err) {\n                                                logger.error('permanent network failure:', err);\n                                                clearInterval(checkId);\n                                            }\n                                        });\n                                    } else {\n                                        checking = false;\n                                    }\n                                } else {\n                                    checking = false;\n                                }\n                            } else {\n                                clearInterval(checkId);\n                            }\n                        });\n                    }\n                }, frequency);\n\n            return {\n                stop: stop\n            };\n        }\n\n        function viewLatestCommit(callback) {\n            _clientGlobal.commitCache.getNCommitsFrom(null, 1, function (err, commits) {\n                if (!err && commits && commits.length > 0) {\n                    viewerCommit(commits[0][_clientGlobal.project.ID_NAME], callback);\n                } else {\n                    logger.error('Cannot get latest commit! [' + JSON.stringify(err) + ']');\n                    callback(err);\n                }\n            });\n        }\n\n        //internal functions\n        function cleanUsersTerritories() {\n            //look out as the user can remove itself at any time!!!\n            var userIds = Object.keys(_users),\n                i,\n                j,\n                events;\n\n            for (i = 0; i < userIds.length; i++) {\n                if (_users[userIds[i]]) {\n                    events = [{eid: null, etype: 'complete'}];\n                    for (j in _users[userIds[i]].PATHS\n                        ) {\n                        events.push({etype: 'unload', eid: j});\n                    }\n                    _users[userIds[i]].PATTERNS = {};\n                    _users[userIds[i]].PATHS = {};\n                    _users[userIds[i]].SENDEVENTS = true;\n                    _users[userIds[i]].FN(events);\n                }\n            }\n        }\n\n        function connectToDatabaseAsync(options, callback) {\n            var oldcallback = callback;\n            callback = function (err) {\n                _TOKEN = tokenWatcher();\n                reLaunchUsers();\n                oldcallback(err);\n            }; //we add tokenWatcher start at this point\n            options = options || {};\n            callback = callback || function () {\n                };\n            options.open = (options.open !== undefined || options.open !== null) ? options.open : false;\n            options.project = options.project || null;\n            if (_clientGlobal.db) {\n                //we have to close the current\n                closeOpenedProject(function () {\n                });\n                _clientGlobal.db.closeDatabase(function () {\n                });\n                _networkStatus = '';\n                changeBranchState(null);\n            }\n            _clientGlobal.db = newDatabase();\n\n            _clientGlobal.db.openDatabase(function (err) {\n                if (err) {\n                    logger.error('Cannot open database');\n                    callback(err);\n                    return;\n                }\n\n                if (_networkWatcher) {\n                    _networkWatcher.stop();\n                }\n                _networkWatcher = networkWatcher();\n                serverEventer(_clientGlobal); //this starts the eventing service\n\n                //FIXME remove option open, and the possibility to open 'first' project\n                // should be clear if it is projectId or projectName\n                if (options.open) {\n                    if (options.project) {\n                        openProject(options.project, callback);\n                    } else {\n                        //default opening routine\n                        _clientGlobal.db.getProjectNames(function (err, names) {\n                            if (!err && names && names.length > 0) {\n                                openProject(names[0], callback);\n                            } else {\n                                logger.error('Cannot get project names / There is no project on the server');\n                                callback(err);\n                            }\n                        });\n                    }\n                } else {\n                    callback(null);\n                }\n            });\n        }\n\n        //loading functions\n        function getStringHash(node) {\n            //TODO there is a memory issue with the huge strings so we have to replace it with something\n            if (node.parent && node.parent.data && node.parent.data[node.relid]) {\n                return node.parent.data[node.relid];\n            }\n            _gHash += 1;\n            return _gHash;\n        }\n\n        //TODO this function will be used when diff based event generation will be reintroduced\n        //function getInheritanceChain(node) {\n        //    var ancestors = [];\n        //    node = _clientGlobal.core.getBase(node);\n        //    while (node) {\n        //        ancestors.push(_clientGlobal.core.getPath(node));\n        //        node = _clientGlobal.core.getBase(node);\n        //    }\n        //    return ancestors;\n        //}\n\n        //TODO this function will be used when diff based event generation will be reintroduced\n        //function isInChangeTree(path) {\n        //    var pathArray = path.split('/'),\n        //        diffObj = _changeTree,\n        //        index = 0,\n        //        found = false;\n        //\n        //    pathArray.shift();\n        //    if (pathArray.length === 0) {\n        //        found = true;\n        //    }\n        //\n        //    if (!diffObj) {\n        //        return false;\n        //    }\n        //\n        //    while (index < pathArray.length && !found) {\n        //        if (diffObj[pathArray[index]]) {\n        //            diffObj = diffObj[pathArray[index]];\n        //            index += 1;\n        //            if (index === pathArray.length) {\n        //                found = true;\n        //            }\n        //        } else {\n        //            index = pathArray.length;\n        //        }\n        //    }\n        //\n        //    if (found && diffObj) {\n        //        if (diffObj.removed !== undefined) {\n        //            return false;\n        //        }\n        //        if (diffObj.reg || diffObj.attr || diffObj.pointer || diffObj.set || diffObj.meta ||\n        //            diffObj.childrenListChanged) {\n        //            return true;\n        //        }\n        //    }\n        //\n        //    return false;\n        //}\n\n        function getModifiedNodes(newerNodes) {\n            var modifiedNodes = [],\n                i;\n\n            for (i in _clientGlobal.nodes) {\n                if (_clientGlobal.nodes.hasOwnProperty(i)) {\n                    if (newerNodes[i]) {\n                        if (newerNodes[i].hash !== _clientGlobal.nodes[i].hash && _clientGlobal.nodes[i].hash !== '') {\n                            modifiedNodes.push(i);\n                        }\n                    }\n                }\n            }\n            return modifiedNodes;\n        }\n\n\n        //this is just a first brute implementation it needs serious optimization!!!\n        function fitsInPatternTypes(path, pattern) {\n            var i;\n\n            if (pattern.items && pattern.items.length > 0) {\n                for (i = 0; i < pattern.items.length; i += 1) {\n                    if (_clientGlobal.META.isTypeOf(path, pattern.items[i])) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                return true;\n            }\n        }\n\n        function patternToPaths(patternId, pattern, pathsSoFar) {\n            var children,\n                subPattern,\n                i;\n\n            if (_clientGlobal.nodes[patternId]) {\n                pathsSoFar[patternId] = true;\n                if (pattern.children && pattern.children > 0) {\n                    children = _clientGlobal.core.getChildrenPaths(_clientGlobal.nodes[patternId].node);\n                    subPattern = COPY(pattern);\n                    subPattern.children -= 1;\n                    for (i = 0; i < children.length; i += 1) {\n                        if (fitsInPatternTypes(children[i], pattern)) {\n                            patternToPaths(children[i], subPattern, pathsSoFar);\n                        }\n                    }\n                }\n            } else {\n                _loadError++;\n            }\n\n        }\n\n        function userEvents(userId, modifiedNodes) {\n            var newPaths = {},\n                startErrorLevel = _loadError,\n                i,\n                events = [];\n\n            for (i in _users[userId].PATTERNS) {\n                if (_users[userId].PATTERNS.hasOwnProperty(i)) {\n                    if (_clientGlobal.nodes[i]) { //TODO we only check pattern if its root is there...\n                        patternToPaths(i, _users[userId].PATTERNS[i], newPaths);\n                    }\n                }\n            }\n\n            if (startErrorLevel !== _loadError) {\n                return; //we send events only when everything is there correctly\n            }\n\n            //deleted items\n            for (i in _users[userId].PATHS) {\n                if (!newPaths[i]) {\n                    events.push({etype: 'unload', eid: i});\n                }\n            }\n\n            //added items\n            for (i in newPaths) {\n                if (!_users[userId].PATHS[i]) {\n                    events.push({etype: 'load', eid: i});\n                }\n            }\n\n            //updated items\n            for (i = 0; i < modifiedNodes.length; i++) {\n                if (newPaths[modifiedNodes[i]]) {\n                    events.push({etype: 'update', eid: modifiedNodes[i]});\n                }\n            }\n\n            _users[userId].PATHS = newPaths;\n\n            //this is how the events should go\n            if (events.length > 0) {\n                if (_loadError > startErrorLevel) {\n                    events.unshift({etype: 'incomplete', eid: null});\n                } else {\n                    events.unshift({etype: 'complete', eid: null});\n                }\n            } else {\n                events.unshift({etype: 'complete', eid: null});\n            }\n            _users[userId].FN(events);\n        }\n\n\n        //partially optimized\n        function loadChildrenPattern(core, nodesSoFar, node, level, callback) {\n            var path = core.getPath(node),\n                childrenPaths = core.getChildrenPaths(node),\n                childrenRelids = core.getChildrenRelids(node),\n                missing = childrenPaths.length,\n                error = null,\n                i,\n                childLoaded = function (err, child) {\n                    if (err || child === null) {\n                        error = error || err;\n                        missing -= 1;\n                        if (missing === 0) {\n                            callback(error);\n                        }\n                    } else {\n                        loadChildrenPattern(core, nodesSoFar, child, level - 1, childrenPatternLoaded);\n                    }\n                },\n                childrenPatternLoaded = function (err) {\n                    error = error || err;\n                    missing -= 1;\n                    if (missing === 0) {\n                        callback(error);\n                    }\n                };\n            _metaNodes[path] = node;\n            if (!nodesSoFar[path]) {\n                nodesSoFar[path] = {node: node, incomplete: true, basic: true, hash: getStringHash(node)};\n            }\n            if (level > 0) {\n                if (missing > 0) {\n                    for (i = 0; i < childrenPaths.length; i++) {\n                        if (nodesSoFar[childrenPaths[i]]) {\n                            loadChildrenPattern(core,\n                                nodesSoFar,\n                                nodesSoFar[childrenPaths[i]].node,\n                                level - 1, childrenPatternLoaded);\n                        } else {\n                            core.loadChild(node, childrenRelids[i], childLoaded);\n                        }\n                    }\n                } else {\n                    callback(error);\n                }\n            } else {\n                callback(error);\n            }\n        }\n\n        function loadPattern(core, id, pattern, nodesSoFar, callback) {\n            var base = null,\n                baseLoaded = function () {\n                    if (pattern.children && pattern.children > 0) {\n                        var level = pattern.children;\n                        loadChildrenPattern(core, nodesSoFar, base, level, callback);\n                    } else {\n                        callback(null);\n                    }\n                };\n\n            if (nodesSoFar[id]) {\n                base = nodesSoFar[id].node;\n                baseLoaded();\n            } else {\n                base = null;\n                if (_loadNodes[ROOT_PATH]) {\n                    base = _loadNodes[ROOT_PATH].node;\n                } else if (_clientGlobal.nodes[ROOT_PATH]) {\n                    base = _clientGlobal.nodes[ROOT_PATH].node;\n                }\n                core.loadByPath(base, id, function (err, node) {\n                    var path;\n                    if (!err && node && !core.isEmpty(node)) {\n                        path = core.getPath(node);\n                        _metaNodes[path] = node;\n                        if (!nodesSoFar[path]) {\n                            nodesSoFar[path] = {\n                                node: node,\n                                incomplete: false,\n                                basic: true,\n                                hash: getStringHash(node)\n                            };\n                        }\n                        base = node;\n                        baseLoaded();\n                    } else {\n                        callback(err);\n                    }\n                });\n            }\n        }\n\n        function orderStringArrayByElementLength(strArray) {\n            var ordered = [],\n                i, j, index;\n\n            for (i = 0; i < strArray.length; i++) {\n                index = -1;\n                j = 0;\n                while (index === -1 && j < ordered.length) {\n                    if (ordered[j].length > strArray[i].length) {\n                        index = j;\n                    }\n                    j++;\n                }\n\n                if (index === -1) {\n                    ordered.push(strArray[i]);\n                } else {\n                    ordered.splice(index, 0, strArray[i]);\n                }\n            }\n            return ordered;\n        }\n\n        //TODO will be used when diff based event generation is reintroduced\n        //function getEventTree(oldRootHash, newRootHash, callback) {\n        //    var error = null,\n        //        sRoot = null,\n        //        tRoot = null,\n        //        loadRoot = function (hash /*, root */) {\n        //            _clientGlobal.core.loadRoot(hash, function (err, r) {\n        //                error = error || err;\n        //                if (sRoot === null && hash === oldRootHash) {\n        //                    sRoot = r;\n        //                } else {\n        //                    tRoot = r;\n        //                }\n        //                needed -= 1;\n        //                if (needed === 0) {\n        //                    rootsLoaded();\n        //                }\n        //            });\n        //\n        //        },\n        //        rootsLoaded = function () {\n        //            if (error) {\n        //                return callback(error);\n        //            }\n        //            _clientGlobal.core.generateLightTreeDiff(sRoot, tRoot, function (err, diff) {\n        //                callback(err, diff);\n        //            });\n        //        },\n        //        needed = 2;\n        //    loadRoot(oldRootHash, sRoot);\n        //    loadRoot(newRootHash, tRoot);\n        //}\n\n        function loadRoot(newRootHash, callback) {\n            //with the newer approach we try to optimize a bit the mechanism of the loading and\n            // try to get rid of the parallelism behind it\n            var patterns = {},\n                orderedPatternIds = [],\n                error = null,\n                i,\n                j,\n                keysi,\n                keysj;\n\n            _loadNodes = {};\n            _loadError = 0;\n\n            //gathering the patterns\n            keysi = Object.keys(_users);\n            for (i = 0; i < keysi.length; i++) {\n                keysj = Object.keys(_users[keysi[i]].PATTERNS);\n                for (j = 0; j < keysj.length; j++) {\n                    if (patterns[keysj[j]]) {\n                        //we check if the range is bigger for the new definition\n                        if (patterns[keysj[j]].children < _users[keysi[i]].PATTERNS[keysj[j]].children) {\n                            patterns[keysj[j]].children = _users[keysi[i]].PATTERNS[keysj[j]].children;\n                        }\n                    } else {\n                        patterns[keysj[j]] = _users[keysi[i]].PATTERNS[keysj[j]];\n                    }\n                }\n            }\n            //getting an ordered key list\n            orderedPatternIds = Object.keys(patterns);\n            orderedPatternIds = orderStringArrayByElementLength(orderedPatternIds);\n\n\n            //and now the one-by-one loading\n            _clientGlobal.core.loadRoot(newRootHash, function (err, root) {\n                var fut,\n                    _loadPattern;\n\n                ASSERT(err || root);\n\n                _clientGlobal.root.object = root;\n                error = error || err;\n                if (!err) {\n                    _clientGlobal.addOn.updateRunningAddOns(root);\n                    _loadNodes[_clientGlobal.core.getPath(root)] = {\n                        node: root,\n                        incomplete: true,\n                        basic: true,\n                        hash: getStringHash(root)\n                    };\n                    _metaNodes[_clientGlobal.core.getPath(root)] = root;\n                    if (orderedPatternIds.length === 0 && Object.keys(_users) > 0) {\n                        //we have user, but they do not interested in any object -> let's relaunch them :D\n                        callback(null);\n                        reLaunchUsers();\n                    } else {\n                        _loadPattern = TASYNC.throttle(TASYNC.wrap(loadPattern), 1);\n                        fut = TASYNC.lift(\n                            orderedPatternIds.map(function (pattern /*, index */) {\n                                return TASYNC.apply(_loadPattern,\n                                    [_clientGlobal.core, pattern, patterns[pattern], _loadNodes],\n                                    this);\n                            }));\n                        TASYNC.unwrap(function () {\n                            return fut;\n                        })(callback);\n                    }\n                } else {\n                    callback(err);\n                }\n            });\n        }\n\n        //this is just a first brute implementation it needs serious optimization!!!\n        function loading(newRootHash, callback) {\n            var finalEvents = function () {\n                var modifiedPaths,\n                    i;\n\n                modifiedPaths = getModifiedNodes(_loadNodes);\n                _clientGlobal.nodes = _loadNodes;\n                _loadNodes = {};\n                for (i in _users) {\n                    if (_users.hasOwnProperty(i)) {\n                        userEvents(i, modifiedPaths);\n                    }\n                }\n                callback(null);\n            };\n\n            callback = callback || function (/*err*/) {\n                };\n\n            _clientGlobal.root.previous = _clientGlobal.root.current;\n            _clientGlobal.root.current = newRootHash;\n            loadRoot(newRootHash, function (err) {\n                if (err) {\n                    _clientGlobal.root.current = null;\n                    callback(err);\n                } else {\n                    finalEvents();\n                }\n            });\n        }\n\n        function getActiveProject() {\n            return _clientGlobal.projectName;\n        }\n\n        function getActualCommit() {\n            return _recentCommits[0];\n        }\n\n        function getActualBranch() {\n            return _clientGlobal.branch;\n        }\n\n        function getActualNetworkStatus() {\n            return _networkStatus;\n        }\n\n        function getActualBranchStatus() {\n            return _clientGlobal.branchState;\n        }\n\n        function commitAsync(params, callback) {\n            var msg;\n\n            if (_clientGlobal.db) {\n                if (_clientGlobal.project) {\n                    msg = params.message || '';\n                    saveRoot(msg, callback);\n                } else {\n                    callback(new Error('there is no open project!'));\n                }\n            } else {\n                callback(new Error('there is no open database connection!'));\n            }\n        }\n\n\n        //constraint functions\n        function setConstraint(path, name, constraintObj) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.setConstraint(_clientGlobal.nodes[path].node, name, constraintObj);\n                saveRoot('setConstraint(' + path + ',' + name + ')');\n            }\n        }\n\n        function delConstraint(path, name) {\n            if (_clientGlobal.core && _clientGlobal.nodes[path] && typeof _clientGlobal.nodes[path].node === 'object') {\n                _clientGlobal.core.delConstraint(_clientGlobal.nodes[path].node, name);\n                saveRoot('delConstraint(' + path + 'name' + ')');\n            }\n        }\n\n        //territory functions\n        function addUI(ui, fn, guid) {\n            ASSERT(fn);\n            ASSERT(typeof fn === 'function');\n            guid = guid || GUID();\n            _users[guid] = {type: 'notused', UI: ui, PATTERNS: {}, PATHS: {}, SENDEVENTS: true, FN: fn};\n            return guid;\n        }\n\n        function removeUI(guid) {\n            delete _users[guid];\n        }\n\n        function _updateTerritoryAllDone(guid, patterns, error) {\n            if (_users[guid]) {\n                _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\n                if (!error) {\n                    userEvents(guid, []);\n                }\n            }\n        }\n\n        function updateTerritory(guid, patterns) {\n            var missing,\n                error,\n                patternLoaded,\n                i;\n\n            if (_users[guid]) {\n                if (_clientGlobal.project) {\n                    if (_clientGlobal.nodes[ROOT_PATH]) {\n                        //TODO: this has to be optimized\n                        missing = 0;\n                        error = null;\n\n                        patternLoaded = function (err) {\n                            error = error || err;\n                            missing -= 1;\n                            if (missing === 0) {\n                                //allDone();\n                                _updateTerritoryAllDone(guid, patterns, error);\n                            }\n                        };\n\n                        for (i in patterns) {\n                            missing += 1;\n                        }\n                        if (missing > 0) {\n                            for (i in patterns) {\n                                if (patterns.hasOwnProperty(i)) {\n                                    loadPattern(_clientGlobal.core, i, patterns[i], _clientGlobal.nodes, patternLoaded);\n                                }\n                            }\n                        } else {\n                            //allDone();\n                            _updateTerritoryAllDone(guid, patterns, error);\n                        }\n                    } else {\n                        //something funny is going on\n                        if (_loadNodes[ROOT_PATH]) {\n                            //probably we are in the loading process,\n                            // so we should redo this update when the loading finishes\n                            //setTimeout(updateTerritory, 100, guid, patterns);\n                        } else {\n                            //root is not in nodes and has not even started to load it yet...\n                            _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\n                        }\n                    }\n                } else {\n                    //we should update the patterns, but that is all\n                    _users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\n                }\n            }\n        }\n\n        function getProjectObject() {\n            return _clientGlobal.project;\n        }\n\n        function getAvailableInterpreterNames() {\n            if (!AllPlugins) {\n                logger.error('AllPlugins were never uploaded!');\n                return [];\n            }\n            var names = [],\n                valids = _clientGlobal.nodes[ROOT_PATH] ? _clientGlobal.core.getRegistry(\n                    _clientGlobal.nodes[ROOT_PATH].node, 'validPlugins') || '' : '';\n            valids = valids.split(' ');\n            for (var i = 0; i < valids.length; i++) {\n                if (AllPlugins.indexOf(valids[i]) !== -1) {\n                    names.push(valids[i]);\n                }\n            }\n            return names;\n        }\n\n        function runServerPlugin(name, context, callback) {\n            _clientGlobal.db.simpleRequest({command: 'executePlugin', name: name, context: context}, callback);\n        }\n\n        function getAvailableDecoratorNames() {\n            if (!AllDecorators) {\n                logger.error('AllDecorators were never uploaded!');\n                return [];\n            }\n            return AllDecorators;\n        }\n\n        function getSeedInfoAsync(callback) {\n            _clientGlobal.db.simpleRequest({command: 'getSeedInfo'}, function (err, id) {\n                if (err) {\n                    return callback(err);\n                }\n\n                _clientGlobal.db.simpleResult(id, callback);\n            });\n        }\n\n        function seedProjectAsync(parameters, callback) {\n            parameters.command = 'seedProject';\n            _clientGlobal.db.simpleRequest(parameters, function (err, id) {\n                if (err) {\n                    return callback(err);\n                }\n\n                _clientGlobal.db.simpleResult(id, callback);\n            });\n        }\n\n\n        _redoer = new UndoRedo({\n            //eventer\n            events: _self.events,\n            networkStates: _self.networkStates,\n            branchStates: _self.branchStates,\n            _eventList: _self._eventList,\n            _getEvent: _self._getEvent,\n            addEventListener: _self.addEventListener,\n            removeEventListener: _self.removeEventListener,\n            removeAllEventListeners: _self.removeAllEventListeners,\n            dispatchEvent: _self.dispatchEvent,\n            getProjectObject: getProjectObject\n        });\n\n\n        _clientAPI = {\n            //eventer\n            events: _self.events,\n            networkStates: _self.networkStates,\n            branchStates: _self.branchStates,\n            _eventList: _self._eventList,\n            _getEvent: _self._getEvent,\n            addEventListener: _self.addEventListener,\n            removeEventListener: _self.removeEventListener,\n            removeAllEventListeners: _self.removeAllEventListeners,\n            dispatchEvent: _self.dispatchEvent,\n            connect: connect,\n\n            getUserId: getUserId,\n\n            //projects, branch, etc.\n            connectToDatabaseAsync: connectToDatabaseAsync,\n            getActiveProjectName: getActiveProject,\n            getActualCommit: getActualCommit,\n            getActualBranch: getActualBranch,\n            getActualNetworkStatus: getActualNetworkStatus,\n            getActualBranchStatus: getActualBranchStatus,\n            commitAsync: commitAsync,\n            goOffline: goOffline,\n            goOnline: goOnline,\n            isProjectReadOnly: function () {\n                return _readOnlyProject;\n            },\n            isCommitReadOnly: function () {\n                return _viewer;\n            },\n\n            startTransaction: startTransaction,\n            completeTransaction: completeTransaction,\n\n            //decorators\n            getAvailableDecoratorNames: getAvailableDecoratorNames,\n            //interpreters\n            getAvailableInterpreterNames: getAvailableInterpreterNames,\n            getProjectObject: getProjectObject,\n            runServerPlugin: runServerPlugin,\n\n            //constraint\n            setConstraint: setConstraint,\n            delConstraint: delConstraint,\n\n            //territory functions for the UI\n            addUI: addUI,\n            removeUI: removeUI,\n            updateTerritory: updateTerritory,\n            getNode: function (_id) {\n                return getNode(_id,\n                    _clientGlobal);\n            },\n\n            //undo - redo\n            undo: _redoer.undo,\n            redo: _redoer.redo,\n\n            //clone services\n            getSeedInfoAsync: getSeedInfoAsync,\n            seedProjectAsync: seedProjectAsync\n\n        };\n\n        for (i in _clientGlobal.META) {\n            _clientAPI[i] = _clientGlobal.META[i];\n        }\n\n        for (i in _clientGlobal.nodeSetter) {\n            _clientAPI[i] = _clientGlobal.nodeSetter[i];\n        }\n\n        for (i in _requests) {\n            _clientAPI[i] = _requests[i];\n        }\n\n        //addOn\n        _clientAPI.validateProjectAsync = _clientGlobal.addOn.validateProjectAsync;\n        _clientAPI.validateModelAsync = _clientGlobal.addOn.validateModelAsync;\n        _clientAPI.validateNodeAsync = _clientGlobal.addOn.validateNodeAsync;\n        _clientAPI.setValidationCallback = _clientGlobal.addOn.setValidationCallback;\n        _clientAPI.getDetailedHistoryAsync = _clientGlobal.addOn.getDetailedHistoryAsync;\n        _clientAPI.getRunningAddOnNames = _clientGlobal.addOn.getRunningAddOnNames;\n        _clientAPI.addOnsAllowed = gmeConfig.addOn.enable === true;\n\n        return _clientAPI;\n    }\n\n    return Client;\n});\n\n",
    "/*globals define*/\r\n/*jshint browser: true*/\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n */\r\ndefine('client/js/client',['./client/index'], function (Client) {\r\n    'use strict';\r\n    return Client;\r\n  });\r\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/BlobConfig',[], function () {\n    'use strict';\n    var BlobConfig = {\n        hashMethod: 'sha1', // TODO: in the future we may switch to sha512\n        hashRegex: new RegExp('^[0-9a-f]{40}$')\n    };\n\n    return BlobConfig;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/BlobMetadata',['blob/BlobConfig'], function (BlobConfig) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of BlobMetadata\n     * @param {object} metadata - A serialized metadata object.\n     * @param {string} metadata.name\n     * @param {string|Object} metadata.content\n     * @param {number} [metadata.size=0]\n     * @param {BlobMetadata.CONTENT_TYPES} [metadata.contentType=BlobMetadata.CONTENT_TYPES.OBJECT]\n     * @param {string} [metadata.mime='']\n     * @param {boolean} [metadata.isPublic=false]\n     * @param {string[]} [metadata.tags=[]]\n     * @constructor\n     */\n    var BlobMetadata = function (metadata) {\n        var key;\n        if (metadata) {\n            this.name = metadata.name;\n            this.size = metadata.size || 0;\n            this.mime = metadata.mime || '';\n            this.isPublic = metadata.isPublic || false;\n            this.tags = metadata.tags || [];\n            this.content = metadata.content;\n            this.contentType = metadata.contentType || BlobMetadata.CONTENT_TYPES.OBJECT;\n            if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n                for (key in this.content) {\n                    if (this.content.hasOwnProperty(key)) {\n                        if (BlobConfig.hashRegex.test(this.content[key].content) === false) {\n                            throw Error('BlobMetadata is malformed: hash is invalid');\n                        }\n                    }\n                }\n            }\n        } else {\n            throw new Error('metadata parameter is not defined');\n        }\n    };\n\n    /**\n     * Type of the metadata\n     * @type {{OBJECT: string, COMPLEX: string, SOFT_LINK: string}}\n     */\n    BlobMetadata.CONTENT_TYPES = {\n        OBJECT: 'object',\n        COMPLEX: 'complex',\n        SOFT_LINK: 'softLink'\n    };\n\n    /**\n     * Serializes the metadata to a JSON object.\n     * @returns {{\n     *  name: string,\n     *  size: number,\n     *  mime: string,\n     *  tags: Array.<string>,\n     *  content: (string|Object},\n     *  contentType: string}}\n     */\n    BlobMetadata.prototype.serialize = function () {\n        var metadata = {\n            name: this.name,\n            size: this.size,\n            mime: this.mime,\n            isPublic: this.isPublic,\n            tags: this.tags,\n            content: this.content,\n            contentType: this.contentType\n        };\n\n        metadata.tags.sort();\n\n        if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n            // override on  purpose to normalize content\n            metadata.content = {};\n            var fnames = Object.keys(this.content);\n            fnames.sort();\n\n            for (var j = 0; j < fnames.length; j += 1) {\n                metadata.content[fnames[j]] = this.content[fnames[j]];\n            }\n        }\n\n        return metadata;\n    };\n\n    return BlobMetadata;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/*\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/Artifact',['blob/BlobMetadata', 'blob/BlobConfig', 'common/core/tasync'], function (BlobMetadata, BlobConfig, tasync) {\n    'use strict';\n    /**\n     * Creates a new instance of artifact, i.e. complex object, in memory. This object can be saved in the storage.\n     * @param {string} name Artifact's name without extension\n     * @param {blob.BlobClient} blobClient\n     * @param {blob.BlobMetadata} descriptor\n     * @constructor\n     */\n    var Artifact = function (name, blobClient, descriptor) {\n        this.name = name;\n        this.blobClient = blobClient;\n        this.blobClientPutFile = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.putFile), 5));\n        this.blobClientGetMetadata = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.getMetadata), 5));\n        // TODO: use BlobMetadata class here\n        this.descriptor = descriptor || {\n            name: name + '.zip',\n            size: 0,\n            mime: 'application/zip',\n            content: {},\n            contentType: 'complex'\n        }; // name and hash pairs\n    };\n\n    /**\n     * Adds content to the artifact as a file.\n     * @param {string} name filename\n     * @param {Blob} content File object or Blob\n     * @param callback\n     */\n    Artifact.prototype.addFile = function (name, content, callback) {\n        var self = this;\n        var filename = name.substring(name.lastIndexOf('/') + 1);\n\n        self.blobClientPutFile.call(self.blobClient, filename, content, function (err, hash) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            self.addObjectHash(name, hash, function (err, hash) {\n                callback(err, hash);\n            });\n        });\n    };\n\n    Artifact.prototype.addFileAsSoftLink = function (name, content, callback) {\n        var self = this;\n        var filename = name.substring(name.lastIndexOf('/') + 1);\n\n        self.blobClientPutFile.call(self.blobClient, filename, content,\n            function (err, hash) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                var size;\n                if (content.size !== undefined) {\n                    size = content.size;\n                }\n                if (content.length !== undefined) {\n                    size = content.length;\n                }\n\n                self.addMetadataHash(name, hash, size, function (err, hash) {\n                    callback(err, hash);\n                });\n            });\n    };\n\n    /**\n     * Adds a hash to the artifact using the given file path.\n     * @param {string} name Path to the file in the artifact. Note: 'a/b/c.txt'\n     * @param {string} hash Metadata hash that has to be added.\n     * @param callback\n     */\n    Artifact.prototype.addObjectHash = function (name, hash, callback) {\n        var self = this;\n\n        if (BlobConfig.hashRegex.test(hash) === false) {\n            callback('Blob hash is invalid');\n            return;\n        }\n\n        self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            if (self.descriptor.content.hasOwnProperty(name)) {\n                callback('Another content with the same name was already added. ' +\n                JSON.stringify(self.descriptor.content[name]));\n\n            } else {\n                self.descriptor.size += metadata.size;\n\n                self.descriptor.content[name] = {\n                    content: metadata.content,\n                    contentType: BlobMetadata.CONTENT_TYPES.OBJECT\n                };\n                callback(null, hash);\n            }\n        });\n    };\n\n    Artifact.prototype.addMetadataHash = function (name, hash, size, callback) {\n        var self = this,\n            addMetadata = function (size) {\n                if (self.descriptor.content.hasOwnProperty(name)) {\n                    callback('Another content with the same name was already added. ' +\n                    JSON.stringify(self.descriptor.content[name]));\n\n                } else {\n                    self.descriptor.size += size;\n\n                    self.descriptor.content[name] = {\n                        content: hash,\n                        contentType: BlobMetadata.CONTENT_TYPES.SOFT_LINK\n                    };\n                    callback(null, hash);\n                }\n            };\n\n        if (typeof size === 'function') {\n            callback = size;\n            size = undefined;\n        }\n\n        if (BlobConfig.hashRegex.test(hash) === false) {\n            callback('Blob hash is invalid');\n            return;\n        }\n        if (size === undefined) {\n            self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                addMetadata(metadata.size);\n            });\n        } else {\n            addMetadata(size);\n        }\n    };\n\n    /**\n     * Adds multiple files.\n     * @param {Object.<string, Blob>} files files to add\n     * @param callback\n     */\n    Artifact.prototype.addFiles = function (files, callback) {\n        var self = this,\n            fileNames = Object.keys(files),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding files: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addFile(fileNames[i], files[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds multiple files as soft-links.\n     * @param {Object.<string, Blob>} files files to add\n     * @param callback\n     */\n    Artifact.prototype.addFilesAsSoftLinks = function (files, callback) {\n        var self = this,\n            fileNames = Object.keys(files),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding files as soft-links: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addFileAsSoftLink(fileNames[i], files[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds hashes to the artifact using the given file paths.\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\n     * @param callback\n     */\n    Artifact.prototype.addObjectHashes = function (objectHashes, callback) {\n        var self = this,\n            fileNames = Object.keys(objectHashes),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding objectHashes: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addObjectHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds hashes to the artifact using the given file paths.\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\n     * @param callback\n     */\n    Artifact.prototype.addMetadataHashes = function (objectHashes, callback) {\n        var self = this,\n            fileNames = Object.keys(objectHashes),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding objectHashes: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addMetadataHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Saves this artifact and uploads the metadata to the server's storage.\n     * @param callback\n     */\n    Artifact.prototype.save = function (callback) {\n        this.blobClient.putMetadata(this.descriptor, callback);\n    };\n\n    return Artifact;\n});\n\n",
    "/*globals define, escape*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n * @author ksmyth / https://github.com/ksmyth\n */\n\ndefine('blob/BlobClient',['blob/Artifact', 'blob/BlobMetadata', 'superagent'], function (Artifact, BlobMetadata, superagent) {\n    'use strict';\n\n    var BlobClient = function (parameters) {\n        this.artifacts = [];\n\n        if (parameters) {\n            this.server = parameters.server || this.server;\n            this.serverPort = parameters.serverPort || this.serverPort;\n            this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\n            this.webgmeclientsession = parameters.webgmeclientsession;\n            this.keepaliveAgentOptions = parameters.keepaliveAgentOptions || { /* use defaults */ };\n        }\n        this.blobUrl = '';\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\n            this.blobUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\n        }\n\n        // TODO: TOKEN???\n        this.blobUrl = this.blobUrl + '/rest/blob/'; // TODO: any ways to ask for this or get it from the configuration?\n\n        this.isNodeOrNodeWebKit = typeof process !== 'undefined';\n        if (this.isNodeOrNodeWebKit) {\n            // node or node-webkit\n            if (this.httpsecure) {\n                this.Agent = require('agentkeepalive').HttpsAgent;\n            } else {\n                this.Agent = require('agentkeepalive');\n            }\n            this.keepaliveAgent = new this.Agent(this.keepaliveAgentOptions);\n        }\n    };\n\n    BlobClient.prototype.getMetadataURL = function (hash) {\n        var metadataBase = this.blobUrl + 'metadata';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n    BlobClient.prototype._getURL = function (base, hash, subpath) {\n        var subpathURL = '';\n        if (subpath) {\n            subpathURL = subpath;\n        }\n        return this.blobUrl + base + '/' + hash + '/' + encodeURIComponent(subpathURL);\n    };\n\n    BlobClient.prototype.getViewURL = function (hash, subpath) {\n        return this._getURL('view', hash, subpath);\n    };\n\n    BlobClient.prototype.getDownloadURL = function (hash, subpath) {\n        return this._getURL('download', hash, subpath);\n    };\n\n    BlobClient.prototype.getCreateURL = function (filename, isMetadata) {\n        if (isMetadata) {\n            return this.blobUrl + 'createMetadata/';\n        } else {\n            return this.blobUrl + 'createFile/' + encodeURIComponent(filename);\n        }\n    };\n\n    BlobClient.prototype.putFile = function (name, data, callback) {\n        var contentLength,\n            req;\n\n        function toArrayBuffer(buffer) {\n            var ab = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(ab);\n            for (var i = 0; i < buffer.length; ++i) {\n                view[i] = buffer[i];\n            }\n            return ab;\n        }\n\n        // On node-webkit, we use XMLHttpRequest, but xhr.send thinks a Buffer is a string and encodes it in utf-8 -\n        // send an ArrayBuffer instead.\n        if (typeof window !== 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\n            data = toArrayBuffer(data); // FIXME will this have performance problems\n        }\n        // on node, empty Buffers will cause a crash in superagent\n        if (typeof window === 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\n            if (data.length === 0) {\n                data = '';\n            }\n        }\n        contentLength = data.hasOwnProperty('length') ? data.length : data.byteLength;\n        req = superagent.post(this.getCreateURL(name));\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n        req.set('Content-Type', 'application/octet-stream')\n            .set('Content-Length', contentLength)\n            .send(data)\n            .end(function (err, res) {\n                if (err || res.status > 399) {\n                    callback(err || res.status);\n                    return;\n                }\n                var response = res.body;\n                // Get the first one\n                var hash = Object.keys(response)[0];\n                callback(null, hash);\n            });\n    };\n\n    BlobClient.prototype.putMetadata = function (metadataDescriptor, callback) {\n        var metadata = new BlobMetadata(metadataDescriptor),\n            blob,\n            contentLength,\n            req;\n        // FIXME: in production mode do not indent the json file.\n        if (typeof Blob !== 'undefined') {\n            blob = new Blob([JSON.stringify(metadata.serialize(), null, 4)], {type: 'text/plain'});\n            contentLength = blob.size;\n        } else {\n            blob = new Buffer(JSON.stringify(metadata.serialize(), null, 4), 'utf8');\n            contentLength = blob.length;\n        }\n\n        req = superagent.post(this.getCreateURL(metadataDescriptor.name, true));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        req.set('Content-Type', 'application/octet-stream')\n            .set('Content-Length', contentLength)\n            .send(blob)\n            .end(function (err, res) {\n                if (err || res.status > 399) {\n                    callback(err || res.status);\n                    return;\n                }\n                // Uploaded.\n                var response = JSON.parse(res.text);\n                // Get the first one\n                var hash = Object.keys(response)[0];\n                callback(null, hash);\n            });\n    };\n\n    BlobClient.prototype.putFiles = function (o, callback) {\n        var self = this,\n            error = '',\n            filenames = Object.keys(o),\n            remaining = filenames.length,\n            hashes = {},\n            putFile;\n        if (remaining === 0) {\n            callback(null, hashes);\n        }\n        putFile = function (filename, data) {\n            self.putFile(filename, data, function (err, hash) {\n                remaining -= 1;\n\n                hashes[filename] = hash;\n\n                if (err) {\n                    error += 'putFile error: ' + err.toString();\n                }\n\n                if (remaining === 0) {\n                    callback(error, hashes);\n                }\n            });\n        };\n\n        for (var j = 0; j < filenames.length; j += 1) {\n            putFile(filenames[j], o[filenames[j]]);\n        }\n    };\n\n    BlobClient.prototype.getSubObject = function (hash, subpath, callback) {\n        return this.getObject(hash, callback, subpath);\n    };\n\n    BlobClient.prototype.getObject = function (hash, callback, subpath) {\n        superagent.parse['application/zip'] = function (obj, parseCallback) {\n            if (parseCallback) {\n                // Running on node; this should be unreachable due to req.pipe() below\n            } else {\n                return obj;\n            }\n        };\n        //superagent.parse['application/json'] = superagent.parse['application/zip'];\n\n        var req = superagent.get(this.getViewURL(hash, subpath));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        if (req.pipe) {\n            // running on node\n            var Writable = require('stream').Writable;\n            var BuffersWritable = function (options) {\n                Writable.call(this, options);\n\n                var self = this;\n                self.buffers = [];\n            };\n            require('util').inherits(BuffersWritable, Writable);\n\n            BuffersWritable.prototype._write = function (chunk, encoding, callback) {\n                this.buffers.push(chunk);\n                callback();\n            };\n\n            var buffers = new BuffersWritable();\n            buffers.on('finish', function () {\n                if (req.req.res.statusCode > 399) {\n                    return callback(req.req.res.statusCode);\n                }\n                callback(null, Buffer.concat(buffers.buffers));\n            });\n            buffers.on('error', function (err) {\n                callback(err);\n            });\n            req.pipe(buffers);\n        } else {\n            req.removeAllListeners('end');\n            req.on('request', function () {\n                if (typeof this.xhr !== 'undefined') {\n                    this.xhr.responseType = 'arraybuffer';\n                }\n            });\n            // req.on('error', callback);\n            req.on('end', function () {\n                if (req.xhr.status > 399) {\n                    callback(req.xhr.status);\n                } else {\n                    var contentType = req.xhr.getResponseHeader('content-type');\n                    var response = req.xhr.response; // response is an arraybuffer\n                    if (contentType === 'application/json') {\n                        var utf8ArrayToString = function (uintArray) {\n                            var inputString = '',\n                                i;\n                            for (i = 0; i < uintArray.byteLength; i++) {\n                                inputString += String.fromCharCode(uintArray[i]);\n                            }\n                            return decodeURIComponent(escape(inputString));\n                        };\n                        response = JSON.parse(utf8ArrayToString(new Uint8Array(response)));\n                    }\n                    callback(null, response);\n                }\n            });\n            req.end(callback);\n        }\n    };\n\n    BlobClient.prototype.getMetadata = function (hash, callback) {\n        var req = superagent.get(this.getMetadataURL(hash));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        req.end(function (err, res) {\n            if (err || res.status > 399) {\n                callback(err || res.status);\n            } else {\n                callback(null, JSON.parse(res.text));\n            }\n        });\n    };\n\n    BlobClient.prototype.createArtifact = function (name) {\n        var artifact = new Artifact(name, this);\n        this.artifacts.push(artifact);\n        return artifact;\n    };\n\n    BlobClient.prototype.getArtifact = function (metadataHash, callback) {\n        // TODO: get info check if complex flag is set to true.\n        // TODO: get info get name.\n        var self = this;\n        this.getMetadata(metadataHash, function (err, info) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            if (info.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n                var artifact = new Artifact(info.name, self, info);\n                self.artifacts.push(artifact);\n                callback(null, artifact);\n            } else {\n                callback('not supported contentType ' + JSON.stringify(info, null, 4));\n            }\n\n        });\n    };\n\n    BlobClient.prototype.saveAllArtifacts = function (callback) {\n        var remaining = this.artifacts.length,\n            hashes = [],\n            error = '',\n            saveCallback;\n\n        if (remaining === 0) {\n            callback(null, hashes);\n        }\n\n        saveCallback = function (err, hash) {\n            remaining -= 1;\n\n            hashes.push(hash);\n\n            if (err) {\n                error += 'artifact.save err: ' + err.toString();\n            }\n            if (remaining === 0) {\n                callback(error, hashes);\n            }\n        };\n\n        for (var i = 0; i < this.artifacts.length; i += 1) {\n\n            this.artifacts[i].save(saveCallback);\n        }\n    };\n\n    return BlobClient;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for creating, monitoring executor jobs.\n *\n * @author lattmann / https://github.com/lattmann\n * @author ksmyth / https://github.com/ksmyth\n */\n\n\ndefine('executor/ExecutorClient',['superagent'], function (superagent) {\n    'use strict';\n\n    var ExecutorClient = function (parameters) {\n        parameters = parameters || {};\n        this.isNodeJS = (typeof window === 'undefined') && (typeof process === 'object');\n        this.isNodeWebkit = (typeof window === 'object') && (typeof process === 'object');\n        //console.log(isNode);\n        if (this.isNodeJS) {\n            this.server = '127.0.0.1';\n            this._clientSession = null; // parameters.sessionId;;\n        }\n        this.server = parameters.server || this.server;\n        this.serverPort = parameters.serverPort || this.serverPort;\n        this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\n        if (this.isNodeJS) {\n            this.http = this.httpsecure ? require('https') : require('http');\n        }\n        this.executorUrl = '';\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\n            this.executorUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\n        }\n        // TODO: TOKEN???\n        // TODO: any ways to ask for this or get it from the configuration?\n        this.executorUrl = this.executorUrl + '/rest/executor/';\n        if (parameters.executorNonce) {\n            this.executorNonce = parameters.executorNonce;\n        }\n    };\n\n    ExecutorClient.prototype.getInfoURL = function (hash) {\n        var metadataBase = this.executorUrl + 'info';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n\n    ExecutorClient.prototype.getCreateURL = function (hash) {\n        var metadataBase = this.executorUrl + 'create';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n    ExecutorClient.prototype.createJob = function (jobInfo, callback) {\n        if (typeof jobInfo === 'string') {\n            jobInfo = { hash: jobInfo }; // old API\n        }\n        this.sendHttpRequestWithData('POST', this.getCreateURL(jobInfo.hash), jobInfo, function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.updateJob = function (jobInfo, callback) {\n        this.sendHttpRequestWithData('POST', this.executorUrl + 'update/' + jobInfo.hash, jobInfo,\n            function (err, response) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                callback(null, response);\n            }\n        );\n    };\n\n    ExecutorClient.prototype.getInfo = function (hash, callback) {\n        this.sendHttpRequest('GET', this.getInfoURL(hash), function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getAllInfo = function (callback) {\n\n        this.sendHttpRequest('GET', this.getInfoURL(), function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getInfoByStatus = function (status, callback) {\n\n        this.sendHttpRequest('GET', this.executorUrl + '?status=' + status, function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getWorkersInfo = function (callback) {\n\n        this.sendHttpRequest('GET', this.executorUrl + 'worker', function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.sendHttpRequest = function (method, url, callback) {\n        return this.sendHttpRequestWithData(method, url, null, callback);\n    };\n\n    ExecutorClient.prototype.sendHttpRequestWithData = function (method, url, data, callback) {\n        var req = new superagent.Request(method, url);\n        if (this.executorNonce) {\n            req.set('x-executor-nonce', this.executorNonce);\n        }\n        if (data) {\n            req.send(data);\n        }\n        req.end(function (err, res) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (res.status > 399) {\n                callback(res.status, res.text);\n            } else {\n                callback(null, res.text);\n            }\n        });\n    };\n\n    ExecutorClient.prototype._ensureAuthenticated = function (options, callback) {\n        //this function enables the session of the client to be authenticated\n        //TODO currently this user does not have a session, so it has to upgrade the options always!!!\n//        if (options.headers) {\n//            options.headers.webgmeclientsession = this._clientSession;\n//        } else {\n//            options.headers = {\n//                'webgmeclientsession': this._clientSession\n//            }\n//        }\n        callback(null, options);\n    };\n\n    return ExecutorClient;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginConfig',[], function () {\n    'use strict';\n    /**\n     * Initializes a new instance of plugin configuration.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginConfig = function (config) {\n        if (config) {\n            var keys = Object.keys(config);\n            for (var i = 0; i < keys.length; i += 1) {\n                // TODO: check for type on deserialization\n                this[keys[i]] = config[keys[i]];\n            }\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginConfig.prototype.serialize = function () {\n        var keys = Object.keys(this);\n        var result = {};\n\n        for (var i = 0; i < keys.length; i += 1) {\n            // TODO: check for type on serialization\n            result[keys[i]] = this[keys[i]];\n        }\n\n        return result;\n    };\n\n\n    return PluginConfig;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginNodeDescription',[], function () {\n    'use strict';\n    /**\n     * Initializes a new instance of plugin node description object.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginNodeDescription = function (config) {\n        if (config) {\n            this.name = config.name;\n            this.id = config.id;\n        } else {\n            this.name = '';\n            this.id = '';\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginNodeDescription.prototype.serialize = function () {\n        var keys = Object.keys(this),\n            result = {},\n            i;\n\n        for (i = 0; i < keys.length; i += 1) {\n            // TODO: check for type on serialization\n            result[keys[i]] = this[keys[i]];\n        }\n\n        return result;\n    };\n\n    return PluginNodeDescription;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginMessage',['plugin/PluginNodeDescription'], function (PluginNodeDescription) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of plugin message.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginMessage = function (config) {\n        if (config) {\n            this.commitHash = config.commitHash;\n            if (config.activeNode instanceof PluginNodeDescription) {\n                this.activeNode = config.activeNode;\n            } else {\n                this.activeNode = new PluginNodeDescription(config.activeNode);\n            }\n\n            this.message = config.message;\n            if (config.severity) {\n                this.severity = config.severity;\n            } else {\n                this.severity = 'info';\n            }\n        } else {\n            this.commitHash = '';\n            this.activeNode = new PluginNodeDescription();\n            this.message = '';\n            this.severity = 'info';\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginMessage.prototype.serialize = function () {\n        var result = {\n            commitHash: this.commitHash,\n            activeNode: this.activeNode.serialize(),\n            message: this.message,\n            severity: this.severity\n        };\n\n        return result;\n    };\n\n    return PluginMessage;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginResult',['plugin/PluginMessage'], function (PluginMessage) {\n    'use strict';\n    /**\n     * Initializes a new instance of a plugin result object.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginResult = function (config) {\n        var pluginMessage,\n            i;\n        if (config) {\n            this.success = config.success;\n            this.pluginName = config.pluginName;\n            this.startTime = config.startTime;\n            this.finishTime = config.finishTime;\n            this.messages = [];\n            this.artifacts = config.artifacts;\n            this.error = config.error;\n\n            for (i = 0; i < config.messages.length; i += 1) {\n                if (config.messages[i] instanceof PluginMessage) {\n                    pluginMessage = config.messages[i];\n                } else {\n                    pluginMessage = new PluginMessage(config.messages[i]);\n                }\n                this.messages.push(pluginMessage);\n            }\n        } else {\n            this.success = false;\n            this.messages = []; // array of PluginMessages\n            this.artifacts = []; // array of hashes\n            this.pluginName = 'PluginName N/A';\n            this.startTime = null;\n            this.finishTime = null;\n            this.error = null;\n        }\n    };\n\n    /**\n     * Gets the success flag of this result object\n     *\n     * @returns {boolean}\n     */\n    PluginResult.prototype.getSuccess = function () {\n        return this.success;\n    };\n\n    /**\n     * Sets the success flag of this result.\n     *\n     * @param {boolean} value\n     */\n    PluginResult.prototype.setSuccess = function (value) {\n        this.success = value;\n    };\n\n    /**\n     * Returns with the plugin messages.\n     *\n     * @returns {plugin.PluginMessage[]}\n     */\n    PluginResult.prototype.getMessages = function () {\n        return this.messages;\n    };\n\n    /**\n     * Adds a new plugin message to the messages list.\n     *\n     * @param {plugin.PluginMessage} pluginMessage\n     */\n    PluginResult.prototype.addMessage = function (pluginMessage) {\n        this.messages.push(pluginMessage);\n    };\n\n    PluginResult.prototype.getArtifacts = function () {\n        return this.artifacts;\n    };\n\n    PluginResult.prototype.addArtifact = function (hash) {\n        this.artifacts.push(hash);\n    };\n\n    /**\n     * Gets the name of the plugin to which the result object belongs to.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getPluginName = function () {\n        return this.pluginName;\n    };\n\n    //------------------------------------------------------------------------------------------------------------------\n    //--------------- Methods used by the plugin manager\n\n    /**\n     * Sets the name of the plugin to which the result object belongs to.\n     *\n     * @param pluginName - name of the plugin\n     */\n    PluginResult.prototype.setPluginName = function (pluginName) {\n        this.pluginName = pluginName;\n    };\n\n    /**\n     * Gets the ISO 8601 representation of the time when the plugin started its execution.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getStartTime = function () {\n        return this.startTime;\n    };\n\n    /**\n     * Sets the ISO 8601 representation of the time when the plugin started its execution.\n     *\n     * @param {string} time\n     */\n    PluginResult.prototype.setStartTime = function (time) {\n        this.startTime = time;\n    };\n\n    /**\n     * Gets the ISO 8601 representation of the time when the plugin finished its execution.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getFinishTime = function () {\n        return this.finishTime;\n    };\n\n    /**\n     * Sets the ISO 8601 representation of the time when the plugin finished its execution.\n     *\n     * @param {string} time\n     */\n    PluginResult.prototype.setFinishTime = function (time) {\n        this.finishTime = time;\n    };\n\n    /**\n     * Gets error if any error occured during execution.\n     * FIXME: should this be an Error object?\n     * @returns {string}\n     */\n    PluginResult.prototype.getError = function () {\n        return this.error;\n    };\n\n    /**\n     * Sets the error string if any error occured during execution.\n     * FIXME: should this be an Error object?\n     * @param {string} time\n     */\n    PluginResult.prototype.setError = function (error) {\n        this.error = error;\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{success: boolean, messages: plugin.PluginMessage[], pluginName: string, finishTime: stirng}}\n     */\n    PluginResult.prototype.serialize = function () {\n        var result = {\n            success: this.success,\n            messages: [],\n            artifacts: this.artifacts,\n            pluginName: this.pluginName,\n            startTime: this.startTime,\n            finishTime: this.finishTime,\n            error: this.error\n        },\n            i;\n\n        for (i = 0; i < this.messages.length; i += 1) {\n            result.messages.push(this.messages[i].serialize());\n        }\n\n        return result;\n    };\n\n    return PluginResult;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * This is the base class that plugins should inherit from.\n * (Using the plugin-generator - the generated plugin will do that.)\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginBase',[\n    'plugin/PluginConfig',\n    'plugin/PluginResult',\n    'plugin/PluginMessage',\n    'plugin/PluginNodeDescription'\n], function (PluginConfig, PluginResult, PluginMessage, PluginNodeDescription) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of a plugin object, which should be a derived class.\n     *\n     * @constructor\n     */\n    var PluginBase = function () {\n        // set by initialize\n        this.logger = null;\n        this.blobClient = null;\n        this._currentConfig = null;\n\n        // set by configure\n        this.core = null;\n        this.project = null;\n        this.projectName = null;\n        this.branchName = null;\n        this.branchHash = null;\n        this.commitHash = null;\n        this.currentHash = null;\n        this.rootNode = null;\n        this.activeNode = null;\n        this.activeSelection = [];\n        this.META = null;\n\n        this.result = null;\n        this.isConfigured = false;\n        this.gmeConfig = null;\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods must be overridden by the derived classes\n\n    /**\n     * Main function for the plugin to execute. This will perform the execution.\n     * Notes:\n     * - do NOT use console.log use this.logger.[error,warning,info,debug] instead\n     * - do NOT put any user interaction logic UI, etc. inside this function\n     * - callback always have to be called even if error happened\n     *\n     * @param {function(string, plugin.PluginResult)} callback - the result callback\n     */\n    PluginBase.prototype.main = function (/*callback*/) {\n        throw new Error('implement this function in the derived class');\n    };\n\n    /**\n     * Readable name of this plugin that can contain spaces.\n     *\n     * @returns {string}\n     */\n    PluginBase.prototype.getName = function () {\n        throw new Error('implement this function in the derived class - getting type automatically is a bad idea,' +\n        'when the js scripts are minified names are useless.');\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods could be overridden by the derived classes\n\n    /**\n     * Current version of this plugin using semantic versioning.\n     * @returns {string}\n     */\n    PluginBase.prototype.getVersion = function () {\n        return '0.1.0';\n    };\n\n    /**\n     * A detailed description of this plugin and its purpose. It can be one or more sentences.\n     *\n     * @returns {string}\n     */\n    PluginBase.prototype.getDescription = function () {\n        return '';\n    };\n\n    /**\n     * Configuration structure with names, descriptions, minimum, maximum values, default values and\n     * type definitions.\n     *\n     * Example:\n     *\n     * [{\n         *    \"name\": \"logChildrenNames\",\n         *    \"displayName\": \"Log Children Names\",\n         *    \"description\": '',\n         *    \"value\": true, // this is the 'default config'\n         *    \"valueType\": \"boolean\",\n         *    \"readOnly\": false\n         * },{\n         *    \"name\": \"logLevel\",\n         *    \"displayName\": \"Logger level\",\n         *    \"description\": '',\n         *    \"value\": \"info\",\n         *    \"valueType\": \"string\",\n         *    \"valueItems\": [\n         *          \"debug\",\n         *          \"info\",\n         *          \"warn\",\n         *          \"error\"\n         *      ],\n         *    \"readOnly\": false\n         * },{\n         *    \"name\": \"maxChildrenToLog\",\n         *    \"displayName\": \"Maximum children to log\",\n         *    \"description\": 'Set this parameter to blabla',\n         *    \"value\": 4,\n         *    \"minValue\": 1,\n         *    \"valueType\": \"number\",\n         *    \"readOnly\": false\n         * }]\n     *\n     * @returns {object[]}\n     */\n    PluginBase.prototype.getConfigStructure = function () {\n        return [];\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods that can be used by the derived classes\n\n    /**\n     * Updates the current success flag with a new value.\n     *\n     * NewValue = OldValue && Value\n     *\n     * @param {boolean} value - apply this flag on current success value\n     * @param {string|null} message - optional detailed message\n     */\n    PluginBase.prototype.updateSuccess = function (value, message) {\n        var prevSuccess = this.result.getSuccess();\n        var newSuccessValue = prevSuccess && value;\n\n        this.result.setSuccess(newSuccessValue);\n        var msg = '';\n        if (message) {\n            msg = ' - ' + message;\n        }\n\n        this.logger.debug('Success was updated from ' + prevSuccess + ' to ' + newSuccessValue + msg);\n    };\n\n    /**\n     * WebGME can export the META types as path and this method updates the generated domain specific types with\n     * webgme node objects. These can be used to define the base class of new objects created through the webgme API.\n     *\n     * @param {object} generatedMETA\n     */\n    PluginBase.prototype.updateMETA = function (generatedMETA) {\n        var name;\n        for (name in this.META) {\n            if (this.META.hasOwnProperty(name)) {\n                generatedMETA[name] = this.META[name];\n            }\n        }\n\n        // TODO: check if names are not the same\n        // TODO: log if META is out of date\n    };\n\n    /**\n     * Checks if the given node is of the given meta-type.\n     * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>\n     * @param node - Node to be checked for type.\n     * @param metaNode - Node object defining the meta type.\n     * @returns {boolean} - True if the given object was of the META type.\n     */\n    PluginBase.prototype.isMetaTypeOf = function (node, metaNode) {\n        var self = this;\n        while (node) {\n            if (self.core.getGuid(node) === self.core.getGuid(metaNode)) {\n                return true;\n            }\n            node = self.core.getBase(node);\n        }\n        return false;\n    };\n\n    /**\n     * Finds and returns the node object defining the meta type for the given node.\n     * @param node - Node to be checked for type.\n     * @returns {Object} - Node object defining the meta type of node.\n     */\n    PluginBase.prototype.getMetaType = function (node) {\n        var self = this,\n            name;\n        while (node) {\n            name = self.core.getAttribute(node, 'name');\n            if (self.META.hasOwnProperty(name) && self.core.getGuid(node) === self.core.getGuid(self.META[name])) {\n                break;\n            }\n            node = self.core.getBase(node);\n        }\n        return node;\n    };\n\n    /**\n     * Returns true if node is a direct instance of a meta-type node (or a meta-type node itself).\n     * @param node - Node to be checked.\n     * @returns {boolean}\n     */\n    PluginBase.prototype.baseIsMeta = function (node) {\n        var self = this,\n            baseName,\n            baseNode = self.core.getBase(node);\n        if (!baseNode) {\n            // FCO does not have a base node, by definition function returns true.\n            return true;\n        }\n        baseName = self.core.getAttribute(baseNode, 'name');\n        return self.META.hasOwnProperty(baseName) &&\n            self.core.getGuid(self.META[baseName]) === self.core.getGuid(baseNode);\n    };\n\n    /**\n     * Gets the current configuration of the plugin that was set by the user and plugin manager.\n     *\n     * @returns {object}\n     */\n    PluginBase.prototype.getCurrentConfig = function () {\n        return this._currentConfig;\n    };\n\n    /**\n     * Creates a new message for the user and adds it to the result.\n     *\n     * @param {object} node - webgme object which is related to the message\n     * @param {string} message - feedback to the user\n     * @param {string} severity - severity level of the message: 'debug', 'info' (default), 'warning', 'error'.\n     */\n    PluginBase.prototype.createMessage = function (node, message, severity) {\n        var severityLevel = severity || 'info';\n        //this occurence of the function will always handle a single node\n\n        var descriptor = new PluginNodeDescription({\n            name: node ? this.core.getAttribute(node, 'name') : '',\n            id: node ? this.core.getPath(node) : ''\n        });\n        var pluginMessage = new PluginMessage({\n            commitHash: this.currentHash,\n            activeNode: descriptor,\n            message: message,\n            severity: severityLevel\n        });\n\n        this.result.addMessage(pluginMessage);\n    };\n\n    /**\n     * Saves all current changes if there is any to a new commit.\n     * If the changes were started from a branch, then tries to fast forward the branch to the new commit.\n     * Note: Does NOT handle any merges at this point.\n     *\n     * @param {string|null} message - commit message\n     * @param callback\n     */\n    PluginBase.prototype.save = function (message, callback) {\n        var self = this;\n\n        this.logger.debug('Saving project');\n\n        this.core.persist(this.rootNode, function (err) {\n            if (err) {\n                self.logger.error(err);\n            }\n        });\n        var newRootHash = self.core.getHash(self.rootNode);\n\n        var commitMessage = '[Plugin] ' + self.getName() + ' (v' + self.getVersion() + ') updated the model.';\n        if (message) {\n            commitMessage += ' - ' + message;\n        }\n        self.currentHash = self.project.makeCommit([self.currentHash], newRootHash, commitMessage, function (err) {\n            if (err) {\n                self.logger.error(err);\n            }\n        });\n\n        if (self.branchName) {\n            // try to fast forward branch if there was a branch name defined\n\n            // FIXME: what if master branch is already in a different state?\n\n            // try to fast forward branch to the current commit\n            self.project.setBranchHash(self.branchName, self.branchHash, self.currentHash, function (err) {\n                if (err) {\n                    // fast forward failed\n                    // TODO: try auto-merge\n\n                    self.logger.error(err);\n                    self.logger.info('\"' + self.branchName + '\" was NOT updated');\n                    self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\n                } else {\n                    // successful fast forward of branch to the new commit\n                    self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\n                    // roll starting point on success\n                    self.branchHash = self.currentHash;\n                }\n                callback(err);\n            });\n\n            // FIXME: is this call async??\n            // FIXME: we are not tracking all commits that we make\n\n        } else {\n            // making commits, we have not started from a branch\n            self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\n            callback(null);\n        }\n\n        // Commit changes.\n        /*            this.core.persist(this.rootNode, function (err) {\n         // TODO: any error here?\n         if (err) {\n         self.logger.error(err);\n         }\n\n         var newRootHash = self.core.getHash(self.rootNode);\n\n         var commitMessage = '[Plugin] ' + self.getName() + ' (v' + self.getVersion() + ') updated the model.';\n         if (message) {\n         commitMessage += ' - ' + message;\n         }\n\n         self.currentHash = self.project.makeCommit([self.currentHash], newRootHash, commitMessage, function (err) {\n         // TODO: any error handling here?\n         if (err) {\n         self.logger.error(err);\n         }\n\n         if (self.branchName) {\n         // try to fast forward branch if there was a branch name defined\n\n         // FIXME: what if master branch is already in a different state?\n\n         self.project.getBranchNames(function (err, branchNames) {\n         if (branchNames.hasOwnProperty(self.branchName)) {\n         var branchHash = branchNames[self.branchName];\n         if (branchHash === self.branchHash) {\n         // the branch does not have any new commits\n         // try to fast forward branch to the current commit\n         self.project.setBranchHash(self.branchName, self.branchHash, self.currentHash, function (err) {\n         if (err) {\n         // fast forward failed\n         self.logger.error(err);\n         self.logger.info('\"' + self.branchName + '\" was NOT updated');\n         self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\n         } else {\n         // successful fast forward of branch to the new commit\n         self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\n         // roll starting point on success\n         self.branchHash = self.currentHash;\n         }\n         callback(err);\n         });\n         } else {\n         // branch has changes a merge is required\n         // TODO: try auto-merge, if fails ...\n         self.logger.warn('Cannot fast forward \"' + self.branchName + '\" branch.\n         Merge is required but not supported yet.');\n         self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\n         callback(null);\n         }\n         } else {\n         // branch was deleted or not found, do nothing\n         self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\n         callback(null);\n         }\n         });\n         // FIXME: is this call async??\n         // FIXME: we are not tracking all commits that we make\n\n         } else {\n         // making commits, we have not started from a branch\n         self.logger.info('Project was saved to ' + self.currentHash + ' commit.');\n         callback(null);\n         }\n         });\n\n         });*/\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods that are used by the Plugin Manager. Derived classes should not use these methods\n\n    /**\n     * Initializes the plugin with objects that can be reused within the same plugin instance.\n     *\n     * @param {logManager} logger - logging capability to console (or file) based on PluginManager configuration\n     * @param {blob.BlobClient} blobClient - virtual file system where files can be generated then saved as a zip file.\n     * @param {object} gmeConfig - global configuration for webGME.\n     */\n    PluginBase.prototype.initialize = function (logger, blobClient, gmeConfig) {\n        if (logger) {\n            this.logger = logger;\n        } else {\n            this.logger = console;\n        }\n        if (!gmeConfig) {\n            // TODO: Remove this check at some point\n            throw new Error('gmeConfig was not provided to Plugin.initialize!');\n        }\n        this.blobClient = blobClient;\n        this.gmeConfig = gmeConfig;\n\n        this._currentConfig = null;\n        // initialize default configuration\n        this.setCurrentConfig(this.getDefaultConfig());\n\n        this.isConfigured = false;\n    };\n\n    /**\n     * Configures this instance of the plugin for a specific execution. This function is called before the main by\n     * the PluginManager.\n     * Initializes the result with a new object.\n     *\n     * @param {PluginContext} config - specific context: project, branch, core, active object and active selection.\n     */\n    PluginBase.prototype.configure = function (config) {\n        this.core = config.core;\n        this.project = config.project;\n        this.projectName = config.projectName;\n        this.branchName = config.branchName;\n        this.branchHash = config.branchName ? config.commitHash : null;\n        this.commitHash = config.commitHash;\n        this.currentHash = config.commitHash;\n        this.rootNode = config.rootNode;\n        this.activeNode = config.activeNode;\n        this.activeSelection = config.activeSelection;\n        this.META = config.META;\n\n        this.result = new PluginResult();\n\n\n        this.isConfigured = true;\n    };\n\n    /**\n     * Gets the default configuration based on the configuration structure for this plugin.\n     *\n     * @returns {plugin.PluginConfig}\n     */\n    PluginBase.prototype.getDefaultConfig = function () {\n        var configStructure = this.getConfigStructure();\n\n        var defaultConfig = new PluginConfig();\n\n        for (var i = 0; i < configStructure.length; i += 1) {\n            defaultConfig[configStructure[i].name] = configStructure[i].value;\n        }\n\n        return defaultConfig;\n    };\n\n    /**\n     * Sets the current configuration of the plugin.\n     *\n     * @param {object} newConfig - this is the actual configuration and NOT the configuration structure.\n     */\n    PluginBase.prototype.setCurrentConfig = function (newConfig) {\n        this._currentConfig = newConfig;\n    };\n\n    return PluginBase;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginContext',[], function () {\n    'use strict';\n\n    /**\n     * Initializes a new instance of PluginContext. This context is set through PluginBase.configure method for a given\n     * plugin instance and execution.\n     *\n     * @constructor\n     */\n    var PluginContext = function () {\n\n        // TODO: something like this\n//        context.project = project;\n//        context.projectName = config.project;\n//        context.core = new Core(context.project);\n//        context.commitHash = config.commit;\n//        context.selected = config.selected;\n//        context.storage = null;\n\n    };\n\n\n    return PluginContext;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n// TODO: Use PluginManagerConfiguration\n// TODO: Load ActiveSelection objects and pass it correctly\n// TODO: Add more statistics to the result object\n// TODO: Result object rename name -> pluginName, time -> finishTime)\n// TODO: Make this class testable\n// TODO: PluginManager should download the plugins\n\n\ndefine('plugin/PluginManagerBase',['plugin/PluginBase', 'plugin/PluginContext'], function (PluginBase, PluginContext) {\n'use strict';\n\n        var PluginManagerBase = function (storage, Core, logger, plugins, gmeConfig) {\n            this.gmeConfig = gmeConfig; // global configuration of webgme\n            this.logger = logger.fork('PluginManager');\n            this._Core = Core;       // webgme core class is used to operate on objects\n            this._storage = storage; // webgme storage\n            this._plugins = plugins; // key value pair of pluginName: pluginType - plugins are already loaded/downloaded\n            this._pluginConfigs = {}; // keeps track of the current configuration for each plugins by name\n\n            if (!this.gmeConfig) {\n                // TODO: this error check is temporary\n                throw new Error('PluginManagerBase takes gmeConfig as parameter!');\n            }\n\n            var pluginNames = Object.keys(this._plugins);\n            for (var i = 0; i < pluginNames.length; i += 1) {\n                var p = new this._plugins[pluginNames[i]]();\n                this._pluginConfigs[pluginNames[i]] = p.getDefaultConfig();\n            }\n        };\n\n        PluginManagerBase.prototype.initialize = function (managerConfiguration, configCallback, callbackContext) {\n            var self = this,\n                pluginName,\n                plugins = this._plugins;\n\n            //#1: PluginManagerBase should load the plugins\n\n            //#2: PluginManagerBase iterates through each plugin and collects the config data\n            var pluginConfigs = {};\n\n            for (pluginName in plugins) {\n                if (plugins.hasOwnProperty(pluginName)) {\n                    var plugin = new plugins[pluginName]();\n                    pluginConfigs[pluginName] = plugin.getConfigStructure();\n                }\n            }\n\n            if (configCallback) {\n                configCallback.call(callbackContext, pluginConfigs, function (updatedPluginConfig) {\n                    for (pluginName in updatedPluginConfig) {\n                        if (updatedPluginConfig.hasOwnProperty(pluginName)) {\n                            //save it back to the plugin\n                            self._pluginConfigs[pluginName] = updatedPluginConfig[pluginName];\n                        }\n                    }\n                });\n            }\n        };\n\n        /**\n         * Gets a new instance of a plugin by name.\n         *\n         * @param {string} name\n         * @returns {plugin.PluginBase}\n         */\n        PluginManagerBase.prototype.getPluginByName = function (name) {\n            return this._plugins[name];\n        };\n\n        PluginManagerBase.prototype.loadMetaNodes = function (pluginContext, callback) {\n            var self = this;\n\n            this.logger.debug('Loading meta nodes');\n\n            // get meta members\n            var metaIDs = pluginContext.core.getMemberPaths(pluginContext.rootNode, 'MetaAspectSet');\n\n            var len = metaIDs.length;\n\n            var nodeObjs = [];\n\n\n            var allObjectsLoadedHandler = function () {\n                var len2 = nodeObjs.length;\n\n                var nameObjMap = {};\n\n                while (len2--) {\n                    var nodeObj = nodeObjs[len2];\n\n                    nameObjMap[pluginContext.core.getAttribute(nodeObj, 'name')] = nodeObj;\n                }\n\n                pluginContext.META = nameObjMap;\n\n                self.logger.debug('Meta nodes are loaded');\n\n                callback(null, pluginContext);\n            };\n\n            var loadedMetaObjectHandler = function (err, nodeObj) {\n                nodeObjs.push(nodeObj);\n\n                if (nodeObjs.length === metaIDs.length) {\n                    allObjectsLoadedHandler();\n                }\n            };\n\n            while (len--) {\n                pluginContext.core.loadByPath(pluginContext.rootNode, metaIDs[len], loadedMetaObjectHandler);\n            }\n        };\n\n        /**\n         *\n         * @param {plugin.PluginManagerConfiguration} managerConfiguration\n         * @param {function} callback\n         */\n        PluginManagerBase.prototype.getPluginContext = function (managerConfiguration, callback) {\n            var self = this,\n                pluginContext = new PluginContext();\n\n            // TODO: check if callback is a function\n            // based on the string values get the node objects\n            // 1) Open project\n            // 2) Load branch OR commit hash\n            // 3) Load rootNode\n            // 4) Load active object\n            // 5) Load active selection\n            // 6) Update context\n            // 7) return\n\n            pluginContext.project = this._storage;\n            pluginContext.projectName = managerConfiguration.project;\n            pluginContext.core = new self._Core(pluginContext.project, {\n                globConf: self.gmeConfig,\n                logger: self.logger.fork('core') //TODO: This logger should probably fork from the plugin logger\n            });\n            pluginContext.commitHash = managerConfiguration.commit;\n            pluginContext.activeNode = null;    // active object\n            pluginContext.activeSelection = []; // selected objects\n\n            // add activeSelection\n            function loadActiveSelectionAndMetaNodes() {\n                var remaining = managerConfiguration.activeSelection.length,\n                    i;\n                function loadNodeByNode(selectedNodePath) {\n                    pluginContext.core.loadByPath(pluginContext.rootNode, selectedNodePath,\n                        function (err, selectedNode) {\n                                remaining -= 1;\n\n                                if (err) {\n                                self.logger.warn('unable to load active selection: ' + selectedNodePath);\n                                } else {\n                                pluginContext.activeSelection.push(selectedNode);\n                                }\n\n                                if (remaining === 0) {\n                                    // all nodes from active selection are loaded\n                                    self.loadMetaNodes(pluginContext, callback);\n                                }\n                        }\n                    );\n                }\n                if (managerConfiguration.activeSelection.length === 0) {\n                    self.loadMetaNodes(pluginContext, callback);\n                } else {\n                    for (i = 0; i < managerConfiguration.activeSelection.length; i += 1) {\n                        loadNodeByNode(managerConfiguration.activeSelection[i]);\n                    }\n                    }\n                }\n\n            // add activeNode\n            function loadCommitHashAndRun(commitHash) {\n                self.logger.info('Loading commit ' + commitHash);\n                pluginContext.project.loadObject(commitHash, function (err, commitObj) {\n                    if (err) {\n                        callback(err, pluginContext);\n                        return;\n                    }\n\n                    if (typeof commitObj === 'undefined' || commitObj === null) {\n                        callback('cannot find commit', pluginContext);\n                        return;\n                    }\n\n                    pluginContext.core.loadRoot(commitObj.root, function (err, rootNode) {\n                        if (err) {\n                            callback('unable to load root', pluginContext);\n                            return;\n                        }\n\n                        pluginContext.rootNode = rootNode;\n                        if (typeof managerConfiguration.activeNode === 'string') {\n                            pluginContext.core.loadByPath(pluginContext.rootNode, managerConfiguration.activeNode,\n                                function (err, activeNode) {\n                                if (err) {\n                                        callback('unable to load selected object', pluginContext);\n                                    return;\n                                }\n\n                                pluginContext.activeNode = activeNode;\n                                loadActiveSelectionAndMetaNodes();\n                                }\n                            );\n                        } else {\n                            pluginContext.activeNode = null;\n                            loadActiveSelectionAndMetaNodes();\n                        }\n                    });\n                });\n            }\n\n            // load commit hash and run based on branch name or commit hash\n            if (managerConfiguration.branchName) {\n                pluginContext.project.getBranchNames(function (err, branchNames) {\n                    self.logger.debug(branchNames);\n\n                        pluginContext.commitHash = branchNames[managerConfiguration.branchName] || pluginContext.commitHash;\n                        pluginContext.branchName = managerConfiguration.branchName;\n                        loadCommitHashAndRun(pluginContext.commitHash);\n                });\n            } else {\n                loadCommitHashAndRun(pluginContext.commitHash);\n            }\n\n        };\n\n        PluginManagerBase.prototype.executePlugin = function (name, managerConfiguration, callback) {\n            // TODO: check if name is a string\n            // TODO: check if managerConfiguration is an instance of PluginManagerConfiguration\n            // TODO: check if callback is a function\n            var self = this,\n                mainCallbackCalls = 0,\n                multiCallbackHandled = false;\n\n            var PluginClass = this.getPluginByName(name);\n\n            var plugin = new PluginClass();\n\n            var pluginLogger = this.logger.fork('gme:plugin:' + name, true);\n\n            plugin.initialize(pluginLogger, managerConfiguration.blobClient, self.gmeConfig);\n\n            plugin.setCurrentConfig(this._pluginConfigs[name]);\n            for (var key in managerConfiguration.pluginConfig) {\n                if (managerConfiguration.pluginConfig.hasOwnProperty(key) &&\n                    plugin._currentConfig.hasOwnProperty(key)) {\n\n                    plugin._currentConfig[key] = managerConfiguration.pluginConfig[key];\n                }\n            }\n            self.getPluginContext(managerConfiguration, function (err, pluginContext) {\n                if (err) {\n                    // TODO: this has to return with an empty PluginResult object and NOT with null.\n                    callback(err, null);\n                    return;\n\n                }\n\n                plugin.configure(pluginContext);\n\n                var startTime = (new Date()).toISOString();\n\n                plugin.main(function (err, result) {\n                    var stackTrace;\n                    mainCallbackCalls += 1;\n                    // set common information (meta info) about the plugin and measured execution times\n                    result.setFinishTime((new Date()).toISOString());\n                    result.setStartTime(startTime);\n\n                    result.setPluginName(plugin.getName());\n\n                    if (mainCallbackCalls > 1) {\n                        stackTrace = new Error().stack;\n                        self.logger.error('The main callback is being called more than once!', {metadata: stackTrace});\n                        result.setError('The main callback is being called more than once!');\n                        if (multiCallbackHandled === true) {\n                            plugin.createMessage(null, stackTrace);\n                            return;\n                        }\n                        multiCallbackHandled = true;\n                        result.setSuccess(false);\n                        plugin.createMessage(null, 'The main callback is being called more than once.');\n                        plugin.createMessage(null, stackTrace);\n                        callback('The main callback is being called more than once!', result);\n                    } else {\n                        result.setError(err);\n                        callback(err, result);\n                    }\n                });\n\n            });\n\n        };\n\n\n        return PluginManagerBase;\n    });\n",
    "define('js/Dialogs/PluginConfig/PluginConfigDialog',[], function () {\n   return;\n});\n\n",
    "/*globals define, WebGMEGlobal, requirejs*/\n/*jshint browser: true*/\n\n/**\n * @author rkereskenyi / https://github.com/rkereskenyi\n * @author lattmann / https://github.com/lattmann\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/Utils/InterpreterManager',[\n    'common/core/core',\n    'plugin/PluginManagerBase',\n    'plugin/PluginResult',\n    'blob/BlobClient',\n    'js/Dialogs/PluginConfig/PluginConfigDialog',\n    'js/logger'\n], function (Core, PluginManagerBase, PluginResult, BlobClient, PluginConfigDialog, Logger) {\n\n    'use strict';\n\n    var InterpreterManager = function (client, gmeConfig) {\n        this._client = client;\n        //this._manager = new PluginManagerBase();\n        this.gmeConfig = gmeConfig;\n        this._savedConfigs = {};\n        this.logger = Logger.create('gme:InterpreterManager', gmeConfig.client.log);\n        this.logger.debug('InterpreterManager ctor');\n    };\n\n    var getPlugin = function (name, callback) {\n        if (WebGMEGlobal && WebGMEGlobal.plugins && WebGMEGlobal.plugins.hasOwnProperty(name)) {\n            callback(null, WebGMEGlobal.plugins[name]);\n        } else {\n            requirejs(['/plugin/' + name + '/' + name + '/' + name],\n                function (InterpreterClass) {\n                    callback(null, InterpreterClass);\n                },\n                function (err) {\n                    callback(err, null);\n                }\n            );\n        }\n    };\n\n    /**\n     *\n     * @param {string} name - name of plugin to be executed.\n     * @param {object} silentPluginCfg - if falsy dialog window will be shown.\n     * @param {object.string} silentPluginCfg.activeNode - Path to activeNode.\n     * @param {object.Array.<string>} silentPluginCfg.activeSelection - Paths to nodes in activeSelection.\n     * @param {object.boolean} silentPluginCfg.runOnServer - Whether to run the plugin on the server or not.\n     * @param {object.object} silentPluginCfg.pluginConfig - Plugin specific options.\n     * @param callback\n     */\n    InterpreterManager.prototype.run = function (name, silentPluginCfg, callback) {\n        var self = this;\n        getPlugin(name, function (err, plugin) {\n            self.logger.debug('Getting getPlugin in run.');\n            if (!err && plugin) {\n                var plugins = {},\n                    runWithConfiguration;\n                plugins[name] = plugin;\n                var pluginManager = new PluginManagerBase(self._client.getProjectObject(), Core, self.logger, plugins,\n                    self.gmeConfig);\n                pluginManager.initialize(null, function (pluginConfigs, configSaveCallback) {\n                    //#1: display config to user\n                    var noServerExecution = self.gmeConfig.plugin.allowServerExecution === false,\n                        hackedConfig = {\n                            'Global Options': [\n                                {\n                                    name: 'runOnServer',\n                                    displayName: 'Execute on Server',\n                                    description: noServerExecution ? 'Server side execution is disabled.' : '',\n                                    value: false, // this is the 'default config'\n                                    valueType: 'boolean',\n                                    readOnly: noServerExecution\n                                }\n                            ]\n                        },\n                        i, j, d, len;\n\n                    for (i in pluginConfigs) {\n                        if (pluginConfigs.hasOwnProperty(i)) {\n                            hackedConfig[i] = pluginConfigs[i];\n\n                            // retrieve user settings from previous run\n                            if (self._savedConfigs.hasOwnProperty(i)) {\n                                var iConfig = self._savedConfigs[i];\n                                len = hackedConfig[i].length;\n\n                                while (len--) {\n                                    if (iConfig.hasOwnProperty(hackedConfig[i][len].name)) {\n                                        hackedConfig[i][len].value = iConfig[hackedConfig[i][len].name];\n                                    }\n                                }\n\n                            }\n                        }\n                    }\n\n                    runWithConfiguration = function (updatedConfig) {\n                        //when Save&Run is clicked in the dialog (or silentPluginCfg was passed)\n                        var globalconfig = updatedConfig['Global Options'],\n                            activeNode,\n                            activeSelection;\n                        delete updatedConfig['Global Options'];\n\n                        activeNode = silentPluginCfg.activeNode;\n                        if (!activeNode && WebGMEGlobal && WebGMEGlobal.State) {\n                            activeNode = WebGMEGlobal.State.getActiveObject();\n                        }\n                        activeSelection = silentPluginCfg.activeSelection;\n                        if (!activeSelection && WebGMEGlobal && WebGMEGlobal.State) {\n                            activeSelection = WebGMEGlobal.State.getActiveSelection();\n                        }\n                        // save config from user\n                        for (i in updatedConfig) {\n                            self._savedConfigs[i] = updatedConfig[i];\n                        }\n\n                        //#2: save it back and run the plugin\n                        if (configSaveCallback) {\n                            configSaveCallback(updatedConfig);\n\n                            // TODO: If global config says try to merge branch then we\n                            // TODO: should pass the name of the branch.\n                            var config = {\n                                project: self._client.getActiveProjectName(),\n                                token: '',\n                                activeNode: activeNode, // active object in the editor\n                                activeSelection: activeSelection || [],\n                                commit: self._client.getActualCommit(), //#668b3babcdf2ddcd7ba38b51acb62d63da859d90,\n\n                                // this has priority over the commit if not null\n                                branchName: self._client.getActualBranch()\n                            };\n\n                            if (globalconfig.runOnServer === true || silentPluginCfg.runOnServer === true) {\n                                var context = {\n                                    managerConfig: config,\n                                    pluginConfigs: updatedConfig\n                                };\n                                self._client.runServerPlugin(name, context, function (err, result) {\n                                    if (err) {\n                                        self.logger.error(err);\n                                        callback(new PluginResult()); //TODO return proper error result\n                                    } else {\n                                        var resultObject = new PluginResult(result);\n                                        callback(resultObject);\n                                    }\n                                });\n                            } else {\n                                config.blobClient = new BlobClient();\n\n                                pluginManager.executePlugin(name, config, function (err, result) {\n                                    if (err) {\n                                        self.logger.error(err);\n                                    }\n                                    callback(result);\n                                });\n                            }\n                        }\n                    };\n\n                    if (silentPluginCfg) {\n                        var updatedConfig = {};\n                        for (i in hackedConfig) {\n                            updatedConfig[i] = {};\n                            len = hackedConfig[i].length;\n                            while (len--) {\n                                updatedConfig[i][hackedConfig[i][len].name] = hackedConfig[i][len].value;\n                            }\n\n                            if (silentPluginCfg && silentPluginCfg.pluginConfig) {\n                                for (j in silentPluginCfg.pluginConfig) {\n                                    updatedConfig[i][j] = silentPluginCfg.pluginConfig[j];\n                                }\n                            }\n                        }\n                        runWithConfiguration(updatedConfig);\n                    } else {\n                        d = new PluginConfigDialog();\n                        silentPluginCfg = {};\n                        d.show(hackedConfig, runWithConfiguration);\n                    }\n                });\n            } else {\n                self.logger.error(err);\n                self.logger.error('unable to load plugin');\n                callback(null); //TODO proper result\n            }\n        });\n    };\n\n    //TODO: Somehow it would feel more right if we do run in async mode, but if not then we should provide getState and\n    //TODO: getResult synchronous functions as well.\n\n    return InterpreterManager;\n});\n\n",
    "/*globals define, document, console, window, GME, docReady, setTimeout*/\n/*jshint browser:true, evil:true*/\n\n/**\n * @author kecso / https://github.com/kecso\n * @author lattmann / https://github.com/lattmann\n * @author nabana / https://github.com/nabana\n * @author ksmyth / https://github.com/ksmyth\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('webgme.classes', [\n    'client/js/client',\n    'blob/BlobClient',\n    'executor/ExecutorClient',\n    'js/Utils/InterpreterManager',\n    'common/core/core',\n    'common/storage/clientstorage',\n    'js/logger',\n    'lib/superagent/superagent-1.1.0'\n], function (Client, BlobClient, ExecutorClient, InterpreterManager, Core, Storage, Logger, superagent) {\n\n    'use strict';\n    // Setting global classes\n\n    GME.classes.Client = Client;\n    GME.classes.BlobClient = BlobClient;\n    GME.classes.ExecutorClient = ExecutorClient;\n    GME.classes.InterpreterManager = InterpreterManager;\n    GME.classes.Core = Core;\n    GME.classes.Storage = Storage;\n    GME.classes.Logger = Logger;\n\n    // Exposing built in libraries\n    GME.utils.superagent = superagent;\n\n    // Pure JavaScript equivalent to jQuery's $.ready() from https://github.com/jfriend00/docReady\n\n    (function (funcName, baseObj) {\n        // The public function name defaults to window.docReady\n        // but you can pass in your own object and own function name and those will be used\n        // if you want to put them in a different namespace\n        funcName = funcName || 'docReady';\n        baseObj = baseObj || window;\n        var readyList = [];\n        var readyFired = false;\n        var readyEventHandlersInstalled = false;\n\n        // call this when the document is ready\n        // this function protects itself against being called more than once\n        function ready() {\n            if (!readyFired) {\n                // this must be set to true before we start calling callbacks\n                readyFired = true;\n                for (var i = 0; i < readyList.length; i++) {\n                    // if a callback here happens to add new ready handlers,\n                    // the docReady() function will see that it already fired\n                    // and will schedule the callback to run right after\n                    // this event loop finishes so all handlers will still execute\n                    // in order and no new ones will be added to the readyList\n                    // while we are processing the list\n                    readyList[i].fn.call(window, readyList[i].ctx);\n                }\n                // allow any closures held by these functions to free\n                readyList = [];\n            }\n        }\n\n        function readyStateChange() {\n            if (document.readyState === 'complete') {\n                ready();\n            }\n        }\n\n        // This is the one public interface\n        // docReady(fn, context);\n        // the context argument is optional - if present, it will be passed\n        // as an argument to the callback\n        baseObj[funcName] = function (callback, context) {\n            // if ready has already fired, then just schedule the callback\n            // to fire asynchronously, but right away\n            if (readyFired) {\n                setTimeout(function () {\n                    callback(context);\n                }, 1);\n                return;\n            } else {\n                // add the function and context to the list\n                readyList.push({fn: callback, ctx: context});\n            }\n            // if document already ready to go, schedule the ready function to run\n            if (document.readyState === 'complete') {\n                setTimeout(ready, 1);\n            } else if (!readyEventHandlersInstalled) {\n                // otherwise if we don't have event handlers installed, install them\n                if (document.addEventListener) {\n                    // first choice is DOMContentLoaded event\n                    document.addEventListener('DOMContentLoaded', ready, false);\n                    // backup is window load event\n                    window.addEventListener('load', ready, false);\n                } else {\n                    // must be IE\n                    document.attachEvent('onreadystatechange', readyStateChange);\n                    window.attachEvent('onload', ready);\n                }\n                readyEventHandlersInstalled = true;\n            }\n        };\n    })('docReady', window);\n\n    // See if there is handler attached to body tag when ready\n\n    var evalOnGmeInit = function () {\n        if (document.body.getAttribute('on-gme-init')) {\n            eval(document.body.getAttribute('on-gme-init'));\n        } else {\n            console.warn('To use GME, define a javascript function and set the body ' +\n            'element\\'s on-gme-init property.');\n        }\n    };\n\n    // wait for document.readyState !== 'loading' and getGmeConfig\n    var stillLoading = 2;\n    var somethingFinishedLoading = function () {\n        if (--stillLoading === 0) {\n            evalOnGmeInit();\n        }\n    };\n\n    if (document.readyState === 'loading') {\n        docReady(function () {\n            somethingFinishedLoading();\n        });\n    } else {\n        somethingFinishedLoading();\n    }\n\n\n    (function getGmeConfig() {\n        var http = new XMLHttpRequest(),\n            configUrl = window.location.origin + '/gmeConfig.json';\n        http.onreadystatechange = function () {\n            if (http.readyState === 4 && http.status === 200) {\n                GME.gmeConfig = JSON.parse(http.responseText);\n                somethingFinishedLoading();\n            } else if (http.readyState === 4 && http.status !== 200) {\n                console.warn('Could not load gmeConfig at', configUrl);\n                somethingFinishedLoading();\n            }\n        };\n        http.open('GET', configUrl, true);\n        http.send();\n    })();\n});\n\n"
  ]
}