{
  "version": 3,
  "file": "C:/Users/kevin/Documents/mms-webcyphy/node_modules/webgme/dist/webgme.classes.build.js",
  "sources": [
    "../node_modules/requirejs/require.js",
    "client/lib/debug/debug.js",
    "client/js/logger.js",
    "common/storage/constants.js",
    "common/storage/storageclasses/watchers.js",
    "common/storage/storageclasses/simpleapi.js",
    "common/storage/storageclasses/objectloaders.js",
    "common/util/assert.js",
    "common/storage/project/cache.js",
    "common/storage/project/interface.js",
    "common/storage/project/branch.js",
    "common/storage/project/project.js",
    "common/util/sha1.js",
    "common/util/canon.js",
    "common/util/key.js",
    "common/storage/storageclasses/editorstorage.js",
    "common/storage/socketio/browserclient.js",
    "common/EventDispatcher.js",
    "common/storage/socketio/websocket.js",
    "common/storage/browserstorage.js",
    "common/core/tasync.js",
    "common/core/coretree.js",
    "common/core/corerel.js",
    "common/core/setcore.js",
    "common/util/guid.js",
    "common/regexp.js",
    "common/core/guidcore.js",
    "common/core/nullpointercore.js",
    "common/core/coreunwrap.js",
    "common/core/coretype.js",
    "common/core/constraintcore.js",
    "common/core/metacore.js",
    "common/core/coretreeloader.js",
    "common/core/corediff.js",
    "common/core/core.js",
    "client/js/client/constants.js",
    "common/core/users/meta.js",
    "common/util/url.js",
    "common/core/users/tojson.js",
    "client/js/client/gmeNodeGetter.js",
    "client/js/client/gmeNodeSetter.js",
    "common/core/users/serialization.js",
    "client/js/client/addon.js",
    "client/js/client.js",
    "common/blob/BlobConfig.js",
    "common/blob/BlobMetadata.js",
    "common/blob/Artifact.js",
    "client/lib/superagent/superagent-1.2.0.js",
    "common/blob/BlobClient.js",
    "common/executor/ExecutorClient.js",
    "plugin/PluginConfig.js",
    "plugin/PluginNodeDescription.js",
    "plugin/PluginMessage.js",
    "plugin/PluginResult.js",
    "plugin/PluginBase.js",
    "plugin/PluginContext.js",
    "plugin/PluginManagerBase.js",
    "../utils/build/empty/empty.js",
    "client/js/Utils/InterpreterManager.js",
    "../teststorage/teststorage.js",
    "../utils/build/webgme.classes/webgme.classes.js"
  ],
  "names": [],
  "mappings": ";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtiEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxfA,ADyfA;ACxfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9HA,AD+HA;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChMA,ADiMA;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA,AD2BA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA,AD4DA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/EA;AACA;AACA;AACA;AACA;AACA;ACLA,ADMA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA,ADuCA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1bA,AD2bA;AC1bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpCA,ADqCA;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnMA,ADoMA;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA,AD8CA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjvBA,ADkvBA;ACjvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACv+BA,ADw+BA;ACv+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC11BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA,ADqBA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA,ADwBA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA,AD8DA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA,ADwFA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnyBA,ADoyBA;ACnyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9fA,AD+fA;AC9fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA,ADyDA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9wEA,AD+wEA;AC9wEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA,ADiDA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA,ADwCA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACthBA,ADuhBA;ACthBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACt5BA,ADu5BA;ACt5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChLA,ADiLA;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC3wDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjGA,ADkGA;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3SA,AD4SA;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACtyCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC1WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA,ADgDA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/MA,ADgNA;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,ACpjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrUA,ADsUA;ACrUA;AACA;AACA;AACA,ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AXxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYryCA,AZsyCA;AYryCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,AClMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "sourcesContent": [
    "/** vim: et:ts=4:sw=4:sts=4\n * @license RequireJS 2.1.16 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/requirejs for details\n */\n//Not using strict: uneven strict support in browsers, #392, and causes\n//problems with requirejs.exec()/transpiler plugins that may not be strict.\n/*jslint regexp: true, nomen: true, sloppy: true */\n/*global window, navigator, document, importScripts, setTimeout, opera */\n\nvar requirejs, require, define;\n(function (global) {\n    var req, s, head, baseElement, dataMain, src,\n        interactiveScript, currentlyAddingScript, mainScript, subPath,\n        version = '2.1.16',\n        commentRegExp = /(\\/\\*([\\s\\S]*?)\\*\\/|([^:]|^)\\/\\/(.*)$)/mg,\n        cjsRequireRegExp = /[^.]\\s*require\\s*\\(\\s*[\"']([^'\"\\s]+)[\"']\\s*\\)/g,\n        jsSuffixRegExp = /\\.js$/,\n        currDirRegExp = /^\\.\\//,\n        op = Object.prototype,\n        ostring = op.toString,\n        hasOwn = op.hasOwnProperty,\n        ap = Array.prototype,\n        apsp = ap.splice,\n        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),\n        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',\n        //PS3 indicates loaded and complete, but need to wait for complete\n        //specifically. Sequence is 'loading', 'loaded', execution,\n        // then 'complete'. The UA check is unfortunate, but not sure how\n        //to feature test w/o causing perf issues.\n        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?\n                      /^complete$/ : /^(complete|loaded)$/,\n        defContextName = '_',\n        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.\n        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',\n        contexts = {},\n        cfg = {},\n        globalDefQueue = [],\n        useInteractive = false;\n\n    function isFunction(it) {\n        return ostring.call(it) === '[object Function]';\n    }\n\n    function isArray(it) {\n        return ostring.call(it) === '[object Array]';\n    }\n\n    /**\n     * Helper function for iterating over an array. If the func returns\n     * a true value, it will break out of the loop.\n     */\n    function each(ary, func) {\n        if (ary) {\n            var i;\n            for (i = 0; i < ary.length; i += 1) {\n                if (ary[i] && func(ary[i], i, ary)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Helper function for iterating over an array backwards. If the func\n     * returns a true value, it will break out of the loop.\n     */\n    function eachReverse(ary, func) {\n        if (ary) {\n            var i;\n            for (i = ary.length - 1; i > -1; i -= 1) {\n                if (ary[i] && func(ary[i], i, ary)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    function getOwn(obj, prop) {\n        return hasProp(obj, prop) && obj[prop];\n    }\n\n    /**\n     * Cycles over properties in an object and calls a function for each\n     * property value. If the function returns a truthy value, then the\n     * iteration is stopped.\n     */\n    function eachProp(obj, func) {\n        var prop;\n        for (prop in obj) {\n            if (hasProp(obj, prop)) {\n                if (func(obj[prop], prop)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Simple function to mix in properties from source into target,\n     * but only if target does not already have a property of the same name.\n     */\n    function mixin(target, source, force, deepStringMixin) {\n        if (source) {\n            eachProp(source, function (value, prop) {\n                if (force || !hasProp(target, prop)) {\n                    if (deepStringMixin && typeof value === 'object' && value &&\n                        !isArray(value) && !isFunction(value) &&\n                        !(value instanceof RegExp)) {\n\n                        if (!target[prop]) {\n                            target[prop] = {};\n                        }\n                        mixin(target[prop], value, force, deepStringMixin);\n                    } else {\n                        target[prop] = value;\n                    }\n                }\n            });\n        }\n        return target;\n    }\n\n    //Similar to Function.prototype.bind, but the 'this' object is specified\n    //first, since it is easier to read/figure out what 'this' will be.\n    function bind(obj, fn) {\n        return function () {\n            return fn.apply(obj, arguments);\n        };\n    }\n\n    function scripts() {\n        return document.getElementsByTagName('script');\n    }\n\n    function defaultOnError(err) {\n        throw err;\n    }\n\n    //Allow getting a global that is expressed in\n    //dot notation, like 'a.b.c'.\n    function getGlobal(value) {\n        if (!value) {\n            return value;\n        }\n        var g = global;\n        each(value.split('.'), function (part) {\n            g = g[part];\n        });\n        return g;\n    }\n\n    /**\n     * Constructs an error with a pointer to an URL with more information.\n     * @param {String} id the error ID that maps to an ID on a web page.\n     * @param {String} message human readable error.\n     * @param {Error} [err] the original error, if there is one.\n     *\n     * @returns {Error}\n     */\n    function makeError(id, msg, err, requireModules) {\n        var e = new Error(msg + '\\nhttp://requirejs.org/docs/errors.html#' + id);\n        e.requireType = id;\n        e.requireModules = requireModules;\n        if (err) {\n            e.originalError = err;\n        }\n        return e;\n    }\n\n    if (typeof define !== 'undefined') {\n        //If a define is already in play via another AMD loader,\n        //do not overwrite.\n        return;\n    }\n\n    if (typeof requirejs !== 'undefined') {\n        if (isFunction(requirejs)) {\n            //Do not overwrite an existing requirejs instance.\n            return;\n        }\n        cfg = requirejs;\n        requirejs = undefined;\n    }\n\n    //Allow for a require config object\n    if (typeof require !== 'undefined' && !isFunction(require)) {\n        //assume it is a config object.\n        cfg = require;\n        require = undefined;\n    }\n\n    function newContext(contextName) {\n        var inCheckLoaded, Module, context, handlers,\n            checkLoadedTimeoutId,\n            config = {\n                //Defaults. Do not set a default for map\n                //config to speed up normalize(), which\n                //will run faster if there is no default.\n                waitSeconds: 7,\n                baseUrl: './',\n                paths: {},\n                bundles: {},\n                pkgs: {},\n                shim: {},\n                config: {}\n            },\n            registry = {},\n            //registry of just enabled modules, to speed\n            //cycle breaking code when lots of modules\n            //are registered, but not activated.\n            enabledRegistry = {},\n            undefEvents = {},\n            defQueue = [],\n            defined = {},\n            urlFetched = {},\n            bundlesMap = {},\n            requireCounter = 1,\n            unnormalizedCounter = 1;\n\n        /**\n         * Trims the . and .. from an array of path segments.\n         * It will keep a leading path segment if a .. will become\n         * the first path segment, to help with module name lookups,\n         * which act like paths, but can be remapped. But the end result,\n         * all paths that use this function should look normalized.\n         * NOTE: this method MODIFIES the input array.\n         * @param {Array} ary the array of path segments.\n         */\n        function trimDots(ary) {\n            var i, part;\n            for (i = 0; i < ary.length; i++) {\n                part = ary[i];\n                if (part === '.') {\n                    ary.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        ary.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Given a relative module name, like ./something, normalize it to\n         * a real name that can be mapped to a path.\n         * @param {String} name the relative name\n         * @param {String} baseName a real name that the name arg is relative\n         * to.\n         * @param {Boolean} applyMap apply the map config to the value. Should\n         * only be done if this normalization is for a dependency ID.\n         * @returns {String} normalized name\n         */\n        function normalize(name, baseName, applyMap) {\n            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,\n                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,\n                baseParts = (baseName && baseName.split('/')),\n                map = config.map,\n                starMap = map && map['*'];\n\n            //Adjust any relative paths.\n            if (name) {\n                name = name.split('/');\n                lastIndex = name.length - 1;\n\n                // If wanting node ID compatibility, strip .js from end\n                // of IDs. Have to do this here, and not in nameToUrl\n                // because node allows either .js or non .js to map\n                // to same file.\n                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n                }\n\n                // Starts with a '.' so need the baseName\n                if (name[0].charAt(0) === '.' && baseParts) {\n                    //Convert baseName to array, and lop off the last part,\n                    //so that . matches that 'directory' and not name of the baseName's\n                    //module. For instance, baseName of 'one/two/three', maps to\n                    //'one/two/three.js', but we want the directory, 'one/two' for\n                    //this normalization.\n                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                    name = normalizedBaseParts.concat(name);\n                }\n\n                trimDots(name);\n                name = name.join('/');\n            }\n\n            //Apply map config if available.\n            if (applyMap && map && (baseParts || starMap)) {\n                nameParts = name.split('/');\n\n                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {\n                    nameSegment = nameParts.slice(0, i).join('/');\n\n                    if (baseParts) {\n                        //Find the longest baseName segment match in the config.\n                        //So, do joins on the biggest to smallest lengths of baseParts.\n                        for (j = baseParts.length; j > 0; j -= 1) {\n                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));\n\n                            //baseName segment has config, find if it has one for\n                            //this name.\n                            if (mapValue) {\n                                mapValue = getOwn(mapValue, nameSegment);\n                                if (mapValue) {\n                                    //Match, update name to the new value.\n                                    foundMap = mapValue;\n                                    foundI = i;\n                                    break outerLoop;\n                                }\n                            }\n                        }\n                    }\n\n                    //Check for a star map match, but just hold on to it,\n                    //if there is a shorter segment match later in a matching\n                    //config, then favor over this star map.\n                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {\n                        foundStarMap = getOwn(starMap, nameSegment);\n                        starI = i;\n                    }\n                }\n\n                if (!foundMap && foundStarMap) {\n                    foundMap = foundStarMap;\n                    foundI = starI;\n                }\n\n                if (foundMap) {\n                    nameParts.splice(0, foundI, foundMap);\n                    name = nameParts.join('/');\n                }\n            }\n\n            // If the name points to a package's name, use\n            // the package main instead.\n            pkgMain = getOwn(config.pkgs, name);\n\n            return pkgMain ? pkgMain : name;\n        }\n\n        function removeScript(name) {\n            if (isBrowser) {\n                each(scripts(), function (scriptNode) {\n                    if (scriptNode.getAttribute('data-requiremodule') === name &&\n                            scriptNode.getAttribute('data-requirecontext') === context.contextName) {\n                        scriptNode.parentNode.removeChild(scriptNode);\n                        return true;\n                    }\n                });\n            }\n        }\n\n        function hasPathFallback(id) {\n            var pathConfig = getOwn(config.paths, id);\n            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {\n                //Pop off the first array value, since it failed, and\n                //retry\n                pathConfig.shift();\n                context.require.undef(id);\n\n                //Custom require that does not do map translation, since\n                //ID is \"absolute\", already mapped/resolved.\n                context.makeRequire(null, {\n                    skipMap: true\n                })([id]);\n\n                return true;\n            }\n        }\n\n        //Turns a plugin!resource to [plugin, resource]\n        //with the plugin being undefined if the name\n        //did not have a plugin prefix.\n        function splitPrefix(name) {\n            var prefix,\n                index = name ? name.indexOf('!') : -1;\n            if (index > -1) {\n                prefix = name.substring(0, index);\n                name = name.substring(index + 1, name.length);\n            }\n            return [prefix, name];\n        }\n\n        /**\n         * Creates a module mapping that includes plugin prefix, module\n         * name, and path. If parentModuleMap is provided it will\n         * also normalize the name via require.normalize()\n         *\n         * @param {String} name the module name\n         * @param {String} [parentModuleMap] parent module map\n         * for the module name, used to resolve relative names.\n         * @param {Boolean} isNormalized: is the ID already normalized.\n         * This is true if this call is done for a define() module ID.\n         * @param {Boolean} applyMap: apply the map config to the ID.\n         * Should only be true if this map is for a dependency.\n         *\n         * @returns {Object}\n         */\n        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {\n            var url, pluginModule, suffix, nameParts,\n                prefix = null,\n                parentName = parentModuleMap ? parentModuleMap.name : null,\n                originalName = name,\n                isDefine = true,\n                normalizedName = '';\n\n            //If no name, then it means it is a require call, generate an\n            //internal name.\n            if (!name) {\n                isDefine = false;\n                name = '_@r' + (requireCounter += 1);\n            }\n\n            nameParts = splitPrefix(name);\n            prefix = nameParts[0];\n            name = nameParts[1];\n\n            if (prefix) {\n                prefix = normalize(prefix, parentName, applyMap);\n                pluginModule = getOwn(defined, prefix);\n            }\n\n            //Account for relative paths if there is a base name.\n            if (name) {\n                if (prefix) {\n                    if (pluginModule && pluginModule.normalize) {\n                        //Plugin is loaded, use its normalize method.\n                        normalizedName = pluginModule.normalize(name, function (name) {\n                            return normalize(name, parentName, applyMap);\n                        });\n                    } else {\n                        // If nested plugin references, then do not try to\n                        // normalize, as it will not normalize correctly. This\n                        // places a restriction on resourceIds, and the longer\n                        // term solution is not to normalize until plugins are\n                        // loaded and all normalizations to allow for async\n                        // loading of a loader plugin. But for now, fixes the\n                        // common uses. Details in #1131\n                        normalizedName = name.indexOf('!') === -1 ?\n                                         normalize(name, parentName, applyMap) :\n                                         name;\n                    }\n                } else {\n                    //A regular module.\n                    normalizedName = normalize(name, parentName, applyMap);\n\n                    //Normalized name may be a plugin ID due to map config\n                    //application in normalize. The map config values must\n                    //already be normalized, so do not need to redo that part.\n                    nameParts = splitPrefix(normalizedName);\n                    prefix = nameParts[0];\n                    normalizedName = nameParts[1];\n                    isNormalized = true;\n\n                    url = context.nameToUrl(normalizedName);\n                }\n            }\n\n            //If the id is a plugin id that cannot be determined if it needs\n            //normalization, stamp it with a unique ID so two matching relative\n            //ids that may conflict can be separate.\n            suffix = prefix && !pluginModule && !isNormalized ?\n                     '_unnormalized' + (unnormalizedCounter += 1) :\n                     '';\n\n            return {\n                prefix: prefix,\n                name: normalizedName,\n                parentMap: parentModuleMap,\n                unnormalized: !!suffix,\n                url: url,\n                originalName: originalName,\n                isDefine: isDefine,\n                id: (prefix ?\n                        prefix + '!' + normalizedName :\n                        normalizedName) + suffix\n            };\n        }\n\n        function getModule(depMap) {\n            var id = depMap.id,\n                mod = getOwn(registry, id);\n\n            if (!mod) {\n                mod = registry[id] = new context.Module(depMap);\n            }\n\n            return mod;\n        }\n\n        function on(depMap, name, fn) {\n            var id = depMap.id,\n                mod = getOwn(registry, id);\n\n            if (hasProp(defined, id) &&\n                    (!mod || mod.defineEmitComplete)) {\n                if (name === 'defined') {\n                    fn(defined[id]);\n                }\n            } else {\n                mod = getModule(depMap);\n                if (mod.error && name === 'error') {\n                    fn(mod.error);\n                } else {\n                    mod.on(name, fn);\n                }\n            }\n        }\n\n        function onError(err, errback) {\n            var ids = err.requireModules,\n                notified = false;\n\n            if (errback) {\n                errback(err);\n            } else {\n                each(ids, function (id) {\n                    var mod = getOwn(registry, id);\n                    if (mod) {\n                        //Set error on module, so it skips timeout checks.\n                        mod.error = err;\n                        if (mod.events.error) {\n                            notified = true;\n                            mod.emit('error', err);\n                        }\n                    }\n                });\n\n                if (!notified) {\n                    req.onError(err);\n                }\n            }\n        }\n\n        /**\n         * Internal method to transfer globalQueue items to this context's\n         * defQueue.\n         */\n        function takeGlobalQueue() {\n            //Push all the globalDefQueue items into the context's defQueue\n            if (globalDefQueue.length) {\n                //Array splice in the values since the context code has a\n                //local var ref to defQueue, so cannot just reassign the one\n                //on context.\n                apsp.apply(defQueue,\n                           [defQueue.length, 0].concat(globalDefQueue));\n                globalDefQueue = [];\n            }\n        }\n\n        handlers = {\n            'require': function (mod) {\n                if (mod.require) {\n                    return mod.require;\n                } else {\n                    return (mod.require = context.makeRequire(mod.map));\n                }\n            },\n            'exports': function (mod) {\n                mod.usingExports = true;\n                if (mod.map.isDefine) {\n                    if (mod.exports) {\n                        return (defined[mod.map.id] = mod.exports);\n                    } else {\n                        return (mod.exports = defined[mod.map.id] = {});\n                    }\n                }\n            },\n            'module': function (mod) {\n                if (mod.module) {\n                    return mod.module;\n                } else {\n                    return (mod.module = {\n                        id: mod.map.id,\n                        uri: mod.map.url,\n                        config: function () {\n                            return  getOwn(config.config, mod.map.id) || {};\n                        },\n                        exports: mod.exports || (mod.exports = {})\n                    });\n                }\n            }\n        };\n\n        function cleanRegistry(id) {\n            //Clean up machinery used for waiting modules.\n            delete registry[id];\n            delete enabledRegistry[id];\n        }\n\n        function breakCycle(mod, traced, processed) {\n            var id = mod.map.id;\n\n            if (mod.error) {\n                mod.emit('error', mod.error);\n            } else {\n                traced[id] = true;\n                each(mod.depMaps, function (depMap, i) {\n                    var depId = depMap.id,\n                        dep = getOwn(registry, depId);\n\n                    //Only force things that have not completed\n                    //being defined, so still in the registry,\n                    //and only if it has not been matched up\n                    //in the module already.\n                    if (dep && !mod.depMatched[i] && !processed[depId]) {\n                        if (getOwn(traced, depId)) {\n                            mod.defineDep(i, defined[depId]);\n                            mod.check(); //pass false?\n                        } else {\n                            breakCycle(dep, traced, processed);\n                        }\n                    }\n                });\n                processed[id] = true;\n            }\n        }\n\n        function checkLoaded() {\n            var err, usingPathFallback,\n                waitInterval = config.waitSeconds * 1000,\n                //It is possible to disable the wait interval by using waitSeconds of 0.\n                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),\n                noLoads = [],\n                reqCalls = [],\n                stillLoading = false,\n                needCycleCheck = true;\n\n            //Do not bother if this call was a result of a cycle break.\n            if (inCheckLoaded) {\n                return;\n            }\n\n            inCheckLoaded = true;\n\n            //Figure out the state of all the modules.\n            eachProp(enabledRegistry, function (mod) {\n                var map = mod.map,\n                    modId = map.id;\n\n                //Skip things that are not enabled or in error state.\n                if (!mod.enabled) {\n                    return;\n                }\n\n                if (!map.isDefine) {\n                    reqCalls.push(mod);\n                }\n\n                if (!mod.error) {\n                    //If the module should be executed, and it has not\n                    //been inited and time is up, remember it.\n                    if (!mod.inited && expired) {\n                        if (hasPathFallback(modId)) {\n                            usingPathFallback = true;\n                            stillLoading = true;\n                        } else {\n                            noLoads.push(modId);\n                            removeScript(modId);\n                        }\n                    } else if (!mod.inited && mod.fetched && map.isDefine) {\n                        stillLoading = true;\n                        if (!map.prefix) {\n                            //No reason to keep looking for unfinished\n                            //loading. If the only stillLoading is a\n                            //plugin resource though, keep going,\n                            //because it may be that a plugin resource\n                            //is waiting on a non-plugin cycle.\n                            return (needCycleCheck = false);\n                        }\n                    }\n                }\n            });\n\n            if (expired && noLoads.length) {\n                //If wait time expired, throw error of unloaded modules.\n                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);\n                err.contextName = context.contextName;\n                return onError(err);\n            }\n\n            //Not expired, check for a cycle.\n            if (needCycleCheck) {\n                each(reqCalls, function (mod) {\n                    breakCycle(mod, {}, {});\n                });\n            }\n\n            //If still waiting on loads, and the waiting load is something\n            //other than a plugin resource, or there are still outstanding\n            //scripts, then just try back later.\n            if ((!expired || usingPathFallback) && stillLoading) {\n                //Something is still waiting to load. Wait for it, but only\n                //if a timeout is not already in effect.\n                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {\n                    checkLoadedTimeoutId = setTimeout(function () {\n                        checkLoadedTimeoutId = 0;\n                        checkLoaded();\n                    }, 50);\n                }\n            }\n\n            inCheckLoaded = false;\n        }\n\n        Module = function (map) {\n            this.events = getOwn(undefEvents, map.id) || {};\n            this.map = map;\n            this.shim = getOwn(config.shim, map.id);\n            this.depExports = [];\n            this.depMaps = [];\n            this.depMatched = [];\n            this.pluginMaps = {};\n            this.depCount = 0;\n\n            /* this.exports this.factory\n               this.depMaps = [],\n               this.enabled, this.fetched\n            */\n        };\n\n        Module.prototype = {\n            init: function (depMaps, factory, errback, options) {\n                options = options || {};\n\n                //Do not do more inits if already done. Can happen if there\n                //are multiple define calls for the same module. That is not\n                //a normal, common case, but it is also not unexpected.\n                if (this.inited) {\n                    return;\n                }\n\n                this.factory = factory;\n\n                if (errback) {\n                    //Register for errors on this module.\n                    this.on('error', errback);\n                } else if (this.events.error) {\n                    //If no errback already, but there are error listeners\n                    //on this module, set up an errback to pass to the deps.\n                    errback = bind(this, function (err) {\n                        this.emit('error', err);\n                    });\n                }\n\n                //Do a copy of the dependency array, so that\n                //source inputs are not modified. For example\n                //\"shim\" deps are passed in here directly, and\n                //doing a direct modification of the depMaps array\n                //would affect that config.\n                this.depMaps = depMaps && depMaps.slice(0);\n\n                this.errback = errback;\n\n                //Indicate this module has be initialized\n                this.inited = true;\n\n                this.ignore = options.ignore;\n\n                //Could have option to init this module in enabled mode,\n                //or could have been previously marked as enabled. However,\n                //the dependencies are not known until init is called. So\n                //if enabled previously, now trigger dependencies as enabled.\n                if (options.enabled || this.enabled) {\n                    //Enable this module and dependencies.\n                    //Will call this.check()\n                    this.enable();\n                } else {\n                    this.check();\n                }\n            },\n\n            defineDep: function (i, depExports) {\n                //Because of cycles, defined callback for a given\n                //export can be called more than once.\n                if (!this.depMatched[i]) {\n                    this.depMatched[i] = true;\n                    this.depCount -= 1;\n                    this.depExports[i] = depExports;\n                }\n            },\n\n            fetch: function () {\n                if (this.fetched) {\n                    return;\n                }\n                this.fetched = true;\n\n                context.startTime = (new Date()).getTime();\n\n                var map = this.map;\n\n                //If the manager is for a plugin managed resource,\n                //ask the plugin to load it now.\n                if (this.shim) {\n                    context.makeRequire(this.map, {\n                        enableBuildCallback: true\n                    })(this.shim.deps || [], bind(this, function () {\n                        return map.prefix ? this.callPlugin() : this.load();\n                    }));\n                } else {\n                    //Regular dependency.\n                    return map.prefix ? this.callPlugin() : this.load();\n                }\n            },\n\n            load: function () {\n                var url = this.map.url;\n\n                //Regular dependency.\n                if (!urlFetched[url]) {\n                    urlFetched[url] = true;\n                    context.load(this.map.id, url);\n                }\n            },\n\n            /**\n             * Checks if the module is ready to define itself, and if so,\n             * define it.\n             */\n            check: function () {\n                if (!this.enabled || this.enabling) {\n                    return;\n                }\n\n                var err, cjsModule,\n                    id = this.map.id,\n                    depExports = this.depExports,\n                    exports = this.exports,\n                    factory = this.factory;\n\n                if (!this.inited) {\n                    this.fetch();\n                } else if (this.error) {\n                    this.emit('error', this.error);\n                } else if (!this.defining) {\n                    //The factory could trigger another require call\n                    //that would result in checking this module to\n                    //define itself again. If already in the process\n                    //of doing that, skip this work.\n                    this.defining = true;\n\n                    if (this.depCount < 1 && !this.defined) {\n                        if (isFunction(factory)) {\n                            //If there is an error listener, favor passing\n                            //to that instead of throwing an error. However,\n                            //only do it for define()'d  modules. require\n                            //errbacks should not be called for failures in\n                            //their callbacks (#699). However if a global\n                            //onError is set, use that.\n                            if ((this.events.error && this.map.isDefine) ||\n                                req.onError !== defaultOnError) {\n                                try {\n                                    exports = context.execCb(id, factory, depExports, exports);\n                                } catch (e) {\n                                    err = e;\n                                }\n                            } else {\n                                exports = context.execCb(id, factory, depExports, exports);\n                            }\n\n                            // Favor return value over exports. If node/cjs in play,\n                            // then will not have a return value anyway. Favor\n                            // module.exports assignment over exports object.\n                            if (this.map.isDefine && exports === undefined) {\n                                cjsModule = this.module;\n                                if (cjsModule) {\n                                    exports = cjsModule.exports;\n                                } else if (this.usingExports) {\n                                    //exports already set the defined value.\n                                    exports = this.exports;\n                                }\n                            }\n\n                            if (err) {\n                                err.requireMap = this.map;\n                                err.requireModules = this.map.isDefine ? [this.map.id] : null;\n                                err.requireType = this.map.isDefine ? 'define' : 'require';\n                                return onError((this.error = err));\n                            }\n\n                        } else {\n                            //Just a literal value\n                            exports = factory;\n                        }\n\n                        this.exports = exports;\n\n                        if (this.map.isDefine && !this.ignore) {\n                            defined[id] = exports;\n\n                            if (req.onResourceLoad) {\n                                req.onResourceLoad(context, this.map, this.depMaps);\n                            }\n                        }\n\n                        //Clean up\n                        cleanRegistry(id);\n\n                        this.defined = true;\n                    }\n\n                    //Finished the define stage. Allow calling check again\n                    //to allow define notifications below in the case of a\n                    //cycle.\n                    this.defining = false;\n\n                    if (this.defined && !this.defineEmitted) {\n                        this.defineEmitted = true;\n                        this.emit('defined', this.exports);\n                        this.defineEmitComplete = true;\n                    }\n\n                }\n            },\n\n            callPlugin: function () {\n                var map = this.map,\n                    id = map.id,\n                    //Map already normalized the prefix.\n                    pluginMap = makeModuleMap(map.prefix);\n\n                //Mark this as a dependency for this plugin, so it\n                //can be traced for cycles.\n                this.depMaps.push(pluginMap);\n\n                on(pluginMap, 'defined', bind(this, function (plugin) {\n                    var load, normalizedMap, normalizedMod,\n                        bundleId = getOwn(bundlesMap, this.map.id),\n                        name = this.map.name,\n                        parentName = this.map.parentMap ? this.map.parentMap.name : null,\n                        localRequire = context.makeRequire(map.parentMap, {\n                            enableBuildCallback: true\n                        });\n\n                    //If current map is not normalized, wait for that\n                    //normalized name to load instead of continuing.\n                    if (this.map.unnormalized) {\n                        //Normalize the ID if the plugin allows it.\n                        if (plugin.normalize) {\n                            name = plugin.normalize(name, function (name) {\n                                return normalize(name, parentName, true);\n                            }) || '';\n                        }\n\n                        //prefix and name should already be normalized, no need\n                        //for applying map config again either.\n                        normalizedMap = makeModuleMap(map.prefix + '!' + name,\n                                                      this.map.parentMap);\n                        on(normalizedMap,\n                            'defined', bind(this, function (value) {\n                                this.init([], function () { return value; }, null, {\n                                    enabled: true,\n                                    ignore: true\n                                });\n                            }));\n\n                        normalizedMod = getOwn(registry, normalizedMap.id);\n                        if (normalizedMod) {\n                            //Mark this as a dependency for this plugin, so it\n                            //can be traced for cycles.\n                            this.depMaps.push(normalizedMap);\n\n                            if (this.events.error) {\n                                normalizedMod.on('error', bind(this, function (err) {\n                                    this.emit('error', err);\n                                }));\n                            }\n                            normalizedMod.enable();\n                        }\n\n                        return;\n                    }\n\n                    //If a paths config, then just load that file instead to\n                    //resolve the plugin, as it is built into that paths layer.\n                    if (bundleId) {\n                        this.map.url = context.nameToUrl(bundleId);\n                        this.load();\n                        return;\n                    }\n\n                    load = bind(this, function (value) {\n                        this.init([], function () { return value; }, null, {\n                            enabled: true\n                        });\n                    });\n\n                    load.error = bind(this, function (err) {\n                        this.inited = true;\n                        this.error = err;\n                        err.requireModules = [id];\n\n                        //Remove temp unnormalized modules for this module,\n                        //since they will never be resolved otherwise now.\n                        eachProp(registry, function (mod) {\n                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {\n                                cleanRegistry(mod.map.id);\n                            }\n                        });\n\n                        onError(err);\n                    });\n\n                    //Allow plugins to load other code without having to know the\n                    //context or how to 'complete' the load.\n                    load.fromText = bind(this, function (text, textAlt) {\n                        /*jslint evil: true */\n                        var moduleName = map.name,\n                            moduleMap = makeModuleMap(moduleName),\n                            hasInteractive = useInteractive;\n\n                        //As of 2.1.0, support just passing the text, to reinforce\n                        //fromText only being called once per resource. Still\n                        //support old style of passing moduleName but discard\n                        //that moduleName in favor of the internal ref.\n                        if (textAlt) {\n                            text = textAlt;\n                        }\n\n                        //Turn off interactive script matching for IE for any define\n                        //calls in the text, then turn it back on at the end.\n                        if (hasInteractive) {\n                            useInteractive = false;\n                        }\n\n                        //Prime the system by creating a module instance for\n                        //it.\n                        getModule(moduleMap);\n\n                        //Transfer any config to this other module.\n                        if (hasProp(config.config, id)) {\n                            config.config[moduleName] = config.config[id];\n                        }\n\n                        try {\n                            req.exec(text);\n                        } catch (e) {\n                            return onError(makeError('fromtexteval',\n                                             'fromText eval for ' + id +\n                                            ' failed: ' + e,\n                                             e,\n                                             [id]));\n                        }\n\n                        if (hasInteractive) {\n                            useInteractive = true;\n                        }\n\n                        //Mark this as a dependency for the plugin\n                        //resource\n                        this.depMaps.push(moduleMap);\n\n                        //Support anonymous modules.\n                        context.completeLoad(moduleName);\n\n                        //Bind the value of that module to the value for this\n                        //resource ID.\n                        localRequire([moduleName], load);\n                    });\n\n                    //Use parentName here since the plugin's name is not reliable,\n                    //could be some weird string with no path that actually wants to\n                    //reference the parentName's path.\n                    plugin.load(map.name, localRequire, load, config);\n                }));\n\n                context.enable(pluginMap, this);\n                this.pluginMaps[pluginMap.id] = pluginMap;\n            },\n\n            enable: function () {\n                enabledRegistry[this.map.id] = this;\n                this.enabled = true;\n\n                //Set flag mentioning that the module is enabling,\n                //so that immediate calls to the defined callbacks\n                //for dependencies do not trigger inadvertent load\n                //with the depCount still being zero.\n                this.enabling = true;\n\n                //Enable each dependency\n                each(this.depMaps, bind(this, function (depMap, i) {\n                    var id, mod, handler;\n\n                    if (typeof depMap === 'string') {\n                        //Dependency needs to be converted to a depMap\n                        //and wired up to this module.\n                        depMap = makeModuleMap(depMap,\n                                               (this.map.isDefine ? this.map : this.map.parentMap),\n                                               false,\n                                               !this.skipMap);\n                        this.depMaps[i] = depMap;\n\n                        handler = getOwn(handlers, depMap.id);\n\n                        if (handler) {\n                            this.depExports[i] = handler(this);\n                            return;\n                        }\n\n                        this.depCount += 1;\n\n                        on(depMap, 'defined', bind(this, function (depExports) {\n                            this.defineDep(i, depExports);\n                            this.check();\n                        }));\n\n                        if (this.errback) {\n                            on(depMap, 'error', bind(this, this.errback));\n                        } else if (this.events.error) {\n                            // No direct errback on this module, but something\n                            // else is listening for errors, so be sure to\n                            // propagate the error correctly.\n                            on(depMap, 'error', bind(this, function(err) {\n                                this.emit('error', err);\n                            }));\n                        }\n                    }\n\n                    id = depMap.id;\n                    mod = registry[id];\n\n                    //Skip special modules like 'require', 'exports', 'module'\n                    //Also, don't call enable if it is already enabled,\n                    //important in circular dependency cases.\n                    if (!hasProp(handlers, id) && mod && !mod.enabled) {\n                        context.enable(depMap, this);\n                    }\n                }));\n\n                //Enable each plugin that is used in\n                //a dependency\n                eachProp(this.pluginMaps, bind(this, function (pluginMap) {\n                    var mod = getOwn(registry, pluginMap.id);\n                    if (mod && !mod.enabled) {\n                        context.enable(pluginMap, this);\n                    }\n                }));\n\n                this.enabling = false;\n\n                this.check();\n            },\n\n            on: function (name, cb) {\n                var cbs = this.events[name];\n                if (!cbs) {\n                    cbs = this.events[name] = [];\n                }\n                cbs.push(cb);\n            },\n\n            emit: function (name, evt) {\n                each(this.events[name], function (cb) {\n                    cb(evt);\n                });\n                if (name === 'error') {\n                    //Now that the error handler was triggered, remove\n                    //the listeners, since this broken Module instance\n                    //can stay around for a while in the registry.\n                    delete this.events[name];\n                }\n            }\n        };\n\n        function callGetModule(args) {\n            //Skip modules already defined.\n            if (!hasProp(defined, args[0])) {\n                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);\n            }\n        }\n\n        function removeListener(node, func, name, ieName) {\n            //Favor detachEvent because of IE9\n            //issue, see attachEvent/addEventListener comment elsewhere\n            //in this file.\n            if (node.detachEvent && !isOpera) {\n                //Probably IE. If not it will throw an error, which will be\n                //useful to know.\n                if (ieName) {\n                    node.detachEvent(ieName, func);\n                }\n            } else {\n                node.removeEventListener(name, func, false);\n            }\n        }\n\n        /**\n         * Given an event from a script node, get the requirejs info from it,\n         * and then removes the event listeners on the node.\n         * @param {Event} evt\n         * @returns {Object}\n         */\n        function getScriptData(evt) {\n            //Using currentTarget instead of target for Firefox 2.0's sake. Not\n            //all old browsers will be supported, but this one was easy enough\n            //to support and still makes sense.\n            var node = evt.currentTarget || evt.srcElement;\n\n            //Remove the listeners once here.\n            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');\n            removeListener(node, context.onScriptError, 'error');\n\n            return {\n                node: node,\n                id: node && node.getAttribute('data-requiremodule')\n            };\n        }\n\n        function intakeDefines() {\n            var args;\n\n            //Any defined modules in the global queue, intake them now.\n            takeGlobalQueue();\n\n            //Make sure any remaining defQueue items get properly processed.\n            while (defQueue.length) {\n                args = defQueue.shift();\n                if (args[0] === null) {\n                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));\n                } else {\n                    //args are id, deps, factory. Should be normalized by the\n                    //define() function.\n                    callGetModule(args);\n                }\n            }\n        }\n\n        context = {\n            config: config,\n            contextName: contextName,\n            registry: registry,\n            defined: defined,\n            urlFetched: urlFetched,\n            defQueue: defQueue,\n            Module: Module,\n            makeModuleMap: makeModuleMap,\n            nextTick: req.nextTick,\n            onError: onError,\n\n            /**\n             * Set a configuration for the context.\n             * @param {Object} cfg config object to integrate.\n             */\n            configure: function (cfg) {\n                //Make sure the baseUrl ends in a slash.\n                if (cfg.baseUrl) {\n                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {\n                        cfg.baseUrl += '/';\n                    }\n                }\n\n                //Save off the paths since they require special processing,\n                //they are additive.\n                var shim = config.shim,\n                    objs = {\n                        paths: true,\n                        bundles: true,\n                        config: true,\n                        map: true\n                    };\n\n                eachProp(cfg, function (value, prop) {\n                    if (objs[prop]) {\n                        if (!config[prop]) {\n                            config[prop] = {};\n                        }\n                        mixin(config[prop], value, true, true);\n                    } else {\n                        config[prop] = value;\n                    }\n                });\n\n                //Reverse map the bundles\n                if (cfg.bundles) {\n                    eachProp(cfg.bundles, function (value, prop) {\n                        each(value, function (v) {\n                            if (v !== prop) {\n                                bundlesMap[v] = prop;\n                            }\n                        });\n                    });\n                }\n\n                //Merge shim\n                if (cfg.shim) {\n                    eachProp(cfg.shim, function (value, id) {\n                        //Normalize the structure\n                        if (isArray(value)) {\n                            value = {\n                                deps: value\n                            };\n                        }\n                        if ((value.exports || value.init) && !value.exportsFn) {\n                            value.exportsFn = context.makeShimExports(value);\n                        }\n                        shim[id] = value;\n                    });\n                    config.shim = shim;\n                }\n\n                //Adjust packages if necessary.\n                if (cfg.packages) {\n                    each(cfg.packages, function (pkgObj) {\n                        var location, name;\n\n                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;\n\n                        name = pkgObj.name;\n                        location = pkgObj.location;\n                        if (location) {\n                            config.paths[name] = pkgObj.location;\n                        }\n\n                        //Save pointer to main module ID for pkg name.\n                        //Remove leading dot in main, so main paths are normalized,\n                        //and remove any trailing .js, since different package\n                        //envs have different conventions: some use a module name,\n                        //some use a file name.\n                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')\n                                     .replace(currDirRegExp, '')\n                                     .replace(jsSuffixRegExp, '');\n                    });\n                }\n\n                //If there are any \"waiting to execute\" modules in the registry,\n                //update the maps for them, since their info, like URLs to load,\n                //may have changed.\n                eachProp(registry, function (mod, id) {\n                    //If module already has init called, since it is too\n                    //late to modify them, and ignore unnormalized ones\n                    //since they are transient.\n                    if (!mod.inited && !mod.map.unnormalized) {\n                        mod.map = makeModuleMap(id);\n                    }\n                });\n\n                //If a deps array or a config callback is specified, then call\n                //require with those args. This is useful when require is defined as a\n                //config object before require.js is loaded.\n                if (cfg.deps || cfg.callback) {\n                    context.require(cfg.deps || [], cfg.callback);\n                }\n            },\n\n            makeShimExports: function (value) {\n                function fn() {\n                    var ret;\n                    if (value.init) {\n                        ret = value.init.apply(global, arguments);\n                    }\n                    return ret || (value.exports && getGlobal(value.exports));\n                }\n                return fn;\n            },\n\n            makeRequire: function (relMap, options) {\n                options = options || {};\n\n                function localRequire(deps, callback, errback) {\n                    var id, map, requireMod;\n\n                    if (options.enableBuildCallback && callback && isFunction(callback)) {\n                        callback.__requireJsBuild = true;\n                    }\n\n                    if (typeof deps === 'string') {\n                        if (isFunction(callback)) {\n                            //Invalid call\n                            return onError(makeError('requireargs', 'Invalid require call'), errback);\n                        }\n\n                        //If require|exports|module are requested, get the\n                        //value for them from the special handlers. Caveat:\n                        //this only works while module is being defined.\n                        if (relMap && hasProp(handlers, deps)) {\n                            return handlers[deps](registry[relMap.id]);\n                        }\n\n                        //Synchronous access to one module. If require.get is\n                        //available (as in the Node adapter), prefer that.\n                        if (req.get) {\n                            return req.get(context, deps, relMap, localRequire);\n                        }\n\n                        //Normalize module name, if it contains . or ..\n                        map = makeModuleMap(deps, relMap, false, true);\n                        id = map.id;\n\n                        if (!hasProp(defined, id)) {\n                            return onError(makeError('notloaded', 'Module name \"' +\n                                        id +\n                                        '\" has not been loaded yet for context: ' +\n                                        contextName +\n                                        (relMap ? '' : '. Use require([])')));\n                        }\n                        return defined[id];\n                    }\n\n                    //Grab defines waiting in the global queue.\n                    intakeDefines();\n\n                    //Mark all the dependencies as needing to be loaded.\n                    context.nextTick(function () {\n                        //Some defines could have been added since the\n                        //require call, collect them.\n                        intakeDefines();\n\n                        requireMod = getModule(makeModuleMap(null, relMap));\n\n                        //Store if map config should be applied to this require\n                        //call for dependencies.\n                        requireMod.skipMap = options.skipMap;\n\n                        requireMod.init(deps, callback, errback, {\n                            enabled: true\n                        });\n\n                        checkLoaded();\n                    });\n\n                    return localRequire;\n                }\n\n                mixin(localRequire, {\n                    isBrowser: isBrowser,\n\n                    /**\n                     * Converts a module name + .extension into an URL path.\n                     * *Requires* the use of a module name. It does not support using\n                     * plain URLs like nameToUrl.\n                     */\n                    toUrl: function (moduleNamePlusExt) {\n                        var ext,\n                            index = moduleNamePlusExt.lastIndexOf('.'),\n                            segment = moduleNamePlusExt.split('/')[0],\n                            isRelative = segment === '.' || segment === '..';\n\n                        //Have a file extension alias, and it is not the\n                        //dots from a relative path.\n                        if (index !== -1 && (!isRelative || index > 1)) {\n                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);\n                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);\n                        }\n\n                        return context.nameToUrl(normalize(moduleNamePlusExt,\n                                                relMap && relMap.id, true), ext,  true);\n                    },\n\n                    defined: function (id) {\n                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);\n                    },\n\n                    specified: function (id) {\n                        id = makeModuleMap(id, relMap, false, true).id;\n                        return hasProp(defined, id) || hasProp(registry, id);\n                    }\n                });\n\n                //Only allow undef on top level require calls\n                if (!relMap) {\n                    localRequire.undef = function (id) {\n                        //Bind any waiting define() calls to this context,\n                        //fix for #408\n                        takeGlobalQueue();\n\n                        var map = makeModuleMap(id, relMap, true),\n                            mod = getOwn(registry, id);\n\n                        removeScript(id);\n\n                        delete defined[id];\n                        delete urlFetched[map.url];\n                        delete undefEvents[id];\n\n                        //Clean queued defines too. Go backwards\n                        //in array so that the splices do not\n                        //mess up the iteration.\n                        eachReverse(defQueue, function(args, i) {\n                            if(args[0] === id) {\n                                defQueue.splice(i, 1);\n                            }\n                        });\n\n                        if (mod) {\n                            //Hold on to listeners in case the\n                            //module will be attempted to be reloaded\n                            //using a different config.\n                            if (mod.events.defined) {\n                                undefEvents[id] = mod.events;\n                            }\n\n                            cleanRegistry(id);\n                        }\n                    };\n                }\n\n                return localRequire;\n            },\n\n            /**\n             * Called to enable a module if it is still in the registry\n             * awaiting enablement. A second arg, parent, the parent module,\n             * is passed in for context, when this method is overridden by\n             * the optimizer. Not shown here to keep code compact.\n             */\n            enable: function (depMap) {\n                var mod = getOwn(registry, depMap.id);\n                if (mod) {\n                    getModule(depMap).enable();\n                }\n            },\n\n            /**\n             * Internal method used by environment adapters to complete a load event.\n             * A load event could be a script load or just a load pass from a synchronous\n             * load call.\n             * @param {String} moduleName the name of the module to potentially complete.\n             */\n            completeLoad: function (moduleName) {\n                var found, args, mod,\n                    shim = getOwn(config.shim, moduleName) || {},\n                    shExports = shim.exports;\n\n                takeGlobalQueue();\n\n                while (defQueue.length) {\n                    args = defQueue.shift();\n                    if (args[0] === null) {\n                        args[0] = moduleName;\n                        //If already found an anonymous module and bound it\n                        //to this name, then this is some other anon module\n                        //waiting for its completeLoad to fire.\n                        if (found) {\n                            break;\n                        }\n                        found = true;\n                    } else if (args[0] === moduleName) {\n                        //Found matching define call for this script!\n                        found = true;\n                    }\n\n                    callGetModule(args);\n                }\n\n                //Do this after the cycle of callGetModule in case the result\n                //of those calls/init calls changes the registry.\n                mod = getOwn(registry, moduleName);\n\n                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {\n                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {\n                        if (hasPathFallback(moduleName)) {\n                            return;\n                        } else {\n                            return onError(makeError('nodefine',\n                                             'No define call for ' + moduleName,\n                                             null,\n                                             [moduleName]));\n                        }\n                    } else {\n                        //A script that does not call define(), so just simulate\n                        //the call for it.\n                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);\n                    }\n                }\n\n                checkLoaded();\n            },\n\n            /**\n             * Converts a module name to a file path. Supports cases where\n             * moduleName may actually be just an URL.\n             * Note that it **does not** call normalize on the moduleName,\n             * it is assumed to have already been normalized. This is an\n             * internal API, not a public one. Use toUrl for the public API.\n             */\n            nameToUrl: function (moduleName, ext, skipExt) {\n                var paths, syms, i, parentModule, url,\n                    parentPath, bundleId,\n                    pkgMain = getOwn(config.pkgs, moduleName);\n\n                if (pkgMain) {\n                    moduleName = pkgMain;\n                }\n\n                bundleId = getOwn(bundlesMap, moduleName);\n\n                if (bundleId) {\n                    return context.nameToUrl(bundleId, ext, skipExt);\n                }\n\n                //If a colon is in the URL, it indicates a protocol is used and it is just\n                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)\n                //or ends with .js, then assume the user meant to use an url and not a module id.\n                //The slash is important for protocol-less URLs as well as full paths.\n                if (req.jsExtRegExp.test(moduleName)) {\n                    //Just a plain path, not module name lookup, so just return it.\n                    //Add extension if it is included. This is a bit wonky, only non-.js things pass\n                    //an extension, this method probably needs to be reworked.\n                    url = moduleName + (ext || '');\n                } else {\n                    //A module that needs to be converted to a path.\n                    paths = config.paths;\n\n                    syms = moduleName.split('/');\n                    //For each module name segment, see if there is a path\n                    //registered for it. Start with most specific name\n                    //and work up from it.\n                    for (i = syms.length; i > 0; i -= 1) {\n                        parentModule = syms.slice(0, i).join('/');\n\n                        parentPath = getOwn(paths, parentModule);\n                        if (parentPath) {\n                            //If an array, it means there are a few choices,\n                            //Choose the one that is desired\n                            if (isArray(parentPath)) {\n                                parentPath = parentPath[0];\n                            }\n                            syms.splice(0, i, parentPath);\n                            break;\n                        }\n                    }\n\n                    //Join the path parts together, then figure out if baseUrl is needed.\n                    url = syms.join('/');\n                    url += (ext || (/^data\\:|\\?/.test(url) || skipExt ? '' : '.js'));\n                    url = (url.charAt(0) === '/' || url.match(/^[\\w\\+\\.\\-]+:/) ? '' : config.baseUrl) + url;\n                }\n\n                return config.urlArgs ? url +\n                                        ((url.indexOf('?') === -1 ? '?' : '&') +\n                                         config.urlArgs) : url;\n            },\n\n            //Delegates to req.load. Broken out as a separate function to\n            //allow overriding in the optimizer.\n            load: function (id, url) {\n                req.load(context, id, url);\n            },\n\n            /**\n             * Executes a module callback function. Broken out as a separate function\n             * solely to allow the build system to sequence the files in the built\n             * layer in the right sequence.\n             *\n             * @private\n             */\n            execCb: function (name, callback, args, exports) {\n                return callback.apply(exports, args);\n            },\n\n            /**\n             * callback for script loads, used to check status of loading.\n             *\n             * @param {Event} evt the event from the browser for the script\n             * that was loaded.\n             */\n            onScriptLoad: function (evt) {\n                //Using currentTarget instead of target for Firefox 2.0's sake. Not\n                //all old browsers will be supported, but this one was easy enough\n                //to support and still makes sense.\n                if (evt.type === 'load' ||\n                        (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {\n                    //Reset interactive script so a script node is not held onto for\n                    //to long.\n                    interactiveScript = null;\n\n                    //Pull out the name of the module and the context.\n                    var data = getScriptData(evt);\n                    context.completeLoad(data.id);\n                }\n            },\n\n            /**\n             * Callback for script errors.\n             */\n            onScriptError: function (evt) {\n                var data = getScriptData(evt);\n                if (!hasPathFallback(data.id)) {\n                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));\n                }\n            }\n        };\n\n        context.require = context.makeRequire();\n        return context;\n    }\n\n    /**\n     * Main entry point.\n     *\n     * If the only argument to require is a string, then the module that\n     * is represented by that string is fetched for the appropriate context.\n     *\n     * If the first argument is an array, then it will be treated as an array\n     * of dependency string names to fetch. An optional function callback can\n     * be specified to execute when all of those dependencies are available.\n     *\n     * Make a local req variable to help Caja compliance (it assumes things\n     * on a require that are not standardized), and to give a short\n     * name for minification/local scope use.\n     */\n    req = requirejs = function (deps, callback, errback, optional) {\n\n        //Find the right context, use default\n        var context, config,\n            contextName = defContextName;\n\n        // Determine if have config object in the call.\n        if (!isArray(deps) && typeof deps !== 'string') {\n            // deps is a config object\n            config = deps;\n            if (isArray(callback)) {\n                // Adjust args if there are dependencies\n                deps = callback;\n                callback = errback;\n                errback = optional;\n            } else {\n                deps = [];\n            }\n        }\n\n        if (config && config.context) {\n            contextName = config.context;\n        }\n\n        context = getOwn(contexts, contextName);\n        if (!context) {\n            context = contexts[contextName] = req.s.newContext(contextName);\n        }\n\n        if (config) {\n            context.configure(config);\n        }\n\n        return context.require(deps, callback, errback);\n    };\n\n    /**\n     * Support require.config() to make it easier to cooperate with other\n     * AMD loaders on globally agreed names.\n     */\n    req.config = function (config) {\n        return req(config);\n    };\n\n    /**\n     * Execute something after the current tick\n     * of the event loop. Override for other envs\n     * that have a better solution than setTimeout.\n     * @param  {Function} fn function to execute later.\n     */\n    req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {\n        setTimeout(fn, 4);\n    } : function (fn) { fn(); };\n\n    /**\n     * Export require as a global, but only if it does not already exist.\n     */\n    if (!require) {\n        require = req;\n    }\n\n    req.version = version;\n\n    //Used to filter out dependencies that are already paths.\n    req.jsExtRegExp = /^\\/|:|\\?|\\.js$/;\n    req.isBrowser = isBrowser;\n    s = req.s = {\n        contexts: contexts,\n        newContext: newContext\n    };\n\n    //Create default context.\n    req({});\n\n    //Exports some context-sensitive methods on global require.\n    each([\n        'toUrl',\n        'undef',\n        'defined',\n        'specified'\n    ], function (prop) {\n        //Reference from contexts instead of early binding to default context,\n        //so that during builds, the latest instance of the default context\n        //with its config gets used.\n        req[prop] = function () {\n            var ctx = contexts[defContextName];\n            return ctx.require[prop].apply(ctx, arguments);\n        };\n    });\n\n    if (isBrowser) {\n        head = s.head = document.getElementsByTagName('head')[0];\n        //If BASE tag is in play, using appendChild is a problem for IE6.\n        //When that browser dies, this can be removed. Details in this jQuery bug:\n        //http://dev.jquery.com/ticket/2709\n        baseElement = document.getElementsByTagName('base')[0];\n        if (baseElement) {\n            head = s.head = baseElement.parentNode;\n        }\n    }\n\n    /**\n     * Any errors that require explicitly generates will be passed to this\n     * function. Intercept/override it if you want custom error handling.\n     * @param {Error} err the error object.\n     */\n    req.onError = defaultOnError;\n\n    /**\n     * Creates the node for the load command. Only used in browser envs.\n     */\n    req.createNode = function (config, moduleName, url) {\n        var node = config.xhtml ?\n                document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :\n                document.createElement('script');\n        node.type = config.scriptType || 'text/javascript';\n        node.charset = 'utf-8';\n        node.async = true;\n        return node;\n    };\n\n    /**\n     * Does the request to load a module for the browser case.\n     * Make this a separate function to allow other environments\n     * to override it.\n     *\n     * @param {Object} context the require context to find state.\n     * @param {String} moduleName the name of the module.\n     * @param {Object} url the URL to the module.\n     */\n    req.load = function (context, moduleName, url) {\n        var config = (context && context.config) || {},\n            node;\n        if (isBrowser) {\n            //In the browser so use a script tag\n            node = req.createNode(config, moduleName, url);\n\n            node.setAttribute('data-requirecontext', context.contextName);\n            node.setAttribute('data-requiremodule', moduleName);\n\n            //Set up load listener. Test attachEvent first because IE9 has\n            //a subtle issue in its addEventListener and script onload firings\n            //that do not match the behavior of all other browsers with\n            //addEventListener support, which fire the onload event for a\n            //script right after the script execution. See:\n            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution\n            //UNFORTUNATELY Opera implements attachEvent but does not follow the script\n            //script execution mode.\n            if (node.attachEvent &&\n                    //Check if node.attachEvent is artificially added by custom script or\n                    //natively supported by browser\n                    //read https://github.com/jrburke/requirejs/issues/187\n                    //if we can NOT find [native code] then it must NOT natively supported.\n                    //in IE8, node.attachEvent does not have toString()\n                    //Note the test for \"[native code\" with no closing brace, see:\n                    //https://github.com/jrburke/requirejs/issues/273\n                    !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&\n                    !isOpera) {\n                //Probably IE. IE (at least 6-8) do not fire\n                //script onload right after executing the script, so\n                //we cannot tie the anonymous define call to a name.\n                //However, IE reports the script as being in 'interactive'\n                //readyState at the time of the define call.\n                useInteractive = true;\n\n                node.attachEvent('onreadystatechange', context.onScriptLoad);\n                //It would be great to add an error handler here to catch\n                //404s in IE9+. However, onreadystatechange will fire before\n                //the error handler, so that does not help. If addEventListener\n                //is used, then IE will fire error before load, but we cannot\n                //use that pathway given the connect.microsoft.com issue\n                //mentioned above about not doing the 'script execute,\n                //then fire the script load event listener before execute\n                //next script' that other browsers do.\n                //Best hope: IE10 fixes the issues,\n                //and then destroys all installs of IE 6-9.\n                //node.attachEvent('onerror', context.onScriptError);\n            } else {\n                node.addEventListener('load', context.onScriptLoad, false);\n                node.addEventListener('error', context.onScriptError, false);\n            }\n            node.src = url;\n\n            //For some cache cases in IE 6-8, the script executes before the end\n            //of the appendChild execution, so to tie an anonymous define\n            //call to the module name (which is stored on the node), hold on\n            //to a reference to this node, but clear after the DOM insertion.\n            currentlyAddingScript = node;\n            if (baseElement) {\n                head.insertBefore(node, baseElement);\n            } else {\n                head.appendChild(node);\n            }\n            currentlyAddingScript = null;\n\n            return node;\n        } else if (isWebWorker) {\n            try {\n                //In a web worker, use importScripts. This is not a very\n                //efficient use of importScripts, importScripts will block until\n                //its script is downloaded and evaluated. However, if web workers\n                //are in play, the expectation that a build has been done so that\n                //only one script needs to be loaded anyway. This may need to be\n                //reevaluated if other use cases become common.\n                importScripts(url);\n\n                //Account for anonymous modules\n                context.completeLoad(moduleName);\n            } catch (e) {\n                context.onError(makeError('importscripts',\n                                'importScripts failed for ' +\n                                    moduleName + ' at ' + url,\n                                e,\n                                [moduleName]));\n            }\n        }\n    };\n\n    function getInteractiveScript() {\n        if (interactiveScript && interactiveScript.readyState === 'interactive') {\n            return interactiveScript;\n        }\n\n        eachReverse(scripts(), function (script) {\n            if (script.readyState === 'interactive') {\n                return (interactiveScript = script);\n            }\n        });\n        return interactiveScript;\n    }\n\n    //Look for a data-main script attribute, which could also adjust the baseUrl.\n    if (isBrowser && !cfg.skipDataMain) {\n        //Figure out baseUrl. Get it from the script tag with require.js in it.\n        eachReverse(scripts(), function (script) {\n            //Set the 'head' where we can append children by\n            //using the script's parent.\n            if (!head) {\n                head = script.parentNode;\n            }\n\n            //Look for a data-main attribute to set main script for the page\n            //to load. If it is there, the path to data main becomes the\n            //baseUrl, if it is not already set.\n            dataMain = script.getAttribute('data-main');\n            if (dataMain) {\n                //Preserve dataMain in case it is a path (i.e. contains '?')\n                mainScript = dataMain;\n\n                //Set final baseUrl if there is not already an explicit one.\n                if (!cfg.baseUrl) {\n                    //Pull off the directory of data-main for use as the\n                    //baseUrl.\n                    src = mainScript.split('/');\n                    mainScript = src.pop();\n                    subPath = src.length ? src.join('/')  + '/' : './';\n\n                    cfg.baseUrl = subPath;\n                }\n\n                //Strip off any trailing .js since mainScript is now\n                //like a module name.\n                mainScript = mainScript.replace(jsSuffixRegExp, '');\n\n                 //If mainScript is still a path, fall back to dataMain\n                if (req.jsExtRegExp.test(mainScript)) {\n                    mainScript = dataMain;\n                }\n\n                //Put the data-main script in the files to load.\n                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];\n\n                return true;\n            }\n        });\n    }\n\n    /**\n     * The function that handles definitions of modules. Differs from\n     * require() in that a string for the module should be the first argument,\n     * and the function to execute after dependencies are loaded should\n     * return a value to define the module corresponding to the first argument's\n     * name.\n     */\n    define = function (name, deps, callback) {\n        var node, context;\n\n        //Allow for anonymous modules\n        if (typeof name !== 'string') {\n            //Adjust args appropriately\n            callback = deps;\n            deps = name;\n            name = null;\n        }\n\n        //This module may not have dependencies\n        if (!isArray(deps)) {\n            callback = deps;\n            deps = null;\n        }\n\n        //If no name, and callback is a function, then figure out if it a\n        //CommonJS thing with dependencies.\n        if (!deps && isFunction(callback)) {\n            deps = [];\n            //Remove comments from the callback string,\n            //look for require calls, and pull them into the dependencies,\n            //but only if there are function args.\n            if (callback.length) {\n                callback\n                    .toString()\n                    .replace(commentRegExp, '')\n                    .replace(cjsRequireRegExp, function (match, dep) {\n                        deps.push(dep);\n                    });\n\n                //May be a CommonJS thing even without require calls, but still\n                //could use exports, and module. Avoid doing exports and module\n                //work though if it just needs require.\n                //REQUIRES the function to expect the CommonJS variables in the\n                //order listed below.\n                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);\n            }\n        }\n\n        //If in IE 6-8 and hit an anonymous define() call, do the interactive\n        //work.\n        if (useInteractive) {\n            node = currentlyAddingScript || getInteractiveScript();\n            if (node) {\n                if (!name) {\n                    name = node.getAttribute('data-requiremodule');\n                }\n                context = contexts[node.getAttribute('data-requirecontext')];\n            }\n        }\n\n        //Always save off evaluating the def call until the script onload handler.\n        //This allows multiple modules to be in a file without prematurely\n        //tracing dependencies, and allows for anonymous module support,\n        //where the module name is not known until the script onload event\n        //occurs. If no context, use the global queue, and get it processed\n        //in the onscript load callback.\n        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n\n\n    /**\n     * Executes the text. Normally just uses eval, but can be modified\n     * to use a better, environment-specific call. Only used for transpiling\n     * loader plugins, not for plain JS modules.\n     * @param {String} text the text to execute/evaluate.\n     */\n    req.exec = function (text) {\n        /*jslint evil: true */\n        return eval(text);\n    };\n\n    //Set up with config info.\n    req(cfg);\n}(this));\n\ndefine(\"../node_modules/requirejs/require\", function(){});\n\n",
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nwindow.debug = exports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Use chrome.storage.local if we are in an app\n */\n\nvar storage;\n\nif (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')\n  storage = chrome.storage.local;\nelse\n  storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      storage.removeItem('debug');\n    } else {\n      storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n},{\"./debug\":2}],2:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":3}],3:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}]},{},[1]);\n\ndefine(\"debug\", function(){});\n\n",
    "/*globals define, debug*/\n/*jshint node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/logger',['debug'], function (_debug) {\n    'use strict';\n    // Separate namespaces using ',' a leading '-' will disable the namespace.\n    // Each part takes a regex.\n    //      ex: localStorage.debug = '*,-socket\\.io*,-engine\\.io*'\n    //      will log all but socket.io and engine.io\n    function createLogger(name, options) {\n        var log = typeof debug === 'undefined' ? _debug(name) : debug(name),\n            level,\n            levels = {\n                silly: 0,\n                input: 1,\n                verbose: 2,\n                prompt: 3,\n                debug: 4,\n                info: 5,\n                data: 6,\n                help: 7,\n                warn: 8,\n                error: 9\n            };\n        if (!options) {\n            throw new Error('options required in logger');\n        }\n        if (options.hasOwnProperty('level') === false) {\n            throw new Error('options.level required in logger');\n        }\n        level = levels[options.level];\n        if (typeof level === 'undefined') {\n            level = levels.info;\n        }\n\n        log.debug = function () {\n            if (log.enabled && level <= levels.debug) {\n                if (console.debug) {\n                    log.log = console.debug.bind(console);\n                } else {\n                    log.log = console.log.bind(console);\n                }\n                log.apply(this, arguments);\n            }\n        };\n        log.info = function () {\n            if (log.enabled && level <= levels.info) {\n                log.log = console.info.bind(console);\n                log.apply(this, arguments);\n            }\n        };\n        log.warn = function () {\n            if (log.enabled && level <= levels.warn) {\n                log.log = console.warn.bind(console);\n                log.apply(this, arguments);\n            }\n        };\n        log.error = function () {\n            if (log.enabled && level <= levels.error) {\n                log.log = console.error.bind(console);\n                log.apply(this, arguments);\n            } else {\n                console.error.apply(console, arguments);\n            }\n        };\n\n        log.fork = function (forkName, useForkName) {\n            forkName = useForkName ? forkName : name + ':' + forkName;\n            return createLogger(forkName, options);\n        };\n\n        log.forkWithOptions = function (_name, _options) {\n            return createLogger(_name, _options);\n        };\n\n        return log;\n    }\n\n    function createWithGmeConfig(name, gmeConfig) {\n        return createLogger(name, gmeConfig.client.log);\n    }\n\n    return {\n        create: createLogger,\n        createWithGmeConfig: createWithGmeConfig\n    };\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/constants',[], function () {\n    'use strict';\n    return {\n\n        // Database related\n        MONGO_ID: '_id',\n        PROJECT_INFO_ID: '*info*',\n        EMPTY_PROJECT_DATA: 'empty',\n        PROJECT_ID_SEP: '+',\n        PROJECT_DISPLAYED_NAME_SEP: '/',\n\n        // Socket IO\n        DATABASE_ROOM: 'database',\n        ROOM_DIVIDER: '%',\n        CONNECTED: 'CONNECTED',\n        DISCONNECTED: 'DISCONNECTED',\n        RECONNECTED: 'RECONNECTED',\n\n        // Branch status\n        SYNCH: 'SYNCH',\n        FORKED: 'FORKED',\n        MERGED: 'MERGED',\n\n        // Events\n        PROJECT_DELETED: 'PROJECT_DELETED',\n        PROJECT_CREATED: 'PROJECT_CREATED',\n\n        BRANCH_DELETED: 'BRANCH_DELETED',\n        BRANCH_CREATED: 'BRANCH_CREATED',\n        BRANCH_HASH_UPDATED: 'BRANCH_HASH_UPDATED',\n\n        BRANCH_UPDATED: 'BRANCH_UPDATED'\n    };\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * Provides watching-functionality of the database and specific projects.\n * Keeps a state of the registered watchers.\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/watchers',['common/storage/constants'], function (CONSTANTS) {\n    'use strict';\n\n    function StorageWatcher(webSocket, logger, gmeConfig) {\n        // watcher counters determining when to join/leave a room on the sever\n        this.watchers = {\n            database: 0,\n            projects: {}\n        };\n        this.webSocket = webSocket;\n        this.logger = this.logger || logger.fork('storage');\n        this.gmeConfig = gmeConfig;\n        this.logger.debug('StorageWatcher ctor');\n        this.connected = false;\n    }\n\n    StorageWatcher.prototype.watchDatabase = function (eventHandler, callback) {\n        this.logger.debug('watchDatabase - handler added');\n        this.webSocket.addEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);\n        this.webSocket.addEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);\n        this.watchers.database += 1;\n        this.logger.debug('Nbr of database watchers:', this.watchers.database);\n        if (this.watchers.database === 1) {\n            this.logger.debug('First watcher will enter database room.');\n            this.webSocket.watchDatabase({join: true}, callback);\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype.unwatchDatabase = function (eventHandler, callback) {\n        this.logger.debug('unwatchDatabase - handler will be removed');\n        this.logger.debug('Nbr of database watchers (before removal):', this.watchers.database);\n        this.webSocket.removeEventListener(CONSTANTS.PROJECT_DELETED, eventHandler);\n        this.webSocket.removeEventListener(CONSTANTS.PROJECT_CREATED, eventHandler);\n        this.watchers.database -= 1;\n        if (this.watchers.database === 0) {\n            this.logger.debug('No more watchers will exit database room.');\n            if (this.connected) {\n                this.webSocket.watchDatabase({join: false}, callback);\n            } else {\n                callback(null);\n            }\n        } else if (this.watchers.database < 0) {\n            this.logger.error('Number of database watchers became negative!');\n            callback('Number of database watchers became negative!');\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype.watchProject = function (projectId, eventHandler, callback) {\n        this.logger.debug('watchProject - handler added for project', projectId);\n        this.webSocket.addEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);\n        this.webSocket.addEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);\n        this.webSocket.addEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);\n\n        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?\n        this.watchers.projects[projectId] + 1 : 1;\n        this.logger.debug('Nbr of watchers for project:', projectId, this.watchers.projects[projectId]);\n        if (this.watchers.projects[projectId] === 1) {\n            this.logger.debug('First watcher will enter project room:', projectId);\n            this.webSocket.watchProject({projectId: projectId, join: true}, callback);\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype.unwatchProject = function (projectId, eventHandler, callback) {\n        this.logger.debug('unwatchProject - handler will be removed', projectId);\n        this.logger.debug('Nbr of database watchers (before removal):', projectId,\n            this.watchers.projects[projectId]);\n        this.webSocket.removeEventListener(CONSTANTS.BRANCH_DELETED + projectId, eventHandler);\n        this.webSocket.removeEventListener(CONSTANTS.BRANCH_CREATED + projectId, eventHandler);\n        this.webSocket.removeEventListener(CONSTANTS.BRANCH_HASH_UPDATED + projectId, eventHandler);\n\n        this.watchers.projects[projectId] = this.watchers.projects.hasOwnProperty(projectId) ?\n        this.watchers.projects[projectId] - 1 : -1;\n        if (this.watchers.projects[projectId] === 0) {\n            this.logger.debug('No more watchers will exit project room:', projectId);\n            delete this.watchers.projects[projectId];\n            if (this.connected) {\n                this.webSocket.watchProject({projectId: projectId, join: false}, callback);\n            } else {\n                callback(null);\n            }\n        } else if (this.watchers.database < 0) {\n            this.logger.error('Number of project watchers became negative!:', projectId);\n            callback('Number of project watchers became negative!');\n        } else {\n            callback(null);\n        }\n    };\n\n    StorageWatcher.prototype._rejoinWatcherRooms = function () {\n        var self = this,\n            projectId,\n            callback = function (err) {\n                //TODO: Add a callback here too.\n                if (err) {\n                    self.logger.error('problems rejoining watcher rooms', err);\n                }\n            };\n        this.logger.debug('rejoinWatcherRooms');\n        if (this.watchers.database > 0) {\n            this.logger.debug('Rejoining database room.');\n            this.webSocket.watchDatabase({join: true}, callback);\n        }\n        for (projectId in this.watchers.projects) {\n            if (this.watchers.projects.hasOwnProperty(projectId) && this.watchers.projects[projectId] > 0) {\n                this.logger.debug('Rejoining project room', projectId, this.watchers.projects[projectId]);\n                this.webSocket.watchProject({projectId: projectId, join: true}, callback);\n            }\n        }\n    };\n\n    return StorageWatcher;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * TODO: Come up with an appropriate name for this.\n * TODO: Proper implementation needed, e.g. error handling.\n *\n * Provides REST-like functionality of the database.\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/simpleapi',['common/storage/storageclasses/watchers'], function (StorageWatcher) {\n    'use strict';\n\n    /**\n     *\n     * @param webSocket\n     * @param logger\n     * @param gmeConfig\n     * @constructor\n     * @class\n     */\n    function StorageSimpleAPI(webSocket, logger, gmeConfig) {\n        // watcher counters determining when to join/leave a room on the sever\n        this.logger = this.logger || logger.fork('storage');\n        StorageWatcher.call(this, webSocket, logger, gmeConfig);\n        this.webSocket = webSocket;\n        this.gmeConfig = gmeConfig;\n        this.logger.debug('StorageSimpleAPI ctor');\n    }\n\n    StorageSimpleAPI.prototype = Object.create(StorageWatcher.prototype);\n    StorageSimpleAPI.prototype.constructor = StorageSimpleAPI;\n\n    /**\n     * Callback for getProjects.\n     *\n     * @callback StorageSimpleAPI~getProjectsCallback\n     * @param {string} err - error string.\n     * @param {{object[]} projects - All projects in the database.\n     * @example\n     * // projects is of the form\n     * // [{ name: 'projectId', read: true, write: false, delete: false} ]\n     */\n\n    /**\n     * Retrieves all the access info for all projects.\n     *\n     * @param {StorageSimpleAPI~getProjectsCallback} callback\n     */\n    StorageSimpleAPI.prototype.getProjects = function (options, callback) {\n        this.logger.debug('invoking getProjects', {metadata: options});\n        this.webSocket.getProjects(options, callback);\n    };\n\n    /**\n     * Callback for getProjectsAndBranches.\n     *\n     * @callback StorageSimpleAPI~getProjectsAndBranches\n     * @param {string} err - error string.\n     * @param {{object[]} projectsWithBranches - Projects the user has at least read-access to.\n     * @example\n     * // projectsWithBranches is of the form\n     * // [{\n     * //    name: 'projectId',\n     * //    read: true, //will always be true\n     * //    write: false,\n     * //    delete: false\n     * //    branches: {\n     * //      master: '#validHash',\n     * //      b1: '#validHashtoo'\n     * //    }\n     * // }]\n     */\n\n\n    StorageSimpleAPI.prototype.getBranches = function (projectId, callback) {\n        var data = {\n            projectId: projectId\n        };\n        this.logger.debug('invoking getBranches', {metadata: data});\n        this.webSocket.getBranches(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getCommits = function (projectId, before, number, callback) {\n        var data = {\n            projectId: projectId,\n            before: before,\n            number: number\n        };\n        this.logger.debug('invoking getCommits', {metadata: data});\n        this.webSocket.getCommits(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getLatestCommitData = function (projectId, branchName, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName\n        };\n        this.logger.debug('invoking getLatestCommitData', {metadata: data});\n        this.webSocket.getLatestCommitData(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.getCommonAncestorCommit = function (projectId, commitA, commitB, callback) {\n        var data = {\n            commitA: commitA,\n            commitB: commitB,\n            projectId: projectId\n        };\n        this.logger.debug('invoking getCommonAncestorCommit', {metadata: data});\n        this.webSocket.getCommonAncestorCommit(data, callback);\n    };\n\n    // Setters\n    StorageSimpleAPI.prototype.createProject = function (projectName, callback) {\n        var data = {\n            projectName: projectName\n        },\n            self = this;\n\n        this.logger.debug('invoking createProject', {metadata: data});\n\n        this.webSocket.createProject(data, function (err, projectId) {\n            if (err) {\n                self.logger.error('cannot create project ', projectName, err);\n                callback(err);\n                return;\n            }\n            self.logger.debug('Project created, projectId', projectId);\n\n            callback(err, projectId);\n        });\n    };\n\n    StorageSimpleAPI.prototype.deleteProject = function (projectId, callback) {\n        var data = {\n            projectId: projectId\n        };\n        this.logger.debug('invoking deleteProject', {metadata: data});\n        this.webSocket.deleteProject(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.setBranchHash = function (projectId, branchName, newHash, oldHash, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName,\n            newHash: newHash,\n            oldHash: oldHash\n        };\n        this.logger.debug('invoking setBranchHash', {metadata: data});\n        this.webSocket.setBranchHash(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.createBranch = function (projectId, branchName, newHash, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName,\n            newHash: newHash,\n            oldHash: ''\n        };\n        this.logger.debug('invoking createBranch', {metadata: data});\n        this.webSocket.setBranchHash(data, callback);\n    };\n\n    StorageSimpleAPI.prototype.deleteBranch = function (projectId, branchName, oldHash, callback) {\n        var data = {\n            projectId: projectId,\n            branchName: branchName,\n            newHash: '',\n            oldHash: oldHash\n        };\n        this.logger.debug('invoking deleteBranch', {metadata: data});\n        this.webSocket.setBranchHash(data, callback);\n    };\n\n    //temporary simple request and result functions\n    StorageSimpleAPI.prototype.simpleRequest = function (parameters, callback) {\n        this.logger.debug('invoking simpleRequest', {metadata: parameters});\n        this.webSocket.simpleRequest(parameters, callback);\n    };\n\n    StorageSimpleAPI.prototype.simpleResult = function (resultId, callback) {\n        this.logger.debug('invoking simpleResult', resultId);\n        this.webSocket.simpleResult(resultId, callback);\n    };\n\n    StorageSimpleAPI.prototype.simpleQuery = function (workerId, parameters, callback) {\n        this.logger.debug('invoking simpleQuery; workerId, parameters', workerId, {metadata: parameters});\n        this.webSocket.simpleQuery(workerId, parameters, callback);\n    };\n\n    return StorageSimpleAPI;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * Provides functionality (used by the project-cache) for loading objects.\n *\n * To avoid multiple round-trips to the server the loadObject requests are put in a bucket\n * that is loaded when the bucket is full (gmeConfig.storage.loadBucketSize) or when a\n * timeout is triggered (gmeConfig.storage.loadBucketTimer).\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/objectloaders',['common/storage/storageclasses/simpleapi'], function (SimpleAPI) {\n    'use strict';\n\n    function StorageObjectLoaders(webSocket, logger, gmeConfig) {\n        // watcher counters determining when to join/leave a room on the sever\n        this.logger = this.logger || logger.fork('storage');\n        SimpleAPI.call(this, webSocket, logger, gmeConfig);\n        this.webSocket = webSocket;\n        this.gmeConfig = gmeConfig;\n        // Bucket for loading objects\n        this.loadBucket = [];\n        this.loadBucketSize = 0;\n        this.loadBucketTimer = null;\n        this.logger.debug('StorageObjectLoaders ctor');\n    }\n\n    StorageObjectLoaders.prototype = Object.create(SimpleAPI.prototype);\n    StorageObjectLoaders.prototype.constructor = StorageObjectLoaders;\n\n    // Getters\n    StorageObjectLoaders.prototype.loadObject = function (projectId, hash, callback) {\n        var self = this;\n        this.logger.debug('loadObject', projectId, hash);\n\n        self.loadBucket.push({projectId: projectId, hash: hash, cb: callback});\n        self.loadBucketSize += 1;\n\n        function resetBucketAndLoadObjects() {\n            var myBucket = self.loadBucket;\n            self.loadBucket = [];\n            self.loadBucketTimer = null;\n            self.loadBucketSize = 0;\n            self.loadObjects(projectId, myBucket);\n        }\n\n        if (self.loadBucketSize === 1) {\n            self.logger.debug('loadBucket was empty starting timer [ms]', self.gmeConfig.storage.loadBucketTimer);\n            self.loadBucketTimer = setTimeout(function () {\n                self.logger.debug('loadBucketTimer triggered, bucketSize:', self.loadBucketSize);\n                resetBucketAndLoadObjects();\n            }, self.gmeConfig.storage.loadBucketTimer);\n        }\n        \n        if (self.loadBucketSize === self.gmeConfig.storage.loadBucketSize) {\n            self.logger.debug('loadBuckSize reached will loadObjects, bucketSize:', self.loadBucketSize);\n            clearTimeout(self.loadBucketTimer);\n            resetBucketAndLoadObjects();\n        }\n    };\n\n    StorageObjectLoaders.prototype.loadObjects = function (projectId, hashedObjects) {\n        var self = this,\n            hashes = {},\n            data,\n            i;\n        for (i = 0; i < hashedObjects.length; i++) {\n            hashes[hashedObjects[i].hash] = true;\n        }\n        hashes = Object.keys(hashes);\n        data = {\n            hashes: hashes,\n            projectId: projectId\n        };\n\n        this.webSocket.loadObjects(data, function (err, result) {\n            if (err) {\n                throw new Error(err);\n            }\n            self.logger.debug('loadObjects returned', {metadata: result});\n            for (i = 0; i < hashedObjects.length; i++) {\n                if (typeof result[hashedObjects[i].hash] === 'string') {\n                    self.logger.error(result[hashedObjects[i].hash]);\n                    hashedObjects[i].cb(result[hashedObjects[i].hash]);\n                } else {\n                    hashedObjects[i].cb(err, result[hashedObjects[i].hash]);\n                }\n            }\n        });\n    };\n\n    return StorageObjectLoaders;\n});\n\n",
    "/*globals define*/\r\n/*jshint node: true, browser: true*/\r\n\r\n/**\r\n * @author mmaroti / https://github.com/mmaroti\r\n */\r\n\r\n\r\ndefine('common/util/assert',[],function () {\r\n    'use strict';\r\n\r\n    var assert = function (cond, msg) {\r\n        if (!cond) {\r\n            var error = new Error(msg || 'ASSERT failed');\r\n\r\n            if (typeof TESTING === 'undefined') {\r\n                console.log('Throwing', error.stack);\r\n                console.log();\r\n            }\r\n\r\n            throw error;\r\n        }\r\n    };\r\n\r\n    return assert;\r\n});\r\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * This class (extracted functionality from cache implemented by mmaroti) caches objects associated\n * with a project.\n *\n * @author pmeijer / https://github.com/pmeijer\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/storage/project/cache',['common/util/assert', 'common/storage/constants'], function (ASSERT, CONSTANTS) {\n    'use strict';\n    function ProjectCache(storage, projectId, mainLogger, gmeConfig) {\n        var missing = {},\n            backup = {},\n            cache = {},\n            logger = mainLogger.fork('ProjectCache'),\n            cacheSize = 0;\n\n        logger.debug('ctor', projectId);\n        function cacheInsert(key, obj) {\n            ASSERT(typeof cache[key] === 'undefined' && obj[CONSTANTS.MONGO_ID] === key);\n            logger.debug('cacheInsert', key);\n\n            //deepFreeze(obj);\n            cache[key] = obj;\n\n            if (++cacheSize >= gmeConfig.storage.cache) {\n                backup = cache;\n                cache = {};\n                cacheSize = 0;\n            }\n        }\n\n        this.loadObject = function (key, callback) {\n            ASSERT(typeof key === 'string' && typeof callback === 'function');\n            logger.debug('loadObject', {metadata: key});\n\n            var obj = cache[key];\n            if (typeof obj === 'undefined') {\n                obj = backup[key];\n                if (typeof obj === 'undefined') {\n                    obj = missing[key];\n                    if (typeof obj === 'undefined') {\n                        obj = [callback];\n                        missing[key] = obj;\n                        logger.debug('object set to be loaded from storage');\n                        storage.loadObject(projectId, key, function (err, obj2) {\n                            ASSERT(typeof obj2 === 'object' || typeof obj2 === 'undefined');\n\n                            if (obj.length !== 0) {\n                                ASSERT(missing[key] === obj);\n\n                                delete missing[key];\n                                if (!err && obj2) {\n                                    cacheInsert(key, obj2);\n                                }\n\n                                var cb;\n                                while ((cb = obj.pop())) {\n                                    cb(err, obj2);\n                                }\n                            }\n                        });\n                    } else {\n                        logger.debug('object was already queued to be loaded');\n                        obj.push(callback);\n                    }\n                    return;\n                } else {\n                    logger.debug('object was in backup');\n                    cacheInsert(key, obj);\n                }\n            } else {\n                logger.debug('object was in cache');\n            }\n\n            ASSERT(typeof obj === 'object' && obj !== null && obj[CONSTANTS.MONGO_ID] === key);\n            callback(null, obj);\n        };\n\n        this.insertObject = function (obj, stackedObjects) {\n            ASSERT(typeof obj === 'object' && obj !== null);\n\n            var key = obj[CONSTANTS.MONGO_ID];\n            logger.debug('insertObject', {metadata: key});\n            ASSERT(typeof key === 'string');\n\n            if (typeof cache[key] !== 'undefined') {\n                logger.warn('object inserted was already in cache');\n            } else {\n                var item = backup[key];\n                cacheInsert(key, obj);\n\n                if (typeof item !== 'undefined') {\n                    logger.warn('object inserted was already in back-up');\n                } else {\n                    item = missing[key];\n                    if (typeof item !== 'undefined') {\n                        delete missing[key];\n\n                        var cb;\n                        while ((cb = item.pop())) {\n                            cb(null, obj);\n                        }\n                    }\n                }\n            }\n            if (stackedObjects) {\n                stackedObjects[key] = obj;\n            }\n        };\n    }\n\n    return ProjectCache;\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * This class defines the common interface for a storage-project\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/project/interface',[\n    'common/storage/project/cache',\n    'common/storage/constants',\n], function (ProjectCache, CONSTANTS) {\n    'use strict';\n\n    function ProjectInterface(projectId, storageObjectsAccessor, mainLogger, gmeConfig) {\n        this.projectId = projectId;\n        this.ID_NAME = CONSTANTS.MONGO_ID;\n        this.logger = mainLogger.fork('Project:' + this.projectId);\n        this.logger.debug('ctor', projectId);\n        this.projectCache = new ProjectCache(storageObjectsAccessor, this.projectId, this.logger, gmeConfig);\n\n        this.getBranch = function (branchName, shouldExist) {\n            throw new Error('getBranch must be overridden in derived class');\n        };\n\n        // Functions forwarded to project cache.\n        this.insertObject = this.projectCache.insertObject;\n        this.loadObject = this.projectCache.loadObject;\n\n        // Functions forwarded to storage.\n        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {\n            throw new Error('makeCommit must be overridden in derived class');\n        };\n\n        this.setBranchHash = function (branchName, newHash, oldHash, callback) {\n            throw new Error('setBranchHash must be overridden in derived class');\n        };\n\n        this.getBranchHash = function (branchName, callback) {\n            throw new Error('setBranchHash must be overridden in derived class');\n        };\n\n        this.createBranch = function (branchName, newHash, callback) {\n            throw new Error('createBranch must be overridden in derived class');\n        };\n\n        this.getBranches = function (callback) {\n            throw new Error('getBranches must be overridden in derived class');\n        };\n\n        this.getCommits = function (before, number, callback) {\n            throw new Error('getCommits must be overridden in derived class');\n        };\n\n        this.getCommonAncestorCommit = function (commitA, commitB, callback) {\n            throw new Error('getCommonAncestorCommit must be overridden in derived class');\n        };\n    }\n\n    return ProjectInterface;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/project/branch',['common/storage/constants'], function (CONSTANTS) {\n    'use strict';\n\n    function Branch(name, mainLogger) {\n        var self = this,\n            logger = mainLogger.fork('Branch:' + name),\n            originHash = '',\n            localHash = '',\n            commitQueue = [],\n            updateQueue = [];\n\n        logger.debug('ctor');\n        this.name = name;\n        this.isOpen = true;\n\n        this.updateHandler = null;\n        this.commitHandler = null;\n\n        this.localUpdateHandler = null;\n\n        this.cleanUp = function () {\n            self.isOpen = false;\n            self.updateHandler = null;\n            self.commitHandler = null;\n            self.localUpdateHandler = null;\n\n            commitQueue = [];\n            updateQueue = [];\n        };\n\n        this.getLocalHash = function () {\n            return localHash;\n        };\n\n        this.getOriginHash = function () {\n            return originHash;\n        };\n\n        this.updateHashes = function (newLocal, newOrigin) {\n            logger.debug('updatingHashes');\n            if (newLocal !== null) {\n                logger.debug('localHash: old, new', localHash, newLocal);\n                localHash = newLocal;\n            }\n            if (newOrigin !== null) {\n                logger.debug('originHash: old, new', originHash, newOrigin);\n                originHash = newOrigin;\n            }\n        };\n\n        this.queueCommit = function (commitData) {\n            commitQueue.push(commitData);\n            logger.debug('Adding new commit to queue', commitQueue.length);\n        };\n\n        this.getFirstCommit = function (shift) {\n            var commitData;\n            if (shift) {\n                commitData = commitQueue.shift();\n                logger.debug('Removed commit from queue', commitQueue.length);\n            } else {\n                commitData = commitQueue[0];\n            }\n\n            return commitData;\n        };\n\n        this.getCommitQueue = function () {\n            return commitQueue;\n        };\n\n        this.getCommitsForNewFork = function (upTillCommitHash) {\n            var i,\n                commitData,\n                commitHash,\n                commitHashExisted = false,\n                subQueue = [];\n\n            logger.debug('getCommitsForNewFork', upTillCommitHash);\n\n            if (commitQueue.length === 0) {\n                commitHash = localHash;\n\n                logger.debug('No commits queued will fork from', commitHash);\n                upTillCommitHash = upTillCommitHash || commitHash;\n                commitHashExisted = upTillCommitHash === commitHash;\n            } else {\n                upTillCommitHash = upTillCommitHash ||\n                    commitQueue[commitQueue.length - 1].commitObject[CONSTANTS.MONGO_ID];\n            }\n\n            logger.debug('Will fork up to commitHash', upTillCommitHash);\n\n            // Move over all commit-data up till the chosen commitHash to the fork's queue,\n            // except the commit that caused the fork (all its objects are already in the database).\n            for (i = 0; i < commitQueue.length; i += 1) {\n                commitData = commitQueue[i];\n                commitHash = commitData.commitObject[CONSTANTS.MONGO_ID];\n                // remove the branchName of the commitData\n                delete commitData.branchName;\n                if (i !== 0) {\n                    subQueue.push(commitData);\n                }\n                if (commitData.commitObject[CONSTANTS.MONGO_ID] === upTillCommitHash) {\n                    // The commitHash from where to fork has been reached.\n                    // If any, the rest of the 'pending' commits will not be used.\n                    commitHashExisted = true;\n                    break;\n                }\n            }\n\n            if (commitHashExisted === false) {\n                logger.error('Could not find the specified commitHash', upTillCommitHash);\n                return false;\n            }\n\n            return {commitHash: commitHash, queue: subQueue};\n        };\n\n        this.queueUpdate = function (updateData) {\n            updateQueue.push(updateData);\n            logger.debug('Adding new update to queue', updateQueue.length);\n        };\n\n        this.getUpdateQueue = function () {\n            return updateQueue;\n        };\n\n        this.getFirstUpdate = function (shift) {\n            var updateData;\n            if (shift) {\n                updateData = updateQueue.shift();\n                logger.debug('Removed update from queue', updateQueue.length);\n            } else {\n                updateData = updateQueue[0];\n            }\n\n            return updateData;\n        };\n    }\n\n    return Branch;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/project/project',[\n    'common/storage/project/interface',\n    'common/storage/project/branch',\n    'common/util/assert'\n    //'q'\n], function (ProjectInterface, Branch, ASSERT) {\n    'use strict';\n\n    function Project(projectId, storage, mainLogger, gmeConfig) {\n        var self = this;\n        this.branches = {};\n\n        ProjectInterface.call(this, projectId, storage, mainLogger, gmeConfig);\n\n        // Functions for client specific branch handling\n        this.getBranch = function (branchName, shouldExist) {\n\n            if (shouldExist === true) {\n                ASSERT(this.branches.hasOwnProperty(branchName), 'branch does not exist ' + branchName);\n            } else if (shouldExist === false) {\n                ASSERT(this.branches.hasOwnProperty(branchName) === false, 'branch already existed ' + branchName);\n            }\n\n            if (this.branches.hasOwnProperty(branchName) === false) {\n                this.branches[branchName] = new Branch(branchName, self.logger);\n            }\n\n            return this.branches[branchName];\n        };\n\n        this.removeBranch = function (branchName) {\n            var existed = this.branches.hasOwnProperty(branchName);\n            if (existed) {\n                delete this.branches[branchName];\n            }\n            return existed;\n        };\n\n        // Functions defined in ProjectInterface\n        this.makeCommit = function (branchName, parents, rootHash, coreObjects, msg, callback) {\n            return storage.makeCommit(self.projectId, branchName, parents, rootHash, coreObjects, msg, callback);\n        };\n\n        this.setBranchHash = function (branchName, newHash, oldHash, callback) {\n            return storage.setBranchHash(self.projectId, branchName, newHash, oldHash, callback);\n        };\n\n        this.getBranchHash = function (branchName, callback) {\n            storage.setBranchHash(self.projectId, branchName, callback);\n        };\n\n        this.createBranch = function (branchName, newHash, callback) {\n            storage.createBranch(self.projectId, branchName, newHash, callback);\n        };\n\n        this.getBranches = function (callback) {\n            storage.getBranches(self.projectId, callback);\n        };\n\n        this.getCommits = function (before, number, callback) {\n            storage.getCommits(self.projectId, before, number, callback);\n        };\n\n        this.getCommonAncestorCommit = function (commitA, commitB, callback) {\n            storage.getCommonAncestorCommit(self.projectId, commitA, commitB, callback);\n        };\n    }\n\n    Project.prototype = Object.create(ProjectInterface);\n    Project.prototype.constructor = Project;\n\n    return Project;\n});\n",
    "//jshint ignore: start\n//SHA1 in Javascript 862 bytes, MIT License, http://antimatter15.com/\ndefine('common/util/sha1',[],function() {\nreturn function(l){function p(b,a){return b<<a|b>>>32-a}l+=\"\";for(var n=Math,c=[1518500249,1859775393,2400959708,3395469782,1732584193,4023233417,2562383102,271733878,3285377520,4294967295],s=n.ceil(l.length/4)+2,q=n.ceil(s/16),g=[],a=0,h=[],j,d,e,f,m,i,b,k;a<q;a++){g[a]=[];for(k=0;k<16;k++){function o(b,c){return l.charCodeAt(a*64+k*4+b)<<c}g[a][k]=o(0,24)|o(1,16)|o(2,8)|o(3,0)}}i=l.length*8-8;a=q-1;g[a][14]=i/(c[9]+1);g[a][14]=n.floor(g[a][14]);g[a][15]=i&c[9];for(a=0;a<q;a++){for(b=0;b<16;b++)h[b]=g[a][b];for(b=16;b<80;b++)h[b]=p(h[b-3]^h[b-8]^h[b-14]^h[b-16],1);j=c[4];d=c[5];e=c[6];f=c[7];m=c[8];for(b=0;b<80;b++){var r=n.floor(b/20),t=p(j,5)+(r<1?d&e^~d&f:r==2?d&e^d&f^e&f:d^e^f)+m+c[r]+h[b]&c[9];m=f;f=e;e=p(d,30);d=j;j=t}c[4]+=j;c[5]+=d;c[6]+=e;c[7]+=f;c[8]+=m}i=\"\";for(z=4;z<9;z++)for(a=7;a>=0;a--)i+=((c[z]&c[9])>>>a*4&15).toString(16);return i};\n});\n\n",
    "//jshint ignore: start\n/* 2012 David Chambers <dc@hashify.me>  */\ndefine('common/util/canon',[], function() {\n    var CANON = {},\n        keys, map, nativeMap, pad,\n        __slice = [].slice,\n        __hasProp = {}.hasOwnProperty;\n\n\n    CANON.stringify = (function() {\n        var canonicalize;\n        canonicalize = function(value) {\n            var pair, _ref;\n            switch (Object.prototype.toString.call(value)) {\n                case '[object Array]':\n                    return ['Array'].concat(__slice.call(map(value, canonicalize)));\n                case '[object Date]':\n                    return ['Date'].concat(isFinite(+value) ? value.getUTCFullYear() + '-' + pad(value.getUTCMonth() + 1) + '-' + pad(value.getUTCDate()) + 'T' + pad(value.getUTCHours()) + ':' + pad(value.getUTCMinutes()) + ':' + pad(value.getUTCSeconds()) + '.' + pad(value.getUTCMilliseconds(), 3) + 'Z' : null);\n                case '[object Function]':\n                    throw new TypeError('functions cannot be serialized');\n                    break;\n                case '[object Number]':\n                    if (isFinite(value)) {\n                        return value;\n                    } else {\n                        return ['Number', \"\" + value];\n                    }\n                    break;\n                case '[object Object]':\n                    pair = function(key) {\n                        return [key, canonicalize(value[key])];\n                    };\n                    return (_ref = ['Object']).concat.apply(_ref, map(keys(value).sort(), pair));\n                case '[object RegExp]':\n                    return ['RegExp', \"\" + value];\n                case '[object Undefined]':\n                    return ['Undefined'];\n                default:\n                    return value;\n            }\n        };\n        return function(value) {\n            return JSON.stringify(canonicalize(value));\n        };\n    })();\n\n    CANON.parse = (function() {\n        var canonicalize;\n        canonicalize = function(value) {\n            var element, elements, idx, object, what, _i, _ref;\n            if (Object.prototype.toString.call(value) !== '[object Array]') {\n                return value;\n            }\n            what = value[0], elements = 2 <= value.length ? __slice.call(value, 1) : [];\n            element = elements[0];\n            switch (what) {\n                case 'Array':\n                    return map(elements, canonicalize);\n                case 'Date':\n                    return new Date(element);\n                case 'Number':\n                    return +element;\n                case 'Object':\n                    object = {};\n                    for (idx = _i = 0, _ref = elements.length; _i < _ref; idx = _i += 2) {\n                        object[elements[idx]] = canonicalize(elements[idx + 1]);\n                    }\n                    return object;\n                case 'RegExp':\n                    return (function(func, args, ctor) {\n                        ctor.prototype = func.prototype;\n                        var child = new ctor, result = func.apply(child, args);\n                        return Object(result) === result ? result : child;\n                    })(RegExp, /^[/](.+)[/]([gimy]*)$/.exec(element).slice(1), function(){});\n                case 'Undefined':\n                    return void 0;\n                default:\n                    throw new Error('invalid input');\n            }\n        };\n        return function(string) {\n            return canonicalize(JSON.parse(string));\n        };\n    })();\n\n    nativeMap = Array.prototype.map;\n\n    map = function(array, iterator) {\n        var el, _i, _len, _results;\n        if (nativeMap && array.map === nativeMap) {\n            return array.map(iterator);\n        } else {\n            _results = [];\n            for (_i = 0, _len = array.length; _i < _len; _i++) {\n                el = array[_i];\n                _results.push(iterator(el));\n            }\n            return _results;\n        }\n    };\n\n    keys = Object.keys || function(object) {\n        var key, _results;\n        _results = [];\n        for (key in object) {\n            if (!__hasProp.call(object, key)) continue;\n            _results.push(key);\n        }\n        return _results;\n    };\n\n    pad = function(n, min) {\n        if (min == null) {\n            min = 2;\n        }\n        return (\"\" + (1000 + n)).substr(4 - min);\n    };\n\n    return CANON;\n\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/util/key',[\n    'common/util/sha1',\n    'common/util/assert',\n    'common/util/canon'\n], function (SHA1, ASSERT, CANON) {\n    'use strict';\n\n    var keyType = null;\n\n    function rand160Bits() {\n        var result = '',\n            i, code;\n        for (i = 0; i < 40; i++) {\n            code = Math.floor(Math.random() * 16);\n            code = code > 9 ? code + 87 : code + 48;\n            result += String.fromCharCode(code);\n        }\n        return result;\n    }\n\n    return function KeyGenerator(object, gmeConfig) {\n        keyType = gmeConfig.storage.keyType;\n        ASSERT(typeof keyType === 'string');\n\n        switch (keyType) {\n            case 'rand160Bits':\n                return rand160Bits();\n            default: //plainSHA1\n                return SHA1(CANON.stringify(object));\n        }\n    };\n});\n",
    "/*globals define*/\n/*jshint node:true*/\n/**\n * This class implements the functionality needed to edit a model in a specific project and branch in a\n * collaborative fashion.\n *\n * It keeps a state of the open projects which in turn keeps track of the open branches.\n *\n * Each project is associated with a project-cache which is shared amongst the branches. So switching\n * between branches is (potentially) an operation that does not require lots of server round-trips.\n *\n * It is possible to have multiple projects open and multiple branches within each project. However\n * one instance of a storage can only hold a single instance of a project (or branch within a project).\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/storageclasses/editorstorage',[\n    'common/storage/storageclasses/objectloaders',\n    'common/storage/constants',\n    'common/storage/project/project',\n    'common/util/assert',\n    'common/util/key'\n], function (StorageObjectLoaders, CONSTANTS, Project, ASSERT, GENKEY) {\n    'use strict';\n\n    function EditorStorage(webSocket, mainLogger, gmeConfig) {\n        var self = this,\n            logger = mainLogger.fork('storage'),\n            projects = {};\n\n        self.logger = logger;\n        self.userId = null;\n\n        StorageObjectLoaders.call(this, webSocket, mainLogger, gmeConfig);\n\n        this.open = function (networkHandler) {\n            webSocket.connect(function (err, connectionState) {\n                if (err) {\n                    logger.error(err);\n                    networkHandler(CONSTANTS.ERROR);\n                } else if (connectionState === CONSTANTS.CONNECTED) {\n                    self.connected = true;\n                    self.userId = webSocket.userId;\n                    networkHandler(connectionState);\n                } else if (connectionState === CONSTANTS.RECONNECTED) {\n                    self._rejoinWatcherRooms();\n                    self._rejoinBranchRooms();\n                    self.connected = true;\n                    networkHandler(connectionState);\n                } else if (connectionState === CONSTANTS.DISCONNECTED) {\n                    self.connected = false;\n                    networkHandler(connectionState);\n                } else {\n                    logger.error('unexpected connection state');\n                    networkHandler(CONSTANTS.ERROR);\n                }\n            });\n        };\n\n        this.close = function (callback) {\n            var error = '',\n                openProjects = Object.keys(projects),\n                projectCnt = openProjects.length;\n\n            logger.debug('Closing storage, openProjects', openProjects);\n\n            function afterProjectClosed(err) {\n                if (err) {\n                    logger.error(err);\n                    error += err;\n                }\n                logger.debug('inside afterProjectClosed projectCnt', projectCnt);\n                if (projectCnt === 0) {\n                    // Remove the handler for the socket.io events 'connect' and 'disconnect'.\n                    logger.debug('Removing connect and disconnect events');\n                    webSocket.socket.removeAllListeners('connect');\n                    webSocket.socket.removeAllListeners('disconnect');\n                    // Disconnect from the server.\n                    logger.debug('Disconnecting web-socket');\n                    webSocket.disconnect();\n                    self.connected = false;\n                    // Remove all local event-listeners.\n                    webSocket.removeAllEventListeners();\n                    callback(error || null);\n                }\n            }\n\n            if (projectCnt > 0) {\n                while (projectCnt) {\n                    projectCnt -= 1;\n                    this.closeProject(openProjects[projectCnt], afterProjectClosed);\n                }\n            } else {\n                logger.debug('No projects were open, will disconnect directly');\n                afterProjectClosed(null);\n            }\n        };\n\n        /**\n         * Callback for openProject.\n         *\n         * @callback EditorStorage~openProjectCallback\n         * @param {string} err - error string.\n         * @param {Project} project - the newly opened project.\n         * @param {object} branches - the newly opened project.\n         * @example\n         * // branches is of the form\n         * // { master: '#somevalidhash', b1: '#someothervalidhash' }\n         */\n\n        /**\n         *\n         * @param {string} projectId - name of project to open.\n         * @param {EditorStorage~openProjectCallback} - callback\n         */\n        this.openProject = function (projectId, callback) {\n            var data = {\n                projectId: projectId\n            };\n            if (projects[projectId]) {\n                logger.error('project is already open', projectId);\n                callback('project is already open');\n            }\n            webSocket.openProject(data, function (err, branches, access) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                var project = new Project(projectId, self, logger, gmeConfig);\n                projects[projectId] = project;\n                callback(err, project, branches, access);\n            });\n        };\n\n        this.closeProject = function (projectId, callback) {\n            var project = projects[projectId],\n                error = '',\n                branchCnt,\n                branchNames;\n            logger.debug('closeProject', projectId);\n\n            function closeAndDelete(err) {\n                if (err) {\n                    logger.error(err);\n                    error += err;\n                }\n                logger.debug('inside closeAndDelete branchCnt', branchCnt);\n                if (branchCnt === 0) {\n                    delete projects[projectId];\n                    logger.debug('project reference deleted, sending close to server.');\n                    webSocket.closeProject({projectId: projectId}, function (err) {\n                        logger.debug('project closed on server.');\n                        callback(err || error);\n                    });\n                }\n            }\n\n            if (project) {\n                branchNames = Object.keys(project.branches);\n                branchCnt = branchNames.length;\n                if (branchCnt > 0) {\n                    logger.warn('Branches still open for project, will be closed.', projectId, branchNames);\n                    while (branchCnt) {\n                        branchCnt -= 1;\n                        this.closeBranch(projectId, branchNames[branchCnt], closeAndDelete);\n                    }\n                } else {\n                    closeAndDelete(null);\n                }\n            } else {\n                logger.warn('Project is not open ', projectId);\n                callback(null);\n            }\n\n        };\n\n        this.openBranch = function (projectId, branchName, updateHandler, commitHandler, callback) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            var self = this,\n                project = projects[projectId],\n                data = {\n                    projectId: projectId,\n                    branchName: branchName\n                };\n\n            webSocket.openBranch(data, function (err, latestCommit) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                var i,\n                    branchHash = latestCommit.commitObject[CONSTANTS.MONGO_ID],\n                    branch = project.getBranch(branchName, false);\n\n                branch.updateHashes(branchHash, branchHash);\n\n                branch.commitHandler = commitHandler;\n                branch.localUpdateHandler = updateHandler;\n\n                branch.updateHandler = function (_ws, updateData) {\n                    var j,\n                        originHash = updateData.commitObject[CONSTANTS.MONGO_ID];\n                    logger.debug('updateHandler invoked for project, branch', projectId, branchName);\n                    for (j = 0; j < updateData.coreObjects.length; j += 1) {\n                        project.insertObject(updateData.coreObjects[j]);\n                    }\n\n                    branch.queueUpdate(updateData);\n                    branch.updateHashes(null, originHash);\n\n                    if (branch.getCommitQueue().length === 0) {\n                        if (branch.getUpdateQueue().length === 1) {\n                            self._pullNextQueuedCommit(projectId, branchName);\n                        }\n                    } else {\n                        logger.debug('commitQueue is not empty, only updating originHash.');\n                    }\n                };\n\n                webSocket.addEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),\n                    branch.updateHandler);\n\n                // Insert the objects from the latest commit into the project cache.\n                for (i = 0; i < latestCommit.coreObjects.length; i += 1) {\n                    project.insertObject(latestCommit.coreObjects[i]);\n                }\n\n                callback(err, latestCommit);\n            });\n        };\n\n        this.closeBranch = function (projectId, branchName, callback) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            logger.debug('closeBranch', projectId, branchName);\n\n            var project = projects[projectId],\n                branch = project.branches[branchName];\n\n            if (branch) {\n                // This will prevent memory leaks and expose if a commit is being\n                // processed at the server this time (see last error in _pushNextQueuedCommit).\n                branch.cleanUp();\n\n                // Stop listening to events from the sever\n                webSocket.removeEventListener(webSocket.getBranchUpdateEventName(projectId, branchName),\n                    branch.updateHandler);\n            } else {\n                logger.warn('Branch is not open', projectId, branchName);\n                callback(null);\n                return;\n            }\n\n            project.removeBranch(branchName);\n            webSocket.closeBranch({projectId: projectId, branchName: branchName}, callback);\n        };\n\n        this.forkBranch = function (projectId, branchName, forkName, commitHash, callback) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            this.logger.debug('forkBranch', projectId, branchName, forkName, commitHash);\n            var self = this,\n                project = projects[projectId],\n                branch = project.getBranch(branchName, true),\n                forkData;\n\n            forkData = branch.getCommitsForNewFork(commitHash, forkName); // commitHash = null defaults to latest commit\n            self.logger.debug('forkBranch - forkData', forkData);\n            if (forkData === false) {\n                callback('Could not find specified commitHash');\n                return;\n            }\n\n            function commitNext() {\n                var currentCommitData = forkData.queue.shift();\n                logger.debug('forkBranch - commitNext, currentCommitData', currentCommitData);\n                if (currentCommitData) {\n                    webSocket.makeCommit(currentCommitData, function (err, result) {\n                        if (err) {\n                            logger.error('forkBranch - failed committing', err);\n                            callback(err);\n                            return;\n                        }\n                        logger.debug('forkBranch - commit successful, hash', result);\n                        commitNext();\n                    });\n                } else {\n                    self.createBranch(projectId, forkName, forkData.commitHash, function (err) {\n                        if (err) {\n                            logger.error('forkBranch - failed creating new branch', err);\n                            callback(err);\n                            return;\n                        }\n                        callback(null, forkData.commitHash);\n                    });\n                }\n            }\n\n            commitNext();\n        };\n\n        this.makeCommit = function (projectId, branchName, parents, rootHash, coreObjects, msg, callback) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            var project = projects[projectId],\n                branch,\n                commitData = {\n                    projectId: projectId\n                };\n\n            commitData.commitObject = self._getCommitObject(projectId, parents, rootHash, msg);\n            commitData.coreObjects = coreObjects;\n            if (typeof branchName === 'string') {\n                commitData.branchName = branchName;\n                branch = project.getBranch(branchName, true);\n                branch.updateHashes(commitData.commitObject[CONSTANTS.MONGO_ID], null);\n                branch.queueCommit(commitData);\n                if (branch.getCommitQueue().length === 1) {\n                    self._pushNextQueuedCommit(projectId, branchName, callback);\n                }\n            } else {\n                ASSERT(typeof callback === 'function', 'Making commit without updating branch requires a callback.');\n                webSocket.makeCommit(commitData, callback);\n            }\n\n            return commitData.commitObject; //commitHash\n        };\n\n        this._pushNextQueuedCommit = function (projectId, branchName, callback) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            var project = projects[projectId],\n                branch = project.getBranch(branchName, true),\n                commitData;\n            logger.debug('_pushNextQueuedCommit', branch.getCommitQueue());\n            if (branch.getCommitQueue().length === 0) {\n                return;\n            }\n\n            commitData = branch.getFirstCommit(false);\n            webSocket.makeCommit(commitData, function (err, result) {\n                if (err) {\n                    logger.error('makeCommit failed', err);\n                }\n\n                // This is for when e.g. a plugin makes a commit to the same branch as the\n                // client and waits for the callback before proceeding.\n                // (If it is a forking commit, the plugin can proceed knowing that and the client will get notified of\n                // the fork through the commitHandler.\n                if (typeof callback === 'function') {\n                    callback(err, result);\n                }\n\n                if (branch.isOpen) {\n                    branch.commitHandler(branch.getCommitQueue(), result, function (push) {\n                        if (push) {\n                            branch.getFirstCommit(true); // Remove the commit from the queue.\n                            branch.updateHashes(null, commitData.commitObject[CONSTANTS.MONGO_ID]);\n                            self._pushNextQueuedCommit(projectId, branchName);\n                        }\n                    });\n                } else {\n                    logger.error('_pushNextQueuedCommit returned from server but the branch was closed, ' +\n                        'the branch has probably been closed while waiting for the response.', projectId, branchName);\n                }\n            });\n        };\n\n        this._getCommitObject = function (projectId, parents, rootHash, msg) {\n            msg = msg || 'n/a';\n            var commitObj = {\n                    root: rootHash,\n                    parents: parents,\n                    updater: [self.userId],\n                    time: (new Date()).getTime(),\n                    message: msg,\n                    type: 'commit'\n                },\n                commitHash = '#' + GENKEY(commitObj, gmeConfig);\n\n            commitObj[CONSTANTS.MONGO_ID] = commitHash;\n\n            return commitObj;\n        };\n\n        this._pullNextQueuedCommit = function (projectId, branchName) {\n            ASSERT(projects.hasOwnProperty(projectId), 'Project not opened: ' + projectId);\n            var self = this,\n                project = projects[projectId],\n                branch = project.getBranch(branchName, true),\n                updateData;\n\n            logger.debug('About to update, updateQueue', {metadata: branch.getUpdateQueue()});\n            if (branch.getUpdateQueue().length === 0) {\n                logger.debug('No queued updates, returns');\n                return;\n            }\n\n            updateData = branch.getFirstUpdate();\n            if (branch.isOpen) {\n                branch.localUpdateHandler(branch.getUpdateQueue(), updateData, function (aborted) {\n                    var originHash = updateData.commitObject[CONSTANTS.MONGO_ID];\n                    if (aborted === false) {\n                        logger.debug('New commit was successfully loaded, updating localHash.');\n                        branch.updateHashes(originHash, null);\n                        branch.getFirstUpdate(true);\n                        self._pullNextQueuedCommit(projectId, branchName);\n                    } else {\n                        logger.warn('Loading of update commit was aborted or failed.', {metadat: updateData});\n                    }\n                });\n            } else {\n                logger.error('_pullNextQueuedCommit returned from server but the branch was closed.',\n                    projectId, branchName);\n            }\n        };\n\n        this._rejoinBranchRooms = function () {\n            var projectId,\n                project,\n                branchName;\n            logger.debug('_rejoinBranchRooms');\n            for (projectId in projects) {\n                if (projects.hasOwnProperty(projectId)) {\n                    project = projects[projectId];\n                    logger.debug('_rejoinBranchRooms found project', projectId);\n                    for (branchName in project.branches) {\n                        if (project.branches.hasOwnProperty(branchName)) {\n                            logger.debug('_rejoinBranchRooms joining branch', projectId, branchName);\n                            webSocket.watchBranch({\n                                projectId: projectId,\n                                branchName: branchName,\n                                join: true\n                            });\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    EditorStorage.prototype = Object.create(StorageObjectLoaders.prototype);\n    EditorStorage.prototype.constructor = EditorStorage;\n\n    return EditorStorage;\n});\n",
    "/*globals define, require*/\n/*jshint browser:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/socketio/browserclient',[], function () {\n    'use strict';\n\n    function IoClient (mainLogger, gmeConfig) {\n        var logger = mainLogger.fork('socketio-browserclient');\n\n        this.connect = function (callback) {\n            var hostAddress = window.location.protocol + '//' + window.location.host,\n                socketIoUrl;\n\n            if (window.__karma__) {\n                // TRICKY: karma uses web sockets too, we need to use the gme server's port\n                hostAddress = window.location.protocol + '//localhost:' + gmeConfig.server.port;\n            }\n\n            socketIoUrl = hostAddress + '/socket.io/socket.io.js';\n            logger.debug('Will require socketIO from', socketIoUrl);\n\n            require([socketIoUrl], function (io_) {\n                var io = io_ || window.io,\n                    socket;\n\n                logger.debug('Connecting to \"' + hostAddress + '\" with options', gmeConfig.socketIO);\n                socket = io.connect(hostAddress, gmeConfig.socketIO);\n                callback(null, socket);\n            });\n        };\n    }\n\n    return IoClient;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author rkereskenyi / https://github.com/rkereskenyi\n */\n\ndefine('common/EventDispatcher',[], function () {\n    'use strict';\n\n    var EventDispatcher = function () {\n        this._eventList = {};\n    };\n\n    EventDispatcher.prototype = {\n        _eventList: null,\n        _getEvent: function (eventName, create) {\n            // Check if Array of Event Handlers has been created\n            if (!this._eventList[eventName]) {\n\n                // Check if the calling method wants to create the Array\n                // if not created. This reduces unneeded memory usage.\n                if (!create) {\n                    return null;\n                }\n\n                // Create the Array of Event Handlers\n                this._eventList[eventName] = [];\n                // new Array\n            }\n\n            // return the Array of Event Handlers already added\n            return this._eventList[eventName];\n        },\n        addEventListener: function (eventName, handler) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName, true);\n\n            // Add the new Event Handler to the Array\n            evt.push(handler);\n        },\n        removeEventListener: function (eventName, handler) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName);\n\n            if (!evt) {\n                return;\n            }\n\n            // Helper Method - an Array.indexOf equivalent\n            var getArrayIndex = function (array, item) {\n                for (var i = 0; i < array.length; i++) {\n                    if (array[i] === item) {\n                        return i;\n                    }\n                }\n                return -1;\n            };\n\n            // Get the Array index of the Event Handler\n            var index = getArrayIndex(evt, handler);\n\n            if (index > -1) {\n                // Remove Event Handler from Array\n                evt.splice(index, 1);\n            }\n        },\n        removeAllEventListeners: function (eventName) {\n            // Get the Array of Event Handlers\n            var evt = this._getEvent(eventName);\n\n            if (!evt) {\n                return;\n            }\n\n            evt.splice(0, evt.length);\n        },\n        dispatchEvent: function (eventName, eventArgs) {\n            // Get a function that will call all the Event Handlers internally\n            var handler = this._getEventHandler(eventName);\n            if (handler) {\n                // call the handler function\n                // Pass in \"sender\" and \"eventArgs\" parameters\n                handler(this, eventArgs);\n            }\n        },\n        _getEventHandler: function (eventName) {\n            // Get Event Handler Array for this Event\n            var evt = this._getEvent(eventName, false);\n            if (!evt || evt.length === 0) {\n                return null;\n            }\n\n            // Create the Handler method that will use currying to\n            // call all the Events Handlers internally\n            var h = function (sender, args) {\n                for (var i = 0; i < evt.length; i++) {\n                    evt[i](sender, args);\n                }\n            };\n\n            // Return this new Handler method\n            return h;\n        }\n    };\n\n    return EventDispatcher;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\n// socket.io-client\n//\ndefine('common/storage/socketio/websocket',[\n    'common/EventDispatcher',\n    'common/storage/constants'\n], function (EventDispatcher, CONSTANTS) {\n\n    'use strict';\n\n    function WebSocket(ioClient, mainLogger, gmeConfig) {\n        var self = this,\n            logger = mainLogger.fork('WebSocket'),\n            beenConnected = false;\n\n        self.socket = null;\n        self.userId = null;\n\n        logger.debug('ctor');\n        EventDispatcher.call(this);\n\n        this.connect = function (networkHandler) {\n            logger.debug('Connecting via ioClient.');\n            ioClient.connect(function (err, socket_) {\n                if (err) {\n                    networkHandler(err);\n                    return;\n                }\n                self.socket = socket_;\n\n                self.socket.on('connect', function () {\n                    if (beenConnected) {\n                        logger.debug('Socket got reconnected.');\n                        networkHandler(null, CONSTANTS.RECONNECTED);\n                    } else {\n                        logger.debug('Socket got connected for the first time.');\n                        beenConnected = true;\n                        self.socket.emit('getUserId', function (err, userId) {\n                            if (err) {\n                                self.userId = gmeConfig.authentication.guestAccount;\n                                logger.error('Error getting user id setting to default', err, self.userId);\n                            } else {\n                                self.userId = userId;\n                            }\n                            networkHandler(null, CONSTANTS.CONNECTED);\n                        });\n                    }\n                });\n\n                self.socket.on('disconnect', function () {\n                    logger.debug('Socket got disconnected!');\n                    networkHandler(null, CONSTANTS.DISCONNECTED);\n                });\n\n                self.socket.on(CONSTANTS.PROJECT_DELETED, function (data) {\n                    data.etype = CONSTANTS.PROJECT_DELETED;\n                    logger.debug('PROJECT_DELETED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.PROJECT_DELETED, data);\n                });\n\n                self.socket.on(CONSTANTS.PROJECT_CREATED, function (data) {\n                    data.etype = CONSTANTS.PROJECT_CREATED;\n                    logger.debug('PROJECT_CREATED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.PROJECT_CREATED, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_CREATED, function (data) {\n                    data.etype = CONSTANTS.BRANCH_CREATED;\n                    logger.debug('BRANCH_CREATED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_CREATED + data.projectId, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_DELETED, function (data) {\n                    data.etype = CONSTANTS.BRANCH_DELETED;\n                    logger.debug('BRANCH_DELETED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_DELETED + data.projectId, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_HASH_UPDATED, function (data) {\n                    data.etype = CONSTANTS.BRANCH_HASH_UPDATED;\n                    logger.debug('BRANCH_HASH_UPDATED event', {metadata: data});\n                    self.dispatchEvent(CONSTANTS.BRANCH_HASH_UPDATED + data.projectId, data);\n                });\n\n                self.socket.on(CONSTANTS.BRANCH_UPDATED, function (data) {\n                    logger.debug('BRANCH_UPDATED event', {metadata: data});\n                    self.dispatchEvent(self.getBranchUpdateEventName(data.projectId, data.branchName), data);\n                });\n            });\n        };\n\n        this.disconnect = function () {\n            self.socket.disconnect();\n            beenConnected = false; //This is a forced disconnect from the storage and all listeners are removed\n        };\n\n        // watcher functions\n        this.watchDatabase = function (data, callback) {\n            self.socket.emit('watchDatabase', data, callback);\n        };\n\n        this.watchProject = function (data, callback) {\n            self.socket.emit('watchProject', data, callback);\n        };\n\n        this.watchBranch = function (data, callback) {\n            self.socket.emit('watchBranch', data, callback);\n        };\n\n        // model editing functions\n        this.openProject = function (data, callback) {\n            self.socket.emit('openProject', data, callback);\n        };\n\n        this.closeProject = function (data, callback) {\n            self.socket.emit('closeProject', data, callback);\n        };\n\n        this.openBranch = function (data, callback) {\n            self.socket.emit('openBranch', data, callback);\n        };\n\n        this.closeBranch = function (data, callback) {\n            self.socket.emit('closeBranch', data, callback);\n        };\n\n        this.makeCommit = function (data, callback) {\n            self.socket.emit('makeCommit', data, callback);\n        };\n\n        this.loadObjects = function (data, callback) {\n            self.socket.emit('loadObjects', data, callback);\n        };\n\n        this.setBranchHash = function (data, callback) {\n            self.socket.emit('setBranchHash', data, callback);\n        };\n\n        // REST like functions\n        this.getProjects = function (data, callback) {\n            self.socket.emit('getProjects', data, callback);\n        };\n\n        this.deleteProject = function (data, callback) {\n            self.socket.emit('deleteProject', data, callback);\n        };\n\n        this.createProject = function (data, callback) {\n            self.socket.emit('createProject', data, callback);\n        };\n\n        this.getBranches = function (data, callback) {\n            self.socket.emit('getBranches', data, callback);\n        };\n\n        this.getCommits = function (data, callback) {\n            self.socket.emit('getCommits', data, callback);\n        };\n\n        this.getLatestCommitData = function (data, callback) {\n            self.socket.emit('getLatestCommitData', data, callback);\n        };\n\n        this.getCommonAncestorCommit = function (data, callback) {\n            self.socket.emit('getCommonAncestorCommit', data, callback);\n        };\n\n        //temporary simple request / result functions\n        this.simpleRequest = function (data, callback) {\n            self.socket.emit('simpleRequest', data, callback);\n        };\n\n        this.simpleResult = function (data, callback) {\n            self.socket.emit('simpleResult', data, callback);\n        };\n\n        this.simpleQuery = function (workerId, data, callback) {\n            self.socket.emit('simpleQuery', workerId, data, callback);\n        };\n\n        // Helper functions\n        this.getBranchUpdateEventName = function (projectName, branchName) {\n            return CONSTANTS.BRANCH_UPDATED + projectName + CONSTANTS.ROOM_DIVIDER + branchName;\n        };\n    }\n\n    WebSocket.prototype = Object.create(EventDispatcher.prototype);\n    WebSocket.prototype.constructor = WebSocket;\n\n    return WebSocket;\n});\n",
    "/*globals define*/\n/*jshint browser:true*/\n/**\n *\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/storage/browserstorage',[\n    'common/storage/storageclasses/editorstorage',\n    'common/storage/socketio/browserclient',\n    'common/storage/socketio/websocket',\n], function (EditorStorage, BrowserIoClient, WebSocket) {\n    'use strict';\n\n    var _storage;\n\n    function _createStorage(logger, gmeConfig) {\n        var ioClient = new BrowserIoClient(logger, gmeConfig),\n            webSocket = new WebSocket(ioClient, logger, gmeConfig),\n            storage = new EditorStorage(webSocket, logger, gmeConfig);\n\n        return storage;\n    }\n\n    function getStorage (logger, gmeConfig, forceNew) {\n        logger.debug('getStorage');\n\n        if (!_storage) {\n            logger.debug('No storage existed, will create new one..');\n            _storage = _createStorage(logger, gmeConfig);\n        } else {\n            logger.debug('Storage existed...');\n\n            if (forceNew === true) {\n                logger.debug('Force new set to true, will create new one.');\n                _storage = _createStorage(logger, gmeConfig);\n            }\n        }\n\n        return _storage;\n    }\n\n    return {\n        getStorage: getStorage\n    };\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true, camelcase: false*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\n(function () {\n    'use strict';\n\n    // ------- assert -------\n\n    var TASYNC_TRACE_ENABLE = true;\n\n    function setTrace(value) {\n        TASYNC_TRACE_ENABLE = value;\n    }\n\n    function assert(cond) {\n        if (!cond) {\n            throw new Error('tasync internal error');\n        }\n    }\n\n    // ------- Future -------\n\n    var STATE_LISTEN = 0;\n    var STATE_REJECTED = 1;\n    var STATE_RESOLVED = 2;\n\n    var Future = function () {\n        this.state = STATE_LISTEN;\n        this.value = [];\n    };\n\n    Future.prototype.register = function (target) {\n        assert(this.state === STATE_LISTEN);\n        assert(typeof target === 'object' && target !== null);\n\n        this.value.push(target);\n    };\n\n    Future.prototype.resolve = function (value) {\n        assert(this.state === STATE_LISTEN && !(value instanceof Future));\n\n        var listeners = this.value;\n\n        this.state = STATE_RESOLVED;\n        this.value = value;\n\n        var i;\n        for (i = 0; i < listeners.length; ++i) {\n            listeners[i].onResolved(value);\n        }\n    };\n\n    Future.prototype.reject = function (error) {\n        assert(this.state === STATE_LISTEN && error instanceof Error);\n\n        var listeners = this.value;\n\n        this.state = STATE_REJECTED;\n        this.value = error;\n\n        var i;\n        for (i = 0; i < listeners.length; ++i) {\n            listeners[i].onRejected(error);\n        }\n    };\n\n    // ------- Delay -------\n\n    function delay(timeout, value) {\n        if (timeout < 0) {\n            return value;\n        }\n\n        var future = new Future();\n        setTimeout(function () {\n            future.resolve(value);\n        }, timeout);\n        return future;\n    }\n\n    // ------- Lift -------\n\n    var FutureLift = function (array, index) {\n        Future.call(this);\n\n        this.array = array;\n        this.index = index;\n    };\n\n    FutureLift.prototype = Object.create(Future.prototype);\n\n    FutureLift.prototype.onResolved = function (value) {\n        assert(this.state === STATE_LISTEN);\n\n        var array = this.array;\n        array[this.index] = value;\n\n        while (++this.index < array.length) {\n            value = array[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    array[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        this.array = null;\n        this.resolve(array);\n    };\n\n    FutureLift.prototype.onRejected = function (error) {\n        this.array = null;\n        this.reject(error);\n    };\n\n    var lift = function (array) {\n        if (!(array instanceof Array)) {\n            throw new Error('array argument is expected');\n        }\n\n        var index;\n        for (index = 0; index < array.length; ++index) {\n            var value = array[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    array[index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    var future = new FutureLift(array, index);\n                    value.register(future);\n                    return future;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        return array;\n    };\n\n    // ------- Apply -------\n\n    var ROOT = {\n        subframes: 0\n    };\n\n    var FRAME = ROOT;\n\n    var FutureApply = function tasync_trace_end(func, that, args, index) {\n        Future.call(this);\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n        this.subframes = 0;\n\n        if (TASYNC_TRACE_ENABLE) {\n            this.trace = new Error();\n        }\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n        this.index = index;\n    };\n\n    FutureApply.prototype = Object.create(Future.prototype);\n\n    FutureApply.prototype.getPath = function () {\n        var future = this.caller,\n            path = [this.position];\n\n        while (future !== ROOT) {\n            path.push(future.position);\n            future = future.caller;\n        }\n\n        return path;\n    };\n\n    function getSlice(trace) {\n        assert(typeof trace === 'string');\n\n        var end = trace.indexOf('tasync_trace_start');\n        if (end >= 0) {\n            end = trace.lastIndexOf('\\n', end) + 1;\n        } else {\n            if (trace.charAt(trace.length - 1) !== '\\n') {\n                // trace += '\\n';\n            }\n            end = undefined;\n        }\n\n        var start = trace.indexOf('tasync_trace_end');\n        if (start >= 0) {\n            start = trace.indexOf('\\n', start) + 1;\n            if (start >= 0) {\n                start = trace.indexOf('\\n', start) + 1;\n            }\n        } else {\n            start = 0;\n        }\n\n        return trace.substring(start, end);\n    }\n\n    function createError(error, future) {\n        if (!(error instanceof Error)) {\n            error = new Error(error);\n        }\n\n        if (TASYNC_TRACE_ENABLE) {\n            error.trace = getSlice(error.stack);\n            do {\n                error.trace += '*** callback ***\\n';\n                error.trace += getSlice(future.trace.stack);\n                future = future.caller;\n            } while (future !== ROOT);\n        }\n\n        return error;\n    }\n\n    FutureApply.prototype.onRejected = function (error) {\n        this.args = null;\n        this.reject(error);\n    };\n\n    FutureApply.prototype.onResolved = function tasync_trace_start(value) {\n        assert(this.state === STATE_LISTEN);\n\n        var args = this.args;\n        args[this.index] = value;\n\n        while (--this.index >= 0) {\n            value = args[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    args[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        assert(FRAME === ROOT);\n        FRAME = this;\n\n        this.args = null;\n        try {\n            value = this.func.apply(this.that, args);\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(createError(error, this));\n            return;\n        }\n\n        FRAME = ROOT;\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n\n            this.onResolved = this.resolve;\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    var apply = function (func, args, that) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        } else if (!(args instanceof Array)) {\n            throw new Error('array argument is expected');\n        }\n\n        var index = args.length;\n        while (--index >= 0) {\n            var value = args[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_LISTEN) {\n                    var future = new FutureApply(func, that, args, index);\n                    value.register(future);\n                    return future;\n                } else if (value.state === STATE_RESOLVED) {\n                    args[index] = value.value;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        return func.apply(that, args);\n    };\n\n    // ------- Call -------\n\n    var FutureCall = function tasync_trace_end(args, index) {\n        Future.call(this);\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n        this.subframes = 0;\n\n        if (TASYNC_TRACE_ENABLE) {\n            this.trace = new Error();\n        }\n\n        this.args = args;\n        this.index = index;\n    };\n\n    FutureCall.prototype = Object.create(Future.prototype);\n\n    FutureCall.prototype.getPath = FutureApply.prototype.getPath;\n    FutureCall.prototype.onRejected = FutureApply.prototype.onRejected;\n\n    var FUNCTION_CALL = Function.call;\n\n    FutureCall.prototype.onResolved = function tasync_trace_start(value) {\n        assert(this.state === STATE_LISTEN);\n\n        var args = this.args;\n        args[this.index] = value;\n\n        while (--this.index >= 0) {\n            value = args[this.index];\n            if (value instanceof Future) {\n                if (value.state === STATE_RESOLVED) {\n                    args[this.index] = value.value;\n                } else if (value.state === STATE_LISTEN) {\n                    value.register(this);\n                    return;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    this.reject(value.value);\n                    return;\n                }\n            }\n        }\n\n        assert(FRAME === ROOT);\n        FRAME = this;\n\n        this.args = null;\n        try {\n            var func = args[0];\n            args[0] = null;\n            value = FUNCTION_CALL.apply(func, args);\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(createError(error, this));\n            return;\n        }\n\n        FRAME = ROOT;\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n\n            this.onResolved = this.resolve;\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    var call = function () {\n        var index = arguments.length;\n        while (--index >= 0) {\n            var value = arguments[index];\n            if (value instanceof Future) {\n                if (value.state === STATE_LISTEN) {\n                    var future = new FutureCall(arguments, index);\n                    value.register(future);\n                    return future;\n                } else if (value.state === STATE_RESOLVED) {\n                    arguments[index] = value.value;\n                } else {\n                    assert(value.state === STATE_REJECTED);\n                    return value;\n                }\n            }\n        }\n\n        var func = arguments[0];\n        return FUNCTION_CALL.apply(func, arguments);\n    };\n\n    // ------- TryCatch -------\n\n    function FutureTryCatch(handler) {\n        Future.call(this);\n\n        this.handler = handler;\n    }\n\n    FutureTryCatch.prototype = Object.create(Future.prototype);\n\n    FutureTryCatch.prototype.onRejected = function (error) {\n        try {\n            var value = this.handler(error);\n\n            if (value instanceof Future) {\n                this.onRejected = Future.prorotype.reject;\n                value.register(this);\n            } else {\n                this.resolve(value);\n            }\n        } catch (err) {\n            this.reject(err);\n        }\n    };\n\n    FutureTryCatch.prototype.onResolved = Future.prototype.resolve;\n\n    function trycatch(func, handler) {\n        if (typeof func !== 'function' || typeof handler !== 'function') {\n            throw new Error('function arguments are expected');\n        }\n\n        try {\n            var value = func();\n\n            if (value instanceof Future) {\n                var future = new FutureTryCatch(handler);\n                value.register(future);\n\n                return future;\n            } else {\n                return value;\n            }\n        } catch (error) {\n            return handler(error);\n        }\n    }\n\n    // ------- Wrap -------\n\n    function wrap(func) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        }\n\n        if (typeof func.tasync_wraped === 'undefined') {\n            func.tasync_wraped = function () {\n                var args = arguments;\n                var future = new Future();\n\n                args[args.length++] = function (error, value) {\n                    if (error) {\n                        future.reject(error instanceof Error ? error : new Error(error));\n                    } else {\n                        future.resolve(value);\n                    }\n                };\n\n                func.apply(this, args);\n\n                if (future.state === STATE_LISTEN) {\n                    return future;\n                } else if (future.state === STATE_RESOLVED) {\n                    return future.value;\n                } else {\n                    assert(future.state === STATE_REJECTED);\n                    throw future.value;\n                }\n            };\n\n            func.tasync_wraped.tasync_unwraped = func;\n        }\n\n        return func.tasync_wraped;\n    }\n\n    // ------- Unwrap -------\n\n    function UnwrapListener(callback) {\n        this.callback = callback;\n    }\n\n    UnwrapListener.prototype.onRejected = function (error) {\n        this.callback(error);\n    };\n\n    UnwrapListener.prototype.onResolved = function (value) {\n        this.callback(null, value);\n    };\n\n    function unwrap(func) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        }\n\n        if (typeof func.tasync_unwraped === 'undefined') {\n            func.tasync_unwraped = function () {\n                var args = arguments;\n\n                var callback = args[--args.length];\n                assert(typeof callback === 'function');\n\n                var value;\n                try {\n                    value = func.apply(this, args);\n                } catch (error) {\n                    callback(error);\n                    return;\n                }\n\n                if (value instanceof Future) {\n                    assert(value.state === STATE_LISTEN);\n\n                    var listener = new UnwrapListener(callback);\n                    value.register(listener);\n                } else {\n                    callback(null, value);\n                }\n            };\n\n            func.tasync_unwraped.tasync_wraped = func;\n        }\n\n        return func.tasync_unwraped;\n    }\n\n    // ------- Throttle -------\n\n    function FutureThrottle(func, that, args) {\n        Future.call(this);\n\n        this.func = func;\n        this.that = that;\n        this.args = args;\n\n        this.caller = FRAME;\n        this.position = ++FRAME.subframes;\n\n        this.path = this.getPath();\n    }\n\n    FutureThrottle.prototype = Object.create(Future.prototype);\n\n    FutureThrottle.prototype.execute = function () {\n        var value;\n        try {\n            assert(FRAME === ROOT);\n            FRAME = this;\n\n            value = this.func.apply(this.that, this.args);\n\n            FRAME = ROOT;\n        } catch (error) {\n            FRAME = ROOT;\n\n            this.reject(error);\n            return;\n        }\n\n        if (value instanceof Future) {\n            assert(value.state === STATE_LISTEN);\n            value.register(this);\n        } else {\n            this.resolve(value);\n        }\n    };\n\n    FutureThrottle.prototype.getPath = FutureApply.prototype.getPath;\n    FutureThrottle.prototype.onResolved = Future.prototype.resolve;\n    FutureThrottle.prototype.onRejected = Future.prototype.reject;\n\n    FutureThrottle.prototype.compare = function (second) {\n        var first = this.path;\n        second = second.path;\n\n        var i, limit = first.length < second.length ? first.length : second.length;\n        for (i = 0; i < limit; ++i) {\n            if (first[i] !== second[i]) {\n                return first[i] - second[i];\n            }\n        }\n\n        return first.length - second.length;\n    };\n\n    function ThrottleListener(limit) {\n        this.running = 0;\n        this.limit = limit;\n        this.queue = [];\n    }\n\n    function priorityQueueInsert(queue, elem) {\n        var low = 0;\n        var high = queue.length;\n\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            assert(low <= mid && mid < high);\n\n            if (elem.compare(queue[mid]) < 0) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        queue.splice(low, 0, elem);\n    }\n\n    ThrottleListener.prototype.execute = function (func, that, args) {\n        if (this.running < this.limit) {\n            var value = func.apply(that, args);\n\n            if (value instanceof Future) {\n                assert(value.state === STATE_LISTEN);\n\n                ++this.running;\n                value.register(this);\n            }\n\n            return value;\n        } else {\n            var future = new FutureThrottle(func, that, args);\n            priorityQueueInsert(this.queue, future);\n\n            return future;\n        }\n    };\n\n    ThrottleListener.prototype.onResolved = function () {\n        if (this.queue.length > 0) {\n            var future = this.queue.pop();\n            future.register(this);\n\n            future.execute();\n        } else {\n            --this.running;\n        }\n    };\n\n    ThrottleListener.prototype.onRejected = ThrottleListener.prototype.onResolved;\n\n    // TODO: prevent recursion, otheriwise throttle will not work\n    function throttle(func, limit) {\n        if (typeof func !== 'function') {\n            throw new Error('function argument is expected');\n        } else if (typeof limit !== 'number') {\n            throw new Error('number argument is expected');\n        }\n\n        var listener = new ThrottleListener(limit);\n\n        return function () {\n            return listener.execute(func, this, arguments);\n        };\n    }\n\n    // ------- Join -------\n\n    function FutureJoin(first) {\n        Future.call(this);\n\n        this.first = first;\n        this.missing = first instanceof Future && first.state === STATE_LISTEN ? 1 : 0;\n    }\n\n    FutureJoin.prototype = Object.create(Future.prototype);\n\n    FutureJoin.prototype.onResolved = function (/*value*/) {\n        if (--this.missing === 0) {\n            assert(this.state !== STATE_RESOLVED);\n\n            if (this.state === STATE_LISTEN) {\n                if (this.first instanceof Future) {\n                    assert(this.first.state === STATE_RESOLVED);\n\n                    this.resolve(this.first.value);\n                } else {\n                    this.resolve(this.first);\n                }\n            }\n        }\n    };\n\n    FutureJoin.prototype.onRejected = function (error) {\n        if (this.state === STATE_LISTEN) {\n            this.reject(error);\n        }\n    };\n\n    function join(first, second) {\n        if (first instanceof Future && first.state === STATE_REJECTED) {\n            return first;\n        } else if (second instanceof Future) {\n            if (second.state === STATE_RESOLVED) {\n                return first;\n            } else if (second.state === STATE_REJECTED) {\n                return second;\n            }\n        } else {\n            return first;\n        }\n\n        if (!(first instanceof FutureJoin)) {\n            first = new FutureJoin(first);\n        }\n\n        first.missing += 1;\n        second.register(first);\n\n        return first;\n    }\n\n    // ------- TASYNC -------\n\n    var TASYNC = {\n        setTrace: setTrace,\n        delay: delay,\n        lift: lift,\n        apply: apply,\n        call: call,\n        trycatch: trycatch,\n        wrap: wrap,\n        unwrap: unwrap,\n        throttle: throttle,\n        join: join\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('common/core/tasync',[], function () {\n            return TASYNC;\n        });\n    } else {\n        module.exports = TASYNC;\n    }\n}());\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/coretree',[\n    'common/util/assert',\n    'common/util/key',\n    'common/core/tasync'\n], function (ASSERT, GENKEY, TASYNC) {\n\n    'use strict';\n\n    var HASH_REGEXP = new RegExp('#[0-9a-f]{40}');\n    var isValidHash = function (key) {\n        return typeof key === 'string' && key.length === 41 && HASH_REGEXP.test(key);\n    };\n\n    var MAX_RELID = Math.pow(2, 31);\n    var createRelid = function (data) {\n        ASSERT(data && typeof data === 'object');\n\n        var relid;\n        do {\n            relid = Math.floor(Math.random() * MAX_RELID);\n            // relid = relid.toString();\n        } while (data[relid] !== undefined);\n\n        return '' + relid;\n    };\n\n    // make relids deterministic\n    if (false) {\n        var nextRelid = 0;\n        createRelid = function (data) {\n            ASSERT(data && typeof data === 'object');\n\n            var relid;\n            do {\n                relid = (nextRelid += -1);\n            } while (data[relid] !== undefined);\n\n            return '' + relid;\n        };\n    }\n\n    var rootCounter = 0;\n\n    return function (storage, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n\n        var gmeConfig = options.globConf,\n            logger = options.logger.fork('coretree'),\n            MAX_AGE = 3, // MAGIC NUMBER\n            MAX_TICKS = 2000, // MAGIC NUMBER\n            MAX_MUTATE = 30000, // MAGIC NUMBER\n\n            ID_NAME = storage.ID_NAME,\n            __getEmptyData = function () {\n                return {};\n            },\n            roots = [],\n            ticks = 0,\n            stackedObjects = {};\n\n        storage.loadObject = TASYNC.wrap(storage.loadObject);\n\n        // ------- static methods\n\n        var getParent = function (node) {\n            ASSERT(typeof node.parent === 'object');\n\n            return node.parent;\n        };\n\n        var getRelid = function (node) {\n            ASSERT(node.relid === null || typeof node.relid === 'string');\n\n            return node.relid;\n        };\n\n        var getLevel = function (node) {\n            var level = 0;\n            while (node.parent !== null) {\n                ++level;\n                node = node.parent;\n            }\n            return level;\n        };\n\n        var getRoot = function (node) {\n            while (node.parent !== null) {\n                node = node.parent;\n            }\n            return node;\n        };\n\n        var getPath = function (node, base) {\n            if (node === null) {\n                return null;\n            }\n\n            var path = '';\n            while (node.relid !== null && node !== base) {\n                path = '/' + node.relid + path;\n                node = node.parent;\n            }\n            return path;\n        };\n\n        var isValidPath = function (path) {\n            return typeof path === 'string' && (path === '' || path.charAt(0) === '/');\n        };\n\n        var splitPath = function (path) {\n            ASSERT(isValidPath(path));\n\n            path = path.split('/');\n            path.splice(0, 1);\n\n            return path;\n        };\n\n        var buildPath = function (path) {\n            ASSERT(path instanceof Array);\n\n            return path.length === 0 ? '' : '/' + path.join('/');\n        };\n\n        var joinPaths = function (first, second) {\n            ASSERT(isValidPath(first) && isValidPath(second));\n\n            return first + second;\n        };\n\n        var getCommonPathPrefixData = function (first, second) {\n            ASSERT(typeof first === 'string' && typeof second === 'string');\n\n            first = splitPath(first);\n            second = splitPath(second);\n\n            var common = [];\n            for (var i = 0; first[i] === second[i] && i < first.length; ++i) {\n                common.push(first[i]);\n            }\n\n            return {\n                common: buildPath(common),\n                first: buildPath(first.slice(i)),\n                firstLength: first.length - i,\n                second: buildPath(second.slice(i)),\n                secondLength: second.length - i\n            };\n        };\n\n        // ------- memory management\n\n        var __detachChildren = function (node) {\n            ASSERT(node.children instanceof Array && node.age >= MAX_AGE - 1);\n\n            var children = node.children;\n            node.children = null;\n            node.age = MAX_AGE;\n\n            for (var i = 0; i < children.length; ++i) {\n                __detachChildren(children[i]);\n            }\n        };\n\n        var __ageNodes = function (nodes) {\n            ASSERT(nodes instanceof Array);\n\n            var i = nodes.length;\n            while (--i >= 0) {\n                var node = nodes[i];\n\n                ASSERT(node.age < MAX_AGE);\n                if (++node.age >= MAX_AGE) {\n                    nodes.splice(i, 1);\n                    __detachChildren(node);\n                } else {\n                    __ageNodes(node.children);\n                }\n            }\n        };\n\n        var __ageRoots = function () {\n            if (++ticks >= MAX_TICKS) {\n                ticks = 0;\n                __ageNodes(roots);\n            }\n        };\n\n        var __getChildNode = function (children, relid) {\n            ASSERT(children instanceof Array && typeof relid === 'string');\n\n            for (var i = 0; i < children.length; ++i) {\n                var child = children[i];\n                if (child.relid === relid) {\n                    ASSERT(child.parent.age === 0);\n\n                    child.age = 0;\n                    return child;\n                }\n            }\n\n            return null;\n        };\n\n        var __getChildData = function (data, relid) {\n            ASSERT(typeof relid === 'string');\n\n            if (typeof data === 'object' && data !== null) {\n                data = data[relid];\n                return typeof data === 'undefined' ? __getEmptyData() : data;\n            } else {\n                return null;\n            }\n        };\n\n        var normalize = function (node) {\n            ASSERT(isValidNode(node));\n            // console.log('normalize start', printNode(getRoot(node)));\n\n            var parent;\n\n            if (node.children === null) {\n                ASSERT(node.age === MAX_AGE);\n\n                if (node.parent !== null) {\n                    parent = normalize(node.parent);\n\n                    var temp = __getChildNode(parent.children, node.relid);\n                    if (temp !== null) {\n                        // TODO: make the current node close to the returned one\n\n                        // console.log('normalize end1',\n                        // printNode(getRoot(temp)));\n                        return temp;\n                    }\n\n                    ASSERT(node.parent.children === null || __getChildNode(node.parent.children, node.relid) === null);\n                    ASSERT(__getChildNode(parent.children, node.relid) === null);\n\n                    node.parent = parent;\n                    parent.children.push(node);\n\n                    temp = __getChildData(parent.data, node.relid);\n                    if (!isValidHash(temp) || temp !== __getChildData(node.data, ID_NAME)) {\n                        node.data = temp;\n                    }\n                } else {\n                    roots.push(node);\n                }\n\n                node.age = 0;\n                node.children = [];\n            } else if (node.age !== 0) {\n                parent = node;\n                do {\n                    parent.age = 0;\n                    parent = parent.parent;\n                } while (parent !== null && parent.age !== 0);\n            }\n\n            // console.log('normalize end2', printNode(getRoot(node)));\n            return node;\n        };\n\n        // ------- hierarchy\n\n        var getAncestor = function (first, second) {\n            ASSERT(getRoot(first) === getRoot(second));\n\n            first = normalize(first);\n            second = normalize(second);\n\n            var a = [];\n            do {\n                a.push(first);\n                first = first.parent;\n            } while (first !== null);\n\n            var b = [];\n            do {\n                b.push(second);\n                second = second.parent;\n            } while (second !== null);\n\n            var i = a.length - 1;\n            var j = b.length - 1;\n            while (i !== 0 && j !== 0 && a[i - 1] === b[j - 1]) {\n                --i;\n                --j;\n            }\n\n            ASSERT(a[i] === b[j]);\n            return a[i];\n        };\n\n        var isAncestor = function (node, ancestor) {\n            ASSERT(getRoot(node) === getRoot(ancestor));\n\n            node = normalize(node);\n            ancestor = normalize(ancestor);\n\n            do {\n                if (node === ancestor) {\n                    return true;\n                }\n\n                node = node.parent;\n            } while (node !== null);\n\n            return false;\n        };\n\n        var createRoot = function () {\n            var root = {\n                parent: null,\n                relid: null,\n                age: 0,\n                children: [],\n                data: {\n                    _mutable: true\n                },\n                rootid: ++rootCounter\n            };\n            root.data[ID_NAME] = '';\n            roots.push(root);\n\n            __ageRoots();\n            return root;\n        };\n\n        var getChild = function (node, relid) {\n            ASSERT(typeof relid === 'string' && relid !== ID_NAME);\n\n            node = normalize(node);\n\n            var child = __getChildNode(node.children, relid);\n            if (child !== null) {\n                return child;\n            }\n\n            child = {\n                parent: node,\n                relid: relid,\n                age: 0,\n                children: [],\n                data: __getChildData(node.data, relid)\n            };\n            node.children.push(child);\n\n            __ageRoots();\n            return child;\n        };\n\n        var createChild = function (node) {\n            node = normalize(node);\n\n            if (typeof node.data !== 'object' || node.data === null) {\n                throw new Error('invalid node data');\n            }\n\n            var relid = createRelid(node.data);\n            var child = {\n                parent: node,\n                relid: relid,\n                age: 0,\n                children: [],\n                data: __getEmptyData()\n            };\n\n            // TODO: make sure that it is not on the list\n            node.children.push(child);\n\n            __ageRoots();\n            return child;\n        };\n\n        var getDescendant = function (node, head, base) {\n            ASSERT(typeof base === 'undefined' || isAncestor(head, base));\n\n            node = normalize(node);\n            head = normalize(head);\n            base = typeof base === 'undefined' ? null : normalize(base.parent);\n\n            var path = [];\n            while (head.parent !== base) {\n                path.push(head.relid);\n                head = head.parent;\n            }\n\n            var i = path.length;\n            while (--i >= 0) {\n                node = getChild(node, path[i]);\n            }\n\n            return node;\n        };\n\n        var getDescendantByPath = function (node, path) {\n            ASSERT(path === '' || path.charAt(0) === '/');\n\n            path = path.split('/');\n\n            for (var i = 1; i < path.length; ++i) {\n                node = getChild(node, path[i]);\n            }\n\n            return node;\n        };\n\n        // ------- data manipulation\n\n        var __isMutableData = function (data) {\n            return typeof data === 'object' && data !== null && data._mutable === true;\n        };\n\n        var isMutable = function (node) {\n            node = normalize(node);\n            return __isMutableData(node.data);\n        };\n\n        var isObject = function (node) {\n            node = normalize(node);\n            return typeof node.data === 'object' && node.data !== null;\n        };\n\n        var isEmpty = function (node) {\n            node = normalize(node);\n            if (typeof node.data !== 'object' || node.data === null) {\n                return false;\n            } else if (node.data === __getEmptyData()) {\n                return true;\n            }\n\n            return __isEmptyData(node.data);\n        };\n\n        var __isEmptyData = function (data) {\n            // TODO: better way to check if object has keys?\n            for (var keys in data) {\n                return false;\n            }\n            return true;\n        };\n\n        var __areEquivalent = function (data1, data2) {\n            return data1 === data2 || (typeof data1 === 'string' && data1 === __getChildData(data2, ID_NAME)) ||\n                (__isEmptyData(data1) && __isEmptyData(data2));\n        };\n\n        var mutateCount = 0;\n        var mutate = function (node) {\n            ASSERT(isValidNode(node));\n\n            node = normalize(node);\n            var data = node.data;\n\n            if (typeof data !== 'object' || data === null) {\n                return false;\n            } else if (data._mutable === true) {\n                return true;\n            }\n\n            // TODO: infinite cycle if MAX_MUTATE is smaller than depth!\n            if (gmeConfig.storage.autoPersist && ++mutateCount > MAX_MUTATE) {\n                mutateCount = 0;\n\n                for (var i = 0; i < roots.length; ++i) {\n                    if (__isMutableData(roots[i].data)) {\n                        __saveData(roots[i].data);\n                    }\n                }\n            }\n\n            if (node.parent !== null && !mutate(node.parent)) {\n                // this should never happen\n                return false;\n            }\n\n            var copy = {\n                _mutable: true\n            };\n\n            for (var key in data) {\n                copy[key] = data[key];\n            }\n\n            ASSERT(copy._mutable === true);\n\n            if (typeof data[ID_NAME] === 'string') {\n                copy[ID_NAME] = '';\n            }\n\n            if (node.parent !== null) {\n                ASSERT(__areEquivalent(__getChildData(node.parent.data, node.relid), node.data));\n                node.parent.data[node.relid] = copy;\n            }\n\n            node.data = copy;\n            return true;\n        };\n\n        var getData = function (node) {\n            node = normalize(node);\n\n            ASSERT(!__isMutableData(node.data));\n            return node.data;\n        };\n\n        var __reloadChildrenData = function (node) {\n            for (var i = 0; i < node.children.length; ++i) {\n                var child = node.children[i];\n\n                var data = __getChildData(node.data, child.relid);\n                if (!isValidHash(data) || data !== __getChildData(child.data, ID_NAME)) {\n                    child.data = data;\n                    __reloadChildrenData(child);\n                }\n            }\n        };\n\n        var setData = function (node, data) {\n            ASSERT(data !== null && typeof data !== 'undefined');\n\n            node = normalize(node);\n            if (node.parent !== null) {\n                if (!mutate(node.parent)) {\n                    throw new Error('incorrect node data');\n                }\n\n                node.parent.data[node.relid] = data;\n            }\n\n            node.data = data;\n            __reloadChildrenData(node);\n        };\n\n        var deleteData = function (node) {\n            node = normalize(node);\n\n            if (node.parent !== null) {\n                if (!mutate(node.parent)) {\n                    throw new Error('incorrect node data');\n                }\n\n                delete node.parent.data[node.relid];\n            }\n\n            var data = node.data;\n\n            node.data = __getEmptyData();\n            __reloadChildrenData(node);\n\n            return data;\n        };\n\n        var copyData = function (node) {\n            node = normalize(node);\n\n            if (typeof node.data !== 'object' || node.data === null) {\n                return node.data;\n            }\n\n            // TODO: return immutable data without coping\n            return JSON.parse(JSON.stringify(node.data));\n        };\n\n        var getProperty = function (node, name) {\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\n\n            var data;\n            node = normalize(node);\n\n            if (typeof node.data === 'object' && node.data !== null) {\n                data = node.data[name];\n            }\n\n            // TODO: corerel uses getProperty to get the overlay content which can get mutable\n            // ASSERT(!__isMutableData(data));\n            return data;\n        };\n\n        var setProperty = function (node, name, data) {\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\n            ASSERT(!__isMutableData(data) /*&& data !== null*/ && data !== undefined);\n            //TODO is the 'null' really can be a value of a property???\n\n            node = normalize(node);\n            if (!mutate(node)) {\n                throw new Error('incorrect node data');\n            }\n\n            node.data[name] = data;\n\n            var child = __getChildNode(node.children, name);\n            if (child !== null) {\n                child.data = data;\n                __reloadChildrenData(child);\n            }\n        };\n\n        var deleteProperty = function (node, name) {\n            ASSERT(typeof name === 'string' && name !== ID_NAME);\n\n            node = normalize(node);\n            if (!mutate(node)) {\n                throw new Error('incorrect node data');\n            }\n\n            delete node.data[name];\n\n            var child = __getChildNode(node.children, name);\n            if (child !== null) {\n                child.data = __getEmptyData();\n                __reloadChildrenData(child);\n            }\n        };\n\n        var noUnderscore = function (relid) {\n            ASSERT(typeof relid === 'string');\n            return relid.charAt(0) !== '_';\n        };\n\n        var getKeys = function (node, predicate) {\n            ASSERT(typeof predicate === 'undefined' || typeof predicate === 'function');\n\n            node = normalize(node);\n            predicate = predicate || noUnderscore;\n\n            if (typeof node.data !== 'object' || node.data === null) {\n                return null;\n            }\n\n            var keys = Object.keys(node.data);\n\n            var i = keys.length;\n            while (--i >= 0 && !predicate(keys[i])) {\n                keys.pop();\n            }\n\n            while (--i >= 0) {\n                if (!predicate(keys[i])) {\n                    keys[i] = keys.pop();\n                }\n            }\n\n            return keys;\n        };\n\n        var getRawKeys = function (object, predicate) {\n            ASSERT(typeof predicate === 'undefined' || typeof predicate === 'function');\n            predicate = predicate || noUnderscore;\n\n            var keys = Object.keys(object);\n\n            var i = keys.length;\n            while (--i >= 0 && !predicate(keys[i])) {\n                keys.pop();\n            }\n\n            while (--i >= 0) {\n                if (!predicate(keys[i])) {\n                    keys[i] = keys.pop();\n                }\n            }\n\n            return keys;\n        };\n\n        // ------- persistence\n\n        var getHash = function (node) {\n            if (node === null) {\n                return null;\n            }\n\n            var hash;\n            node = normalize(node);\n            if (typeof node.data === 'object' && node.data !== null) {\n                hash = node.data[ID_NAME];\n            }\n\n            ASSERT(typeof hash === 'string' || typeof hash === 'undefined');\n            return hash;\n        };\n\n        var isHashed = function (node) {\n            node = normalize(node);\n            return typeof node.data === 'object' && node.data !== null && typeof node.data[ID_NAME] === 'string';\n        };\n\n        var setHashed = function (node, hashed, noMutate) {\n            ASSERT(typeof hashed === 'boolean');\n\n            node = normalize(node);\n            if (!noMutate) {\n                if (!mutate(node)) {\n                    throw new Error('incorrect node data');\n                }\n            }\n\n            if (hashed) {\n                node.data[ID_NAME] = '';\n            } else {\n                delete node.data[ID_NAME];\n            }\n\n            ASSERT(typeof node.children[ID_NAME] === 'undefined');\n        };\n\n        var __saveData = function (data) {\n            ASSERT(__isMutableData(data));\n\n            var done = __getEmptyData(),\n                keys = Object.keys(data),\n                i, child, sub, hash;\n\n            delete data._mutable;\n\n            for (i = 0; i < keys.length; i++) {\n                child = data[keys[i]];\n                if (__isMutableData(child)) {\n                    sub = __saveData(child);\n                    if (sub === __getEmptyData()) {\n                        delete data[keys[i]];\n                    } else {\n                        done = sub;\n                        if (typeof child[ID_NAME] === 'string') {\n                            data[keys[i]] = child[ID_NAME];\n                        }\n                    }\n                } else {\n                    done = undefined;\n                }\n            }\n\n\n            if (done !== __getEmptyData()) {\n                hash = data[ID_NAME];\n                ASSERT(hash === '' || typeof hash === 'undefined');\n\n                if (hash === '') {\n                    hash = '#' + GENKEY(data, gmeConfig);\n                    data[ID_NAME] = hash;\n\n                    done = data;\n                    storage.insertObject(data, stackedObjects);\n                    //stackedObjects[hash] = data;\n                }\n            }\n\n            return done;\n        };\n\n        var persist = function (node) {\n            var updated = false,\n                result;\n\n            node = normalize(node);\n\n            if (!__isMutableData(node.data)) {\n                return {rootHash: node.data[ID_NAME], objects: {}};\n            }\n\n            updated = __saveData(node.data);\n            if (updated !== __getEmptyData()) {\n                result = {};\n                result.objects = stackedObjects;\n                stackedObjects = {};\n                result.rootHash = node.data[ID_NAME];\n            } else {\n                result = {rootHash: node.data[ID_NAME], objects: {}};\n            }\n\n            return result;\n        };\n\n        var loadRoot = function (hash) {\n            ASSERT(isValidHash(hash));\n\n            return TASYNC.call(__loadRoot2, storage.loadObject(hash));\n        };\n\n        var __loadRoot2 = function (data) {\n            var root = {\n                parent: null,\n                relid: null,\n                age: 0,\n                children: [],\n                data: data,\n                rootid: ++rootCounter\n            };\n            roots.push(root);\n\n            __ageRoots();\n            return root;\n        };\n\n        var loadChild = function (node, relid) {\n            ASSERT(isValidNode(node));\n\n            node = getChild(node, relid);\n\n            if (isValidHash(node.data)) {\n                // TODO: this is a hack, we should avoid loading it multiple\n                // times\n                return TASYNC.call(__loadChild2, node, storage.loadObject(node.data));\n            } else {\n                return typeof node.data === 'object' && node.data !== null ? node : null;\n            }\n        };\n\n        var getChildHash = function (node, relid) {\n            ASSERT(isValidNode(node));\n\n            node = getChild(node, relid);\n\n            if (isValidHash(node.data)) {\n                // TODO: this is a hack, we should avoid loading it multiple\n                // times\n                return node.data;\n            } else {\n                return typeof node.data === 'object' && node.data !== null ? getHash(node) : null;\n            }\n        };\n\n\n        var __loadChild2 = function (node, newdata) {\n            node = normalize(node);\n\n            // TODO: this is a hack, we should avoid loading it multiple times\n            if (isValidHash(node.data)) {\n                ASSERT(node.data === newdata[ID_NAME]);\n\n                node.data = newdata;\n                __reloadChildrenData(node);\n            } else {\n                // TODO: if this bites you, use the Cache\n                /*if(node.data !== newdata){\n                 console.log('kecso',node);\n                 }\n                 ASSERT(node.data === newdata);*/\n            }\n\n            return node;\n        };\n\n        var loadByPath = function (node, path) {\n            ASSERT(isValidNode(node));\n            ASSERT(path === '' || path.charAt(0) === '/');\n\n            path = path.split('/');\n            return __loadDescendantByPath2(node, path, 1);\n        };\n\n        var __loadDescendantByPath2 = function (node, path, index) {\n            if (node === null || index === path.length) {\n                return node;\n            }\n\n            var child = loadChild(node, path[index]);\n            return TASYNC.call(__loadDescendantByPath2, child, path, index + 1);\n        };\n\n        // ------- valid -------\n\n        var printNode = function (node) {\n            var str = '{';\n            str += 'age:' + node.age;\n\n            if (typeof node.relid === 'string') {\n                str += ', relid: \"' + node.relid + '\"';\n            }\n\n            str += ', children:';\n            if (node.children === null) {\n                str += 'null';\n            } else {\n                str += '[';\n                for (var i = 0; i < node.children.length; ++i) {\n                    if (i !== 0) {\n                        str += ', ';\n                    }\n                    str += printNode(node.children[i]);\n                }\n                str += ']';\n            }\n\n            str += '}';\n            return str;\n        };\n\n        var __test = function (text, cond) {\n            if (!cond) {\n                throw new Error(text);\n            }\n        };\n\n        var checkValidTree = function (node) {\n            if (isValidNode(node)) {\n                if (node.children instanceof Array) {\n                    for (var i = 0; i < node.children.length; ++i) {\n                        checkValidTree(node.children[i]);\n                    }\n                }\n            }\n        };\n\n        // disable checking for now\n        var checkValidTreeRunning = true;\n\n        var isValidNode = function (node) {\n            try {\n                __test('object', typeof node === 'object' && node !== null);\n                __test('object 2', node.hasOwnProperty('parent') && node.hasOwnProperty('relid'));\n                __test('parent', typeof node.parent === 'object');\n                __test('relid', typeof node.relid === 'string' || node.relid === null);\n                __test('parent 2', (node.parent === null) === (node.relid === null));\n                __test('age', node.age >= 0 && node.age <= MAX_AGE);\n                __test('children', node.children === null || node.children instanceof Array);\n                __test('children 2', (node.age === MAX_AGE) === (node.children === null));\n                __test('data', typeof node.data === 'object' || typeof node.data === 'string' ||\n                    typeof node.data === 'number');\n\n                if (node.parent !== null) {\n                    __test('age 2', node.age >= node.parent.age);\n                    __test('mutable', !__isMutableData(node.data) || __isMutableData(node.parent.data));\n                }\n\n                if (!checkValidTreeRunning) {\n                    checkValidTreeRunning = true;\n                    checkValidTree(getRoot(node));\n                    checkValidTreeRunning = false;\n                }\n\n                return true;\n            } catch (error) {\n                logger.error(error.message, {stack: error.stack, node: node});\n                return false;\n            }\n        };\n\n        return {\n            getParent: getParent,\n            getRelid: getRelid,\n            getLevel: getLevel,\n            getRoot: getRoot,\n            getPath: getPath,\n            isValidPath: isValidPath,\n            splitPath: splitPath,\n            buildPath: buildPath,\n            joinPaths: joinPaths,\n            getCommonPathPrefixData: getCommonPathPrefixData,\n\n            normalize: normalize,\n            getAncestor: getAncestor,\n            isAncestor: isAncestor,\n            createRoot: createRoot,\n            createChild: createChild,\n            getChild: getChild,\n            getDescendant: getDescendant,\n            getDescendantByPath: getDescendantByPath,\n\n            isMutable: isMutable,\n            isObject: isObject,\n            isEmpty: isEmpty,\n            mutate: mutate,\n            getData: getData,\n            setData: setData,\n            deleteData: deleteData,\n            copyData: copyData,\n            getProperty: getProperty,\n            setProperty: setProperty,\n            deleteProperty: deleteProperty,\n            getKeys: getKeys,\n            getRawKeys: getRawKeys,\n\n            isHashed: isHashed,\n            setHashed: setHashed,\n            getHash: getHash,\n            persist: persist,\n            loadRoot: loadRoot,\n            loadChild: loadChild,\n            loadByPath: loadByPath,\n\n            isValidNode: isValidNode,\n\n            getChildHash: getChildHash\n        };\n    };\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/corerel',['common/util/assert', 'common/core/coretree', 'common/core/tasync'], function (ASSERT, CoreTree, TASYNC) {\n\n    'use strict';\n\n    // ----------------- RELID -----------------\n\n    var ATTRIBUTES = 'atr';\n    var REGISTRY = 'reg';\n    var OVERLAYS = 'ovr';\n    var COLLSUFFIX = '-inv';\n\n    function isPointerName(name) {\n        ASSERT(typeof name === 'string');\n        //TODO this is needed as now we work with modified data as well\n        if (name === '_mutable') {\n            return false;\n        }\n        return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\n    }\n\n    function isValidRelid(relid) {\n        return typeof relid === 'string' && parseInt(relid, 10).toString() === relid;\n    }\n\n    function __test(text, cond) {\n        if (!cond) {\n            throw new Error(text);\n        }\n    }\n\n    // ----------------- Core -----------------\n\n    function CoreRel(coretree, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        ASSERT(typeof coretree === 'object');\n\n        var logger = options.logger.fork('corerel');\n\n        logger.debug('initialized');\n\n        function isValidNode(node) {\n            try {\n                __test('coretree', coretree.isValidNode(node));\n                __test('isobject', coretree.isObject(node));\n\n                return true;\n            } catch (error) {\n                logger.error(error.message, {metadata: {stack: error.stack, node: node}});\n                return false;\n            }\n        }\n\n        function getAttributeNames(node) {\n            ASSERT(isValidNode(node));\n\n            node = (coretree.getProperty(node, ATTRIBUTES) || {});\n            var keys = coretree.getRawKeys(node);\n            var i = keys.length;\n            while (--i >= 0) {\n                if (keys[i].charAt(0) === '') {\n                    console.log('***** This happens?');\n                    keys.splice(i, 1);\n                }\n            }\n\n            return keys;\n        }\n\n        function getRegistryNames(node) {\n            ASSERT(isValidNode(node));\n\n            node = (coretree.getProperty(node, REGISTRY) || {});\n            var keys = coretree.getRawKeys(node);\n            var i = keys.length;\n            while (--i >= 0) {\n                if (keys[i].charAt(0) === '') {\n                    console.log('***** This happens?');\n                    keys.splice(i, 1);\n                }\n            }\n\n            return keys;\n        }\n\n        function getAttribute(node, name) {\n            /*node = coretree.getChild(node, ATTRIBUTES);\n             return coretree.getProperty(node, name);*/\n            return (coretree.getProperty(node, ATTRIBUTES) || {})[name];\n        }\n\n        function delAttribute(node, name) {\n            node = coretree.getChild(node, ATTRIBUTES);\n            coretree.deleteProperty(node, name);\n        }\n\n        function setAttribute(node, name, value) {\n            node = coretree.getChild(node, ATTRIBUTES);\n            coretree.setProperty(node, name, value);\n        }\n\n        function getRegistry(node, name) {\n            /*node = coretree.getChild(node, REGISTRY);\n             return coretree.getProperty(node, name);*/\n            return (coretree.getProperty(node, REGISTRY) || {})[name];\n        }\n\n        function delRegistry(node, name) {\n            node = coretree.getChild(node, REGISTRY);\n            coretree.deleteProperty(node, name);\n        }\n\n        function setRegistry(node, name, value) {\n            node = coretree.getChild(node, REGISTRY);\n            coretree.setProperty(node, name, value);\n        }\n\n        function overlayInsert(overlays, source, name, target) {\n            ASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\n            ASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\n            ASSERT(coretree.getCommonPathPrefixData(source, target).common === '');\n\n            // console.log('insert', overlays.parent.data.atr.name, source, name, target);\n\n            var node = coretree.getChild(overlays, source);\n\n            ASSERT(coretree.getProperty(node, name) === undefined);\n            coretree.setProperty(node, name, target);\n\n            node = coretree.getChild(overlays, target);\n            name = name + COLLSUFFIX;\n\n            var array = coretree.getProperty(node, name);\n            if (array) {\n                ASSERT(array.indexOf(source) < 0);\n\n                array = array.slice(0);\n                array.push(source);\n            } else {\n                array = [source];\n            }\n\n            coretree.setProperty(node, name, array);\n        }\n\n        function overlayRemove(overlays, source, name, target) {\n            ASSERT(isValidNode(overlays) && coretree.getRelid(overlays) === OVERLAYS);\n            ASSERT(coretree.isValidPath(source) && coretree.isValidPath(target) && isPointerName(name));\n            ASSERT(coretree.getCommonPathPrefixData(source, target).common === '');\n\n            // console.log('remove', overlays.parent.data.atr.name, source, name, target);\n\n            var node = coretree.getChild(overlays, source);\n            ASSERT(node && coretree.getProperty(node, name) === target);\n            coretree.deleteProperty(node, name);\n\n            if (coretree.getKeys(node).length === 0) {\n                coretree.deleteProperty(overlays, source);\n            }\n\n            node = coretree.getChild(overlays, target);\n            ASSERT(node);\n\n            name = name + COLLSUFFIX;\n\n            var array = coretree.getProperty(node, name);\n            ASSERT(Array.isArray(array) && array.length >= 1);\n\n            if (array.length === 1) {\n                ASSERT(array[0] === source);\n\n                coretree.deleteProperty(node, name);\n            } else {\n                var index = array.indexOf(source);\n                ASSERT(index >= 0);\n\n                array = array.slice(0);\n                array.splice(index, 1);\n\n                coretree.setProperty(node, name, array);\n            }\n\n            if (coretree.getKeys(node).length === 0) {\n                coretree.deleteProperty(overlays, target);\n            }\n        }\n\n        function overlayQuery(overlays, prefix) {\n            ASSERT(isValidNode(overlays) && coretree.isValidPath(prefix));\n\n            var prefix2 = prefix + '/';\n            var list = [];\n            var paths = coretree.getKeys(overlays);\n\n            for (var i = 0; i < paths.length; ++i) {\n                var path = paths[i];\n                if (path === prefix || path.substr(0, prefix2.length) === prefix2) {\n                    var node = coretree.getChild(overlays, path);\n                    var names = coretree.getKeys(node);\n\n                    for (var j = 0; j < names.length; ++j) {\n                        var name = names[j];\n                        if (isPointerName(name)) {\n                            list.push({\n                                s: path,\n                                n: name,\n                                t: coretree.getProperty(node, name),\n                                p: true\n                            });\n                        } else {\n                            var array = coretree.getProperty(node, name);\n                            ASSERT(Array.isArray(array));\n                            name = name.slice(0, -COLLSUFFIX.length);\n                            for (var k = 0; k < array.length; ++k) {\n                                list.push({\n                                    s: array[k],\n                                    n: name,\n                                    t: path,\n                                    p: false\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n\n            // console.log('query', overlays.parent.data.atr.name, prefix, list);\n\n            return list;\n        }\n\n        function createNode(parameters) {\n            parameters = parameters || {};\n            var relid = parameters.relid,\n                parent = parameters.parent;\n\n            ASSERT(!parent || isValidNode(parent));\n            ASSERT(!relid || typeof relid === 'string');\n\n            var node;\n            if (parent) {\n                if (relid) {\n                    node = coretree.getChild(parent, relid);\n                } else {\n                    node = coretree.createChild(parent);\n                }\n                coretree.setHashed(node, true);\n            } else {\n                node = coretree.createRoot();\n            }\n\n            return node;\n        }\n\n        function deleteNode(node) {\n            ASSERT(isValidNode(node));\n\n            var parent = coretree.getParent(node);\n            var prefix = '/' + coretree.getRelid(node);\n            ASSERT(parent !== null);\n\n            coretree.deleteProperty(parent, coretree.getRelid(node));\n\n            while (parent) {\n                var overlays = coretree.getChild(parent, OVERLAYS);\n\n                var list = overlayQuery(overlays, prefix);\n                for (var i = 0; i < list.length; ++i) {\n                    var entry = list[i];\n                    overlayRemove(overlays, entry.s, entry.n, entry.t);\n                }\n\n                prefix = '/' + coretree.getRelid(parent) + prefix;\n                parent = coretree.getParent(parent);\n            }\n        }\n\n        function copyNode(node, parent) {\n            ASSERT(isValidNode(node));\n            ASSERT(!parent || isValidNode(parent));\n\n            node = coretree.normalize(node);\n            var newNode;\n\n            if (parent) {\n                var ancestor = coretree.getAncestor(node, parent);\n\n                // cannot copy inside of itself\n                if (ancestor === node) {\n                    return null;\n                }\n\n                newNode = coretree.createChild(parent);\n                coretree.setHashed(newNode, true);\n                coretree.setData(newNode, coretree.copyData(node));\n\n                var ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\n                var ancestorNewPath = coretree.getPath(newNode, ancestor);\n\n                var base = coretree.getParent(node);\n                var baseOldPath = '/' + coretree.getRelid(node);\n                var aboveAncestor = 1;\n\n                while (base) {\n                    var baseOverlays = coretree.getChild(base, OVERLAYS);\n                    var list = overlayQuery(baseOverlays, baseOldPath);\n                    var tempAncestor = coretree.getAncestor(base, ancestor);\n\n                    aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\n\n                    var relativePath = aboveAncestor < 0 ?\n                        coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\n\n                    for (var i = 0; i < list.length; ++i) {\n                        var entry = list[i];\n\n                        if (entry.p) {\n                            ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n                            ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');\n\n                            var source, target, overlays;\n\n                            if (aboveAncestor < 0) {\n                                //below ancestor node - further from root\n                                source = ancestorNewPath + entry.s.substr(baseOldPath.length);\n                                target = coretree.joinPaths(relativePath, entry.t);\n                                overlays = ancestorOverlays;\n                            } else if (aboveAncestor === 0) {\n                                //at ancestor node\n                                var data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\n\n                                overlays = newNode;\n                                while (data.firstLength-- > 0) {\n                                    overlays = coretree.getParent(overlays);\n                                }\n                                overlays = coretree.getChild(overlays, OVERLAYS);\n\n                                source = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\n                                target = data.second;\n                            } else {\n                                //above ancestor node - closer to root\n                                ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n\n                                source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\n                                target = entry.t;\n                                overlays = baseOverlays;\n                            }\n\n                            overlayInsert(overlays, source, entry.n, target);\n                        }\n                    }\n\n                    baseOldPath = '/' + coretree.getRelid(base) + baseOldPath;\n                    base = coretree.getParent(base);\n                }\n            } else {\n                newNode = coretree.createRoot();\n                coretree.setData(newNode, coretree.copyData(node));\n            }\n\n            return newNode;\n        }\n\n        //kecso\n        function copyNodes(nodes, parent) {\n            //copying multiple nodes at once for keeping their internal relations\n            var paths = [],\n                i, j, index, names, pointer,\n                copiedNodes = [],\n                internalRelationPaths = []; // Every single element will be an object with the\n                                            // internally pointing relations and the index of the target.\n\n            for (i = 0; i < nodes.length; i++) {\n                paths.push(coretree.getPath(nodes[i]));\n            }\n\n            for (i = 0; i < nodes.length; i++) {\n                names = getPointerNames(nodes[i]);\n                pointer = {};\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(getPointerPath(nodes[i], names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                internalRelationPaths.push(pointer);\n            }\n\n            //now we use our simple copy\n            for (i = 0; i < nodes.length; i++) {\n                copiedNodes.push(copyNode(nodes[i], parent));\n            }\n\n            //and now back to the relations\n            for (i = 0; i < internalRelationPaths.length; i++) {\n                names = Object.keys(internalRelationPaths[i]);\n                for (j = 0; j < names.length; j++) {\n                    setPointer(copiedNodes[i], names[j], copiedNodes[internalRelationPaths[i][names[j]]]);\n                }\n            }\n\n            return copiedNodes;\n        }\n\n        function moveNode(node, parent) {\n            ASSERT(isValidNode(node) && isValidNode(parent));\n\n            node = coretree.normalize(node);\n            var ancestor = coretree.getAncestor(node, parent);\n\n            // cannot move inside of itself\n            if (ancestor === node) {\n                return null;\n            }\n\n            var base = coretree.getParent(node);\n            var baseOldPath = '/' + coretree.getRelid(node);\n            var aboveAncestor = 1;\n\n            var oldNode = node;\n            node = coretree.getChild(parent, coretree.getRelid(oldNode));\n            if (!coretree.isEmpty(node)) {\n                // we have to change the relid of the node, to fit into its new\n                // place...\n                node = coretree.createChild(parent);\n            }\n            coretree.setHashed(node, true);\n            coretree.setData(node, coretree.copyData(oldNode));\n\n            var ancestorOverlays = coretree.getChild(ancestor, OVERLAYS);\n            var ancestorNewPath = coretree.getPath(node, ancestor);\n\n            while (base) {\n                var baseOverlays = coretree.getChild(base, OVERLAYS);\n                var list = overlayQuery(baseOverlays, baseOldPath);\n                var tempAncestor = coretree.getAncestor(base, ancestor);\n\n                aboveAncestor = (base === ancestor ? 0 : tempAncestor === base ? 1 : -1);\n\n                var relativePath = aboveAncestor < 0 ?\n                    coretree.getPath(base, ancestor) : coretree.getPath(ancestor, base);\n\n                for (var i = 0; i < list.length; ++i) {\n                    var entry = list[i];\n\n                    overlayRemove(baseOverlays, entry.s, entry.n, entry.t);\n\n                    var tmp;\n                    if (!entry.p) {\n                        tmp = entry.s;\n                        entry.s = entry.t;\n                        entry.t = tmp;\n                    }\n\n                    ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n                    ASSERT(entry.s === baseOldPath || entry.s.charAt(baseOldPath.length) === '/');\n\n                    var source, target, overlays;\n\n                    if (aboveAncestor < 0) {\n                        //below ancestor node\n                        source = ancestorNewPath + entry.s.substr(baseOldPath.length);\n                        target = coretree.joinPaths(relativePath, entry.t);\n                        overlays = ancestorOverlays;\n                    } else if (aboveAncestor === 0) {\n                        //at ancestor node\n                        var data = coretree.getCommonPathPrefixData(ancestorNewPath, entry.t);\n\n                        overlays = node;\n                        while (data.firstLength-- > 0) {\n                            overlays = coretree.getParent(overlays);\n                        }\n                        overlays = coretree.getChild(overlays, OVERLAYS);\n\n                        source = coretree.joinPaths(data.first, entry.s.substr(baseOldPath.length));\n                        target = data.second;\n                    } else {\n                        //above ancestor node\n                        ASSERT(entry.s.substr(0, baseOldPath.length) === baseOldPath);\n\n                        source = relativePath + ancestorNewPath + entry.s.substr(baseOldPath.length);\n                        target = entry.t;\n                        overlays = baseOverlays;\n                    }\n\n                    if (!entry.p) {\n                        tmp = entry.s;\n                        entry.s = entry.t;\n                        entry.t = tmp;\n\n                        tmp = source;\n                        source = target;\n                        target = tmp;\n                    }\n\n                    //console.log(source, target);\n                    overlayInsert(overlays, source, entry.n, target);\n                }\n\n                baseOldPath = '/' + coretree.getRelid(base) + baseOldPath;\n                base = coretree.getParent(base);\n            }\n\n            deleteNode(oldNode);\n\n            return node;\n        }\n\n        function getChildrenRelids(node) {\n            ASSERT(isValidNode(node));\n\n            return coretree.getKeys(node, isValidRelid);\n        }\n\n        function getChildrenPaths(node) {\n            var path = coretree.getPath(node);\n\n            var relids = getChildrenRelids(node);\n            for (var i = 0; i < relids.length; ++i) {\n                relids[i] = path + '/' + relids[i];\n            }\n\n            return relids;\n        }\n\n        function loadChildren(node) {\n            ASSERT(isValidNode(node));\n\n            var children = coretree.getKeys(node, isValidRelid);\n            for (var i = 0; i < children.length; ++i) {\n                children[i] = coretree.loadChild(node, children[i]);\n            }\n\n            return TASYNC.lift(children);\n        }\n\n        function getPointerNames(node) {\n            ASSERT(isValidNode(node));\n\n            var source = '';\n            var names = [];\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    for (var name in child) {\n                        ASSERT(names.indexOf(name) === -1);\n                        if (isPointerName(name)) {\n                            names.push(name);\n                        }\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return names;\n        }\n\n        function getPointerPath(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(coretree.getPath(node), target);\n            }\n\n            return target;\n        }\n\n        function hasPointer(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child && child[name] !== undefined) {\n                    return true;\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return false;\n        }\n\n        function getOutsidePointerPath(node, name, source) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n            ASSERT(typeof source === 'string');\n\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(coretree.getPath(node), target);\n            }\n\n            return target;\n        }\n\n        function loadPointer(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            var source = '';\n            var target;\n\n            do {\n                var child = (coretree.getProperty(node, OVERLAYS) || {})[source];\n                if (child) {\n                    target = child[name];\n                    if (target !== undefined) {\n                        break;\n                    }\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            if (target !== undefined) {\n                ASSERT(typeof target === 'string' && node);\n                return coretree.loadByPath(node, target);\n            } else {\n                return null;\n            }\n        }\n\n        function getCollectionNames(node) {\n            ASSERT(isValidNode(node));\n\n            var target = '';\n            var names = [];\n\n            do {\n                var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\n                if (child) {\n                    for (var name in child) {\n                        if (!isPointerName(name) && name !== '_mutable') {\n                            name = name.slice(0, -COLLSUFFIX.length);\n                            if (isPointerName(name) && names.indexOf(name) < 0) {\n                                names.push(name);\n                            }\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return names;\n        }\n\n        function loadCollection(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            name += COLLSUFFIX;\n\n            var collection = [];\n            var target = '';\n\n            do {\n                var child = coretree.getChild(node, OVERLAYS);\n\n                child = coretree.getChild(child, target);\n                if (child) {\n                    var sources = coretree.getProperty(child, name);\n                    if (sources) {\n                        ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                        for (var i = 0; i < sources.length; ++i) {\n                            collection.push(coretree.loadByPath(node, sources[i]));\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return TASYNC.lift(collection);\n        }\n\n        function getCollectionPaths(node, name) {\n            ASSERT(isValidNode(node) && name);\n\n            name += COLLSUFFIX;\n\n            var result = [];\n            var target = '';\n\n            do {\n                var child = coretree.getChild(node, OVERLAYS);\n\n                child = coretree.getChild(child, target);\n                if (child) {\n                    var sources = coretree.getProperty(child, name);\n                    if (sources) {\n                        ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                        var prefix = coretree.getPath(node);\n\n                        for (var i = 0; i < sources.length; ++i) {\n                            result.push(coretree.joinPaths(prefix, sources[i]));\n                        }\n                    }\n                }\n\n                target = '/' + coretree.getRelid(node) + target;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return result;\n        }\n\n        function deletePointer(node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var source = '';\n\n            do {\n                var overlays = coretree.getChild(node, OVERLAYS);\n                ASSERT(overlays);\n\n                var target = coretree.getProperty(coretree.getChild(overlays, source), name);\n                if (target !== undefined) {\n                    overlayRemove(overlays, source, name, target);\n                    return true;\n                }\n\n                source = '/' + coretree.getRelid(node) + source;\n                node = coretree.getParent(node);\n            } while (node);\n\n            return false;\n        }\n\n        function setPointer(node, name, target) {\n            ASSERT(isValidNode(node) && typeof name === 'string' && (!target || isValidNode(target)));\n\n            deletePointer(node, name);\n\n            if (target) {\n                var ancestor = coretree.getAncestor(node, target);\n\n                var overlays = coretree.getChild(ancestor, OVERLAYS);\n                var sourcePath = coretree.getPath(node, ancestor);\n                var targetPath = coretree.getPath(target, ancestor);\n\n                overlayInsert(overlays, sourcePath, name, targetPath);\n            }\n        }\n\n        function getChildrenHashes(node) {\n            var keys = getChildrenRelids(node),\n                i, hashes = {};\n\n            for (i = 0; i < keys.length; i++) {\n                hashes[keys[i]] = coretree.getChildHash(node, keys[i]);\n            }\n\n            return hashes;\n        }\n\n        // copy everything from coretree\n        var corerel = {};\n        for (var key in coretree) {\n            corerel[key] = coretree[key];\n        }\n\n        corerel.isValidNode = isValidNode;\n        corerel.isValidRelid = isValidRelid;\n\n        corerel.getChildrenRelids = getChildrenRelids;\n        corerel.getChildrenPaths = getChildrenPaths;\n\n        corerel.loadChildren = loadChildren;\n        corerel.createNode = createNode;\n        corerel.deleteNode = deleteNode;\n        corerel.copyNode = copyNode;\n        corerel.copyNodes = copyNodes;\n        corerel.moveNode = moveNode;\n\n        corerel.getAttributeNames = getAttributeNames;\n        corerel.getAttribute = getAttribute;\n        corerel.setAttribute = setAttribute;\n        corerel.delAttribute = delAttribute;\n\n        corerel.getRegistryNames = getRegistryNames;\n        corerel.getRegistry = getRegistry;\n        corerel.setRegistry = setRegistry;\n        corerel.delRegistry = delRegistry;\n\n        corerel.getPointerNames = getPointerNames;\n        corerel.getPointerPath = getPointerPath;\n        corerel.hasPointer = hasPointer;\n        corerel.getOutsidePointerPath = getOutsidePointerPath;\n        corerel.loadPointer = loadPointer;\n        corerel.deletePointer = deletePointer;\n        corerel.setPointer = setPointer;\n        corerel.getCollectionNames = getCollectionNames;\n        corerel.getCollectionPaths = getCollectionPaths;\n        corerel.loadCollection = loadCollection;\n\n        corerel.getCoreTree = function () {\n            return coretree;\n        };\n\n        corerel.getChildrenHashes = getChildrenHashes;\n\n        corerel.overlayInsert = overlayInsert;\n\n        return corerel;\n    }\n\n    return CoreRel;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/setcore',['common/util/assert'], function (ASSERT) {\n    'use strict';\n\n    var SETS_ID = '_sets';\n    var REL_ID = 'member';\n\n    function SetCore(innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n\n        var logger = options.logger.fork('setcore');\n        //help functions\n        var setModified = function (node) {\n            innerCore.setRegistry(node, '_sets_', (innerCore.getRegistry(node, '_sets_') || 0) + 1);\n        };\n        var getMemberPath = function (node, setElementNode) {\n            var ownPath = innerCore.getPath(node),\n                memberPath = innerCore.getPointerPath(setElementNode, REL_ID);\n\n            //TODO this is a hack and should be solved some other way if possible\n            ownPath = ownPath.substring(0, ownPath.indexOf('/_'));\n\n            if (ownPath !== memberPath) {\n                return memberPath;\n            }\n\n            //now we should check who really set this member as its own\n            while (innerCore.getBase(node) !== null && innerCore.getBase(setElementNode) !== null &&\n            innerCore.getRegistry(innerCore.getBase(setElementNode), '_') === '_') {\n\n                node = innerCore.getBase(node);\n                setElementNode = innerCore.getBase(setElementNode);\n                ownPath = innerCore.getPath(node);\n\n                //TODO this is a hack and should be solved some other way if possible\n                ownPath = ownPath.substring(0, ownPath.indexOf('/_'));\n            }\n            memberPath = innerCore.getPointerPath(setElementNode, REL_ID);\n\n\n            return memberPath;\n\n        };\n        var getMemberRelId = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName);\n            var elements = innerCore.getChildrenRelids(setNode);\n\n            for (var i = 0; i < elements.length; i++) {\n                if (getMemberPath(node, innerCore.getChild(setNode, elements[i])) === memberPath) {\n                    return elements[i];\n                }\n            }\n            return null;\n        };\n        var createNewMemberRelid = function (setNode) {\n            var MAX_RELID = Math.pow(2, 31);\n            var existingRelIds = innerCore.getChildrenRelids(setNode);\n            var relid;\n            do {\n                relid = Math.floor(Math.random() * MAX_RELID);\n            } while (existingRelIds.indexOf(relid) !== -1);\n            return '' + relid;\n        };\n\n        var harmonizeMemberData = function (node, setName) {\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName),\n                base = innerCore.getBase(setNode),\n                allMembers = innerCore.getChildrenRelids(setNode),\n                ownMembers, inheritedMembers, i, j, path, names, ownMember, inheritedMember, k;\n            if (base) {\n                harmonizeMemberData(base, setName); //recursively harmonize base members first\n                inheritedMembers = innerCore.getChildrenRelids(base);\n                ownMembers = [];\n                for (i = 0; i < allMembers.length; i++) {\n                    if (inheritedMembers.indexOf(allMembers[i]) === -1) {\n                        ownMembers.push(allMembers[i]);\n                    }\n                }\n\n                for (i = 0; i < ownMembers.length; i++) {\n                    ownMember = innerCore.getChild(setNode, ownMembers[i]);\n                    path = innerCore.getPointerPath(ownMember, 'member');\n                    for (j = 0; j < inheritedMembers.length; j++) {\n                        inheritedMember = innerCore.getChild(setNode, inheritedMembers[j]);\n                        if (getMemberPath(node, inheritedMember) === path) {\n                            //redundancy...\n                            names = innerCore.getAttributeNames(ownMember);\n                            for (k = 0; k < names.length; k++) {\n                                if (innerCore.getAttribute(ownMember, names[k]) !==\n                                    innerCore.getAttribute(inheritedMember, names[k])) {\n\n                                    innerCore.setAttribute(inheritedMember, names[k],\n                                        innerCore.getAttribute(ownMember, names[k]));\n                                }\n                            }\n                            names = innerCore.getRegistryNames(ownMember);\n                            for (k = 0; k < names.length; k++) {\n                                if (innerCore.getRegistry(ownMember, names[k]) !==\n                                    innerCore.getRegistry(inheritedMember, names[k])) {\n\n                                    innerCore.setRegistry(inheritedMember, names[k],\n                                        innerCore.getRegistry(ownMember, names[k]));\n                                }\n                            }\n                            innerCore.deleteNode(innerCore.getChild(setNode, ownMembers[i]), true);\n                        }\n                    }\n                }\n            }\n        };\n\n        //copy lower layer\n        var setcore = {};\n        for (var i in innerCore) {\n            setcore[i] = innerCore[i];\n        }\n        logger.debug('initialized');\n        //adding new functions\n        setcore.getSetNumbers = function (node) {\n            return this.getSetNames(node).length;\n        };\n\n        setcore.getSetNames = function (node) {\n            return innerCore.getPointerNames(innerCore.getChild(node, SETS_ID)) || [];\n        };\n\n        setcore.getPointerNames = function (node) {\n            var sorted = [],\n                raw = innerCore.getPointerNames(node);\n            for (var i = 0; i < raw.length; i++) {\n                if (raw[i].indexOf(REL_ID) === -1) {\n                    sorted.push(raw[i]);\n                }\n            }\n            return sorted;\n        };\n\n        setcore.getCollectionNames = function (node) {\n            var sorted = [],\n                raw = innerCore.getCollectionNames(node);\n            for (var i = 0; i < raw.length; i++) {\n                if (raw[i].indexOf(REL_ID) === -1) {\n                    sorted.push(raw[i]);\n                }\n            }\n            return sorted;\n        };\n\n        setcore.getMemberPaths = function (node, setName) {\n            ASSERT(typeof setName === 'string');\n            harmonizeMemberData(node, setName);\n            var setNode = innerCore.getChild(innerCore.getChild(node, SETS_ID), setName);\n            var members = [];\n            var elements = innerCore.getChildrenRelids(setNode);\n            elements = elements.sort(); //TODO this should be removed at some point\n            for (var i = 0; i < elements.length; i++) {\n                var path = getMemberPath(node, innerCore.getChild(setNode, elements[i]));\n                if (path) {\n                    members.push(path);\n                }\n            }\n            return members;\n        };\n\n        setcore.delMember = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            harmonizeMemberData(node, setName);\n            //we only need the path of the member so we allow to enter only it\n            if (typeof memberPath !== 'string') {\n                memberPath = innerCore.getPath(memberPath);\n            }\n\n            var setMemberRelId = getMemberRelId(node, setName, memberPath);\n            if (setMemberRelId) {\n                var setMemberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), setMemberRelId);\n\n                innerCore.deleteNode(setMemberNode, true);\n                setModified(node);\n            }\n        };\n\n        setcore.addMember = function (node, setName, member) {\n            ASSERT(typeof setName === 'string');\n            var setsNode = innerCore.getChild(node, SETS_ID);\n            //TODO decide if the member addition should really create the set or it should fail...\n            if (innerCore.getPointerPath(setsNode, setName) === undefined) {\n                setcore.createSet(node, setName);\n            }\n            harmonizeMemberData(node, setName);\n            var setNode = innerCore.getChild(setsNode, setName);\n            var setMemberRelId = getMemberRelId(node, setName, setcore.getPath(member));\n            if (setMemberRelId === null) {\n                var setMember = innerCore.getChild(setNode, createNewMemberRelid(setNode));\n                innerCore.setPointer(setMember, 'member', member);\n\n                //TODO hack, somehow the empty children have been removed during persist\n                innerCore.setRegistry(setMember, '_', '_');\n                setModified(node);\n            }\n        };\n\n        //TODO: Refactor out getMemberNode:\n        //TODO: var memberNode = innerCore.getChild(\n        //TODO: innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n        setcore.getMemberAttributeNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getAttributeNames(memberNode);\n            }\n            return [];\n        };\n\n        setcore.getMemberOwnAttributeNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getOwnAttributeNames(memberNode);\n            }\n            return [];\n        };\n\n        setcore.getMemberAttribute = function (node, setName, memberPath, attrName) {\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getAttribute(memberNode, attrName);\n            }\n        };\n\n        setcore.setMemberAttribute = function (node, setName, memberPath, attrName, attrValue) {\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string' && attrValue !== undefined);\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.setAttribute(memberNode, attrName, attrValue);\n                setModified(node);\n            }\n        };\n\n        setcore.delMemberAttribute = function (node, setName, memberPath, attrName) {\n            ASSERT(typeof setName === 'string' && typeof attrName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.delAttribute(memberNode, attrName);\n                setModified(node);\n            }\n        };\n\n        setcore.getMemberRegistryNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getRegistryNames(memberNode);\n            }\n            return [];\n        };\n        setcore.getMemberOwnRegistryNames = function (node, setName, memberPath) {\n            ASSERT(typeof setName === 'string');\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getOwnRegistryNames(memberNode);\n            }\n            return [];\n        };\n        setcore.getMemberRegistry = function (node, setName, memberPath, regName) {\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                return innerCore.getRegistry(memberNode, regName);\n            }\n        };\n        setcore.setMemberRegistry = function (node, setName, memberPath, regName, regValue) {\n            ASSERT(typeof setName === 'string' && typeof regName === 'string' && regValue !== undefined);\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.setRegistry(memberNode, regName, regValue);\n                setModified(node);\n            }\n        };\n        setcore.delMemberRegistry = function (node, setName, memberPath, regName) {\n            ASSERT(typeof setName === 'string' && typeof regName === 'string');\n            harmonizeMemberData(node, setName);\n            var memberRelId = getMemberRelId(node, setName, memberPath);\n            if (memberRelId) {\n                var memberNode = innerCore.getChild(\n                    innerCore.getChild(innerCore.getChild(node, SETS_ID), setName), memberRelId);\n\n                innerCore.delRegistry(memberNode, regName);\n                setModified(node);\n            }\n        };\n        setcore.createSet = function (node, setName) {\n            ASSERT(typeof setName === 'string');\n            var setsNode = innerCore.getChild(node, SETS_ID),\n                setNode = innerCore.getChild(setsNode, setName);\n\n            //FIXME: hack, somehow the empty children have been removed during persist\n            innerCore.setRegistry(setNode, '_', '_');\n\n            innerCore.setPointer(innerCore.getChild(node, SETS_ID), setName, null);\n            setModified(node);\n        };\n        setcore.deleteSet = function (node, setName) {\n            ASSERT(typeof setName === 'string');\n            var setsNode = innerCore.getChild(node, SETS_ID),\n                setNode = innerCore.getChild(setsNode, setName);\n            innerCore.deletePointer(setsNode, setName);\n            innerCore.deleteNode(setNode, true);\n            setModified(node);\n        };\n\n        setcore.isMemberOf = function (node) {\n            //TODO we should find a proper way to do this - or at least some support from lower layers would be fine\n            var coll = setcore.getCollectionPaths(node, REL_ID);\n            var sets = {};\n            for (var i = 0; i < coll.length; i++) {\n                var pathArray = coll[i].split('/');\n                if (pathArray.indexOf('_meta') === -1) {\n                    //now we simply skip META sets...\n                    var index = pathArray.indexOf(SETS_ID);\n                    if (index > 0 && pathArray.length > index + 1) {\n                        //otherwise it is not a real set\n                        var ownerPath = pathArray.slice(0, index).join('/');\n                        if (sets[ownerPath] === undefined) {\n                            sets[ownerPath] = [];\n                        }\n                        sets[ownerPath].push(pathArray[index + 1]);\n                    }\n                }\n            }\n            return sets;\n        };\n\n        /*setcore.getDataForSingleHash = function(node){\n         ASSERT(setcore.isValidNode(node));\n         var datas = innerCore.getDataForSingleHash(node);\n\n         //now we should stir all the sets hashes into the node's hash to get changes deep inside\n         var names = setcore.getSetNames(node);\n         for(var i=0;i<names.length;i++){\n         var setNode = setcore.getChild(setcore.getChild(node,SETS_ID),names[i]);\n         var memberRelids = setcore.getChildrenRelids(setNode);\n         for(var j=0;j<memberRelids.length;j++){\n         datas = datas.concat(innerCore.getDataForSingleHash(setcore.getChild(setNode,memberRelids[j])));\n         }\n         }\n\n         return datas;\n         };*/\n\n        return setcore;\n\n    }\n\n    return SetCore;\n});\n\n\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true, bitwise: false*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/util/guid',[],function () {\n    'use strict';\n\n    var guid = function () {\n        var S4 = function () {\n            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n        };\n\n        //return GUID\n        return (S4() + S4() + '-' + S4() + '-' + S4() + '-' + S4() + '-' + S4() + S4() + S4());\n    };\n\n    return guid;\n});\n",
    "/*globals define*/\n/*jshint node:true, browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('common/regexp',[], function () {\n    'use strict';\n    var HASH = new RegExp('^#[0-9a-zA-Z_]*$'),\n        BRANCH = new RegExp('^[0-9a-zA-Z_]*$'),\n        RAW_BRANCH = new RegExp('^\\\\*[0-9a-zA-Z_]*$'),// This is how it's stored in mongodb, i.e. with a prefixed *.\n        PROJECT = new RegExp('^(?!system\\\\.)(?!_)[0-9a-zA-Z_+]*$'), // project name may not start with system. or _\n\n        GUID = new RegExp('[a-z0-9]{8}(-[a-z0-9]{4}){3}-[a-z0-9]{12}', 'i');\n\n    return {\n        HASH: HASH,\n        BRANCH: BRANCH,\n        RAW_BRANCH: RAW_BRANCH,\n        PROJECT: PROJECT,\n        GUID: GUID\n    };\n});\n\n",
    "/*globals define*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/guidcore',[\n    'common/util/assert',\n    'common/util/guid',\n    'common/core/tasync',\n    'common/regexp'\n], function (ASSERT, GUID, TASYNC, REGEXP) {\n\n    'use strict';\n\n    var OWN_GUID = '_relguid';\n\n    function guidCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var logger = options.logger.fork('guidCore');\n        //helper functions\n        function toInternalGuid(myGuid) {\n            return myGuid.replace(/-/g, '');\n        }\n\n        function toExternalGuid(myGuid) {\n            var out = myGuid.substr(0, 8) + '-' + myGuid.substr(8, 4) + '-' +\n                myGuid.substr(12, 4) + '-' + myGuid.substr(16, 4) + '-' + myGuid.substr(20);\n            return out;\n        }\n\n        function guidToArray(guid) {\n            if (guid === null || guid === undefined) {\n                return [0, 0, 0, 0, 0, 0, 0, 0];\n            }\n            var array = [];\n            for (var i = 0; i < guid.length / 4; i++) {\n                array.push(parseInt(guid.substr(4 * i, 4), 16));\n            }\n            return array;\n        }\n\n        function getRelidGuid(node) {\n            //TODO we always should know what structure we should expect as a relid -\n            // now we think it is a number so it can be converted to 0xsomething\n            var relid = _core.getRelid(node);\n            relid = Number(relid);\n            if (relid === 'NaN') {\n                return null;\n            }\n            if (relid < 0) {\n                relid = relid * (-1);\n            }\n\n            relid = relid.toString(16);\n\n            //now we should fill up with 0's in the beggining\n            while (relid.length < 32) {\n                relid = relid + '0'; //TODO we pad to the end so the final result will be more visible during debug\n            }\n            return relid;\n        }\n\n        function xorGuids(a, b) {\n            var arrayA = guidToArray(a);\n            var arrayB = guidToArray(b);\n\n            ASSERT(arrayA.length === arrayB.length);\n\n            var arrayOut = [];\n            for (var i = 0; i < arrayA.length; i++) {\n                /*jshint bitwise: false*/\n                arrayOut.push(arrayA[i] ^ arrayB[i]);\n            }\n            for (i = 0; i < arrayOut.length; i++) {\n                arrayOut[i] = Number(arrayOut[i]).toString(16);\n                var difi = 4 - arrayOut[i].length;\n                while (difi > 0) {\n                    arrayOut[i] = '0' + arrayOut[i];\n                    difi--;\n                }\n            }\n            return arrayOut.join('');\n        }\n\n        var _core = {};\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n        logger.debug('initialized');\n        //new functions\n        _core.getMiddleGuid = function (node) {\n            var outGuid = _core.getAttribute(node, OWN_GUID);\n            var tempnode = _core.getParent(node);\n            while (tempnode) {\n                outGuid = xorGuids(outGuid, _core.getAttribute(tempnode, OWN_GUID));\n                tempnode = _core.getParent(tempnode);\n            }\n            return outGuid;\n        };\n\n        _core.getGuid = function (node) {\n            var middle = _core.getMiddleGuid(node),\n                relid = getRelidGuid(node),\n                guid = xorGuids(middle, relid);\n            return toExternalGuid(guid);\n        };\n\n        _core.setGuid = function (node, guid) {\n            ASSERT(REGEXP.GUID.test(guid));\n            var children = _core.loadChildren(node);\n            return TASYNC.call(function (nodeArray) {\n                var newGuid = toInternalGuid(guid);\n                //first setting the node's OWN_GUID\n                var oldOwn = _core.getAttribute(node, OWN_GUID);\n                var parent = _core.getParent(node);\n                if (parent) {\n                    _core.setAttribute(node, OWN_GUID,\n                        xorGuids(newGuid, xorGuids(_core.getMiddleGuid(parent), getRelidGuid(node))));\n                } else {\n                    _core.setAttribute(node, OWN_GUID, xorGuids(newGuid, getRelidGuid(node)));\n                }\n                var newOwn = _core.getAttribute(node, OWN_GUID);\n                //now modify its children's\n                for (var i = 0; i < nodeArray.length; i++) {\n                    var oldGuid = _core.getAttribute(nodeArray[i], OWN_GUID);\n                    _core.setAttribute(nodeArray[i], OWN_GUID, xorGuids(oldGuid, xorGuids(oldOwn, newOwn)));\n                }\n\n                return;\n            }, children);\n        };\n\n        //modified functions\n        _core.createNode = function (parameters) {\n            parameters = parameters || {};\n            var guid = parameters.guid || GUID(),\n                parent = parameters.parent;\n\n            ASSERT(REGEXP.GUID.test(guid));\n\n            var node = _innerCore.createNode(parameters);\n            guid = toInternalGuid(guid);\n\n            var relguid = '';\n            if (parent) {\n                relguid = xorGuids(toInternalGuid(_core.getMiddleGuid(_core.getParent(node))),\n                    xorGuids(guid, getRelidGuid(node)));\n            } else {\n                relguid = xorGuids(guid, getRelidGuid(node));\n            }\n            _innerCore.setAttribute(node, OWN_GUID, relguid);\n\n            return node;\n        };\n\n        _core.moveNode = function (node, parent) {\n            var oldGuid = toInternalGuid(_core.getGuid(node)),\n                newNode = _innerCore.moveNode(node, parent);\n\n            _core.setAttribute(newNode, OWN_GUID, xorGuids(_core.getMiddleGuid(parent),\n                xorGuids(oldGuid, getRelidGuid(newNode))));\n\n            return newNode;\n        };\n\n        _core.copyNode = function (node, parent) {\n            var newNode = _innerCore.copyNode(node, parent);\n            _core.setAttribute(newNode, OWN_GUID, toInternalGuid(GUID()));\n            return newNode;\n        };\n\n        _core.copyNodes = function (nodes, parent) {\n            var copiedNodes = _innerCore.copyNodes(nodes, parent),\n                i;\n            for (i = 0; i < copiedNodes.length; i++) {\n                _core.setAttribute(copiedNodes[i], OWN_GUID, toInternalGuid(GUID()));\n            }\n\n            return copiedNodes;\n        };\n\n        return _core;\n    }\n\n    return guidCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/nullpointercore',['common/util/assert'], function (ASSERT) {\n    'use strict';\n\n    var NULLPTR_NAME = '_null_pointer';\n    var NULLPTR_RELID = '_nullptr';\n\n\n    function nullPointerCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('nullpointercore');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n        logger.debug('initialized');\n\n        //extra functions\n        _core.setPointer = function (node, name, target) {\n            if (target === null) {\n                var nullChild = _innerCore.getChild(node, NULLPTR_RELID);\n                _innerCore.setAttribute(nullChild, 'name', NULLPTR_NAME);\n                _innerCore.setPointer(node, name, nullChild);\n            } else {\n                _innerCore.setPointer(node, name, target);\n            }\n        };\n\n        _core.getPointerPath = function (node, name) {\n            var path = _innerCore.getPointerPath(node, name);\n            if (path && path.indexOf(NULLPTR_RELID) !== -1) {\n                return null;\n            } else {\n                return path;\n            }\n        };\n\n        _core.loadPointer = function (node, name) {\n            var path = _core.getPointerPath(node, name);\n            if (path === null) {\n                return null;\n            } else {\n                return _innerCore.loadPointer(node, name);\n            }\n        };\n\n        return _core;\n    }\n\n    return nullPointerCore;\n});\n\n\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/coreunwrap',['common/util/assert', 'common/core/tasync'], function (ASSERT, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreUnwrap -----------------\n\n    var CoreUnwrap = function (oldcore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var logger = options.logger.fork('coreunwrap');\n\n        function checkNode(node) {\n            if (node === null || oldcore.isValidNode(node)) {\n                return node;\n            } else {\n                throw new Error('Invalid result node');\n            }\n        }\n\n        function checkNodes(nodes) {\n            ASSERT(nodes instanceof Array);\n\n            var i;\n            for (i = 0; i < nodes.length; ++i) {\n                if (!oldcore.isValidNode(nodes[i])) {\n                    throw new Error('Invalid result node array');\n                }\n            }\n\n            return nodes;\n        }\n\n        // copy all operations\n        var core = {};\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        core.loadRoot = TASYNC.unwrap(oldcore.loadRoot);\n        //core.persist = TASYNC.unwrap(oldcore.persist);\n\n        // core.loadChild = TASYNC.unwrap(oldcore.loadChild);\n        core.loadChild = TASYNC.unwrap(function (node, relid) {\n            return TASYNC.call(checkNode, oldcore.loadChild(node, relid));\n        });\n\n        // core.loadByPath = TASYNC.unwrap(oldcore.loadByPath);\n        core.loadByPath = TASYNC.unwrap(function (node, path) {\n            return TASYNC.call(checkNode, oldcore.loadByPath(node, path));\n        });\n\n        // core.loadChildren = TASYNC.unwrap(oldcore.loadChildren);\n        core.loadChildren = TASYNC.unwrap(function (node) {\n            return TASYNC.call(checkNodes, oldcore.loadChildren(node));\n        });\n\n        core.loadPointer = TASYNC.unwrap(oldcore.loadPointer);\n        core.loadCollection = TASYNC.unwrap(oldcore.loadCollection);\n\n        core.loadSubTree = TASYNC.unwrap(oldcore.loadSubTree);\n        core.loadTree = TASYNC.unwrap(oldcore.loadTree);\n\n        //core diff async functions\n        if (typeof oldcore.generateTreeDiff === 'function') {\n            core.generateTreeDiff = TASYNC.unwrap(oldcore.generateTreeDiff);\n        }\n\n        if (typeof oldcore.generateLightTreeDiff === 'function') {\n            core.generateLightTreeDiff = TASYNC.unwrap(oldcore.generateLightTreeDiff);\n        }\n\n        if (typeof oldcore.applyTreeDiff === 'function') {\n            core.applyTreeDiff = TASYNC.unwrap(oldcore.applyTreeDiff);\n        }\n\n        return core;\n    };\n\n    return CoreUnwrap;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/coretype',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreType -----------------\n\n    //FIXME TODO these stuff have been simply copied from lower layer, probably it should be put to some constant place\n    var OVERLAYS = 'ovr';\n    var COLLSUFFIX = '-inv';\n\n    var CoreType = function (oldcore, options) {\n        // copy all operations\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var core = {},\n            logger = options.logger.fork('coretype');\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        // ----- validity\n\n        function __test(text, cond) {\n            if (!cond) {\n                throw new Error(text);\n            }\n        }\n\n        function isValidNode(node) {\n            try {\n                __test('core', oldcore.isValidNode(node));\n                __test('base', typeof node.base === 'object');\n                return true;\n            } catch (error) {\n                logger.error(error.message, {stack: error.stack, node: node});\n                return false;\n            }\n        }\n\n        function isFalseNode(node) {\n            //TODO this hack should be removed, but now it seems just fine :)\n            if (typeof oldcore.getPointerPath(node, 'base') === 'undefined') {\n                return true;\n            }\n            return false;\n        }\n\n        core.isValidNode = isValidNode;\n\n        // ----- navigation\n\n        core.getBase = function (node) {\n            ASSERT(isValidNode(node));\n\n            // TODO: check if base has moved\n            return node.base;\n        };\n\n        core.getBaseRoot = function (node) {\n            ASSERT(isValidNode(node));\n            while (node.base !== null) {\n                node = node.base;\n            }\n\n            return node;\n        };\n\n        core.loadRoot = function (hash) {\n            return TASYNC.call(__loadRoot2, oldcore.loadRoot(hash));\n        };\n\n        function __loadRoot2(node) {\n            ASSERT(typeof node.base === 'undefined' || node.base === null);\n            //kecso - TODO it should be undefined, but maybe because of the cache it can be null\n\n            node.base = null;\n            return node;\n        }\n\n        core.loadChild = function (node, relid) {\n            var child = null,\n                base = core.getBase(node),\n                basechild = null;\n            if (base) {\n                //the parent is inherited\n                if (core.getChildrenRelids(base).indexOf(relid) !== -1) {\n                    //inherited child\n                    if (oldcore.getChildrenRelids(node).indexOf(relid) !== -1) {\n                        //but it is overwritten so we should load it\n                        child = oldcore.loadChild(node, relid);\n                    }\n                    basechild = core.loadChild(base, relid);\n                    return TASYNC.call(function (b, c, n, r) {\n                        if (c) {\n                            child = c;\n                            child.base = b;\n                            return child;\n                        } else {\n                            child = oldcore.getChild(n, r);\n                            core.setHashed(child, true, true);\n                            child.base = b;\n\n                            return child;\n                        }\n                    }, basechild, child, node, relid);\n                }\n            }\n            //normal child\n            return TASYNC.call(__loadBase, oldcore.loadChild(node, relid));\n        };\n\n        core.loadByPath = function (node, path) {\n            ASSERT(isValidNode(node));\n            ASSERT(path === '' || path.charAt(0) === '/');\n            path = path.split('/');\n            return loadDescendantByPath(node, path, 1);\n        };\n        var loadDescendantByPath = function (node, pathArray, index) {\n            if (node === null || index === pathArray.length) {\n                return node;\n            }\n\n            var child = core.loadChild(node, pathArray[index]);\n            return TASYNC.call(loadDescendantByPath, child, pathArray, index + 1);\n        };\n\n        //TODO the pointer loading is totally based upon the loadByPath...\n        core.loadPointer = function (node, name) {\n            var pointerPath = core.getPointerPath(node, name);\n            if (pointerPath === undefined) {\n                return undefined;\n            }\n            if (pointerPath === null) {\n                return null;\n            }\n            return TASYNC.call(core.loadByPath, core.getRoot(node), pointerPath);\n        };\n\n        function __loadBase(node) {\n            ASSERT(node === null || typeof node.base === 'undefined' || typeof node.base === 'object');\n\n            if (typeof node.base === 'undefined') {\n                if (core.isEmpty(node)) {\n                    //empty nodes do not have a base\n                    node.base = null;\n                    return node;\n                } else if (isFalseNode(node)) {\n                    var root = core.getRoot(node);\n                    oldcore.deleteNode(node);\n                    core.persist(root);\n                    return null;\n                } else {\n                    var basepath = oldcore.getPointerPath(node, 'base');\n                    ASSERT(basepath !== undefined);\n                    if (basepath === null) {\n                        node.base = null;\n                        return node;\n                    } else {\n                        return TASYNC.call(__loadBase2, node, core.loadByPath(core.getRoot(node), basepath));\n                    }\n                }\n            } else {\n                //TODO can the base change at this point???\n                return node;\n            }\n        }\n\n        function __loadBase2(node, target) {\n            if (typeof node.base !== null && typeof node.base === 'object' &&\n                (oldcore.getPath(node.base) === oldcore.getPath(target))) {\n                //TODO somehow the object already loaded properly and we do no know about it!!!\n                return node;\n            } else {\n                ASSERT(typeof node.base === 'undefined' || node.base === null); //kecso\n\n                if (target === null) {\n                    node.base = null;\n                    return node;\n                } else {\n                    return TASYNC.call(function (n, b) {\n                        n.base = b;\n                        return n;\n                    }, node, __loadBase(target));\n                }\n            }\n        }\n\n        core.getChildrenRelids = function (node) {\n            var inheritRelIds = node.base === null ? [] : core.getChildrenRelids(core.getBase(node));\n            var ownRelIds = oldcore.getChildrenRelids(node);\n            for (var i = 0; i < inheritRelIds.length; i++) {\n                if (ownRelIds.indexOf(inheritRelIds[i]) === -1) {\n                    ownRelIds.push(inheritRelIds[i]);\n                }\n            }\n            return ownRelIds;\n        };\n\n        core.loadChildren = function (node) {\n            ASSERT(isValidNode(node));\n            var relids = core.getChildrenRelids(node);\n            relids = relids.sort(); //TODO this should be temporary\n            var children = [];\n            for (var i = 0; i < relids.length; i++) {\n                children[i] = core.loadChild(node, relids[i]);\n            }\n            return TASYNC.call(function (n) {\n                var newn = [];\n                for (var i = 0; i < n.length; i++) {\n                    if (n[i] !== null) {\n                        newn.push(n[i]);\n                    }\n                }\n                return newn;\n            }, TASYNC.lift(children));\n        };\n\n        //collection handling and needed functions\n        function _isInheritedChild(node) {\n            var parent = core.getParent(node),\n                base = core.getBase(node),\n                parentBase = parent ? core.getBase(parent) : null,\n                baseParent = base ? core.getParent(base) : null;\n\n            if (baseParent && parentBase && core.getPath(baseParent) === core.getPath(parentBase)) {\n                return true;\n            }\n            return false;\n        }\n\n        function _getInstanceRoot(node) {\n\n            while (_isInheritedChild(node)) {\n                node = core.getParent(node);\n            }\n\n            return node;\n        }\n\n        //TODO copied function from corerel\n        function isPointerName(name) {\n            ASSERT(typeof name === 'string');\n\n            return name.slice(-COLLSUFFIX.length) !== COLLSUFFIX;\n        }\n\n        function _getInheritedCollectionNames(node) {\n            var target = '',\n                names = [],\n                coretree = core.getCoreTree(),\n                startNode = node,\n                endNode = _getInstanceRoot(node),\n                exit;\n\n            if (core.getPath(startNode) === core.getPath(endNode)) {\n                return names;\n            }\n\n            do {\n                startNode = core.getBase(startNode);\n                endNode = core.getBase(endNode);\n                node = startNode;\n                exit = false;\n                target = '';\n                do {\n                    if (core.getPath(node) === core.getPath(endNode)) {\n                        exit = true;\n                    }\n                    var child = coretree.getProperty(coretree.getChild(node, OVERLAYS), target);\n                    if (child) {\n                        for (var name in child) {\n                            if (!isPointerName(name)) {\n                                name = name.slice(0, -COLLSUFFIX.length);\n                                if (names.indexOf(name) < 0) {\n                                    names.push(name);\n                                }\n                            }\n                        }\n                    }\n\n                    target = '/' + coretree.getRelid(node) + target;\n                    node = coretree.getParent(node);\n                } while (!exit);\n            } while (_isInheritedChild(startNode));\n\n            return names;\n        }\n\n        function _getInheritedCollectionPaths(node, name) {\n            var target = '',\n                result = [],\n                coretree = core.getCoreTree(),\n                startNode = node,\n                endNode = _getInstanceRoot(node),\n                prefixStart = startNode,\n                prefixNode = prefixStart,\n                exit,\n                collName = name + COLLSUFFIX,\n                notOverwritten = function (sNode, eNode, source) {\n                    var result = true,\n                        tNode = sNode,\n                        child, target;\n\n                    while (core.getPath(tNode) !== core.getPath(eNode)) {\n                        child = coretree.getChild(tNode, OVERLAYS);\n                        child = coretree.getChild(child, source);\n                        if (child) {\n                            target = coretree.getProperty(child, name);\n                            if (target) {\n                                return false;\n                            }\n                        }\n                        tNode = core.getBase(tNode);\n                    }\n\n                    return result;\n                };\n\n            if (core.getPath(startNode) === core.getPath(endNode)) {\n                return result;\n            }\n\n            do {\n                startNode = core.getBase(startNode);\n                endNode = core.getBase(endNode);\n                node = startNode;\n                prefixNode = prefixStart;\n                exit = false;\n                target = '';\n                do {\n                    if (core.getPath(node) === core.getPath(endNode)) {\n                        exit = true;\n                    }\n                    var child = coretree.getChild(node, OVERLAYS);\n                    child = coretree.getChild(child, target);\n                    if (child) {\n                        var sources = coretree.getProperty(child, collName);\n                        if (sources) {\n                            ASSERT(Array.isArray(sources) && sources.length >= 1);\n\n                            var prefix = coretree.getPath(prefixNode);\n\n                            for (var i = 0; i < sources.length; ++i) {\n                                if (notOverwritten(prefixNode, node, sources[i])) {\n                                    result.push(coretree.joinPaths(prefix, sources[i]));\n                                }\n                            }\n                        }\n                    }\n\n                    target = '/' + coretree.getRelid(node) + target;\n                    node = coretree.getParent(node);\n                    prefixNode = core.getParent(prefixNode);\n                } while (!exit);\n            } while (_isInheritedChild(startNode));\n\n            return result;\n        }\n\n        core.getCollectionNames = function (node) {\n            ASSERT(isValidNode(node));\n            var checkCollNames = function (draft) {\n                    var filtered = [],\n                        i, sources;\n                    for (i = 0; i < draft.length; i++) {\n                        sources = core.getCollectionPaths(node, draft[i]);\n                        if (sources.length > 0) {\n                            filtered.push(draft[i]);\n                        }\n                    }\n                    return filtered;\n                },\n                ownNames = oldcore.getCollectionNames(node),\n                inhNames = checkCollNames(_getInheritedCollectionNames(node)),\n                i;\n            for (i = 0; i < ownNames.length; i++) {\n                if (inhNames.indexOf(ownNames[i]) < 0) {\n                    inhNames.push(ownNames[i]);\n                }\n            }\n\n            return inhNames;\n        };\n\n        core.getCollectionPaths = function (node, name) {\n            ASSERT(isValidNode(node) && name);\n            var ownPaths = oldcore.getCollectionPaths(node, name),\n                inhPaths = _getInheritedCollectionPaths(node, name);\n\n            inhPaths = inhPaths.concat(ownPaths);\n\n            return inhPaths;\n        };\n\n        core.loadCollection = function (node, name) {\n            var root = core.getRoot(node);\n            var paths = core.getCollectionPaths(node, name);\n\n            var nodes = [];\n            for (var i = 0; i < paths.length; i++) {\n                nodes[i] = core.loadByPath(root, paths[i]);\n            }\n\n            return TASYNC.lift(nodes);\n        };\n\n        // ----- creation\n\n        core.createNode = function (parameters) {\n            parameters = parameters || {};\n            var base = parameters.base || null,\n                parent = parameters.parent;\n\n\n            ASSERT(!parent || isValidNode(parent));\n            ASSERT(!base || isValidNode(base));\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\n\n            var node = oldcore.createNode(parameters);\n            node.base = base;\n            oldcore.setPointer(node, 'base', base);\n\n            return node;\n        };\n\n        // ----- properties\n\n        core.getAttributeNames = function (node) {\n            ASSERT(isValidNode(node));\n\n            var merged = {};\n            do {\n                var names = oldcore.getAttributeNames(node);\n                for (var i = 0; i < names.length; ++i) {\n                    if (!(names[i] in merged)) {\n                        merged[names[i]] = true;\n                    }\n                }\n\n                node = node.base;\n            } while (node);\n\n            return Object.keys(merged);\n        };\n        core.getOwnAttributeNames = function (node) {\n            return oldcore.getAttributeNames(node);\n        };\n\n        core.getRegistryNames = function (node) {\n            ASSERT(isValidNode(node));\n\n            var merged = {};\n            do {\n                var names = oldcore.getRegistryNames(node);\n                for (var i = 0; i < names.length; ++i) {\n                    if (!(names[i] in merged)) {\n                        merged[names[i]] = true;\n                    }\n                }\n\n                node = node.base;\n            } while (node);\n\n            return Object.keys(merged);\n        };\n        core.getOwnRegistryNames = function (node) {\n            return oldcore.getRegistryNames(node);\n        };\n\n        core.getAttribute = function (node, name) {\n            ASSERT(isValidNode(node));\n            var value;\n            do {\n                value = oldcore.getAttribute(node, name);\n                node = node.base;\n            } while (typeof value === 'undefined' && node !== null);\n\n            return value;\n        };\n        core.getOwnAttribute = function (node, name) {\n            return oldcore.getAttribute(node, name);\n        };\n\n        core.getRegistry = function (node, name) {\n            ASSERT(isValidNode(node));\n            var value;\n            do {\n                value = oldcore.getRegistry(node, name);\n                node = node.base;\n            } while (typeof value === 'undefined' && node !== null);\n\n            return value;\n        };\n        core.getOwnRegistry = function (node, name) {\n            return oldcore.getRegistry(node, name);\n        };\n\n\n        // ----- pointers\n\n        core.getPointerNames = function (node) {\n            ASSERT(isValidNode(node));\n\n            var merged = {};\n            do {\n                var names = oldcore.getPointerNames(node);\n                for (var i = 0; i < names.length; ++i) {\n                    if (!(names[i] in merged)) {\n                        merged[names[i]] = true;\n                    }\n                }\n\n                node = node.base;\n            } while (node);\n\n            return Object.keys(merged);\n        };\n        core.getOwnPointerNames = function (node) {\n            ASSERT(isValidNode(node));\n            return oldcore.getPointerNames(node);\n        };\n\n        core.getPointerPath = function (node, name) {\n            ASSERT(isValidNode(node) && typeof name === 'string');\n\n            var ownPointerPath = oldcore.getPointerPath(node, name);\n            if (ownPointerPath !== undefined) {\n                return ownPointerPath;\n            }\n            var source = '',\n                target,\n                coretree = core.getCoreTree(),\n                basePath,\n                hasNullTarget = false,\n                getProperty = function (node, name) {\n                    var property;\n                    while (property === undefined && node !== null) {\n                        property = coretree.getProperty(node, name);\n                        node = core.getBase(node);\n                    }\n                    return property;\n                },\n                getSimpleBasePath = function (node) {\n                    var path = oldcore.getPointerPath(node, name);\n                    if (path === undefined) {\n                        if (node.base !== null && node.base !== undefined) {\n                            return getSimpleBasePath(node.base);\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return path;\n                    }\n                },\n                getParentOfBasePath = function (node) {\n                    if (node.base) {\n                        var parent = core.getParent(node.base);\n                        if (parent) {\n                            return core.getPath(parent);\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return undefined;\n                    }\n                },\n                getBaseOfParentPath = function (node) {\n                    var parent = core.getParent(node);\n                    if (parent) {\n                        if (parent.base) {\n                            return core.getPath(parent.base);\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return undefined;\n                    }\n                },\n                getTargetRelPath = function (node, relSource, name) {\n                    var ovr = core.getChild(node, 'ovr');\n                    var source = core.getChild(ovr, relSource);\n                    return getProperty(source, name);\n                };\n\n            basePath = node.base ? getSimpleBasePath(node.base) : undefined;\n\n            while (node) {\n                target = getTargetRelPath(node, source, name);\n                if (target !== undefined) {\n                    if (target.indexOf('_nullptr') !== -1) {\n                        hasNullTarget = true;\n                        target = undefined;\n                    } else {\n                        break;\n                    }\n                }\n\n                source = '/' + core.getRelid(node) + source;\n                if (getParentOfBasePath(node) === getBaseOfParentPath(node)) {\n                    node = core.getParent(node);\n                } else {\n                    node = null;\n                }\n            }\n\n\n            if (target !== undefined) {\n                ASSERT(node);\n                target = coretree.joinPaths(oldcore.getPath(node), target);\n            }\n\n            if (typeof target === 'string') {\n                return target;\n            }\n            if (typeof basePath === 'string') {\n                return basePath;\n            }\n            if (hasNullTarget === true) {\n                return null;\n            }\n            return undefined;\n\n        };\n        core.getOwnPointerPath = function (node, name) {\n            oldcore.getPointerPath(node, name);\n        };\n\n        core.setBase = function (node, base) {\n            ASSERT(isValidNode(node) && (base === undefined || base === null || isValidNode(base)));\n            ASSERT(!base || core.getPath(core.getParent(node)) !== core.getPath(base));\n            ASSERT(!base || core.getPath(node) !== core.getPath(base));\n            if (!!base) {\n                //TODO maybe this is not the best way, needs to be double checked\n                node.base = base;\n                var parent = core.getParent(node),\n                    parentBase, baseParent;\n                if (parent) {\n                    parentBase = core.getBase(parent);\n                    baseParent = core.getParent(base);\n                    if (core.getPath(parentBase) !== core.getPath(baseParent)) {\n                        //we have to set an exact pointer only if it is not inherited child\n                        oldcore.setPointer(node, 'base', base);\n                    } else {\n                        oldcore.deletePointer(node, 'base'); //we remove the pointer just in case\n                    }\n                } else {\n                    //if for some reason the node doesn't have a parent it is surely not an inherited child\n                    oldcore.setPointer(node, 'base', base);\n                }\n            } else {\n                oldcore.setPointer(node, 'base', null);\n                node.base = null;\n            }\n        };\n\n        core.getChild = function (node, relid) {\n            ASSERT(isValidNode(node) && (typeof node.base === 'undefined' || typeof node.base === 'object'));\n            var child = oldcore.getChild(node, relid);\n            if (node.base !== null && node.base !== undefined) {\n                if (child.base === null || child.base === undefined) {\n                    child.base = core.getChild(node.base, relid);\n                }\n            } else {\n                child.base = null;\n            }\n            return child;\n        };\n        core.moveNode = function (node, parent) {\n            //TODO we have to check if the move is really allowed!!!\n            ASSERT(isValidNode(node) && isValidNode(parent));\n            var base = node.base,\n                parentBase = parent.base;\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\n            ASSERT(!parentBase || core.getPath(parentBase) !== core.getPath(node));\n\n            var moved = oldcore.moveNode(node, parent);\n            moved.base = base;\n            return moved;\n        };\n        core.copyNode = function (node, parent) {\n            var base = node.base;\n            ASSERT(!base || core.getPath(base) !== core.getPath(parent));\n\n            var newnode = oldcore.copyNode(node, parent);\n            newnode.base = base;\n            oldcore.setPointer(newnode, 'base', base);\n            return newnode;\n        };\n        function _inheritedPointerNames(node) {\n            var allNames = core.getPointerNames(node),\n                ownNames = core.getOwnPointerNames(node),\n                names = [],\n                i;\n\n            for (i = 0; i < allNames.length; i++) {\n                if (ownNames.indexOf(allNames[i]) === -1) {\n                    names.push(allNames[i]);\n                }\n            }\n\n            return names;\n        }\n\n        core.copyNodes = function (nodes, parent) {\n            var copiedNodes,\n                i, j, index, base,\n                relations = [],\n                names, pointer,\n                paths = [];\n\n            //here we also have to copy the inherited relations which points inside the copy area\n            for (i = 0; i < nodes.length; i++) {\n                paths.push(core.getPath(nodes[i]));\n            }\n\n            for (i = 0; i < nodes.length; i++) {\n                names = _inheritedPointerNames(nodes[i]);\n                pointer = {};\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(core.getPointerPath(nodes[i], names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                relations.push(pointer);\n            }\n\n            //making the actual copy\n            copiedNodes = oldcore.copyNodes(nodes, parent);\n\n            //setting internal-inherited relations\n            for (i = 0; i < nodes.length; i++) {\n                names = Object.keys(relations[i]);\n                for (j = 0; j < names.length; j++) {\n                    core.setPointer(copiedNodes[i], names[j], copiedNodes[relations[i][names[j]]]);\n                }\n            }\n\n            //setting base relation\n            for (i = 0; i < nodes.length; i++) {\n                base = nodes[i].base;\n                copiedNodes[i].base = base;\n                oldcore.setPointer(copiedNodes[i], 'base', base);\n            }\n\n\n            return copiedNodes;\n        };\n\n        core.getChildrenPaths = function (node) {\n            var path = core.getPath(node);\n\n            var relids = core.getChildrenRelids(node);\n            for (var i = 0; i < relids.length; ++i) {\n                relids[i] = path + '/' + relids[i];\n            }\n\n            return relids;\n        };\n\n        core.deleteNode = function (node, technical) {\n            //currently we only check if the node is inherited from its parents children\n            if (node && (node.base !== null || technical === true)) {\n                var parent = core.getParent(node),\n                    parentsBase = parent ? core.getBase(node) : null,\n                    base = core.getBase(node),\n                    basesParent = base ? core.getParent(node) : null;\n\n                if (parent && parentsBase && base && basesParent) {\n                    if (core.getPath(parentsBase) !== core.getPath(basesParent)) {\n                        oldcore.deleteNode(node);\n                    }\n                } else {\n                    oldcore.deleteNode(node);\n                }\n            }\n        };\n\n        core.getTypeRoot = function (node) {\n            if (node.base) {\n                while (node.base !== null) {\n                    node = core.getBase(node);\n                }\n                return node;\n            } else {\n                return null;\n            }\n        };\n\n        // -------- kecso\n\n        return core;\n    };\n\n    return CoreType;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n *\n * example constraint structure for the outside world:\n * {\n *  script:string,\n *  priority:integer,\n *  name:string,\n *  message:string\n * }\n * provided API:\n * getConstraint(node,name) -> constraintObj\n * setConstraint(node,constraintObj)\n * getConstraintNames(node)\n * delConstraint(node,name)\n */\n\ndefine('common/core/constraintcore',['common/util/assert'], function (ASSERT) {\n    'use strict';\n    var CONSTRAINTS_RELID = '_constraints';\n    var C_DEF_PRIORITY = 1;\n\n    function constraintCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('constraintcore');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n        logger.debug('initialized');\n        var createNewConstraintRelId = function (constraintsNode) {\n            var max = Math.pow(2, 31);\n            var existingRelIds = _innerCore.getChildrenRelids(constraintsNode);\n            var relId;\n            do {\n                relId = Math.floor(Math.random() * max);\n            } while (existingRelIds.indexOf(relId) !== -1);\n            return '' + relId;\n        };\n\n        var getConstraintRelId = function (constraintsNode, name) {\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\n            var relId;\n            for (var i = 0; i < relIds.length; i++) {\n                if (name === _innerCore.getAttribute(_innerCore.getChild(constraintsNode, relIds[i]), 'name')) {\n                    relId = relIds[i];\n                    break;\n                }\n            }\n            return relId;\n        };\n        var getRegConstName = function (name) {\n            return '_ch#_' + name;\n        };\n\n        _core.getConstraint = function (node, name) {\n            ASSERT(_innerCore.isValidNode(node));\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var constRelId = getConstraintRelId(constraintsNode, name);\n            if (constRelId) {\n                var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\n                return {\n                    script: _innerCore.getAttribute(constraintNode, 'script'),\n                    priority: _innerCore.getAttribute(constraintNode, 'priority'),\n                    info: _innerCore.getAttribute(constraintNode, 'info')\n                };\n            } else {\n                return null;\n            }\n        };\n\n        _core.setConstraint = function (node, name, constraintObj) {\n            ASSERT(_innerCore.isValidNode(node));\n            ASSERT(typeof constraintObj === 'object' && typeof name === 'string');\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var constRelId = getConstraintRelId(constraintsNode, name);\n            if (!constRelId) {\n                //we should create a new one\n                constRelId = createNewConstraintRelId(constraintsNode);\n            }\n\n            var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\n            constraintObj.priority = constraintObj.priority || C_DEF_PRIORITY;\n            constraintObj.script = constraintObj.script || 'console.log(\"empty constraint\");';\n            constraintObj.info = constraintObj.info || '';\n            _innerCore.setAttribute(constraintNode, 'name', name);\n            _innerCore.setAttribute(constraintNode, 'script', constraintObj.script);\n            _innerCore.setAttribute(constraintNode, 'priority', constraintObj.priority);\n            _innerCore.setAttribute(constraintNode, 'info', constraintObj.info);\n            _innerCore.setRegistry(node, getRegConstName(name),\n                (_innerCore.getRegistry(node, getRegConstName(name)) || 0) + 1);\n        };\n\n        _core.delConstraint = function (node, name) {\n            ASSERT(_innerCore.isValidNode(node));\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var constRelId = getConstraintRelId(constraintsNode, name);\n            if (constRelId) {\n                var constraintNode = _innerCore.getChild(constraintsNode, constRelId);\n                _innerCore.deleteNode(constraintNode, true);\n            }\n            _innerCore.delRegistry(node, getRegConstName(name));\n        };\n\n        _core.getConstraintNames = function (node) {\n            ASSERT(_innerCore.isValidNode(node));\n            var constraintsNode = _innerCore.getChild(node, CONSTRAINTS_RELID);\n            var relIds = _innerCore.getChildrenRelids(constraintsNode);\n            var names = [];\n            for (var i = 0; i < relIds.length; i++) {\n                names.push(_innerCore.getAttribute(_innerCore.getChild(constraintsNode, relIds[i]), 'name'));\n            }\n            return names;\n        };\n\n        //TODO this means we always have to have this layer above type/inheritance layer\n        _core.getOwnConstraintNames = function (node) {\n            ASSERT(_innerCore.isValidNode(node));\n            var names = _core.getConstraintNames(node),\n                base = _core.getBase(node),\n                baseNames = [],\n                i, index;\n\n            if (base) {\n                baseNames = _core.getConstraintNames(base);\n            }\n\n            for (i = 0; i < baseNames.length; i++) {\n                index = names.indexOf(baseNames[i]);\n                if (index !== -1) {\n                    names.splice(index, 1);\n                }\n            }\n\n            return names;\n        };\n\n        return _core;\n    }\n\n    return constraintCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author mmaroti / https://github.com/mmaroti\n */\n\ndefine('common/core/metacore',[\n    'common/util/assert',\n    'common/core/core',\n    'common/core/tasync',\n    'common/util/canon'\n], function (ASSERT, Core, TASYNC, CANON) {\n    'use strict';\n\n    // ----------------- CoreType -----------------\n\n    var MetaCore = function (oldcore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        // copy all operations\n        var core = {},\n            logger = options.logger.fork('metacore');\n        for (var key in oldcore) {\n            core[key] = oldcore[key];\n        }\n        logger.debug('initialized');\n        var sameNode = function (nodeA, nodeB) {\n            if (core.getPath(nodeA) === core.getPath(nodeB)) {\n                return true;\n            }\n            return false;\n        };\n\n        var realNode = function (node) { //TODO we have to make some more sophisticated distinction\n            if (core.getPath(node).indexOf('_') !== -1) {\n                return false;\n            }\n            return true;\n        };\n\n        var getMetaNode = function (node) {\n            return core.getChild(node, '_meta');\n        };\n        var getMetaChildrenNode = function (node) {\n            return core.getChild(getMetaNode(node), 'children');\n        };\n        var getMetaPointerNode = function (node, name) {\n            var meta = getMetaNode(node),\n                pointerNames = core.getPointerNames(meta) || [];\n            if (pointerNames.indexOf(name) !== -1) {\n                return core.getChild(meta, '_p_' + name);\n            }\n            return null;\n        };\n        var _MetaPointerNode = function (node, name) {\n            //this function always gives back a node, use this if you just want to create the node as well\n            core.setPointer(getMetaNode(node), name, null);\n            return core.getChild(getMetaNode(node), '_p_' + name);\n        };\n\n        var getMetaAspectsNode = function (node) {\n            return core.getChild(getMetaNode(node), 'aspects');\n        };\n        var getMetaAspectNode = function (node, name) {\n            var aspectNode = getMetaAspectsNode(node),\n                names = core.getPointerNames(aspectNode) || [];\n            if (names.indexOf(name) !== -1) {\n                return core.getChild(aspectNode, '_a_' + name);\n            }\n            return null;\n        };\n\n        var _MetaAspectNode = function (node, name) {\n            //this function always gives back a node, use this if you just want to create the node as well\n            var aspectNode = core.getChild(getMetaNode(node), 'aspects');\n\n            core.setPointer(aspectNode, name, null);\n            return core.getChild(aspectNode, '_a_' + name);\n        };\n        //now the additional functions\n        core.isTypeOf = function (node, typeNode) {\n            if (!realNode(node)) {\n                return false;\n            }\n            while (node) {\n                if (sameNode(node, typeNode)) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n            return false;\n        };\n\n        core.isValidChildOf = function (node, parentNode) {\n            if (!realNode(node)) {\n                return true;\n            }\n            var validChildTypePaths = core.getMemberPaths(getMetaChildrenNode(parentNode), 'items') || [];\n            while (node) {\n                if (validChildTypePaths.indexOf(core.getPath(node)) !== -1) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n            return false;\n        };\n\n        core.getValidPointerNames = function (node) {\n            var validNames = core.getPointerNames(getMetaNode(node)) || [],\n                i,\n                validPointerNames = [],\n                metaPointerNode, max;\n            for (i = 0; i < validNames.length; i++) {\n                metaPointerNode = getMetaPointerNode(node, validNames[i]);\n                max = core.getAttribute(metaPointerNode, 'max');\n                if (max === 1) {\n                    //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\n                    validPointerNames.push(validNames[i]);\n                }\n            }\n\n            return validPointerNames;\n        };\n\n        core.getValidSetNames = function (node) {\n            var validNames = core.getPointerNames(getMetaNode(node)) || [],\n                i,\n                validSetNames = [],\n                metaPointerNode, max;\n\n            for (i = 0; i < validNames.length; i++) {\n                metaPointerNode = getMetaPointerNode(node, validNames[i]);\n                max = core.getAttribute(metaPointerNode, 'max');\n                if (max === undefined || max === -1 || max > 1) {\n                    //TODO specify what makes something a pointer and what a set??? - can you extend a pointer to a set????\n                    validSetNames.push(validNames[i]);\n                }\n            }\n\n            return validSetNames;\n        };\n\n        core.isValidTargetOf = function (node, source, name) {\n            if (!realNode(source) || node === null) { //we position ourselves over the null-pointer layer\n                return true;\n            }\n            var pointerMetaNode = getMetaPointerNode(source, name);\n            if (pointerMetaNode) {\n                var validTargetTypePaths = core.getMemberPaths(pointerMetaNode, 'items') || [];\n                while (node) {\n                    if (validTargetTypePaths.indexOf(core.getPath(node)) !== -1) {\n                        return true;\n                    }\n                    node = core.getBase(node);\n                }\n            }\n            return false;\n        };\n\n        core.getValidAttributeNames = function (node) {\n            var names = [];\n            if (realNode(node)) {\n                names = core.getAttributeNames(getMetaNode(node)) || [];\n            }\n            return names;\n        };\n\n        core.isValidAttributeValueOf = function (node, name, value) {\n            //currently it only checks the name and the type\n            if (!realNode(node)) {\n                return true;\n            }\n            if (core.getValidAttributeNames(node).indexOf(name) === -1) {\n                return false;\n            }\n            var meta = core.getAttribute(getMetaNode(node), name);\n            switch (meta.type) {\n                case 'boolean':\n                    if (value === true || value === false) {\n                        return true;\n                    }\n                    break;\n                case 'string':\n                case 'asset':\n                    if (typeof value === 'string') {\n                        return true;\n                    }\n                    break;\n                case 'integer':\n                    if (!isNaN(parseInt(value)) && parseFloat(value) === parseInt(value)) {\n                        return true;\n                    }\n                    break;\n                case 'float':\n                    if (!isNaN(parseFloat(value))) {\n                        return true;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            return false;\n        };\n\n\n        core.getValidAspectNames = function (node) {\n            return core.getPointerNames(getMetaAspectsNode(node)) || [];\n        };\n\n        //additional meta functions for getting meta definitions\n        core.getJsonMeta = function (node) {\n            var meta = {children: {}, attributes: {}, pointers: {}, aspects: {}, constraints: {}},\n                tempNode,\n                names,\n                pointer,\n                i, j;\n\n            //fill children part\n            tempNode = getMetaChildrenNode(node);\n\n            meta.children.minItems = [];\n            meta.children.maxItems = [];\n            meta.children.items = core.getMemberPaths(tempNode, 'items');\n            for (i = 0; i < meta.children.items.length; i++) {\n                meta.children.minItems.push(\n                    core.getMemberAttribute(tempNode, 'items', meta.children.items[i], 'min') || -1);\n\n                meta.children.maxItems.push(\n                    core.getMemberAttribute(tempNode, 'items', meta.children.items[i], 'max') || -1);\n            }\n            meta.children.min = core.getAttribute(tempNode, 'min');\n            meta.children.max = core.getAttribute(tempNode, 'max');\n\n            //attributes\n            names = core.getValidAttributeNames(node);\n            for (i = 0; i < names.length; i++) {\n                meta.attributes[names[i]] = core.getAttribute(getMetaNode(node), names[i]);\n            }\n\n            //pointers\n            names = core.getPointerNames(getMetaNode(node));\n            for (i = 0; i < names.length; i++) {\n                tempNode = getMetaPointerNode(node, names[i]);\n                pointer = {};\n\n                pointer.items = core.getMemberPaths(tempNode, 'items');\n                pointer.min = core.getAttribute(tempNode, 'min');\n                pointer.max = core.getAttribute(tempNode, 'max');\n                pointer.minItems = [];\n                pointer.maxItems = [];\n\n                for (j = 0; j < pointer.items.length; j++) {\n                    pointer.minItems.push(core.getMemberAttribute(tempNode, 'items', pointer.items[j], 'min') || -1);\n                    pointer.maxItems.push(core.getMemberAttribute(tempNode, 'items', pointer.items[j], 'max') || -1);\n\n                }\n\n                meta.pointers[names[i]] = pointer;\n            }\n\n            //aspects\n            names = core.getValidAspectNames(node);\n\n            for (i = 0; i < names.length; i++) {\n                tempNode = getMetaAspectNode(node, names[i]);\n                meta.aspects[names[i]] = core.getMemberPaths(tempNode, 'items') || [];\n            }\n\n            //constraints\n            names = core.getConstraintNames(node);\n            for (i = 0; i < names.length; i++) {\n                meta.constraints[names[i]] = core.getConstraint(node, names[i]);\n            }\n\n            return meta;\n        };\n\n        var getMetaObjectDiff = function (bigger, smaller) {\n            //TODO this is a specific diff calculation for META rule JSONs\n            var diff = {},\n                names, i,\n                itemedElementDiff = function (bigItem, smallItem) {\n                    var diffItems = {},\n                        diff, i, index, names;\n                    for (i = 0; i < bigItem.items.length; i++) {\n                        if (smallItem.items.indexOf(bigItem.items[i]) === -1) {\n                            diffItems[bigItem.items[i]] = true;\n                        }\n                    }\n                    names = Object.keys(diffItems);\n                    for (i = 0; i < names.length; i++) {\n                        diff = diff || {items: [], minItems: [], maxItems: []};\n                        index = bigItem.items.indexOf(names[i]);\n                        diff.items.push(bigItem.items[index]);\n                        diff.minItems.push(bigItem.minItems[index]);\n                        diff.maxItems.push(bigItem.maxItems[index]);\n\n                    }\n                    if (bigItem.min && ((smallItem.min && bigItem.min !== smallItem.min) || !smallItem.min)) {\n                        diff = diff || {};\n                        diff.min = bigItem.min;\n                    }\n                    if (bigItem.max && ((smallItem.max && bigItem.max !== smallItem.max) || !smallItem.max)) {\n                        diff = diff || {};\n                        diff.max = bigItem.max;\n                    }\n                    return diff || {};\n                };\n            //attributes\n            if (smaller.attributes) {\n                names = Object.keys(bigger.attributes);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.attributes[names[i]]) {\n                        //they both have the attribute - if it differs we keep the whole of the bigger\n                        if (CANON.stringify(smaller.attributes[names[i]] !==\n                            CANON.stringify(bigger.attributes[names[i]]))) {\n\n                            diff.attributes = diff.attributes || {};\n                            diff.attributes[names[i]] = bigger.attributes[names[i]];\n                        }\n                    } else {\n                        diff.attributes = diff.attributes || {};\n                        diff.attributes[names[i]] = bigger.attributes[names[i]];\n                    }\n                }\n            } else if (bigger.attributes) {\n                diff.attributes = bigger.attributes;\n            }\n            //children\n            if (smaller.children) {\n                diff.children = itemedElementDiff(bigger.children, smaller.children);\n                if (Object.keys(diff.children).length < 1) {\n                    delete diff.children;\n                }\n            } else if (bigger.children) {\n                diff.children = bigger.children;\n            }\n            //pointers\n            if (smaller.pointers) {\n                diff.pointers = {};\n                names = Object.keys(bigger.pointers);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.pointers[names[i]]) {\n                        diff.pointers[names[i]] = itemedElementDiff(bigger.pointers[names[i]],\n                            smaller.pointers[names[i]]);\n                        if (Object.keys(diff.pointers[names[i]]).length < 1) {\n                            delete diff.pointers[names[i]];\n                        }\n                    } else {\n                        diff.pointers[names[i]] = bigger.pointers[names[i]];\n                    }\n                }\n            } else if (bigger.pointers) {\n                diff.pointers = bigger.pointers;\n            }\n            if (Object.keys(diff.pointers).length < 1) {\n                delete diff.pointers;\n            }\n            //aspects\n            if (smaller.aspects) {\n                diff.aspects = {};\n                names = Object.keys(bigger.aspects);\n                for (i = 0; i < names.length; i++) {\n                    if (smaller.aspects[names[i]]) {\n                        smaller.aspects[names[i]] = smaller.aspects[names[i]].sort();\n                        bigger.aspects[names[i]] = bigger.aspects[names[i]].sort();\n                        if (bigger.aspects[names[i]].length > smaller.aspects[names[i]].length) {\n                            diff.aspects[names[i]] = bigger.aspects[names[i]].slice(smaller.aspects[names[i]].length);\n                        }\n                    } else {\n                        diff.aspects[names[i]] = bigger.aspects[names[i]];\n                    }\n                }\n            } else if (bigger.aspects) {\n                diff.aspects = bigger.aspects;\n            }\n\n            if (Object.keys(diff.aspects).length < 1) {\n                delete diff.aspects;\n            }\n            return diff;\n        };\n\n        core.getOwnJsonMeta = function (node) {\n            var base = core.getBase(node),\n                baseMeta = base ? core.getJsonMeta(base) : {},\n                meta = core.getJsonMeta(node);\n\n            return getMetaObjectDiff(meta, baseMeta);\n        };\n\n        core.clearMetaRules = function (node) {\n            core.deleteNode(getMetaNode(node), true);\n        };\n\n        core.setAttributeMeta = function (node, name, value) {\n            ASSERT(typeof value === 'object' && typeof name === 'string' && name);\n\n            core.setAttribute(getMetaNode(node), name, value);\n        };\n        core.delAttributeMeta = function (node, name) {\n            core.delAttribute(getMetaNode(node), name);\n        };\n        core.getAttributeMeta = function (node, name) {\n            return core.getAttribute(getMetaNode(node), name);\n        };\n\n        core.getValidChildrenPaths = function (node) {\n            return core.getMemberPaths(getMetaChildrenNode(node), 'items');\n        };\n        core.setChildMeta = function (node, child, min, max) {\n            core.addMember(getMetaChildrenNode(node), 'items', child);\n            min = min || -1;\n            max = max || -1;\n            core.setMemberAttribute(getMetaChildrenNode(node), 'items', core.getPath(child), 'min', min);\n            core.setMemberAttribute(getMetaChildrenNode(node), 'items', core.getPath(child), 'max', max);\n        };\n        core.delChildMeta = function (node, childPath) {\n            core.delMember(getMetaChildrenNode(node), 'items', childPath);\n        };\n        core.setChildrenMetaLimits = function (node, min, max) {\n            if (min) {\n                core.setAttribute(getMetaChildrenNode(node), 'min', min);\n            }\n            if (max) {\n                core.setAttribute(getMetaChildrenNode(node), 'max', max);\n            }\n        };\n\n        core.setPointerMetaTarget = function (node, name, target, min, max) {\n            core.addMember(_MetaPointerNode(node, name), 'items', target);\n            min = min || -1;\n            core.setMemberAttribute(_MetaPointerNode(node, name), 'items', core.getPath(target), 'min', min);\n            max = max || -1;\n            core.setMemberAttribute(_MetaPointerNode(node, name), 'items', core.getPath(target), 'max', max);\n        };\n        core.delPointerMetaTarget = function (node, name, targetPath) {\n            var metaNode = getMetaPointerNode(node, name);\n            if (metaNode) {\n                core.delMember(metaNode, 'items', targetPath);\n            }\n        };\n        core.setPointerMetaLimits = function (node, name, min, max) {\n            if (min) {\n                core.setAttribute(_MetaPointerNode(node, name), 'min', min);\n            }\n            if (max) {\n                core.setAttribute(_MetaPointerNode(node, name), 'max', max);\n            }\n        };\n        core.delPointerMeta = function (node, name) {\n            core.deleteNode(_MetaPointerNode(node, name), true);\n            core.deletePointer(getMetaNode(node), name);\n        };\n\n        core.setAspectMetaTarget = function (node, name, target) {\n            core.addMember(_MetaAspectNode(node, name), 'items', target);\n        };\n        core.delAspectMetaTarget = function (node, name, targetPath) {\n            var metaNode = getMetaAspectNode(node, name);\n            if (metaNode) {\n                core.delMember(metaNode, 'items', targetPath);\n            }\n        };\n        core.delAspectMeta = function (node, name) {\n            core.deleteNode(_MetaAspectNode(node, name), true);\n            core.deletePointer(getMetaAspectsNode(node), name);\n        };\n\n        //type related extra query functions\n        var isOnMetaSheet = function (node) {\n            //MetaAspectSet\n            var sets = core.isMemberOf(node);\n\n            if (sets && sets[''] && sets[''].indexOf('MetaAspectSet') !== -1) {\n                //TODO this is all should be global constant values\n                return true;\n            }\n            return false;\n        };\n        core.getBaseType = function (node) {\n            //TODO this functions now uses the fact that we think of META as the MetaSetContainer of the ROOT\n            while (node) {\n                if (isOnMetaSheet(node)) {\n                    return node;\n                }\n                node = core.getBase(node);\n            }\n            return null;\n        };\n        core.isInstanceOf = function (node, name) {\n            //TODO this is name based query - doesn't check the node's own name\n            node = core.getBase(node);\n            while (node) {\n                if (core.getAttribute(node, 'name') === name) {\n                    return true;\n                }\n                node = core.getBase(node);\n            }\n\n            return false;\n        };\n\n        return core;\n    };\n\n    return MetaCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/coretreeloader',['common/util/assert', 'common/core/core', 'common/core/tasync'], function (ASSERT, Core, TASYNC) {\n    'use strict';\n\n    // ----------------- CoreTreeLoader -----------------\n\n    var MetaCore = function (innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var core = {},\n            key,\n            logger = options.logger.fork('coretreeloader');\n        for (key in innerCore) {\n            core[key] = innerCore[key];\n        }\n        logger.debug('initialized');\n        //adding load functions\n        core.loadSubTree = function (root) {\n            var loadSubTrees = function (nodes) {\n                for (var i = 0; i < nodes.length; i++) {\n                    nodes[i] = core.loadSubTree(nodes[i]);\n                }\n                return TASYNC.lift(nodes);\n\n            };\n            return TASYNC.call(function (children) {\n                if (children.length < 1) {\n                    return [root];\n                } else {\n                    return TASYNC.call(function (subArrays) {\n                        var nodes = [],\n                            i;\n                        for (i = 0; i < subArrays.length; i++) {\n                            nodes = nodes.concat(subArrays[i]);\n                        }\n                        nodes.unshift(root);\n                        return nodes;\n                    }, loadSubTrees(children));\n                }\n            }, core.loadChildren(root));\n        };\n        core.loadTree = function (rootHash) {\n            return TASYNC.call(core.loadSubTree, core.loadRoot(rootHash));\n        };\n\n        return core;\n    };\n    return MetaCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n// TODO: This files needs refactoring\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/corediff',['common/util/canon', 'common/core/tasync', 'common/util/assert'], function (CANON, TASYNC, ASSERT) {\n    'use strict';\n\n    function diffCore(_innerCore, options) {\n        ASSERT(typeof options === 'object');\n        ASSERT(typeof options.globConf === 'object');\n        ASSERT(typeof options.logger !== 'undefined');\n        var _core = {},\n            logger = options.logger.fork('corediff'),\n            _yetToCompute = {},\n            _DIFF = {},\n            _needChecking = true,\n            _rounds = 0,\n            TODELETESTRING = '*to*delete*',\n            toFrom = {}, //TODO should not be global\n            fromTo = {}, //TODO should not be global\n            _concatResult,\n            _diffMoves = {},\n            _conflictItems = [],\n            _conflictMine,\n            _conflictTheirs,\n            _concatBase,\n            _concatExtension,\n            _concatBaseRemovals,\n            _concatMoves;\n\n        logger.debug('initialized');\n        for (var i in _innerCore) {\n            _core[i] = _innerCore[i];\n        }\n\n        function normalize(obj) {\n            if (!obj) {\n                return obj;\n            }\n            var keys = Object.keys(obj),\n                i;\n            if (JSON.stringify(obj.set) === JSON.stringify({})) {\n                delete obj.set;\n            }\n\n            for (i = 0; i < keys.length; i++) {\n                /*if (Array.isArray(obj[keys[i]])) {\n                 if (obj[keys[i]].length === 0) {\n                 delete obj[keys[i]];\n                 }*/\n                if (Array.isArray(obj[keys[i]])) {\n                    //do nothing, leave the array as is\n                } else if (obj[keys[i]] === undefined) {\n                    delete obj[keys[i]]; //there cannot be undefined in the object\n                } else if (keys[i] === 'set') {\n                    //do nothing with set as it can include empty set's as well\n                } else if (typeof obj[keys[i]] === 'object') {\n                    normalize(obj[keys[i]]);\n                    if (obj[keys[i]] && Object.keys(obj[keys[i]]).length === 0) {\n                        delete obj[keys[i]];\n                    }\n                }\n            }\n            keys = Object.keys(obj);\n            if (keys.length === 1) {\n                //it only has the GUID, so the node doesn't changed at all\n                delete obj.guid;\n            }\n        }\n\n        function attrDiff(source, target) {\n            var sNames = _core.getOwnAttributeNames(source),\n                tNames = _core.getOwnAttributeNames(target),\n                i,\n                diff = {};\n\n            for (i = 0; i < sNames.length; i++) {\n                if (tNames.indexOf(sNames[i]) === -1) {\n                    diff[sNames[i]] = TODELETESTRING;\n                }\n            }\n\n            for (i = 0; i < tNames.length; i++) {\n                if (_core.getAttribute(source, tNames[i]) === undefined) {\n                    diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\n                } else {\n                    if (CANON.stringify(_core.getAttribute(source, tNames[i])) !==\n                        CANON.stringify(_core.getAttribute(target, tNames[i]))) {\n\n                        diff[tNames[i]] = _core.getAttribute(target, tNames[i]);\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        function regDiff(source, target) {\n            var sNames = _core.getOwnRegistryNames(source),\n                tNames = _core.getOwnRegistryNames(target),\n                i,\n                diff = {};\n\n            for (i = 0; i < sNames.length; i++) {\n                if (tNames.indexOf(sNames[i]) === -1) {\n                    diff[sNames[i]] = TODELETESTRING;\n                }\n            }\n\n            for (i = 0; i < tNames.length; i++) {\n                if (_core.getRegistry(source, tNames[i]) === undefined) {\n                    diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\n                } else {\n                    if (CANON.stringify(_core.getRegistry(source, tNames[i])) !==\n                        CANON.stringify(_core.getRegistry(target, tNames[i]))) {\n\n                        diff[tNames[i]] = _core.getRegistry(target, tNames[i]);\n                    }\n                }\n            }\n\n            return diff;\n        }\n\n        function childrenDiff(source, target) {\n            var sRelids = _core.getChildrenRelids(source),\n                tRelids = _core.getChildrenRelids(target),\n                tHashes = _core.getChildrenHashes(target),\n                sHashes = _core.getChildrenHashes(source),\n                i,\n                diff = {added: [], removed: []};\n\n            for (i = 0; i < sRelids.length; i++) {\n                if (tRelids.indexOf(sRelids[i]) === -1) {\n                    diff.removed.push({relid: sRelids[i], hash: sHashes[sRelids[i]]});\n                }\n            }\n\n            for (i = 0; i < tRelids.length; i++) {\n                if (sRelids.indexOf(tRelids[i]) === -1) {\n                    diff.added.push({relid: tRelids[i], hash: tHashes[tRelids[i]]});\n                }\n            }\n\n            return diff;\n\n        }\n\n        function pointerDiff(source, target) {\n            var getPointerData = function (node) {\n                    var data = {},\n                        names = _core.getPointerNames(node),\n                        i;\n                    for (i = 0; i < names.length; i++) {\n                        data[names[i]] = _core.getPointerPath(node, names[i]);\n                    }\n                    return data;\n                },\n                sPointer = getPointerData(source),\n                tPointer = getPointerData(target);\n\n            if (CANON.stringify(sPointer) !== CANON.stringify(tPointer)) {\n                return {source: sPointer, target: tPointer};\n            }\n            return {};\n        }\n\n        function setDiff(source, target) {\n            var getSetData = function (node) {\n                    var data = {},\n                        names, targets, keys, i, j, k;\n\n                    names = _core.getSetNames(node);\n                    for (i = 0; i < names.length; i++) {\n                        data[names[i]] = {};\n                        targets = _core.getMemberPaths(node, names[i]);\n                        for (j = 0; j < targets.length; j++) {\n                            data[names[i]][targets[j]] = {attr: {}, reg: {}};\n                            keys = _core.getMemberOwnAttributeNames(node, names[i], targets[j]);\n                            for (k = 0; k < keys.length; k++) {\n                                data[names[i]][targets[j]].attr[keys[k]] = _core.getMemberAttribute(node,\n                                    names[i], targets[j], keys[k]);\n                            }\n                            keys = _core.getMemberRegistryNames(node, names[i], targets[j]);\n                            for (k = 0; k < keys.length; k++) {\n                                data[names[i]][targets[j]].reg[keys[k]] = _core.getMemberRegistry(node,\n                                    names[i], targets[j], keys[k]);\n                            }\n                        }\n                    }\n\n                    return data;\n\n                },\n                sSet = getSetData(source),\n                tSet = getSetData(target);\n\n            if (CANON.stringify(sSet) !== CANON.stringify(tSet)) {\n                return {source: sSet, target: tSet};\n            }\n            return {};\n        }\n\n        function ovrDiff(source, target) {\n            var getOvrData = function (node) {\n                    var paths, names, i, j,\n                        ovr = _core.getProperty(node, 'ovr') || {},\n                        data = {},\n                        base = _core.getPath(node);\n\n                    paths = Object.keys(ovr);\n                    for (i = 0; i < paths.length; i++) {\n                        if (paths[i].indexOf('_') === -1) {\n                            data[paths[i]] = {};\n                            names = Object.keys(ovr[paths[i]]);\n                            for (j = 0; j < names.length; j++) {\n                                if (ovr[paths[i]][names[j]] === '/_nullptr') {\n                                    data[paths[i]][names[j]] = null;\n                                } else if (names[j].slice(-4) !== '-inv' &&\n                                    ovr[paths[i]][names[j]].indexOf('_') === -1) {\n\n                                    data[paths[i]][names[j]] = _core.joinPaths(base, ovr[paths[i]][names[j]]);\n                                }\n                            }\n                        }\n                    }\n                    return data;\n                },\n                sOvr = getOvrData(source),\n                tOvr = getOvrData(target);\n\n            if (CANON.stringify(sOvr) !== CANON.stringify(tOvr)) {\n                return {source: sOvr, target: tOvr};\n            }\n            return {};\n        }\n\n        function metaDiff(source, target) {\n            //TODO jsonMeta format should be changed in all places!!!\n            var convertJsonMeta = function (jsonMeta) {\n                    var i, j, names, itemsObject;\n                    //children\n                    if (jsonMeta.children) {\n                        itemsObject = jsonMeta.children;\n                        for (i = 0; i < itemsObject.items.length; i += 1) {\n                            itemsObject[itemsObject.items[i]] = {\n                                min: itemsObject.minItems[i],\n                                max: itemsObject.maxItems[i]\n                            };\n                        }\n                        delete itemsObject.items;\n                        delete itemsObject.minItems;\n                        delete itemsObject.maxItems;\n                    }\n                    //ptr\n                    if (jsonMeta.pointers) {\n                        names = Object.keys(jsonMeta.pointers);\n\n                        for (j = 0; j < names.length; j += 1) {\n                            itemsObject = jsonMeta.pointers[names[j]];\n                            for (i = 0; i < itemsObject.items.length; i += 1) {\n                                itemsObject[itemsObject.items[i]] = {\n                                    min: itemsObject.minItems[i],\n                                    max: itemsObject.maxItems[i]\n                                };\n                            }\n                            delete itemsObject.items;\n                            delete itemsObject.minItems;\n                            delete itemsObject.maxItems;\n                        }\n                    }\n                    return jsonMeta;\n                },\n                sMeta = convertJsonMeta(_core.getOwnJsonMeta(source)),\n                tMeta = convertJsonMeta(_core.getOwnJsonMeta(target));\n            if (CANON.stringify(sMeta) !== CANON.stringify(tMeta)) {\n                return {source: sMeta, target: tMeta};\n            }\n            return {};\n        }\n\n        function combineMoveIntoMetaDiff(diff) {\n            var keys = Object.keys(diff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (_diffMoves[keys[i]]) {\n                    diff[_diffMoves[keys[i]]] = diff[keys[i]];\n                    delete diff[keys[i]];\n                } else if (typeof diff[keys[i]] === 'object') {\n                    combineMoveIntoMetaDiff(diff[keys[i]]);\n                }\n            }\n        }\n\n        function combineMoveIntoPointerDiff(diff) {\n            var keys = Object.keys(diff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (_diffMoves[diff[keys[i]]]) {\n                    diff[keys[i]] = _diffMoves[diff[keys[i]]];\n                }\n            }\n        }\n\n        function finalizeDiff() {\n            finalizeMetaDiff(_DIFF);\n            finalizePointerDiff(_DIFF);\n            finalizeSetDiff(_DIFF);\n            normalize(_DIFF);\n        }\n\n        function finalizeMetaDiff(diff) {\n            //at this point _DIFF is ready and the _diffMoves is complete...\n            var relids = getDiffChildrenRelids(diff),\n                i, sMeta, tMeta;\n            if (diff.meta) {\n                sMeta = diff.meta.source || {};\n                tMeta = diff.meta.target || {};\n                combineMoveIntoMetaDiff(sMeta);\n                diff.meta = diffObjects(sMeta, tMeta);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizeMetaDiff(diff[relids[i]]);\n            }\n        }\n\n        function finalizePointerDiff(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, sPointer, tPointer;\n            if (diff.pointer) {\n                sPointer = diff.pointer.source || {};\n                tPointer = diff.pointer.target || {};\n                /*if(diff.movedFrom && !sPointer.base && tPointer.base){\n                 delete tPointer.base;\n                 }*/\n                combineMoveIntoPointerDiff(sPointer);\n                diff.pointer = diffObjects(sPointer, tPointer);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizePointerDiff(diff[relids[i]]);\n            }\n        }\n\n        function finalizeSetDiff(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, sSet, tSet;\n            if (diff.set) {\n                sSet = diff.set.source || {};\n                tSet = diff.set.target || {};\n                combineMoveIntoMetaDiff(sSet);\n                diff.set = diffObjects(sSet, tSet);\n            }\n            for (i = 0; i < relids.length; i++) {\n                finalizeSetDiff(diff[relids[i]]);\n            }\n        }\n\n        function isEmptyNodeDiff(diff) {\n            if (\n                Object.keys(diff.children || {}).length > 0 ||\n                Object.keys(diff.attr || {}).length > 0 ||\n                Object.keys(diff.reg || {}).length > 0 ||\n                Object.keys(diff.pointer || {}).length > 0 ||\n                Object.keys(diff.set || {}).length > 0 ||\n                diff.meta\n            ) {\n                return false;\n            }\n            return true;\n        }\n\n        function getPathOfDiff(diff, path) {\n            var pathArray = path.split('/'),\n                i;\n            pathArray.shift();\n            for (i = 0; i < pathArray.length; i++) {\n                diff[pathArray[i]] = diff[pathArray[i]] || {};\n                diff = diff[pathArray[i]];\n            }\n\n            return diff;\n        }\n\n        function extendDiffWithOvr(diff, oDiff) {\n            var i, paths, names, j, tDiff;\n            //first extend sources\n            paths = Object.keys(oDiff.source || {});\n            for (i = 0; i < paths.length; i++) {\n                tDiff = getPathOfDiff(diff, paths[i]);\n                if (tDiff.removed !== true) {\n                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};\n                    names = Object.keys(oDiff.source[paths[i]]);\n                    for (j = 0; j < names.length; j++) {\n                        tDiff.pointer.source[names[j]] = oDiff.source[paths[i]][names[j]];\n                    }\n                }\n            }\n            //then targets\n            paths = Object.keys(oDiff.target || {});\n            for (i = 0; i < paths.length; i++) {\n                tDiff = getPathOfDiff(diff, paths[i]);\n                if (tDiff.removed !== true) {\n                    tDiff.pointer = tDiff.pointer || {source: {}, target: {}};\n                    names = Object.keys(oDiff.target[paths[i]]);\n                    for (j = 0; j < names.length; j++) {\n                        tDiff.pointer.target[names[j]] = oDiff.target[paths[i]][names[j]];\n                    }\n                }\n            }\n        }\n\n        function updateDiff(sourceRoot, targetRoot) {\n            var diff = _core.nodeDiff(sourceRoot, targetRoot) || {},\n                oDiff = ovrDiff(sourceRoot, targetRoot),\n                getChild = function (childArray, relid) {\n                    for (var i = 0; i < childArray.length; i++) {\n                        if (_core.getRelid(childArray[i]) === relid) {\n                            return childArray[i];\n                        }\n                    }\n                    return null;\n                };\n            return TASYNC.call(function (sChildren, tChildren) {\n                ASSERT(sChildren.length >= 0 && tChildren.length >= 0);\n\n                var i, child, done, tDiff, guid, base,\n                    childComputationFinished = function (cDiff, relid/*, d*/) {\n                        diff[relid] = cDiff;\n                        return null;\n                    };\n\n                tDiff = diff.children ? diff.children.removed || [] : [];\n                for (i = 0; i < tDiff.length; i++) {\n                    diff.childrenListChanged = true;\n                    child = getChild(sChildren, tDiff[i].relid);\n                    if (child) {\n                        guid = _core.getGuid(child);\n                        diff[tDiff[i].relid] = {guid: guid, removed: true, hash: _core.getHash(child)};\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].from = child;\n                        _yetToCompute[guid].fromExpanded = false;\n                    }\n                }\n\n                tDiff = diff.children ? diff.children.added || [] : [];\n                for (i = 0; i < tDiff.length; i++) {\n                    diff.childrenListChanged = true;\n                    child = getChild(tChildren, tDiff[i].relid);\n                    if (child) {\n                        guid = _core.getGuid(child);\n                        base = _core.getBase(child);\n                        diff[tDiff[i].relid] = {\n                            guid: guid,\n                            removed: false,\n                            hash: _core.getHash(child),\n                            pointer: {source: {}, target: {base: base === null ? null : _core.getPath(base)}}\n                        };\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].to = child;\n                        _yetToCompute[guid].toExpanded = false;\n                    }\n                }\n\n                for (i = 0; i < tChildren.length; i++) {\n                    child = getChild(sChildren, _core.getRelid(tChildren[i]));\n                    if (child && _core.getHash(tChildren[i]) !== _core.getHash(child)) {\n                        done = TASYNC.call(childComputationFinished,\n                            updateDiff(child, tChildren[i]), _core.getRelid(child), done);\n                    }\n                }\n                return TASYNC.call(function () {\n                    delete diff.children;\n                    extendDiffWithOvr(diff, oDiff);\n                    normalize(diff);\n                    if (Object.keys(diff).length > 0) {\n                        diff.guid = _core.getGuid(targetRoot);\n                        diff.hash = _core.getHash(targetRoot);\n                        diff.oGuids = gatherObstructiveGuids(targetRoot);\n                        return TASYNC.call(function (finalDiff) {\n                            return finalDiff;\n                        }, fillMissingGuid(targetRoot, '', diff));\n                    } else {\n                        return diff;\n                    }\n\n                }, done);\n            }, _core.loadChildren(sourceRoot), _core.loadChildren(targetRoot));\n        }\n\n        function gatherObstructiveGuids(node) {\n            var result = {},\n                putParents = function (n) {\n                    while (n) {\n                        result[_core.getGuid(n)] = true;\n                        n = _core.getParent(n);\n                    }\n                };\n            while (node) {\n                putParents(node);\n                node = _core.getBase(node);\n            }\n            return result;\n        }\n\n        function fillMissingGuid(root, path, diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i,\n                done,\n                subComputationFinished = function (cDiff, relid) {\n                    diff[relid] = cDiff;\n                    return null;\n                };\n\n            for (i = 0; i < relids.length; i++) {\n                done = TASYNC.call(subComputationFinished,\n                    fillMissingGuid(root, path + '/' + relids[i], diff[relids[i]]), relids[i]);\n            }\n\n            return TASYNC.call(function () {\n                if (diff.guid) {\n                    return diff;\n                } else {\n                    return TASYNC.call(function (child) {\n                        diff.guid = _core.getGuid(child);\n                        diff.hash = _core.getHash(child);\n                        diff.oGuids = gatherObstructiveGuids(child);\n                        return diff;\n                    }, _core.loadByPath(root, path));\n                }\n            }, done);\n        }\n\n        function expandDiff(root, isDeleted) {\n            var diff = {\n                guid: _core.getGuid(root),\n                hash: _core.getHash(root),\n                removed: isDeleted === true\n            };\n            return TASYNC.call(function (children) {\n                var guid;\n                for (var i = 0; i < children.length; i++) {\n                    guid = _core.getGuid(children[i]);\n                    diff[_core.getRelid(children[i])] = {\n                        guid: guid,\n                        hash: _core.getHash(children[i]),\n                        removed: isDeleted === true\n                    };\n\n                    if (isDeleted) {\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].from = children[i];\n                        _yetToCompute[guid].fromExpanded = false;\n                    } else {\n                        _yetToCompute[guid] = _yetToCompute[guid] || {};\n                        _yetToCompute[guid].to = children[i];\n                        _yetToCompute[guid].toExpanded = false;\n                    }\n                }\n                return diff;\n            }, _core.loadChildren(root));\n        }\n\n        function insertIntoDiff(path, diff) {\n            var pathArray = path.split('/'),\n                relid = pathArray.pop(),\n                sDiff = _DIFF,\n                i;\n            pathArray.shift();\n            for (i = 0; i < pathArray.length; i++) {\n                sDiff = sDiff[pathArray[i]];\n            }\n            //sDiff[relid] = diff;\n            sDiff[relid] = mergeObjects(sDiff[relid], diff);\n        }\n\n        function diffObjects(source, target) {\n            var diff = {},\n                sKeys = Object.keys(source),\n                tKeys = Object.keys(target),\n                tDiff, i;\n            for (i = 0; i < sKeys.length; i++) {\n                if (tKeys.indexOf(sKeys[i]) === -1) {\n                    diff[sKeys[i]] = TODELETESTRING;\n                }\n            }\n            for (i = 0; i < tKeys.length; i++) {\n                if (sKeys.indexOf(tKeys[i]) === -1) {\n                    diff[tKeys[i]] = target[tKeys[i]];\n                } else {\n                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\n                        typeof target[tKeys[i]] === 'object' &&\n                        (target[tKeys[i]] !== null && source[tKeys[i]] !== null)) {\n                        tDiff = diffObjects(source[tKeys[i]], target[tKeys[i]]);\n                        if (Object.keys(tDiff).length > 0) {\n                            diff[tKeys[i]] = tDiff;\n                        }\n                    } else if (source[tKeys[i]] !== target[tKeys[i]]) {\n                        diff[tKeys[i]] = target[tKeys[i]];\n                    }\n                }\n            }\n            return diff;\n        }\n\n        function mergeObjects(source, target) {\n            var merged = {},\n                sKeys = Object.keys(source),\n                tKeys = Object.keys(target),\n                i;\n            for (i = 0; i < sKeys.length; i++) {\n                merged[sKeys[i]] = source[sKeys[i]];\n            }\n            for (i = 0; i < tKeys.length; i++) {\n                if (sKeys.indexOf(tKeys[i]) === -1) {\n                    merged[tKeys[i]] = target[tKeys[i]];\n                } else {\n                    if (typeof target[tKeys[i]] === typeof source[tKeys[i]] &&\n                        typeof target[tKeys[i]] === 'object' && !(target instanceof Array)) {\n                        merged[tKeys[i]] = mergeObjects(source[tKeys[i]], target[tKeys[i]]);\n                    } else {\n                        merged[tKeys[i]] = target[tKeys[i]];\n                    }\n                }\n            }\n\n            return merged;\n        }\n\n        function removePathFromDiff(diff, path) {\n            var relId, i, pathArray;\n            if (path === '') {\n                diff = null;\n            } else {\n                pathArray = path.split('/');\n                pathArray.shift();\n                relId = pathArray.pop();\n                for (i = 0; i < pathArray.length; i++) {\n                    diff = diff[pathArray[i]];\n                }\n                delete diff[relId];\n            }\n        }\n\n        function shrinkDiff(rootDiff) {\n            var _shrink = function (diff) {\n                if (diff) {\n                    var keys = getDiffChildrenRelids(diff),\n                        i;\n                    if (typeof diff.movedFrom === 'string') {\n                        removePathFromDiff(rootDiff, diff.movedFrom);\n                    }\n\n                    if (diff.removed !== false || typeof diff.movedFrom === 'string') {\n                        delete diff.hash;\n                    }\n\n                    if (diff.removed === true) {\n                        for (i = 0; i < keys.length; i++) {\n                            delete diff[keys[i]];\n                        }\n                    } else {\n\n                        for (i = 0; i < keys.length; i++) {\n                            _shrink(diff[keys[i]]);\n                        }\n                    }\n                }\n            };\n            _shrink(rootDiff);\n        }\n\n        function checkRound() {\n            var guids = Object.keys(_yetToCompute),\n                done, ytc,\n                i,\n                computingMove = function (mDiff, info) {\n                    mDiff.guid = _core.getGuid(info.from);\n                    mDiff.movedFrom = _core.getPath(info.from);\n                    mDiff.ooGuids = gatherObstructiveGuids(info.from);\n                    _diffMoves[_core.getPath(info.from)] = _core.getPath(info.to);\n                    insertAtPath(_DIFF, _core.getPath(info.to), mDiff);\n                    return null;\n                },\n                expandFrom = function (mDiff, info) {\n                    mDiff.hash = _core.getHash(info.from);\n                    mDiff.removed = true;\n                    insertIntoDiff(_core.getPath(info.from), mDiff);\n                    return null;\n                },\n                expandTo = function (mDiff, info) {\n                    if (!mDiff.hash) {\n                        mDiff.hash = _core.getHash(info.to);\n                    }\n                    mDiff.removed = false;\n                    insertIntoDiff(_core.getPath(info.to), mDiff);\n                    return null;\n                };\n\n            if (_needChecking !== true || guids.length < 1) {\n                shrinkDiff(_DIFF);\n                finalizeDiff();\n                return _DIFF;\n            }\n            _needChecking = false;\n            for (i = 0; i < guids.length; i++) {\n                ytc = _yetToCompute[guids[i]];\n                if (ytc.from && ytc.to) {\n                    //move\n                    _needChecking = true;\n                    delete _yetToCompute[guids[i]];\n                    done = TASYNC.call(computingMove, updateDiff(ytc.from, ytc.to), ytc);\n                } else {\n                    if (ytc.from && ytc.fromExpanded === false) {\n                        //expand from\n                        ytc.fromExpanded = true;\n                        _needChecking = true;\n                        done = TASYNC.call(expandFrom, expandDiff(ytc.from, true), ytc);\n                    } else if (ytc.to && ytc.toExpanded === false) {\n                        //expand to\n                        ytc.toExpanded = true;\n                        _needChecking = true;\n                        done = TASYNC.call(expandTo, expandDiff(ytc.to, false), ytc);\n                    }\n                }\n            }\n            return TASYNC.call(checkRound, done);\n        }\n\n        _core.nodeDiff = function (source, target) {\n            var diff = {\n                children: childrenDiff(source, target),\n                attr: attrDiff(source, target),\n                reg: regDiff(source, target),\n                pointer: pointerDiff(source, target),\n                set: setDiff(source, target),\n                meta: metaDiff(source, target)\n            };\n\n            normalize(diff);\n            return isEmptyNodeDiff(diff) ? null : diff;\n        };\n\n        _core.generateTreeDiff = function (sRoot, tRoot) {\n            _yetToCompute = {};\n            _DIFF = {};\n            _diffMoves = {};\n            _needChecking = true;\n            _rounds = 0;\n            return TASYNC.call(function (d) {\n                _DIFF = d;\n                return checkRound();\n            }, updateDiff(sRoot, tRoot));\n        };\n\n        _core.generateLightTreeDiff = function (sRoot, tRoot) {\n            return updateDiff(sRoot, tRoot);\n        };\n\n        function getDiffChildrenRelids(diff) {\n            var keys = Object.keys(diff),\n                i,\n                filteredKeys = [],\n                forbiddenWords = {\n                    guid: true,\n                    hash: true,\n                    attr: true,\n                    reg: true,\n                    pointer: true,\n                    set: true,\n                    meta: true,\n                    removed: true,\n                    movedFrom: true,\n                    childrenListChanged: true,\n                    oGuids: true,\n                    ooGuids: true,\n                    min: true,\n                    max: true\n                };\n            for (i = 0; i < keys.length; i++) {\n                if (!forbiddenWords[keys[i]]) {\n                    filteredKeys.push(keys[i]);\n                }\n            }\n            return filteredKeys;\n        }\n\n        function getMoveSources(diff, path, toFrom, fromTo) {\n            var relids = getDiffChildrenRelids(diff),\n                i;\n\n            for (i = 0; i < relids.length; i++) {\n                getMoveSources(diff[relids[i]], path + '/' + relids[i], toFrom, fromTo);\n            }\n\n            if (typeof diff.movedFrom === 'string') {\n                toFrom[path] = diff.movedFrom;\n                fromTo[diff.movedFrom] = path;\n            }\n        }\n\n        function getAncestor(node, path) {\n            var ownPath = _core.getPath(node),\n                ancestorPath = '',\n                i, ownPathArray, pathArray;\n            pathArray = path.split('/');\n            ownPathArray = ownPath.split('/');\n            ownPathArray.shift();\n            pathArray.shift();\n            for (i = 0; i < ownPathArray.length; i++) {\n                if (ownPathArray[i] === pathArray[i]) {\n                    ancestorPath = ancestorPath + '/' + ownPathArray[i];\n                } else {\n                    break;\n                }\n            }\n            while (ownPath !== ancestorPath) {\n                node = _core.getParent(node);\n                ownPath = _core.getPath(node);\n            }\n            return node;\n        }\n\n        function setBaseOfNewNode(node, relid, basePath) {\n            //TODO this is a kind of low level hack so maybe there should be another way to do this\n            var ancestor = getAncestor(node, basePath),\n                sourcePath = _core.getPath(node).substr(_core.getPath(ancestor).length),\n                targetPath = basePath.substr(_core.getPath(ancestor).length);\n            sourcePath = sourcePath + '/' + relid;\n            _innerCore.overlayInsert(_core.getChild(ancestor, 'ovr'), sourcePath, 'base', targetPath);\n        }\n\n        function makeInitialContainmentChanges(node, diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i, done, child, moved,\n                moving = function (n, di, p, m/*, d*/) {\n                    if (m === true) {\n                        n = _core.moveNode(n, p);\n                    }\n                    return makeInitialContainmentChanges(n, di);\n                };\n\n            for (i = 0; i < relids.length; i++) {\n                moved = false;\n                if (diff[relids[i]].movedFrom) {\n                    //moved node\n                    moved = true;\n                    child = _core.loadByPath(_core.getRoot(node), diff[relids[i]].movedFrom);\n                } else if (diff[relids[i]].removed === false) {\n                    //added node\n                    //first we hack the pointer, then we create the node\n                    if (diff[relids[i]].pointer && diff[relids[i]].pointer.base) {\n                        //we can set base if the node has one, otherwise it is 'inheritance internal' node\n                        setBaseOfNewNode(node, relids[i], diff[relids[i]].pointer.base);\n                    }\n                    if (diff[relids[i]].hash) {\n                        _core.setProperty(node, relids[i], diff[relids[i]].hash);\n                        child = _core.loadChild(node, relids[i]);\n                    } else {\n                        child = _core.getChild(node, relids[i]);\n                        _core.setHashed(child, true);\n                    }\n                } else {\n                    //simple node\n                    child = _core.loadChild(node, relids[i]);\n                }\n\n                done = TASYNC.call(moving, child, diff[relids[i]], node, moved, done);\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyNodeChange(root, path, nodeDiff) {\n            //check for move\n            var node;\n            node = _core.loadByPath(root, path);\n\n            return TASYNC.call(function (n) {\n                var done,\n                    relids = getDiffChildrenRelids(nodeDiff),\n                    i;\n                if (nodeDiff.removed === true) {\n                    _core.deleteNode(n);\n                    return;\n                }\n                applyAttributeChanges(n, nodeDiff.attr || {});\n                applyRegistryChanges(n, nodeDiff.reg || {});\n                done = applyPointerChanges(n, nodeDiff.pointer || {});\n                done = TASYNC.call(applySetChanges, n, nodeDiff.set || {}, done);\n                if (nodeDiff.meta) {\n                    delete nodeDiff.meta.empty;\n                    done = TASYNC.call(applyMetaChanges, n, nodeDiff.meta, done);\n                }\n                for (i = 0; i < relids.length; i++) {\n                    /*done = TASYNC.call(function () {\n                     return null;\n                     }, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]), done);*/\n                    done = TASYNC.join(done, applyNodeChange(root, path + '/' + relids[i], nodeDiff[relids[i]]));\n                }\n                /*TASYNC.call(function (d) {\n                 return done;\n                 }, done);*/\n                return done;\n            }, node);\n        }\n\n        function applyAttributeChanges(node, attrDiff) {\n            var i, keys;\n            keys = Object.keys(attrDiff);\n            for (i = 0; i < keys.length; i++) {\n                if (attrDiff[keys[i]] === TODELETESTRING) {\n                    _core.delAttribute(node, keys[i]);\n                } else {\n                    _core.setAttribute(node, keys[i], attrDiff[keys[i]]);\n                }\n            }\n        }\n\n        function applyRegistryChanges(node, regDiff) {\n            var i, keys;\n            keys = Object.keys(regDiff);\n            for (i = 0; i < keys.length; i++) {\n                if (regDiff[keys[i]] === TODELETESTRING) {\n                    _core.delRegistry(node, keys[i]);\n                } else {\n                    _core.setRegistry(node, keys[i], regDiff[keys[i]]);\n                }\n            }\n        }\n\n        function setPointer(node, name, target) {\n            var targetNode;\n            if (target === null) {\n                targetNode = null;\n            } else {\n                if (fromTo[target]) {\n                    target = fromTo[target];\n                }\n                targetNode = _core.loadByPath(_core.getRoot(node), target);\n            }\n            return TASYNC.call(function (t) {\n                //TODO watch if handling of base changes!!!\n                _core.setPointer(node, name, t);\n                return;\n            }, targetNode);\n        }\n\n        function applyPointerChanges(node, pointerDiff) {\n            var done,\n                keys = Object.keys(pointerDiff),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                if (pointerDiff[keys[i]] === TODELETESTRING) {\n                    _core.deletePointer(node, keys[i]);\n                } else {\n                    done = setPointer(node, keys[i], pointerDiff[keys[i]]);\n                }\n            }\n\n            return TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n\n        }\n\n        function addMember(node, name, target, data) {\n            var memberAttrSetting = function (diff) {\n                    var keys = _core.getMemberOwnAttributeNames(node, name, target),\n                        i;\n                    for (i = 0; i < keys.length; i++) {\n                        _core.delMemberAttribute(node, name, target, keys[i]);\n                    }\n\n                    keys = Object.keys(diff);\n                    for (i = 0; i < keys.length; i++) {\n                        _core.setMemberAttribute(node, name, target, keys[i], diff[keys[i]]);\n                    }\n                },\n                memberRegSetting = function (diff) {\n                    var keys = _core.getMemberOwnRegistryNames(node, name, target),\n                        i;\n                    for (i = 0; i < keys.length; i++) {\n                        _core.delMemberRegistry(node, name, target, keys[i]);\n                    }\n\n                    keys = Object.keys(diff);\n                    for (i = 0; i < keys.length; i++) {\n                        _core.setMemberRegistry(node, name, target, keys[i], diff[keys[i]]);\n                    }\n                };\n            return TASYNC.call(function (t) {\n                _core.addMember(node, name, t);\n                memberAttrSetting(data.attr || {});\n                memberRegSetting(data.reg || {});\n                return;\n            }, _core.loadByPath(_core.getRoot(node), target));\n        }\n\n        function applySetChanges(node, setDiff) {\n            var done,\n                setNames = Object.keys(setDiff),\n                elements, i, j;\n            for (i = 0; i < setNames.length; i++) {\n                if (setDiff[setNames[i]] === TODELETESTRING) {\n                    _core.deleteSet(node, setNames[i]);\n                } else {\n                    _core.createSet(node, setNames[i]);\n                    elements = Object.keys(setDiff[setNames[i]]);\n                    for (j = 0; j < elements.length; j++) {\n                        if (setDiff[setNames[i]][elements[j]] === TODELETESTRING) {\n                            _core.delMember(node, setNames[i], elements[j]);\n                        } else {\n                            done = addMember(node, setNames[i], elements[j], setDiff[setNames[i]][elements[j]]);\n                        }\n                    }\n                }\n            }\n\n            return TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n\n        }\n\n        function applyMetaAttributes(node, metaAttrDiff) {\n            var i, keys, newValue;\n            if (metaAttrDiff === TODELETESTRING) {\n                //we should delete all MetaAttributes\n                keys = _core.getValidAttributeNames(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delAttributeMeta(node, keys[i]);\n                }\n            } else {\n                keys = Object.keys(metaAttrDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaAttrDiff[keys[i]] === TODELETESTRING) {\n                        _core.delAttributeMeta(node, keys[i]);\n                    } else {\n                        newValue = jsonConcat(_core.getAttributeMeta(node, keys[i]) || {}, metaAttrDiff[keys[i]]);\n                        _core.setAttributeMeta(node, keys[i], newValue);\n                    }\n                }\n            }\n        }\n\n        function applyMetaConstraints(node, metaConDiff) {\n            var keys, i;\n            if (metaConDiff === TODELETESTRING) {\n                //remove all constraints\n                keys = _core.getConstraintNames(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delConstraint(node, keys[i]);\n                }\n            } else {\n                keys = Object.keys(metaConDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaConDiff[keys[i]] === TODELETESTRING) {\n                        _core.delConstraint(node, keys[i]);\n                    } else {\n                        _core.setConstraint(node, keys[i], jsonConcat(_core.getConstraint(node, keys[i]) || {},\n                            metaConDiff[keys[i]]));\n                    }\n                }\n            }\n        }\n\n        function applyMetaChildren(node, metaChildrenDiff) {\n            var keys, i, done,\n                setChild = function (target, data/*, d*/) {\n                    _core.setChildMeta(node, target, data.min, data.max);\n                };\n            if (metaChildrenDiff === TODELETESTRING) {\n                //remove all valid child\n                keys = _core.getValidChildrenPaths(node);\n                for (i = 0; i < keys.length; i++) {\n                    _core.delChildMeta(node, keys[i]);\n                }\n            } else {\n                _core.setChildrenMetaLimits(node, metaChildrenDiff.min, metaChildrenDiff.max);\n                delete metaChildrenDiff.max; //TODO we do not need it anymore, but maybe there is a better way\n                delete metaChildrenDiff.min;\n                keys = Object.keys(metaChildrenDiff);\n                for (i = 0; i < keys.length; i++) {\n                    if (metaChildrenDiff[keys[i]] === TODELETESTRING) {\n                        _core.delChildMeta(node, keys[i]);\n                    } else {\n                        done = TASYNC.call(setChild, _core.loadByPath(_core.getRoot(node), keys[i]),\n                            metaChildrenDiff[keys[i]], done);\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaPointers(node, metaPointerDiff) {\n            var names, targets, i, j, done,\n                setPointer = function (name, target, data/*, d*/) {\n                    _core.setPointerMetaTarget(node, name, target, data.min, data.max);\n                };\n            if (metaPointerDiff === TODELETESTRING) {\n                //remove all pointers,sets and their targets\n                names = _core.getValidPointerNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delPointerMeta(node, names[i]);\n                }\n\n                names = _core.getValidSetNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delPointerMeta(node, names[i]);\n                }\n                return;\n            }\n\n            names = Object.keys(metaPointerDiff);\n            for (i = 0; i < names.length; i++) {\n                if (metaPointerDiff[names[i]] === TODELETESTRING) {\n                    _core.delPointerMeta(node, names[i]);\n                } else {\n                    _core.setPointerMetaLimits(node, names[i], metaPointerDiff[names[i]].min,\n                        metaPointerDiff[names[i]].max);\n                    //TODO we do not need it anymore, but maybe there is a better way\n                    delete metaPointerDiff[names[i]].max;\n                    delete metaPointerDiff[names[i]].min;\n                    targets = Object.keys(metaPointerDiff[names[i]]);\n                    for (j = 0; j < targets.length; j++) {\n                        if (metaPointerDiff[names[i]][targets[j]] === TODELETESTRING) {\n                            _core.delPointerMetaTarget(node, names[i], targets[j]);\n                        } else {\n                            done = TASYNC.call(setPointer, names[i], _core.loadByPath(_core.getRoot(node), targets[j]),\n                                metaPointerDiff[names[i]][targets[j]], done);\n                        }\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaAspects(node, metaAspectsDiff) {\n            var names, targets, i, j, done,\n                setAspect = function (name, target/*, d*/) {\n                    _core.setAspectMetaTarget(node, name, target);\n                };\n            if (metaAspectsDiff === TODELETESTRING) {\n                //remove all aspects\n                names = _core.getValidAspectNames(node);\n                for (i = 0; i < names.length; i++) {\n                    _core.delAspectMeta(node, names[i]);\n                }\n                return;\n            }\n\n            names = Object.keys(metaAspectsDiff);\n            for (i = 0; i < names.length; i++) {\n                if (metaAspectsDiff[names[i]] === TODELETESTRING) {\n                    _core.delAspectMeta(node, names[i]);\n                } else {\n                    targets = metaAspectsDiff[names[i]];\n                    for (j = 0; j < targets.length; j++) {\n                        if (metaAspectsDiff[names[i]][targets[j]] === TODELETESTRING) {\n                            _core.delAspectMetaTarget(node, names[i], targets[j]);\n                        } else {\n                            done = TASYNC.call(setAspect, names[i], _core.loadByPath(_core.getRoot(node), targets[j]),\n                                done);\n                        }\n                    }\n                }\n            }\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        function applyMetaChanges(node, metaDiff) {\n            var done;\n            applyMetaAttributes(node, metaDiff.attributes || TODELETESTRING);\n            applyMetaConstraints(node, metaDiff.constraints || TODELETESTRING);\n            done = applyMetaChildren(node, metaDiff.children || TODELETESTRING);\n            done = TASYNC.call(applyMetaPointers, node, metaDiff.pointers || TODELETESTRING, done);\n            done = TASYNC.call(applyMetaAspects, node, metaDiff.aspects || TODELETESTRING, done);\n\n            TASYNC.call(function (/*d*/) {\n                return null;\n            }, done);\n        }\n\n        _core.applyTreeDiff = function (root, diff) {\n\n            toFrom = {};\n            fromTo = {};\n            getMoveSources(diff, '', toFrom, fromTo);\n\n            return TASYNC.join(makeInitialContainmentChanges(root, diff), applyNodeChange(root, '', diff));\n        };\n\n        function getNodeByGuid(diff, guid) {\n            var relids, i, node;\n            if (diff.guid === guid) {\n                return diff;\n            }\n\n            relids = getDiffChildrenRelids(diff);\n            for (i = 0; i < relids.length; i++) {\n                node = getNodeByGuid(diff[relids[i]], guid);\n                if (node) {\n                    return node;\n                }\n            }\n            return null;\n        }\n\n        function insertAtPath(diff, path, object) {\n            ASSERT(typeof path === 'string');\n            var i, base, relid, nodepath;\n            if (path === '') {\n                _concatResult = JSON.parse(JSON.stringify(object));\n                return;\n            }\n            nodepath = path.match(/\\/\\/.*\\/\\//) || [];\n            nodepath = nodepath[0] || 'there is no nodepath in the path';\n            path = path.replace(nodepath, '/*nodepath*/');\n            nodepath = nodepath.replace(/\\/\\//g, '/');\n            nodepath = nodepath.slice(0, -1);\n            path = path.split('/');\n            path.shift();\n            if (path.indexOf('*nodepath*') !== -1) {\n                path[path.indexOf('*nodepath*')] = nodepath;\n            }\n            relid = path.pop();\n            base = diff;\n            for (i = 0; i < path.length; i++) {\n                base[path[i]] = base[path[i]] || {};\n                base = base[path[i]];\n            }\n            base[relid] = JSON.parse(JSON.stringify(object));\n            return;\n        }\n\n        //FIXME check if it is really depreciated\n        //function changeMovedPaths(singleNode) {\n        //    var keys, i;\n        //    keys = Object.keys(singleNode);\n        //    for (i = 0; i < keys.length; i++) {\n        //        if (_concatMoves.fromTo[keys[i]]) {\n        //            singleNode[_concatMoves.fromTo[keys[i]]] = singleNode[keys[i]];\n        //            delete singleNode[keys[i]];\n        //            if (typeof singleNode[_concatMoves.fromTo[keys[i]]] === 'object' &&\n        //                singleNode[_concatMoves.fromTo[keys[i]]] !== null) {\n        //\n        //                changeMovedPaths(singleNode[_concatMoves.fromTo[keys[i]]]);\n        //            }\n        //        } else {\n        //            if (typeof singleNode[keys[i]] === 'string' && keys[i] !== 'movedFrom' &&\n        //                _concatMoves.fromTo[singleNode[keys[i]]]) {\n        //\n        //                singleNode[keys[i]] = _concatMoves.fromTo[keys[i]];\n        //            }\n        //\n        //            if (typeof singleNode[keys[i]] === 'object' && singleNode[keys[i]] !== null) {\n        //                changeMovedPaths(singleNode[keys[i]]);\n        //            }\n        //        }\n        //\n        //    }\n        //    if (typeof singleNode === 'object' && singleNode !== null) {\n        //        keys = Object.keys(singleNode);\n        //        for (i = 0; i < keys.length; i++) {\n        //            if (_concatMoves.fromTo[keys[i]]) {\n        //                singleNode[_concatMoves.fromTo[keys[i]]] = singleNode[keys[i]];\n        //                delete singleNode[keys[i]];\n        //            }\n        //        }\n        //    } else if (typeof singleNode === 'string') {\n        //\n        //    }\n        //\n        //}\n\n        function getSingleNode(node) {\n            //removes the children from the node\n            var result = JSON.parse(JSON.stringify(node)),\n                keys = getDiffChildrenRelids(result),\n                i;\n            for (i = 0; i < keys.length; i++) {\n                delete result[keys[i]];\n            }\n            //changeMovedPaths(result);\n            return result;\n        }\n\n        function jsonConcat(base, extension) {\n            var baseKeys = Object.keys(base),\n                extKeys = Object.keys(extension),\n                concat = JSON.parse(JSON.stringify(base)),\n                i;\n            for (i = 0; i < extKeys.length; i++) {\n                if (baseKeys.indexOf(extKeys[i]) === -1) {\n                    concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\n                } else {\n                    if (typeof base[extKeys[i]] === 'object' && typeof extension[extKeys[i]] === 'object') {\n                        concat[extKeys[i]] = jsonConcat(base[extKeys[i]], extension[extKeys[i]]);\n                    } else { //either from value to object or object from value we go with the extension\n                        concat[extKeys[i]] = JSON.parse(JSON.stringify(extension[extKeys[i]]));\n                    }\n                }\n            }\n            return concat;\n        }\n\n        //FIXME are we going to use this function\n        //function getConflictByGuid(conflict, guid) {\n        //    var relids, i, result;\n        //    if (conflict.guid === guid) {\n        //        return conflict;\n        //    }\n        //    relids = getDiffChildrenRelids(conflict);\n        //    for (i = 0; i < relids.length; i++) {\n        //        result = getConflictByGuid(conflict[relids[i]], guid);\n        //        if (result) {\n        //            return result;\n        //        }\n        //    }\n        //    return null;\n        //}\n\n        function getPathByGuid(conflict, guid, path) {\n            var relids, i, result;\n            if (conflict.guid === guid) {\n                return path;\n            }\n            relids = getDiffChildrenRelids(conflict);\n            for (i = 0; i < relids.length; i++) {\n                result = getPathByGuid(conflict[relids[i]], guid, path + '/' + relids[i]);\n                if (result) {\n                    return result;\n                }\n            }\n            return null;\n        }\n\n        //now we try a different approach, which maybe more simple\n        function getCommonPathForConcat(path) {\n            if (_concatMoves.getExtensionSourceFromDestination[path]) {\n                path = _concatMoves.getExtensionSourceFromDestination[path];\n            }\n            if (_concatMoves.getBaseDestinationFromSource[path]) {\n                path = _concatMoves.getBaseDestinationFromSource[path];\n            }\n            return path;\n        }\n\n        function getConcatBaseRemovals(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                i;\n            if (diff.removed !== true) {\n                if (diff.movedFrom) {\n                    if (_concatBaseRemovals[diff.guid] !== undefined) {\n                        delete _concatBaseRemovals[diff.guid];\n                    } else {\n                        _concatBaseRemovals[diff.guid] = false;\n                    }\n                }\n                for (i = 0; i < relids.length; i++) {\n                    getConcatBaseRemovals(diff[relids[i]]);\n                }\n            } else {\n                if (_concatBaseRemovals[diff.guid] === false) {\n                    delete _concatBaseRemovals[diff.guid];\n                } else {\n                    _concatBaseRemovals[diff.guid] = true;\n                }\n            }\n        }\n\n        function getObstructiveGuids(diffNode) {\n            var result = [],\n                keys, i;\n            keys = Object.keys(diffNode.oGuids || {});\n            for (i = 0; i < keys.length; i++) {\n                if (_concatBaseRemovals[keys[i]]) {\n                    result.push(keys[i]);\n                }\n            }\n            keys = Object.keys(diffNode.ooGuids || {});\n            for (i = 0; i < keys.length; i++) {\n                if (_concatBaseRemovals[keys[i]]) {\n                    result.push(keys[i]);\n                }\n            }\n            return result;\n        }\n\n        function getWhomIObstructGuids(guid) {\n            //this function is needed when the extension contains a deletion where the base did not delete the node\n            var guids = [],\n                checkNode = function (diffNode) {\n                    var relids, i;\n                    if ((diffNode.oGuids && diffNode.oGuids[guid]) || (diffNode.ooGuids && diffNode.ooGuids[guid])) {\n                        guids.push(diffNode.guid);\n                    }\n\n                    relids = getDiffChildrenRelids(diffNode);\n                    for (i = 0; i < relids.length; i++) {\n                        checkNode(diffNode[relids[i]]);\n                    }\n                };\n            checkNode(_concatBase);\n            return guids;\n        }\n\n        function gatherFullNodeConflicts(diffNode, mine, path, opposingPath) {\n            var conflict,\n                opposingConflict,\n                keys, i,\n                createSingleKeyValuePairConflicts = function (pathBase, data) {\n                    var keys, i;\n                    keys = Object.keys(data);\n                    for (i = 0; i < keys.length; i++) {\n                        conflict[pathBase + '/' + keys[i]] = conflict[pathBase + '/' + keys[i]] || {\n                                value: data[keys[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[pathBase + '/' + keys[i]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[pathBase + '/' + keys[i]] = true;\n                    }\n                };\n\n            //setting the conflicts\n            if (mine === true) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n            ASSERT(opposingConflict);\n            //if the node was moved we should make a conflict for the whole node as well\n            if (diffNode.movedFrom) {\n                conflict[path] = conflict[path] || {value: path, conflictingPaths: {}};\n                conflict[path].conflictingPaths[opposingPath] = true;\n                opposingConflict.conflictingPaths[path] = true;\n            }\n            createSingleKeyValuePairConflicts(path + '/attr', diffNode.attr || {});\n            createSingleKeyValuePairConflicts(path + '/reg', diffNode.reg || {});\n            createSingleKeyValuePairConflicts(path + '/pointer', diffNode.pointer || {});\n\n            if (diffNode.set) {\n                if (diffNode.set === TODELETESTRING) {\n                    conflict[path + '/set'] = conflict[path + '/set'] || {value: TODELETESTRING, conflictingPaths: {}};\n                    conflict[path + '/set'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/set'] = true;\n                } else {\n                    keys = Object.keys(diffNode.set);\n                    for (i = 0; i < keys.length; i++) {\n                        if (diffNode.set[keys[i]] === TODELETESTRING) {\n                            conflict[path + '/set/' + keys[i]] = conflict[path + '/set/' + keys[i]] || {\n                                    value: TODELETESTRING,\n                                    conflictingPaths: {}\n                                };\n                            conflict[path + '/set/' + keys[i]].conflictingPaths[opposingPath] = true;\n                            opposingConflict.conflictingPaths[path + '/set/' + keys[i]] = true;\n                        } else {\n                            gatherFullSetConflicts(diffNode.set[keys[i]], mine, path + '/set/' + keys[i], opposingPath);\n                        }\n                    }\n                }\n            }\n\n            if (diffNode.meta) {\n                gatherFullMetaConflicts(diffNode.meta, mine, path + '/meta', opposingPath);\n            }\n\n            //if the opposing item is theirs, we have to recursively go down in our changes\n            if (mine) {\n                keys = getDiffChildrenRelids(diffNode);\n                for (i = 0; i < keys.length; i++) {\n                    gatherFullNodeConflicts(diffNode[keys[i]], true, path + '/' + keys[i], opposingPath);\n                }\n            }\n\n        }\n\n        function gatherFullSetConflicts(diffSet, mine, path, opposingPath) {\n            var relids = getDiffChildrenRelids(diffSet),\n                i, keys, j, conflict, opposingConflict;\n\n            //setting the conflicts\n            if (mine === true) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n            for (i = 0; i < relids.length; i++) {\n                if (diffSet[relids[i]] === TODELETESTRING) {\n                    //single conflict as the element was removed\n                    conflict[path + '/' + relids[i] + '/'] = conflict[path + '/' + relids[i] + '/'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/' + relids[i] + '/'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/' + relids[i] + '/'] = true;\n                } else {\n                    keys = Object.keys(diffSet[relids[i]].attr || {});\n                    for (j = 0; j < keys.length; j++) {\n                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]] =\n                            conflict[path + '/' + relids[i] + '//attr/' + keys[j]] || {\n                                value: diffSet[relids[i]].attr[keys[j]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/' + relids[i] + '//attr/' + keys[j]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//attr/' + keys[j]] = true;\n                    }\n                    keys = Object.keys(diffSet[relids[i]].reg || {});\n                    for (j = 0; j < keys.length; j++) {\n                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]] =\n                            conflict[path + '/' + relids[i] + '//reg/' + keys[j]] || {\n                                value: diffSet[relids[i]].reg[keys[j]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/' + relids[i] + '//reg/' + keys[j]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/' + relids[i] + '//reg/' + keys[j]] = true;\n                    }\n                }\n            }\n        }\n\n        function concatSingleKeyValuePairs(path, base, extension) {\n            var keys, i, temp;\n            keys = Object.keys(extension);\n            for (i = 0; i < keys.length; i++) {\n                temp = extension[keys[i]];\n                if (typeof temp === 'string' && temp !== TODELETESTRING) {\n                    temp = getCommonPathForConcat(temp);\n                }\n                if (base[keys[i]] && CANON.stringify(base[keys[i]]) !== CANON.stringify(temp)) {\n                    //conflict\n                    _conflictMine[path + '/' + keys[i]] = {value: base[keys[i]], conflictingPaths: {}};\n                    _conflictTheirs[path + '/' + keys[i]] = {value: extension[keys[i]], conflictingPaths: {}};\n                    _conflictMine[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;\n                    _conflictTheirs[path + '/' + keys[i]].conflictingPaths[path + '/' + keys[i]] = true;\n                } else {\n                    base[keys[i]] = extension[keys[i]];\n                }\n            }\n        }\n\n        function concatSet(path, base, extension) {\n            var names = Object.keys(extension),\n                members, i, j, memberPath;\n\n            for (i = 0; i < names.length; i++) {\n                if (base[names[i]]) {\n                    if (base[names[i]] === TODELETESTRING) {\n                        if (extension[names[i]] !== TODELETESTRING) {\n                            //whole set conflict\n                            _conflictMine[path + '/' + names[i]] = {value: TODELETESTRING, conflictingPaths: {}};\n                            gatherFullSetConflicts(extension[names[i]],\n                                false, path + '/' + names[i], path + '/' + names[i]);\n                        }\n                    } else {\n                        if (extension[names[i]] === TODELETESTRING) {\n                            //whole set conflict\n                            _conflictTheirs[path + '/' + names[i]] = {value: TODELETESTRING, conflictingPaths: {}};\n                            gatherFullSetConflicts(base[names[i]], true, path + '/' + names[i], path + '/' + names[i]);\n                        } else {\n                            //now we can only have member or sub-member conflicts...\n                            members = getDiffChildrenRelids(extension[names[i]]);\n                            for (j = 0; j < members.length; j++) {\n                                memberPath = getCommonPathForConcat(members[j]);\n                                if (base[names[i]][memberPath]) {\n                                    if (base[names[i]][memberPath] === TODELETESTRING) {\n                                        if (extension[names[i]][members[j]] !== TODELETESTRING) {\n                                            //whole member conflict\n                                            _conflictMine[path + '/' + names[i] + '/' + memberPath + '//'] = {\n                                                value: TODELETESTRING,\n                                                conflictingPaths: {}\n                                            };\n                                            gatherFullNodeConflicts(extension[names[i]][members[j]],\n                                                false,\n                                                path + '/' + names[i] + '/' + memberPath + '//', path +\n                                                '/' + names[i] + '/' + memberPath + '//');\n                                        }\n                                    } else {\n                                        if (extension[names[i]][members[j]] === TODELETESTRING) {\n                                            //whole member conflict\n                                            _conflictTheirs[path + '/' + names[i] + '/' + memberPath + '//'] = {\n                                                value: TODELETESTRING,\n                                                conflictingPaths: {}\n                                            };\n                                            gatherFullNodeConflicts(base[names[i]][memberPath],\n                                                true,\n                                                path + '/' + names[i] + '/' + memberPath + '//', path +\n                                                '/' + names[i] + '/' + memberPath + '//');\n                                        } else {\n                                            if (extension[names[i]][members[j]].attr) {\n                                                if (base[names[i]][memberPath].attr) {\n                                                    concatSingleKeyValuePairs(path + '/' +\n                                                        names[i] + '/' + memberPath + '/' + '/attr',\n                                                        base[names[i]][memberPath].attr,\n                                                        extension[names[i]][members[j]].attr);\n                                                } else {\n                                                    base[names[i]][memberPath].attr =\n                                                        extension[names[i]][members[j]].attr;\n                                                }\n                                            }\n                                            if (extension[names[i]][members[j]].reg) {\n                                                if (base[names[i]][memberPath].reg) {\n                                                    concatSingleKeyValuePairs(path + '/' +\n                                                        names[i] + '/' + memberPath + '/' + '/reg',\n                                                        base[names[i]][memberPath].reg,\n                                                        extension[names[i]][members[j]].reg);\n                                                } else {\n                                                    base[names[i]][memberPath].reg =\n                                                        extension[names[i]][members[j]].reg;\n                                                }\n                                            }\n\n                                        }\n                                    }\n                                } else {\n                                    //concat\n                                    base[names[i]][memberPath] = extension[names[i]][members[j]];\n                                }\n                            }\n                        }\n                    }\n                } else {\n                    //simple concatenation\n                    //TODO the path for members should be replaced here as well...\n                    base[names[i]] = extension[names[i]];\n                }\n            }\n        }\n\n        function gatherFullMetaConflicts(diffMeta, mine, path, opposingPath) {\n            var conflict, opposingConflict,\n                relids, i, j, keys, tPath, key;\n\n            if (mine) {\n                conflict = _conflictMine;\n                opposingConflict = _conflictTheirs[opposingPath];\n            } else {\n                conflict = _conflictTheirs;\n                opposingConflict = _conflictMine[opposingPath];\n            }\n\n            if (diffMeta === TODELETESTRING) {\n                conflict[path] = conflict[path] || {value: TODELETESTRING, conflictingPaths: {}};\n                conflict[path].conflictingPaths[opposingPath] = true;\n                opposingConflict.conflictingPaths[path] = true;\n                return; //there is no other conflict\n            }\n\n            //children\n            if (diffMeta.children) {\n                if (diffMeta.children === TODELETESTRING) {\n                    conflict[path + '/children'] = conflict[path + '/children'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/children'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/children'] = true;\n                } else {\n                    if (diffMeta.children.max) {\n                        conflict[path + '/children/max'] = conflict[path + '/children/max'] || {\n                                value: diffMeta.children.max,\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/max'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/max'] = true;\n                    }\n                    if (diffMeta.children.min) {\n                        conflict[path + '/children/min'] = conflict[path + '/children/min'] || {\n                                value: diffMeta.children.min,\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/min'].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/min'] = true;\n                    }\n                    relids = getDiffChildrenRelids(diffMeta.children);\n                    for (i = 0; i < relids.length; i++) {\n                        conflict[path + '/children/' + relids[i]] = conflict[path + '/children/' + relids[i]] || {\n                                value: diffMeta.children[relids[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[path + '/children/' + relids[i]].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[path + '/children/' + relids[i]] = true;\n                    }\n                }\n            }\n            //attributes\n            if (diffMeta.attributes) {\n                if (diffMeta.attributes === TODELETESTRING) {\n                    conflict[path + '/attributes'] = conflict[path + '/attributes'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/attributes'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/attributes'] = true;\n                } else {\n                    keys = Object.keys(diffMeta.attributes);\n                    for (i = 0; i < keys.length; i++) {\n                        key = path + '/attributes/' + keys[i];\n                        conflict[key] = conflict[key] || {\n                                value: diffMeta.attributes[keys[i]],\n                                conflictingPaths: {}\n                            };\n                        conflict[key].conflictingPaths[opposingPath] = true;\n                        opposingConflict.conflictingPaths[key] = true;\n                    }\n                }\n            }\n            //pointers\n            if (diffMeta.pointers) {\n                if (diffMeta.pointers === TODELETESTRING) {\n                    conflict[path + '/pointers'] = conflict[path + '/pointers'] || {\n                            value: TODELETESTRING,\n                            conflictingPaths: {}\n                        };\n                    conflict[path + '/pointers'].conflictingPaths[opposingPath] = true;\n                    opposingConflict.conflictingPaths[path + '/pointers'] = true;\n                } else {\n                    keys = Object.keys(diffMeta.pointers);\n                    for (i = 0; i < keys.length; i++) {\n                        if (diffMeta.pointers[keys[i]] === TODELETESTRING) {\n                            conflict[path + '/pointers/' + keys[i]] = conflict[path + '/pointers/' + keys[i]] || {\n                                    value: TODELETESTRING,\n                                    conflictingPaths: {}\n                                };\n                            conflict[path + '/pointers/' + keys[i]].conflictingPaths[opposingPath] = true;\n                            opposingConflict.conflictingPaths[path + '/pointers/' + keys[i]] = true;\n                        } else {\n                            if (diffMeta.pointers[keys[i]].max) {\n                                conflict[path + '/pointers/' + keys[i] + '/max'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/max'] || {\n                                        value: diffMeta.pointers[keys[i]].max,\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/max'].conflictingPaths[opposingPath] = true;\n                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/max'] = true;\n                            }\n                            if (diffMeta.pointers[keys[i]].min) {\n                                conflict[path + '/pointers/' + keys[i] + '/min'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/min'] || {\n                                        value: diffMeta.pointers[keys[i]].min,\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/min'].conflictingPaths[opposingPath] = true;\n                                opposingConflict.conflictingPaths[path + '/pointers/' + keys[i] + '/min'] = true;\n                            }\n                            relids = getDiffChildrenRelids(diffMeta.pointers[keys[i]]);\n                            for (j = 0; j < relids.length; j++) {\n                                tPath = getCommonPathForConcat(relids[j]);\n                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] =\n                                    conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'] || {\n                                        value: diffMeta.pointers[keys[i]][relids[j]],\n                                        conflictingPaths: {}\n                                    };\n                                conflict[path + '/pointers/' + keys[i] + '/' + tPath + '//'].\n                                    conflictingPaths[opposingPath] = true;\n                                opposingConflict.\n                                    conflictingPaths[path + '/pointers/' + keys[i] + '/' + tPath + '//'] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            //aspects\n            //TODO\n        }\n\n        function concatMeta(path, base, extension) {\n            var keys, i, tPath, j, paths, t2Path,\n                mergeMetaItems = function (bPath, bData, eData) {\n                    var bKeys, tKeys, i, tPath, t2Path;\n                    //delete checks\n                    if (bData === TODELETESTRING || eData === TODELETESTRING) {\n                        if (CANON.stringify(bData) !== CANON.stringify(eData)) {\n                            _conflictMine[bPath] = _conflictMine[bPath] || {value: bData, conflictingPaths: {}};\n                            _conflictMine[bPath].conflictingPaths[bPath] = true;\n                            _conflictTheirs[bPath] = _conflictTheirs[bPath] || {value: eData, conflictingPaths: {}};\n                            _conflictTheirs[bPath].conflictingPaths[bPath] = true;\n                        }\n                    } else {\n                        //max\n                        if (eData.max) {\n                            if (bData.max && bData.max !== eData.max) {\n                                tPath = bPath + '/max';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData.max,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData.max,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData.max = eData.max;\n                            }\n                        }\n                        //min\n                        if (eData.min) {\n                            if (bData.min && bData.min !== eData.min) {\n                                tPath = bPath + '/min';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData.min,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData.min,\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData.min = eData.min;\n                            }\n                        }\n                        //targets\n                        bKeys = getDiffChildrenRelids(bData);\n                        tKeys = getDiffChildrenRelids(eData);\n                        for (i = 0; i < tKeys.length; i++) {\n                            tPath = getCommonPathForConcat(tKeys[i]);\n                            if (bKeys.indexOf(tPath) !== -1 && CANON.stringify(bData[tPath]) !==\n                                CANON.stringify(eData[tKeys[i]])) {\n\n                                t2Path = tPath;\n                                tPath = bPath + '/' + tPath + '//';\n                                _conflictMine[tPath] = _conflictMine[tPath] || {\n                                        value: bData[t2Path],\n                                        conflictingPaths: {}\n                                    };\n                                _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                        value: eData[tKeys[i]],\n                                        conflictingPaths: {}\n                                    };\n                                _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                            } else {\n                                bData[tPath] = eData[tKeys[i]];\n                            }\n                        }\n                    }\n                };\n            if (CANON.stringify(base) !== CANON.stringify(extension)) {\n                if (base === TODELETESTRING) {\n                    _conflictMine[path] = _conflictMine[path] || {value: TODELETESTRING, conflictingPaths: {}};\n                    gatherFullMetaConflicts(extension, false, path, path);\n                } else {\n                    if (extension === TODELETESTRING) {\n                        _conflictTheirs[path] = _conflictTheirs[path] || {\n                                value: TODELETESTRING,\n                                conflictingPaths: {}\n                            };\n                        gatherFullMetaConflicts(base, true, path, path);\n                    } else {\n                        //now check for sub-meta conflicts\n\n                        //children\n                        if (extension.children) {\n                            if (base.children) {\n                                mergeMetaItems(path + '/children', base.children, extension.children);\n                            } else {\n                                //we just simply merge the extension's\n                                base.children = extension.children;\n                            }\n                        }\n                        //pointers\n                        if (extension.pointers) {\n                            if (base.pointers) {\n                                //complete deletion\n                                if (base.pointers === TODELETESTRING || extension.pointers === TODELETESTRING) {\n                                    if (CANON.stringify(base.pointers) !== CANON.stringify(extension.pointers)) {\n                                        tPath = path + '/pointers';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.pointers,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.pointers,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.pointers);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.pointers[keys[i]]) {\n                                            mergeMetaItems(path + '/pointers/' + keys[i], base.pointers[keys[i]],\n                                                extension.pointers[keys[i]]);\n                                        } else {\n                                            base.pointers[keys[i]] = extension.pointers[keys[i]];\n                                        }\n                                    }\n                                }\n                            } else {\n                                base.pointers = extension.pointers;\n                            }\n                        }\n                        //attributes\n                        if (extension.attributes) {\n                            if (base.attributes) {\n                                if (extension.attributes === TODELETESTRING || base.attributes === TODELETESTRING) {\n                                    if (CANON.stringify(base.attributes) !== CANON.stringify(extension.attributes)) {\n                                        tPath = path + '/attributes';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.attributes,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.attributes,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.attributes);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.attributes[keys[i]]) {\n                                            if (extension.attributes[keys[i]] === TODELETESTRING ||\n                                                base.attributes[keys[i]] === TODELETESTRING) {\n\n                                                if (CANON.stringify(base.attributes[keys[i]]) !==\n                                                    CANON.stringify(extension.attributes[keys[i]])) {\n\n                                                    tPath = path + '/attributes/' + [keys[i]];\n                                                    _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                            value: base.attributes[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                            value: extension.attributes[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                }\n                                            } else {\n                                                concatSingleKeyValuePairs(path + '/attributes/' + keys[i],\n                                                    base.attributes[keys[i]], extension.attributes[keys[i]]);\n                                            }\n                                        } else {\n                                            base.attributes[keys[i]] = extension.attributes[keys[i]];\n                                        }\n                                    }\n\n                                }\n                            } else {\n                                base.attributes = extension.attributes;\n                            }\n                        }\n\n                        //aspects\n                        if (extension.aspects) {\n                            if (base.aspects) {\n                                if (extension.aspects === TODELETESTRING || base.aspects === TODELETESTRING) {\n                                    if (CANON.stringify(base.aspects) !== CANON.stringify(extension.aspects)) {\n                                        tPath = path + '/aspects';\n                                        _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                value: base.aspects,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                        _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                value: extension.aspects,\n                                                conflictingPaths: {}\n                                            };\n                                        _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                    }\n                                } else {\n                                    keys = Object.keys(extension.aspects);\n                                    for (i = 0; i < keys.length; i++) {\n                                        if (base.aspects[keys[i]]) {\n                                            if (extension.aspects[keys[i]] === TODELETESTRING ||\n                                                base.aspects[keys[i]] === TODELETESTRING) {\n                                                if (CANON.stringify(base.aspects[keys[i]]) !==\n                                                    CANON.stringify(extension.aspects[keys[i]])) {\n                                                    tPath = path + '/aspects/' + keys[i];\n                                                    _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                            value: base.aspects[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                            value: extension.aspects[keys[i]],\n                                                            conflictingPaths: {}\n                                                        };\n                                                    _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                }\n                                            } else {\n                                                paths = Object.keys(extension.aspects[keys[i]]);\n                                                for (j = 0; j < paths.length; j++) {\n                                                    tPath = getCommonPathForConcat(paths[j]);\n                                                    if (base.aspects[keys[i]][tPath]) {\n                                                        if (CANON.stringify(base.aspects[keys[i]][tPath]) !==\n                                                            CANON.stringify(extension.aspects[keys[i]][paths[j]])) {\n                                                            t2Path = tPath;\n                                                            tPath = path + '/aspects/' + keys[i] + '/' + tPath + '//';\n                                                            _conflictMine[tPath] = _conflictMine[tPath] || {\n                                                                    value: base.aspects[keys[i]][t2Path],\n                                                                    conflictingPaths: {}\n                                                                };\n                                                            _conflictMine[tPath].conflictingPaths[tPath] = true;\n                                                            _conflictTheirs[tPath] = _conflictTheirs[tPath] || {\n                                                                    value: extension.aspects[keys[i]][paths[j]],\n                                                                    conflictingPaths: {}\n                                                                };\n                                                            _conflictTheirs[tPath].conflictingPaths[tPath] = true;\n                                                        }\n                                                    } else {\n                                                        base.aspects[keys[i]][tPath] =\n                                                            extension.aspects[keys[i]][paths[j]];\n                                                    }\n                                                }\n                                            }\n                                        } else {\n                                            base.aspects[keys[i]] = extension.aspects[keys[i]];\n                                        }\n                                    }\n                                }\n                            } else {\n                                base.aspects = extension.aspects;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        function tryToConcatNodeChange(extNode, path) {\n            var guid = extNode.guid,\n                oGuids = getObstructiveGuids(extNode),\n                baseNode = getNodeByGuid(_concatBase, guid),\n                basePath = getPathByGuid(_concatBase, guid, ''),\n                i, tPath,\n                relids = getDiffChildrenRelids(extNode);\n\n\n            if (extNode.removed === true) {\n                if (baseNode && baseNode.removed !== true) {\n                    tPath = basePath + '/removed';\n                    _conflictTheirs[tPath] = _conflictTheirs[tPath] || {value: true, conflictingPaths: {}};\n                    oGuids = getWhomIObstructGuids(guid);\n                    ASSERT(oGuids.length > 0);\n                    for (i = 0; i < oGuids.length; i++) {\n                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);\n                        basePath = getPathByGuid(_concatBase, oGuids[i], '');\n                        gatherFullNodeConflicts(baseNode, true, basePath, tPath);\n                    }\n                } else {\n                    //we simply concat the deletion\n                    insertAtPath(_concatBase, path, extNode);\n                }\n            } else {\n                if (oGuids.length > 0) {\n                    for (i = 0; i < oGuids.length; i++) {\n                        baseNode = getNodeByGuid(_concatBase, oGuids[i]);\n                        basePath = getPathByGuid(_concatBase, oGuids[i], '');\n                        _conflictMine[basePath + '/removed'] = _conflictMine[basePath + '/removed'] || {\n                                value: true,\n                                conflictingPaths: {}\n                            };\n                        gatherFullNodeConflicts(extNode, false, path, basePath + '/removed');\n                    }\n                } else if (baseNode) {\n                    //here we are able to check the sub-node conflicts\n                    //check double moves - we do not care if they moved under the same parent\n                    if (extNode.movedFrom) {\n                        if (baseNode.movedFrom && path !== basePath) {\n                            _conflictMine[basePath] = _conflictMine[basePath] || {\n                                    value: 'move',\n                                    conflictingPaths: {}\n                                };\n                            _conflictTheirs[path] = _conflictTheirs[path] || {value: 'move', conflictingPaths: {}};\n                            _conflictMine[basePath].conflictingPaths[path] = true;\n                            _conflictTheirs[path].conflictingPaths[basePath] = true;\n                            //we keep the node where it is, but synchronize the paths\n                            path = basePath;\n                        } else if (path !== basePath) {\n                            //first we move the base object to its new path\n                            //we copy the moved from information right here\n                            baseNode.movedFrom = extNode.movedFrom;\n                            insertAtPath(_concatBase, path, baseNode);\n                            removePathFromDiff(_concatBase, basePath);\n                            baseNode = getNodeByGuid(_concatBase, guid);\n                            basePath = getPathByGuid(_concatBase, guid, '');\n                            ASSERT(path === basePath);\n                        }\n                    }\n\n                    ASSERT(basePath === path || baseNode.movedFrom === path);\n                    path = basePath; //the base was moved\n\n\n                    //and now the sub-node conflicts\n                    if (extNode.attr) {\n                        if (baseNode.attr) {\n                            concatSingleKeyValuePairs(path + '/attr', baseNode.attr, extNode.attr);\n                        } else {\n                            insertAtPath(_concatBase, path + '/attr', extNode.attr);\n                        }\n                    }\n                    if (extNode.reg) {\n                        if (baseNode.reg) {\n                            concatSingleKeyValuePairs(path + '/reg', baseNode.reg, extNode.reg);\n                        } else {\n                            insertAtPath(_concatBase, path + '/reg', extNode.reg);\n                        }\n                    }\n                    if (extNode.pointer) {\n                        if (baseNode.pointer) {\n                            concatSingleKeyValuePairs(path + '/pointer', baseNode.pointer, extNode.pointer);\n                        } else {\n                            insertAtPath(_concatBase, path + '/pointer', extNode.pointer);\n                        }\n                    }\n                    if (extNode.set) {\n                        if (baseNode.set) {\n                            concatSet(path + '/set', baseNode.set, extNode.set);\n                        } else {\n                            insertAtPath(_concatBase, path + '/set', extNode.set);\n                        }\n                    }\n                    if (extNode.meta) {\n                        if (baseNode.meta) {\n                            concatMeta(path + '/meta', baseNode.meta, extNode.meta);\n                        } else {\n                            insertAtPath(_concatBase, path + '/meta', extNode.meta);\n                        }\n                    }\n                } else {\n                    //there is no basenode so we can concat the whole node\n                    insertAtPath(_concatBase, path, getSingleNode(extNode));\n                }\n            }\n\n            //here comes the recursion\n            for (i = 0; i < relids.length; i++) {\n                tryToConcatNodeChange(extNode[relids[i]], path + '/' + relids[i]);\n            }\n\n        }\n\n        function generateConflictItems() {\n            var items = [],\n                keys, i, j, conflicts;\n            keys = Object.keys(_conflictMine);\n\n            for (i = 0; i < keys.length; i++) {\n                conflicts = Object.keys(_conflictMine[keys[i]].conflictingPaths || {});\n                ASSERT(conflicts.length > 0);\n                for (j = 0; j < conflicts.length; j++) {\n                    items.push({\n                        selected: 'mine',\n                        mine: {\n                            path: keys[i],\n                            info: keys[i].replace(/\\//g, ' / '),\n                            value: _conflictMine[keys[i]].value\n                        },\n                        theirs: {\n                            path: conflicts[j],\n                            info: conflicts[j].replace(/\\//g, ' / '),\n                            value: _conflictTheirs[conflicts[j]].value\n                        }\n                    });\n                }\n            }\n            return items;\n        }\n\n        function harmonizeConflictPaths(diff) {\n            var relids = getDiffChildrenRelids(diff),\n                keys, i, members, j;\n\n            keys = Object.keys(diff.pointer || {});\n            for (i = 0; i < keys.length; i++) {\n                diff.pointer[keys[i]] = getCommonPathForConcat(diff.pointer[keys[i]]);\n            }\n            keys = Object.keys(diff.set || {});\n            for (i = 0; i < keys.length; i++) {\n                members = Object.keys(diff.set[keys[i]] || {});\n                for (j = 0; j < members.length; j++) {\n                    if (members[j] !== getCommonPathForConcat(members[j])) {\n                        diff.set[keys[i]][getCommonPathForConcat(members[j])] = diff.set[keys[i]][members[j]];\n                        delete diff.set[keys[i]][members[j]];\n                    }\n                }\n            }\n\n            //TODO we have to do the meta as well\n            for (i = 0; i < relids.length; i++) {\n                harmonizeConflictPaths(diff[relids[i]]);\n            }\n        }\n\n        _core.tryToConcatChanges = function (base, extension) {\n            var result = {};\n            _conflictItems = [];\n            _conflictMine = {};\n            _conflictTheirs = {};\n            _concatBase = base;\n            _concatExtension = extension;\n            _concatBaseRemovals = {};\n            _concatMoves = {\n                getBaseSourceFromDestination: {},\n                getBaseDestinationFromSource: {},\n                getExtensionSourceFromDestination: {},\n                getExtensionDestinationFromSource: {}\n            };\n            getMoveSources(base,\n                '', _concatMoves.getBaseSourceFromDestination, _concatMoves.getBaseDestinationFromSource);\n            getMoveSources(extension,\n                '', _concatMoves.getExtensionSourceFromDestination, _concatMoves.getExtensionDestinationFromSource);\n            getConcatBaseRemovals(base);\n            tryToConcatNodeChange(_concatExtension, '');\n\n            result.items = generateConflictItems();\n            result.mine = _conflictMine;\n            result.theirs = _conflictTheirs;\n            result.merge = _concatBase;\n            harmonizeConflictPaths(result.merge);\n            return result;\n        };\n\n        function depthOfPath(path) {\n            ASSERT(typeof path === 'string');\n            return path.split('/').length;\n        }\n\n        function resolveMoves(resolveObject) {\n            var i, moves = {},\n                filteredItems = [],\n                path,\n                moveBaseOfPath = function (path) {\n                    var keys = Object.keys(moves),\n                        i, maxDepth = -1,\n                        base = null;\n                    for (i = 0; i < keys.length; i++) {\n                        if (path.indexOf(keys[i]) === 1 && depthOfPath(keys[i]) > maxDepth) {\n                            base = keys[i];\n                            maxDepth = depthOfPath(keys[i]);\n                        }\n                    }\n                    return base;\n                };\n            for (i = 0; i < resolveObject.items.length; i++) {\n                if (resolveObject.items[i].selected === 'theirs' && resolveObject.items[i].theirs.value === 'move') {\n                    moves[resolveObject.items[i].mine.path] = resolveObject.items[i].theirs.path;\n                    //and we also make the move\n                    insertAtPath(resolveObject.merge,\n                        resolveObject.items[i].theirs.path,\n                        getPathOfDiff(resolveObject.merge, resolveObject.items[i].mine.path));\n                    removePathFromDiff(resolveObject.merge, resolveObject.items[i].mine.path);\n                } else {\n                    filteredItems.push(resolveObject.items[i]);\n                }\n            }\n            resolveObject.items = filteredItems;\n\n            //in a second run we modify all sub-path of the moves paths\n            for (i = 0; i < resolveObject.items.length; i++) {\n                if (resolveObject.items[i].selected === 'theirs') {\n                    path = moveBaseOfPath(resolveObject.items[i].theirs.path);\n                    if (path) {\n                        resolveObject.items[i].theirs.path =\n                            resolveObject.items[i].theirs.path.replace(path, moves[path]);\n                    }\n                    path = moveBaseOfPath(resolveObject.items[i].mine.path);\n                    if (path) {\n                        resolveObject.items[i].mine.path = resolveObject.items[i].mine.path.replace(path, moves[path]);\n                    }\n                }\n            }\n        }\n\n        _core.applyResolution = function (conflictObject) {\n            //we apply conflict items to the merge and return it as a diff\n            var i;\n            resolveMoves(conflictObject);\n            for (i = 0; i < conflictObject.items.length; i++) {\n                if (conflictObject.items[i].selected !== 'mine') {\n                    removePathFromDiff(conflictObject.merge, conflictObject.items[i].mine.path);\n                    insertAtPath(conflictObject.merge,\n                        conflictObject.items[i].theirs.path, conflictObject.items[i].theirs.value);\n                }\n            }\n\n            return conflictObject.merge;\n        };\n\n\n        //we remove some low level functions as they should not be used on high level\n        delete _core.overlayInsert;\n\n        return _core;\n    }\n\n    return diffCore;\n});\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/core',[\n    'common/core/corerel',\n    'common/core/setcore',\n    'common/core/guidcore',\n    'common/core/nullpointercore',\n    'common/core/coreunwrap',\n    'common/core/coretype',\n    'common/core/constraintcore',\n    'common/core/coretree',\n    'common/core/metacore',\n    'common/core/coretreeloader',\n    'common/core/corediff'\n], function (CoreRel, Set, Guid, NullPtr, UnWrap, Type, Constraint, CoreTree, MetaCore, TreeLoader, CoreDiff) {\n    'use strict';\n\n    function Core(storage, options) {\n        var core,\n            coreLayers = [];\n        coreLayers.push(CoreRel);\n        coreLayers.push(NullPtr);\n        coreLayers.push(Type);\n        coreLayers.push(NullPtr);\n        coreLayers.push(Set);\n        coreLayers.push(Guid);\n        coreLayers.push(Constraint);\n        coreLayers.push(MetaCore);\n        coreLayers.push(CoreDiff);\n        coreLayers.push(TreeLoader);\n        if (options.usertype !== 'tasync') {\n            coreLayers.push(UnWrap);\n        }\n\n        core = coreLayers.reduce(function (inner, Class) {\n            return new Class(inner, options);\n        }, new CoreTree(storage, options));\n\n        return core;\n    }\n\n    return Core;\n});\n\n",
    "/*globals define*/\n/*jshint browser:true*/\n\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/client/constants',['common/storage/constants'], function (STORAGE_CONSTANTS) {\n    'use strict';\n\n    return {\n\n        STORAGE: STORAGE_CONSTANTS,\n\n        BRANCH_STATUS: {\n            SYNC: 'SYNC',\n            AHEAD_SYNC: 'AHEAD_SYNC',\n            AHEAD_NOT_SYNC: 'AHEAD_NOT_SYNC',\n            PULLING: 'PULLING'\n        },\n\n        // Events\n        NETWORK_STATUS_CHANGED: 'NETWORK_STATUS_CHANGED',\n        BRANCH_STATUS_CHANGED: 'BRANCH_STATUS_CHANGED',\n\n        BRANCH_CHANGED: 'BRANCH_CHANGED',\n        PROJECT_CLOSED: 'PROJECT_CLOSED',\n        PROJECT_OPENED: 'PROJECT_OPENED',\n\n        UNDO_AVAILABLE: 'UNDO_AVAILABLE',\n        REDO_AVAILABLE: 'REDO_AVAILABLE'\n    };\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/meta',[], function () {\n    'use strict';\n\n    function metaStorage() {\n        var _core = null,\n            _nodes = null,\n            _save = function () {\n            },\n            _initialized = false;\n\n        function initialize(core, nodes, save) {\n            _core = core;\n            _nodes = nodes;\n            _save = save;\n            _initialized = true;\n        }\n\n        function isValidMeta(/*meta*/) {\n            /*if( typeof meta === 'object'){\n             if(\n             //children\n             typeof meta.children === 'object' &&\n             (meta.children.types === null || typeof meta.children.types === 'array') &&\n             (typeof meta.children.min === 'undefined' || typeof meta.children.min === 'number') &&\n             (typeof meta.children.max === 'undefined' || typeof meta.children.max === 'number')){\n\n             //attributes\n             }\n             }\n\n             return false;*/\n            //TODO implement it :)\n            return true;\n        }\n\n        //function isValidAttributeSchema(atrSchema) {\n        //    //TODO implement :)\n        //    return true;\n        //}\n\n        //TODO this may change\n        function pathToRefObject(path) {\n            var ref = {};\n            ref.$ref = path;\n            return ref;\n        }\n\n        //TODO this may change\n        function refObjectToPath(ref) {\n            if (typeof ref.$ref === 'string') {\n                return ref.$ref/*.substring(1)*/;\n            } else {\n                return null;\n            }\n        }\n\n        //getter setter functions\n        function getMeta(path) {\n            var i, j,\n                meta = {children: {}, attributes: {}, pointers: {}, aspects: {}};\n\n            if (_nodes === null || _nodes === undefined) {\n                return meta;\n            }\n            var node = _nodes[path] || null;\n            if (!node) {\n                return null;\n            }\n\n            var metaNode = _core.getChild(node, '_meta');\n            var childrenNode = _core.getChild(metaNode, 'children');\n            //children\n            meta.children = {};\n            meta.children.minItems = [];\n            meta.children.maxItems = [];\n            meta.children.items = _core.getMemberPaths(childrenNode, 'items');\n            for (i = 0; i < meta.children.items.length; i++) {\n                meta.children.minItems.push(\n                    _core.getMemberAttribute(childrenNode, 'items', meta.children.items[i], 'min') || -1);\n\n                meta.children.maxItems.push(\n                    _core.getMemberAttribute(childrenNode, 'items', meta.children.items[i], 'max') || -1);\n\n                meta.children.items[i] = pathToRefObject(meta.children.items[i]);\n            }\n            meta.children.min = _core.getAttribute(childrenNode, 'min');\n            meta.children.max = _core.getAttribute(childrenNode, 'max');\n\n            //attributes - they are simple json objects from our point of view\n            var atrNames = _core.getAttributeNames(metaNode);\n            for (i = 0; i < atrNames.length; i++) {\n                meta.attributes[atrNames[i]] = JSON.parse(JSON.stringify(\n                    _core.getAttribute(metaNode, atrNames[i])));\n            }\n\n            //pointers and pointer lists\n            var pointerNames = _core.getPointerNames(metaNode) || [];\n            for (i = 0; i < pointerNames.length; i++) {\n                var pointerNode = _core.getChild(metaNode, '_p_' + pointerNames[i]);\n                var pointer = {};\n                pointer.items = _core.getMemberPaths(pointerNode, 'items');\n                pointer.min = _core.getAttribute(pointerNode, 'min');\n                pointer.max = _core.getAttribute(pointerNode, 'max');\n                pointer.minItems = [];\n                pointer.maxItems = [];\n\n                for (j = 0; j < pointer.items.length; j++) {\n                    pointer.minItems.push(\n                        _core.getMemberAttribute(pointerNode, 'items', pointer.items[j], 'min') || -1);\n\n                    pointer.maxItems.push(\n                        _core.getMemberAttribute(pointerNode, 'items', pointer.items[j], 'max') || -1);\n\n                    pointer.items[j] = pathToRefObject(pointer.items[j]);\n\n                }\n\n                meta.pointers[pointerNames[i]] = pointer;\n            }\n\n            //aspects\n            var aspectsNode = _core.getChild(metaNode, 'aspects');\n            var aspectNames = _core.getPointerNames(aspectsNode);\n            if (aspectNames.length > 0) {\n                meta.aspects = {};\n                for (i = 0; i < aspectNames.length; i++) {\n                    var aspectNode = _core.getChild(aspectsNode, '_a_' + aspectNames[i]);\n                    meta.aspects[aspectNames[i]] = {items: []};\n                    var items = _core.getMemberPaths(aspectNode, 'items');\n                    for (j = 0; j < items.length; j++) {\n                        meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\n                    }\n                }\n            }\n\n            return meta;\n        }\n\n        function setMeta(path, meta) {\n            var i,\n                j,\n                aspectNode,\n                targetPath;\n            if (!isValidMeta) {\n                return;\n            }\n            var node = _nodes[path] || null;\n            if (node) {\n                var metaNode = _core.getChild(node, '_meta');\n                _core.deleteNode(metaNode, true);\n                metaNode = _core.getChild(node, '_meta');\n                if (meta.children) {\n                    var childrenNode = _core.getChild(metaNode, 'children');\n                    if (meta.children.items && meta.children.items.length) {\n                        if (meta.children.min) {\n                            _core.setAttribute(childrenNode, 'min', meta.children.min);\n                        }\n                        if (meta.children.max) {\n                            _core.setAttribute(childrenNode, 'max', meta.children.max);\n                        }\n\n                        for (i = 0; i < meta.children.items.length; i++) {\n                            targetPath = refObjectToPath(meta.children.items[i]);\n                            if (typeof targetPath === 'string' && _nodes[targetPath]) {\n                                _core.addMember(childrenNode, 'items', _nodes[targetPath]);\n                                if (meta.children.minItems[i] !== -1) {\n                                    _core.setMemberAttribute(childrenNode, 'items', targetPath, 'min',\n                                        meta.children.minItems[i]);\n                                }\n                                if (meta.children.maxItems[i] !== -1) {\n                                    _core.setMemberAttribute(childrenNode, 'items', targetPath, 'max',\n                                        meta.children.maxItems[i]);\n                                }\n                            }\n                        }\n\n                    } else {\n                        _core.deleteNode(childrenNode, true);\n                    }\n                }\n\n                if (meta.attributes) {\n                    for (i in meta.attributes) {\n                        _core.setAttribute(metaNode, i, meta.attributes[i]);\n                    }\n                }\n\n                if (meta.pointers) {\n                    for (i in meta.pointers) {\n                        _core.setPointer(metaNode, i, null);\n                        var pointerNode = _core.getChild(metaNode, '_p_' + i);\n                        if (meta.pointers[i].items && meta.pointers[i].items.length) {\n                            if (meta.pointers[i].min) {\n                                _core.setAttribute(pointerNode, 'min', meta.pointers[i].min);\n                            }\n                            if (meta.pointers[i].max) {\n                                _core.setAttribute(pointerNode, 'max', meta.pointers[i].max);\n                            }\n\n                            for (j = 0; j < meta.pointers[i].items.length; j++) {\n                                targetPath = refObjectToPath(meta.pointers[i].items[j]);\n                                if (typeof targetPath === 'string' && _nodes[targetPath]) {\n                                    _core.addMember(pointerNode, 'items', _nodes[targetPath]);\n                                    if (meta.pointers[i].minItems[j] !== -1) {\n                                        _core.setMemberAttribute(pointerNode, 'items', targetPath, 'min',\n                                            meta.pointers[i].minItems[j]);\n                                    }\n                                    if (meta.pointers[i].maxItems[j] !== -1) {\n                                        _core.setMemberAttribute(pointerNode, 'items', targetPath, 'max',\n                                            meta.pointers[i].maxItems[j]);\n                                    }\n                                }\n                            }\n\n                        }\n                    }\n                }\n\n                if (meta.aspects) {\n                    var aspectsNode = _core.getChild(metaNode, 'aspects'),\n                        aspectNames = [];\n                    for (i in meta.aspects) {\n                        _core.setPointer(aspectsNode, i, null);\n                        aspectNode = _core.getChild(aspectsNode, '_a_' + i);\n                        if (meta.aspects[i].items) {\n                            for (j = 0; j < meta.aspects[i].items.length; j++) {\n                                var member = _nodes[refObjectToPath(meta.aspects[i].items[j])];\n                                if (member) {\n                                    _core.addMember(aspectNode, 'items', member);\n                                }\n                            }\n                        }\n                        aspectNames.push(i);\n                    }\n                    if (aspectNames.length > 0) {\n                        meta.aspects = {};\n                        for (i = 0; i < aspectNames.length; i++) {\n                            aspectNode = _core.getChild(aspectsNode, '_a_' + aspectNames[i]);\n                            meta.aspects[aspectNames[i]] = {items: []};\n                            var items = _core.getMemberPaths(aspectNode, 'items');\n                            for (j = 0; j < items.length; j++) {\n                                meta.aspects[aspectNames[i]].items.push(pathToRefObject(items[j]));\n                            }\n                        }\n                    }\n                }\n\n                var metaEvent = _core.getRegistry(node, '_meta_event_') || 0;\n                _core.setRegistry(node, '_meta_event_', metaEvent + 1);\n                _save('setMeta(' + path + ')');\n            }\n        }\n\n\n        //validation functions\n        function getBaseChain(path) {\n            var chain = [];\n            var node = _nodes[path];\n            if (node) {\n                while (node !== null) {\n                    chain.push(_core.getPath(node));\n                    node = _core.getBase(node);\n                }\n            }\n            return chain;\n        }\n\n        function isTypeOf(path, typePath) {\n            var node = _nodes[path];\n            if (node) {\n                var chain = getBaseChain(path);\n                if (chain.indexOf(typePath) !== -1) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function isValidTypeOfArray(path, typePathArray) {\n            var i = 0,\n                isGood = false;\n            while (i < typePathArray.length && isGood === false) {\n                isGood = isTypeOf(path, typePathArray[i]);\n                i++;\n            }\n            return isGood;\n        }\n\n        function isValidChild(path, childPath) {\n            var node = _nodes[path];\n            var child = _nodes[childPath];\n            if (node && child) {\n                var metaNode = _core.getChild(node, '_meta');\n                var childrenNode = _core.getChild(metaNode, 'children');\n                var items = _core.getMemberPaths(childrenNode, 'items');\n                return isValidTypeOfArray(childPath, items);\n            }\n            return false;\n        }\n\n        function isValidTarget(path, name, targetPath) {\n            var node = _nodes[path];\n            var target = _nodes[targetPath];\n            if (node && target) {\n                var meta = _core.getChild(node, '_meta');\n                var pointer = _core.getChild(meta, '_p_' + name);\n                var items = _core.getMemberPaths(pointer, 'items');\n                return isValidTypeOfArray(targetPath, items);\n            }\n            return false;\n        }\n\n        function isValidAttribute(/*path, name, attribute*/) {\n            //TODO we should check against schema\n            return true;\n        }\n\n        function getValidChildrenTypes(path) {\n            var node = _nodes[path];\n            if (node) {\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node, '_meta'), 'children'), 'items');\n            }\n            return [];\n        }\n\n        function getValidTargetTypes(path, name) {\n            var node = _nodes[path];\n            if (node) {\n                return _core.getMemberPaths(_core.getChild(_core.getChild(node, '_meta'), '_p_' + name), 'items');\n            }\n            return [];\n        }\n\n        function hasOwnMetaRules(path) {\n            var node = _nodes[path];\n            if (node) {\n                var own = getMeta(path);\n                var base = getMeta(_core.getPath(_core.getBase(node)));\n                return own === base;\n            }\n            return false;\n        }\n\n        function filterValidTarget(path, name, paths) {\n            var targets = [];\n            for (var i = 0; i < paths.length; i++) {\n                if (isValidTarget(path, name, paths[i])) {\n                    targets.push(paths[i]);\n                }\n            }\n            return targets;\n        }\n\n        function getOwnValidChildrenTypes(path) {\n            var node = _nodes[path];\n            var items = [];\n            if (node) {\n                var own = getValidChildrenTypes(path);\n                var base = getValidChildrenTypes(_core.getPath(_core.getBase(node)));\n                for (var i = 0; i < own.length; i++) {\n                    if (base.indexOf(own[i]) === -1) {\n                        items.push(own[i]);\n                    }\n                }\n            }\n            return items;\n        }\n\n        function getOwnValidTargetTypes(path, name) {\n            var node = _nodes[path];\n            var items = [];\n            if (node) {\n                var own = getValidTargetTypes(path, name);\n                var base = getValidTargetTypes(_core.getPath(_core.getBase(node)), name);\n                for (var i = 0; i < own.length; i++) {\n                    if (base.indexOf(own[i]) === -1) {\n                        items.push(own[i]);\n                    }\n                }\n            }\n            return items;\n        }\n\n        function getValidAttributeNames(path) {\n            var rawMeta = getMeta(path),\n                names = [];\n            if (rawMeta) {\n                for (var i in rawMeta.attributes) {\n                    names.push(i);\n                }\n            }\n            return names;\n        }\n\n        function getOwnValidAttributeNames(path) {\n            var names = [],\n                node = _nodes[path];\n\n            if (node) {\n                var own = getValidAttributeNames(path);\n                var base = getValidAttributeNames(_core.getPath(_core.getBase(node)));\n                for (var i = 0; i < own.length; i++) {\n                    if (base.indexOf(own[i]) === -1) {\n                        names.push(own[i]);\n                    }\n                }\n            }\n            return names;\n        }\n\n        function indexOfPathInRefObjArray(array, path) {\n            var index = 0;\n            while (index < array.length) {\n                if (path === refObjectToPath(array[index])) {\n                    return index;\n                }\n                index++;\n            }\n            return -1;\n        }\n\n        function getChildrenMeta(path) {\n            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var childrenMeta = {};\n                childrenMeta.min = rawMeta.children.min;\n                childrenMeta.max = rawMeta.children.max;\n                childrenMeta.items = rawMeta.children.items;\n                if (childrenMeta.items !== null) {\n                    for (var i = 0; i < childrenMeta.items.length; i++) {\n                        var child = {};\n                        child.id = refObjectToPath(childrenMeta.items[i]);\n                        if (rawMeta.children.minItems) {\n                            child.min = rawMeta.children.minItems[i] === -1 ? undefined : rawMeta.children.minItems[i];\n                        }\n                        if (rawMeta.children.maxItems) {\n                            child.max = rawMeta.children.maxItems[i] === -1 ? undefined : rawMeta.children.maxItems[i];\n                        }\n\n                        childrenMeta.items[i] = child;\n                    }\n                }\n\n                return childrenMeta;\n            }\n            return null;\n        }\n\n        function getChildrenMetaAttribute(path/*, attrName*/) {\n            var childrenMeta = getChildrenMeta(path);\n            if (childrenMeta) {\n                return childrenMeta.attrName;\n            }\n            return null;\n        }\n\n        function setChildrenMetaAttribute(path, attrName, value) {\n            if (attrName !== 'items') {\n                var rawMeta = getMeta(path);\n                rawMeta.children[attrName] = value;\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getValidChildrenItems(path) {\n            var childrenMeta = getChildrenMeta(path);\n            if (childrenMeta) {\n                return childrenMeta.items;\n            }\n            return null;\n        }\n\n        function updateValidChildrenItem(path, newTypeObj) {\n            var i,\n                rawMeta;\n            if (newTypeObj && newTypeObj.id) {\n                rawMeta = getMeta(path);\n                if (rawMeta) {\n                    if (rawMeta.children.minItems === null || rawMeta.children.minItems === undefined) { //TODO: use ! ?\n                        rawMeta.children.minItems = [];\n                        for (i = 0; i < rawMeta.children.items.length; i++) {\n                            rawMeta.children.minItems.push(-1);\n                        }\n                    }\n                    if (rawMeta.children.maxItems === null || rawMeta.children.maxItems === undefined) { //TODO: use ! ?\n                        rawMeta.children.maxItems = [];\n                        for (i = 0; i < rawMeta.children.items.length; i++) {\n                            rawMeta.children.maxItems.push(-1);\n                        }\n                    }\n                    var refObj = pathToRefObject(newTypeObj.id);\n                    var index = indexOfPathInRefObjArray(rawMeta.children.items, newTypeObj.id);\n                    if (index === -1) {\n                        index = rawMeta.children.items.length;\n                        rawMeta.children.items.push(refObj);\n                        rawMeta.children.minItems.push(-1);\n                        rawMeta.children.maxItems.push(-1);\n                    }\n                    // jshint expr:true\n                    (newTypeObj.min === null || newTypeObj.min === undefined) ?\n                        rawMeta.children.minItems[index] = -1 : rawMeta.children.minItems[index] = newTypeObj.min;\n\n                    (newTypeObj.max === null || newTypeObj.max === undefined) ?\n                        rawMeta.children.maxItems[index] = -1 : rawMeta.children.maxItems[index] = newTypeObj.max;\n                    // jshint expr:false\n                    setMeta(path, rawMeta);\n                }\n            }\n        }\n\n        function removeValidChildrenItem(path, typeId) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                //var refObj = pathToRefObject(typeId);\n                var index = indexOfPathInRefObjArray(rawMeta.children.items, typeId);\n                if (index !== -1) {\n                    rawMeta.children.items.splice(index, 1);\n                    if (rawMeta.children.minItems) {\n                        rawMeta.children.minItems.splice(index, 1);\n                    }\n                    if (rawMeta.children.maxItems) {\n                        rawMeta.children.maxItems.splice(index, 1);\n                    }\n                    setMeta(path, rawMeta);\n                }\n            }\n        }\n\n        function getAttributeSchema(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                if (rawMeta.attributes[name]) {\n                    return rawMeta.attributes[name];\n                }\n            }\n            return null;\n        }\n\n        function setAttributeSchema(path, name, schema) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                //TODO check schema validity - but it is also viable to check it only during setMeta\n                rawMeta.attributes[name] = schema;\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function removeAttributeSchema(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                delete rawMeta.attributes[name];\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getPointerMeta(path, name) {\n            //the returned object structure is : {'min':0,'max':0,'items':[{'id':path,'min':0,'max':0},...]}\n            var rawMeta = getMeta(path);\n            if (rawMeta && rawMeta.pointers[name]) {\n                var pointerMeta = {};\n                pointerMeta.min = rawMeta.pointers[name].min;\n                pointerMeta.max = rawMeta.pointers[name].max;\n                pointerMeta.items = rawMeta.pointers[name].items;\n                if (pointerMeta.items !== null) {\n                    for (var i = 0; i < pointerMeta.items.length; i++) {\n                        var child = {};\n                        child.id = refObjectToPath(pointerMeta.items[i]);\n                        if (rawMeta.pointers[name].minItems) {\n                            child.min = rawMeta.pointers[name].minItems[i] === -1 ?\n                                undefined : rawMeta.pointers[name].minItems[i]; //FIXME: avoid assigning undefined\n                        }\n                        if (rawMeta.pointers[name].maxItems) {\n                            child.max = rawMeta.pointers[name].maxItems[i] === -1 ?\n                                undefined : rawMeta.pointers[name].maxItems[i]; //FIXME: avoid assigning undefined\n                        }\n                        pointerMeta.items[i] = child;\n                    }\n                }\n                return pointerMeta;\n            }\n            return null;\n        }\n\n        function getValidTargetItems(path, name) {\n            var pointerMeta = getPointerMeta(path, name);\n            if (pointerMeta) {\n                return pointerMeta.items;\n            }\n            return null;\n        }\n\n        function updateValidTargetItem(path, name, targetObj) {\n            var rawMeta = getMeta(path);\n            if (rawMeta && targetObj && targetObj.id) {\n                var pointer = rawMeta.pointers[name] || null;\n                if (pointer === null) {\n                    rawMeta.pointers[name] = {items: [], minItems: [], maxItems: []};\n                    pointer = rawMeta.pointers[name];\n                }\n                var refObj = pathToRefObject(targetObj.id);\n                var index = indexOfPathInRefObjArray(pointer.items, targetObj.id);\n                if (index === -1) {\n                    index = pointer.items.length;\n                    pointer.items.push(refObj);\n                    pointer.minItems.push(-1);\n                    pointer.maxItems.push(-1);\n                }\n                // jshint expr:true\n                (targetObj.min === null || targetObj.min === undefined) ?\n                    pointer.minItems[index] = -1 : pointer.minItems[index] = targetObj.min;\n\n                (targetObj.max === null || targetObj.max === undefined) ?\n                    pointer.maxItems[index] = -1 : pointer.maxItems[index] = targetObj.max;\n                // jshint expr:false\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function removeValidTargetItem(path, name, targetId) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var pointer = rawMeta.pointers[name] || null;\n                if (pointer !== null) {\n                    //var refObj = pathToRefObject(targetId);\n                    var index = indexOfPathInRefObjArray(pointer.items, targetId);\n                    if (index !== -1) {\n                        pointer.items.splice(index, 1);\n                        if (pointer.minItems) {\n                            pointer.minItems.splice(index, 1);\n                        }\n                        if (pointer.maxItems) {\n                            pointer.maxItems.splice(index, 1);\n                        }\n                        setMeta(path, rawMeta);\n                    }\n                }\n            }\n        }\n\n        function deleteMetaPointer(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                delete rawMeta.pointers[name];\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function setPointerMeta(path, name, meta) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var pointer = rawMeta.pointers[name] || null;\n                if (pointer === null) {\n                    rawMeta.pointers[name] = {items: [], minItems: [], maxItems: []};\n                    pointer = rawMeta.pointers[name];\n                }\n                pointer.min = meta.min;\n                pointer.max = meta.max;\n                if (meta.items && meta.items.length) {\n                    for (var i = 0; i < meta.items.length; i++) {\n                        pointer.items.push(pathToRefObject(meta.items[i].id));\n                        pointer.minItems.push(meta.items[i].min || -1);\n                        pointer.maxItems.push(meta.items[i].max || -1);\n                    }\n                }\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function setChildrenMeta(path, name, meta) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                var children = rawMeta.children;\n\n                children.min = meta.min;\n                children.max = meta.max;\n                if (meta.items && meta.items.length) {\n                    for (var i = 0; i < meta.items.length; i++) {\n                        children.items.push(pathToRefObject(meta.items[i].id));\n                        children.minItems.push(meta.items[i].min || -1);\n                        children.maxItems.push(meta.items[i].max || -1);\n                    }\n                }\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getMetaAspectNames(path) {\n            var rawMeta = getMeta(path),\n                names = [];\n\n            if (rawMeta && rawMeta.aspects) {\n                for (var i in rawMeta.aspects) {\n                    names.push(i);\n                }\n            }\n            return names;\n        }\n\n        function getOwnMetaAspectNames(path) {\n            var names = getMetaAspectNames(path),\n                ownNames = [];\n            if (_nodes[path]) {\n                var baseNames = getMetaAspectNames(_core.getPath(_core.getBase(_nodes[path])));\n                for (var i = 0; i < names.length; i++) {\n                    if (baseNames.indexOf(names[i]) === -1) {\n                        ownNames.push(names[i]);\n                    }\n                }\n            }\n            return ownNames;\n        }\n\n        function getMetaAspect(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                if (rawMeta.aspects[name]) {\n                    var aspect = {items: []};\n                    for (var i = 0; i < rawMeta.aspects[name].items.length; i++) {\n                        aspect.items.push(refObjectToPath(rawMeta.aspects[name].items[i]));\n                    }\n                    if (aspect.items.length === 0) {\n                        delete aspect.items;\n                    }\n                    return aspect;\n                }\n                return null;\n            }\n            return null;\n        }\n\n        function setMetaAspect(path, name, aspect) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n\n                rawMeta.aspects = rawMeta.aspects || {};\n                rawMeta.aspects[name] = {items: []};\n                for (var i = 0; i < aspect.items.length; i++) {\n                    rawMeta.aspects[name].items.push(pathToRefObject(aspect.items[i]));\n                }\n                setMeta(path, rawMeta);\n            }\n        }\n\n        function getAspectTerritoryPattern(path, name) {\n            var aspect = getMetaAspect(path, name);\n            if (aspect !== null) {\n                aspect.children = 1; //TODO now it is fixed, maybe we can change that in the future\n                return aspect;\n            }\n            return null;\n        }\n\n        function deleteMetaAspect(path, name) {\n            var rawMeta = getMeta(path);\n            if (rawMeta) {\n                if (rawMeta.aspects && rawMeta.aspects[name]) {\n                    delete rawMeta.aspects[name];\n                    setMeta(path, rawMeta);\n                }\n            }\n        }\n\n        return {\n            refObjectToPath: refObjectToPath,\n            pathToRefObject: pathToRefObject,\n\n\n            initialize: initialize,\n            getMeta: getMeta,\n            setMeta: setMeta,\n            isTypeOf: isTypeOf,\n            hasOwnMetaRules: hasOwnMetaRules,\n\n            //containment\n            isValidChild: isValidChild,\n            getChildrenMeta: getChildrenMeta,\n            setChildrenMeta: setChildrenMeta,\n            getChildrenMetaAttribute: getChildrenMetaAttribute,\n            setChildrenMetaAttribute: setChildrenMetaAttribute,\n            getValidChildrenTypes: getValidChildrenTypes,\n            getOwnValidChildrenTypes: getOwnValidChildrenTypes,\n            getValidChildrenItems: getValidChildrenItems,\n            updateValidChildrenItem: updateValidChildrenItem,\n            removeValidChildrenItem: removeValidChildrenItem,\n\n            //attribute\n            isValidAttribute: isValidAttribute,\n            getAttributeSchema: getAttributeSchema,\n            setAttributeSchema: setAttributeSchema,\n            removeAttributeSchema: removeAttributeSchema,\n            getValidAttributeNames: getValidAttributeNames,\n            getOwnValidAttributeNames: getOwnValidAttributeNames,\n\n            //pointer\n            isValidTarget: isValidTarget,\n            getPointerMeta: getPointerMeta,\n            setPointerMeta: setPointerMeta,\n            getValidTargetItems: getValidTargetItems,\n            getValidTargetTypes: getValidTargetTypes,\n            getOwnValidTargetTypes: getOwnValidTargetTypes,\n            filterValidTarget: filterValidTarget,\n            updateValidTargetItem: updateValidTargetItem,\n            removeValidTargetItem: removeValidTargetItem,\n            deleteMetaPointer: deleteMetaPointer,\n\n            //aspect\n            getMetaAspectNames: getMetaAspectNames,\n            getOwnMetaAspectNames: getOwnMetaAspectNames,\n            getMetaAspect: getMetaAspect,\n            setMetaAspect: setMetaAspect,\n            getAspectTerritoryPattern: getAspectTerritoryPattern,\n            deleteMetaAspect: deleteMetaAspect\n\n        };\n    }\n\n    return metaStorage;\n});\n\n",
    "/*globals define*/\r\n/*jshint browser: true, node:true*/\r\n\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n *\r\n * FIXME: is there a built in function to JavaScript to parse cookies?\r\n */\r\n\r\ndefine('common/util/url',[],function () {\r\n    'use strict';\r\n\r\n    function parseCookie(cookie) {\r\n        var parsed,\r\n            elements,\r\n            i,\r\n            pair;\r\n\r\n        cookie = decodeURIComponent(cookie);\r\n        parsed = {};\r\n        elements = cookie.split(/[;] */);\r\n        for (i = 0; i < elements.length; i++) {\r\n            pair = elements[i].split('=');\r\n            parsed[pair[0]] = pair[1];\r\n        }\r\n        return parsed;\r\n    }\r\n\r\n    function urlToRefObject(url) {\r\n        return {\r\n            $ref: url\r\n        };\r\n    }\r\n\r\n    return {\r\n        parseCookie: parseCookie,\r\n        urlToRefObject: urlToRefObject\r\n    };\r\n});\r\n\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/tojson',['common/core/users/meta', 'common/util/url'], function (BaseMeta, URL) {\n    'use strict';\n\n    var META = new BaseMeta(),\n        _refTypes = {\n            url: 'url',\n            path: 'path',\n            guid: 'guid'\n        };\n\n    var changeRefObjects = function (refType, urlPrefix, object, core, root, callback) {\n        var i;\n        if (typeof object === 'object') {\n            var needed = 0,\n                neededNames = [],\n                error = null;\n            for (i in object) { // TODO: use key here instead\n                if (object[i] !== null && typeof object[i] === 'object') {\n                    needed++;\n                    neededNames.push(i);\n                }\n            }\n            if (needed > 0) {\n                for (i = 0; i < neededNames.length; i++) {\n                    if (object[neededNames[i]].$ref) {\n                        //reference object\n                        pathToRefObjAsync(refType, urlPrefix, object[neededNames[i]].$ref/*.substring(1)*/,\n                            core, root,\n                            function (err, refObj) {\n                                error = error || err;\n                                object[neededNames[i]] = refObj;\n                                if (--needed === 0) {\n                                    callback(error);\n                                }\n                            }\n                        );\n                    } else {\n                        changeRefObjects(refType, urlPrefix, object[neededNames[i]], core, root, function (err) {\n                            error = error || err;\n                            if (--needed === 0) {\n                                callback(error);\n                            }\n                        });\n                    }\n                }\n            } else {\n                callback(null);\n            }\n        } else {\n            callback(null);\n        }\n    };\n\n    var pathToRefObj = function (refType, urlPrefix, path) {\n        var result;\n        switch (refType) {\n            case _refTypes.url:\n                if (path === null) {\n                    result = URL.urlToRefObject(null);\n                } else {\n                    result = URL.urlToRefObject(urlPrefix + '&path=' + encodeURIComponent(path));\n                }\n                break;\n            case _refTypes.path:\n                result = URL.urlToRefObject(path);\n                break;\n            default:\n                result = URL.urlToRefObject(null);\n                break;\n        }\n\n        return result;\n    };\n\n    var getParentRefObject = function (refType, urlPrefix, core, node) {\n        var parent = core.getParent(node),\n            path = null,\n            result;\n\n        if (parent) {\n            path = core.getPath(parent);\n        }\n        switch (refType) {\n            case _refTypes.url:\n                if (path === null) {\n                    result = URL.urlToRefObject(null);\n                } else {\n                    result = URL.urlToRefObject(urlPrefix + '&path=' + encodeURIComponent(path));\n                }\n                break;\n            case _refTypes.path:\n                result = URL.urlToRefObject(path);\n                break;\n            case _refTypes.guid:\n                if (path === null) {\n                    result = URL.urlToRefObject(null);\n                } else {\n                    var refObj = URL.urlToRefObject(path);\n                    refObj.GUID = core.getGuid(parent);\n                    result = refObj;\n                }\n                break;\n        }\n\n        return result;\n    };\n\n    var pathToRefObjAsync = function (refType, urlPrefix, path, core, root, callback) {\n        switch (refType) {\n            case _refTypes.url:\n                if (path === null) {\n                    callback(null, URL.urlToRefObject(null));\n                }\n                callback(null, URL.urlToRefObject(urlPrefix + '&path=' + encodeURIComponent(path)));\n                break;\n            case _refTypes.path:\n                callback(null, URL.urlToRefObject(path));\n                break;\n            case _refTypes.guid:\n                core.loadByPath(root, path, function (err, node) {\n                    if (err) {\n                        callback(err, null);\n                    } else {\n                        var refObj = URL.urlToRefObject(path);\n                        refObj.GUID = core.getGuid(node);\n                        callback(null, refObj);\n                    }\n                });\n                break;\n            default:\n                callback(null, URL.urlToRefObject(null));\n        }\n    };\n\n    var getChildrenGuids = function (core, node, callback) {\n        var GUIDHash = {};\n        core.loadChildren(node, function (err, children) {\n            if (err) {\n                callback(err, null);\n            } else {\n                for (var i = 0; i < children.length; i++) {\n                    GUIDHash[core.getPath(children[i])] = core.getGuid(children[i]);\n                }\n                callback(null, GUIDHash);\n            }\n        });\n    };\n\n    var getMetaOfNode = function (core, node, urlPrefix, refType, callback) {\n        var meta = META.getMeta(core.getPath(node));\n        changeRefObjects(refType, urlPrefix, meta, core, core.getRoot(node), function (err) {\n            callback(err, meta);\n        });\n    };\n\n    var getChildrenOfNode = function (core, node, urlPrefix, refType, callback) {\n        if (refType === _refTypes.guid) {\n            getChildrenGuids(core, node, function (err, gHash) {\n                if (err) {\n                    callback(err);\n                } else {\n                    //TODO possibly it needs some ordering\n                    var children = [];\n                    for (var i in gHash) {\n                        var refObj = URL.urlToRefObject(i);\n                        refObj.GUID = gHash[i];\n                        children.push(refObj);\n                    }\n                    callback(null, children);\n                }\n            });\n        } else {\n            var paths = core.getChildrenPaths(node);\n            var children = [];\n            for (var i = 0; i < paths.length; i++) {\n                children.push(pathToRefObj(refType, urlPrefix, paths[i]));\n            }\n            callback(null, children);\n        }\n    };\n\n    var getSetAttributesAndRegistry = function (core, node, setName, setOwnerPath, callback) {\n        var path = core.getPath(node),\n            i;\n        core.loadByPath(core.getRoot(node), setOwnerPath, function (err, owner) {\n            if (err) {\n                callback(err);\n            } else {\n                if (owner) {\n                    var atrAndReg = {attributes: {}, registry: {}};\n                    var names = core.getMemberAttributeNames(owner, setName, path);\n                    for (i = 0; i < names.length; i++) {\n                        atrAndReg.attributes[names[i]] = core.getMemberAttribute(owner, setName, path, names[i]);\n                    }\n                    names = core.getMemberRegistryNames(owner, setName, path);\n                    for (i = 0; i < names.length; i++) {\n                        atrAndReg.registry[names[i]] = core.getMemberRegistry(owner, setName, path, names[i]);\n                    }\n                    callback(null, atrAndReg);\n                } else {\n                    callback('internal error', null);\n                }\n            }\n        });\n    };\n\n    var getMemberAttributesAndRegistry = function (core, node, setName, memberPath) {\n        var retObj = {attributes: {}, registry: {}},\n            names,\n            i;\n        names = core.getMemberAttributeNames(node, setName, memberPath);\n        for (i = 0; i < names.length; i++) {\n            retObj.attributes[names[i]] = core.getMemberAttribute(node, setName, memberPath, names[i]);\n        }\n        names = core.getMemberRegistryNames(node, setName, memberPath);\n        for (i = 0; i < names.length; i++) {\n            retObj.registry[names[i]] = core.getMemberRegistry(node, setName, memberPath, names[i]);\n        }\n        return retObj;\n    };\n\n    var getSetsOfNode = function (core, node, urlPrefix, refType, callback) {\n        var setsInfo = {};\n        var createOneSetInfo = function (setName, callback) {\n            var needed,\n                members = (core.getMemberPaths(node, setName)).sort(), //TODO Remove the sort part at some point\n                info = {from: [], to: [], set: true},\n                i,\n                error = null,\n                containers = [],\n                collectSetInfo = function (nodePath, container, callback) {\n                    if (container === true) {\n                        pathToRefObjAsync(refType, urlPrefix, nodePath, core, core.getRoot(node),\n                            function (err, refObj) {\n                                if (!err && refObj !== undefined && refObj !== null) {\n                                    getSetAttributesAndRegistry(core, node, setName, nodePath,\n                                        function (err, atrAndReg) {\n                                            if (atrAndReg) {\n                                                for (var j in atrAndReg) {\n                                                    refObj[j] = atrAndReg[j];\n                                                }\n                                            }\n                                            callback(err, refObj);\n                                        }\n                                    );\n                                } else {\n                                    callback(err, null);\n                                }\n                            }\n                        );\n                    } else {\n                        //member\n                        pathToRefObjAsync(refType, urlPrefix, nodePath, core, core.getRoot(node),\n                            function (err, refObj) {\n                                if (refObj !== undefined && refObj !== null) {\n                                    var atrAndReg = getMemberAttributesAndRegistry(core, node, setName, nodePath);\n                                    for (var j in atrAndReg) {\n                                        refObj[j] = atrAndReg[j];\n                                    }\n                                    callback(err, refObj);\n                                }\n                            }\n                        );\n                    }\n                };\n\n            for (i in memberOfInfo) {\n                if (memberOfInfo[i].indexOf(setName) !== -1) {\n                    containers.push(i);\n                }\n            }\n\n            needed = members.length + containers.length;\n            if (needed > 0) {\n                for (i = 0; i < members.length; i++) {\n                    collectSetInfo(members[i], false, function (err, refObj) {\n                        error = error || err;\n                        if (refObj !== undefined && refObj !== null) {\n                            info.to.push(refObj);\n                        }\n\n                        if (--needed === 0) {\n                            if (error === null) {\n                                setsInfo[setName] = info;\n                            }\n                            callback(error);\n                        }\n                    });\n                }\n\n                for (i = 0; i < containers.length; i++) {\n                    collectSetInfo(containers[i], true, function (err, refObj) {\n                        error = error || err;\n                        if (refObj !== undefined && refObj !== null) {\n                            info.from.push(refObj);\n                        }\n\n                        if (--needed === 0) {\n                            if (error === null) {\n                                setsInfo[setName] = info;\n                            }\n                            callback(error);\n                        }\n                    });\n                }\n            } else {\n                callback(null);\n            }\n        };\n\n        var tArray = core.getSetNames(node),\n            memberOfInfo = core.isMemberOf(node),\n            i, j, needed, error = null;\n        for (j in memberOfInfo) {\n            for (i = 0; i < memberOfInfo[j].length; i++) {\n                if (tArray.indexOf(memberOfInfo[j][i]) === -1) {\n                    tArray.push(memberOfInfo[j][i]);\n                }\n            }\n        }\n        needed = tArray.length;\n        if (needed > 0) {\n            for (i = 0; i < tArray.length; i++) {\n                createOneSetInfo(tArray[i], function (err) {\n                    error = error || err;\n                    if (--needed === 0) {\n                        callback(error, setsInfo);\n                    }\n                });\n            }\n        } else {\n            callback(null, setsInfo);\n        }\n    };\n\n    var getPointersGUIDs = function (core, node, callback) {\n        var gHash = {},\n            pointerNames = core.getPointerNames(node),\n            collectionNames = core.getCollectionNames(node),\n            needed = pointerNames.length + collectionNames.length,\n            error = null,\n            i;\n        if (needed > 0) {\n            //pointers\n            for (i = 0; i < pointerNames.length; i++) {\n                core.loadPointer(node, pointerNames[i], function (err, pointer) {\n                    error = error || err;\n                    if (pointer) {\n                        if (gHash[core.getPath(pointer)] === undefined) {\n                            gHash[core.getPath(pointer)] = core.getGuid(pointer);\n                        }\n                    }\n\n                    if (--needed === 0) {\n                        callback(error, gHash);\n                    }\n                });\n            }\n            //collections\n            for (i = 0; i < collectionNames.length; i++) {\n                core.loadCollection(node, collectionNames[i], function (err, collection) {\n                    error = error || err;\n                    if (collection) {\n                        for (var j = 0; j < collection.length; j++) {\n                            if (gHash[core.getPath(collection[j])] === undefined) {\n                                gHash[core.getPath(collection[j])] = core.getGuid(collection[j]);\n                            }\n                        }\n                    }\n\n                    if (--needed === 0) {\n                        callback(error, gHash);\n                    }\n                });\n            }\n        } else {\n            callback(error, gHash);\n        }\n    };\n\n    var getPointersOfNode = function (core, node, urlPrefix, refType, callback) {\n        var GUIDHash = {};\n        var getRefObj = function (path) {\n            if (refType === _refTypes.guid) {\n                var refObj = URL.urlToRefObject(path);\n                refObj.GUID = GUIDHash[path];\n                return refObj;\n            } else {\n                return pathToRefObj(refType, urlPrefix, path);\n            }\n        };\n        var initialized = function () {\n            var pointers = {},\n                tArray = core.getPointerNames(node),\n                t2Array = core.getCollectionNames(node),\n                i, j;\n            for (i = 0; i < t2Array.length; i++) {\n                if (tArray.indexOf(t2Array[i]) === -1) {\n                    tArray.push(t2Array[i]);\n                }\n            }\n            for (i = 0; i < tArray.length; i++) {\n                var coll = core.getCollectionPaths(node, tArray[i]);\n                var pointer = {to: [], from: [], set: false},\n                    pPath = core.getPointerPath(node, tArray[i]);\n                if (pPath !== undefined) {\n                    pointer.to.push(getRefObj(pPath));\n                }\n                for (j = 0; j < coll.length; j++) {\n                    pointer.from.push(getRefObj(coll[j]));\n                }\n                pointers[tArray[i]] = pointer;\n            }\n            callback(null, pointers);\n        };\n\n        //start\n        if (refType === _refTypes.guid) {\n            getPointersGUIDs(core, node, function (err, gHash) {\n                if (err) {\n                    callback(err, null);\n                } else {\n                    GUIDHash = gHash;\n                    initialized();\n                }\n            });\n        } else {\n            initialized();\n        }\n    };\n\n    var getOwnPartOfNode = function (core, node) {\n        var own = {attributes: [], registry: [], pointers: []};\n        own.attributes = core.getOwnAttributeNames(node);\n        own.registry = core.getOwnRegistryNames(node);\n        own.pointers = core.getOwnPointerNames(node);\n        return own;\n    };\n\n    var getJsonNode = function (core, node, urlPrefix, refType, callback) {\n        var nodes = {},\n            tArray,\n            i,\n            jNode;\n\n        if (refType === _refTypes.guid && typeof core.getGuid !== 'function') {\n            callback(new Error('cannot provide GUIDs'), null);\n        }\n\n        nodes[core.getPath(node)] = node;\n        META.initialize(core, nodes, function () {\n            //TODO: is this asynchronous?\n        });\n\n        jNode = {\n            meta: {},\n            children: [],\n            attributes: {},\n            pointers: {},\n            registry: {}\n        };\n\n\n        //basic parts of the node\n        //GUID\n        if (typeof core.getGuid === 'function') {\n            jNode.GUID = core.getGuid(node);\n        }\n        //RELID\n        jNode.RELID = core.getRelid(node);\n        //registry entries\n        tArray = core.getRegistryNames(node);\n        for (i = 0; i < tArray.length; i++) {\n            jNode.registry[tArray[i]] = core.getRegistry(node, tArray[i]);\n        }\n        //attribute entries\n        tArray = core.getAttributeNames(node);\n        for (i = 0; i < tArray.length; i++) {\n            jNode.attributes[tArray[i]] = core.getAttribute(node, tArray[i]);\n        }\n\n        //own part of the node\n        jNode.OWN = getOwnPartOfNode(core, node);\n\n        //reference to parent\n        jNode.parent = getParentRefObject(refType, urlPrefix, core, node);\n\n\n        //now calling the relational parts\n        var needed = 4,\n            error = null;\n        getChildrenOfNode(core, node, urlPrefix, refType, function (err, children) {\n            error = error || err;\n            jNode.children = children;\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n        getMetaOfNode(core, node, urlPrefix, refType, function (err, meta) {\n            error = error || err;\n            jNode.meta = meta;\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n        getPointersOfNode(core, node, urlPrefix, refType, function (err, pointers) {\n            error = error || err;\n            for (var i in pointers) {\n                jNode.pointers[i] = pointers[i];\n            }\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n        getSetsOfNode(core, node, urlPrefix, refType, function (err, sets) {\n            error = error || err;\n            for (var i in sets) {\n                jNode.pointers[i] = sets[i];\n            }\n            if (--needed === 0) {\n                callback(error, jNode);\n            }\n        });\n    };\n\n    return getJsonNode;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('js/client/gmeNodeGetter',['common/core/users/tojson'], function (toJson) {\n    'use strict';\n\n    //getNode\n    function getNode(_id, logger, state, meta, storeNode) {\n\n        function getParentId() {\n            //just for sure, as it may missing from the cache\n            return storeNode(state.core.getParent(state.nodes[_id].node));\n        }\n\n        function getId() {\n            return _id;\n        }\n\n        function getGuid() {\n            return state.core.getGuid(state.nodes[_id].node);\n        }\n\n        function getChildrenIds() {\n            return state.core.getChildrenPaths(state.nodes[_id].node);\n        }\n\n        function getBaseId() {\n            var base = state.core.getBase(state.nodes[_id].node);\n            if (base) {\n                return storeNode(base);\n            } else {\n                return null;\n            }\n\n        }\n\n        function getInheritorIds() {\n            return [];\n        }\n\n        function getAttribute(name) {\n            return state.core.getAttribute(state.nodes[_id].node, name);\n        }\n\n        function getOwnAttribute(name) {\n            return state.core.getOwnAttribute(state.nodes[_id].node, name);\n        }\n\n        function getEditableAttribute(name) {\n            var value = state.core.getAttribute(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getOwnEditableAttribute(name) {\n            var value = state.core.getOwnAttribute(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getRegistry(name) {\n            return state.core.getRegistry(state.nodes[_id].node, name);\n        }\n\n        function getOwnRegistry(name) {\n            return state.core.getOwnRegistry(state.nodes[_id].node, name);\n        }\n\n        function getEditableRegistry(name) {\n            var value = state.core.getRegistry(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getOwnEditableRegistry(name) {\n            var value = state.core.getOwnRegistry(state.nodes[_id].node, name);\n            if (typeof value === 'object') {\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n\n        function getPointer(name) {\n            //return _core.getPointerPath(_nodes[_id].node,name);\n            if (name === 'base') {\n                //base is a special case as it complicates with inherited children\n                return {to: state.core.getPath(state.core.getBase(state.nodes[_id].node)),\n                    from: []};\n            }\n            return {to: state.core.getPointerPath(state.nodes[_id].node, name), from: []};\n        }\n\n        function getOwnPointer(name) {\n            return {to: state.core.getOwnPointerPath(state.nodes[_id].node, name), from: []};\n        }\n\n        function getPointerNames() {\n            return state.core.getPointerNames(state.nodes[_id].node);\n        }\n\n        function getOwnPointerNames() {\n            return state.core.getOwnPointerNames(state.nodes[_id].node);\n        }\n\n        function getAttributeNames() {\n            return state.core.getAttributeNames(state.nodes[_id].node);\n        }\n\n        function getOwnAttributeNames() {\n            return state.core.getOwnAttributeNames(state.nodes[_id].node);\n        }\n\n        function getRegistryNames() {\n            return state.core.getRegistryNames(state.nodes[_id].node);\n        }\n\n        function getOwnRegistryNames() {\n            return state.core.getOwnRegistryNames(state.nodes[_id].node);\n        }\n\n        //SET\n        function getMemberIds(setid) {\n            return state.core.getMemberPaths(state.nodes[_id].node, setid);\n        }\n\n        function getSetNames() {\n            return state.core.getSetNames(state.nodes[_id].node);\n        }\n\n        function getMemberAttributeNames(setid, memberid) {\n            return state.core.getMemberAttributeNames(state.nodes[_id].node, setid, memberid);\n        }\n\n        function getMemberAttribute(setid, memberid, name) {\n            return state.core.getMemberAttribute(state.nodes[_id].node, setid, memberid, name);\n        }\n\n        function getEditableMemberAttribute(setid, memberid, name) {\n            var attr = state.core.getMemberAttribute(state.nodes[_id].node, setid, memberid, name);\n            if (attr !== null && attr !== undefined) {\n                return JSON.parse(JSON.stringify(attr));\n            }\n            return null;\n        }\n\n        function getMemberRegistryNames(setid, memberid) {\n            return state.core.getMemberRegistryNames(state.nodes[_id].node, setid, memberid);\n        }\n\n        function getMemberRegistry(setid, memberid, name) {\n            return state.core.getMemberRegistry(state.nodes[_id].node, setid, memberid, name);\n        }\n\n        function getEditableMemberRegistry(setid, memberid, name) {\n            var attr = state.core.getMemberRegistry(state.nodes[_id].node, setid, memberid, name);\n            if (attr !== null && attr !== undefined) {\n                return JSON.parse(JSON.stringify(attr));\n            }\n            return null;\n        }\n\n        //META\n        function getValidChildrenTypes() {\n            //return getMemberIds('ValidChildren');\n            return meta.getValidChildrenTypes(_id);\n        }\n\n        //constraint functions\n        function getConstraintNames() {\n            return state.core.getConstraintNames(state.nodes[_id].node);\n        }\n\n        function getOwnConstraintNames() {\n            return state.core.getOwnConstraintNames(state.nodes[_id].node);\n        }\n\n        function getConstraint(name) {\n            return state.core.getConstraint(state.nodes[_id].node, name);\n        }\n\n        function printData() {\n            //probably we will still use it for test purposes, but now it goes officially\n            // into printing the node's json representation\n            toJson(state.core, state.nodes[_id].node, '', 'guid', function (err, jNode) {\n                state.logger.debug('node in JSON format[status = ', err, ']:', jNode);\n            });\n        }\n\n        function toString() {\n            return state.core.getAttribute(state.nodes[_id].node, 'name') + ' (' + _id + ')';\n        }\n\n        function getCollectionPaths(name) {\n            return state.core.getCollectionPaths(state.nodes[_id].node, name);\n        }\n\n        if (state.nodes[_id]) {\n            return {\n                getParentId: getParentId,\n                getId: getId,\n                getGuid: getGuid,\n                getChildrenIds: getChildrenIds,\n                getBaseId: getBaseId,\n                getInheritorIds: getInheritorIds,\n                getAttribute: getAttribute,\n                getEditableAttribute: getEditableAttribute,\n                getRegistry: getRegistry,\n                getEditableRegistry: getEditableRegistry,\n                getOwnAttribute: getOwnAttribute,\n                getOwnEditableAttribute: getOwnEditableAttribute,\n                getOwnRegistry: getOwnRegistry,\n                getOwnEditableRegistry: getOwnEditableRegistry,\n                getPointer: getPointer,\n                getPointerNames: getPointerNames,\n                getAttributeNames: getAttributeNames,\n                getRegistryNames: getRegistryNames,\n                getOwnAttributeNames: getOwnAttributeNames,\n                getOwnRegistryNames: getOwnRegistryNames,\n                getOwnPointer: getOwnPointer,\n                getOwnPointerNames: getOwnPointerNames,\n\n                //SetFunctions\n                getMemberIds: getMemberIds,\n                getSetNames: getSetNames,\n                getMemberAttributeNames: getMemberAttributeNames,\n                getMemberAttribute: getMemberAttribute,\n                getEditableMemberAttribute: getEditableMemberAttribute,\n                getMemberRegistryNames: getMemberRegistryNames,\n                getMemberRegistry: getMemberRegistry,\n                getEditableMemberRegistry: getEditableMemberRegistry,\n\n                //META functions\n                getValidChildrenTypes: getValidChildrenTypes,\n\n                //constraint functions\n                getConstraintNames: getConstraintNames,\n                getOwnConstraintNames: getOwnConstraintNames,\n                getConstraint: getConstraint,\n\n                printData: printData,\n                toString: toString,\n\n                getCollectionPaths: getCollectionPaths\n\n            };\n        } else {\n            //logger.warn('Tried to get node with path \"' + _id + '\" but was not in state.nodes');\n        }\n\n        return null;\n    }\n\n    return getNode;\n});\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('js/client/gmeNodeSetter',[], function () {\n    'use strict';\n    function gmeNodeSetter(logger, state, saveRoot, storeNode) {\n\n        function setAttributes(path, name, value, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setAttribute(state.nodes[path].node, name, value);\n                msg = msg || 'setAttribute(' + path + ',' + name + ',' + value + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delAttributes(path, name, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delAttribute(state.nodes[path].node, name);\n                msg = msg || 'delAttribute(' + path + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setRegistry(path, name, value, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setRegistry(state.nodes[path].node, name, value);\n                msg = msg || 'setRegistry(' + path + ',' + ',' + name + ',' + value + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delRegistry(path, name, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delRegistry(state.nodes[path].node, name);\n                msg = msg || 'delRegistry(' + path + ',' + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function copyMoreNodes(parameters, msg) {\n            var pathestocopy = [],\n                i,\n                j,\n                newNode;\n\n            if (typeof parameters.parentId === 'string' && state.nodes[parameters.parentId] &&\n                typeof state.nodes[parameters.parentId].node === 'object') {\n                for (i in parameters) {\n                    if (i !== 'parentId') {\n                        pathestocopy.push(i);\n                    }\n                }\n\n                msg = msg || 'copyMoreNodes(' + pathestocopy + ',' + parameters.parentId + ')';\n                if (pathestocopy.length < 1) {\n                    // empty on purpose\n                } else if (pathestocopy.length === 1) {\n                    newNode = state.core.copyNode(state.nodes[pathestocopy[0]].node,\n                        state.nodes[parameters.parentId].node);\n                    storeNode(newNode);\n                    if (parameters[pathestocopy[0]]) {\n                        for (j in parameters[pathestocopy[0]].attributes) {\n                            if (parameters[pathestocopy[0]].attributes.hasOwnProperty(j)) {\n                                state.core.setAttribute(newNode, j, parameters[pathestocopy[0]].attributes[j]);\n                            }\n                        }\n                        for (j in parameters[pathestocopy[0]].registry) {\n                            if (parameters[pathestocopy[0]].registry.hasOwnProperty(j)) {\n                                state.core.setRegistry(newNode, j, parameters[pathestocopy[0]].registry[j]);\n                            }\n                        }\n                    }\n                    saveRoot(msg);\n                } else {\n                    copyMoreNodesAsync(pathestocopy, parameters.parentId, function (err, copyarr) {\n                        var i,\n                            j;\n                        if (err) {\n                            //rollBackModification();\n                            state.logger.error(err);\n                        } else {\n                            for (i in copyarr) {\n                                if (copyarr.hasOwnProperty(i) && parameters[i]) {\n                                    for (j in parameters[i].attributes) {\n                                        if (parameters[i].attributes.hasOwnProperty(j)) {\n                                            state.core.setAttribute(copyarr[i], j, parameters[i].attributes[j]);\n                                        }\n                                    }\n                                    for (j in parameters[i].registry) {\n                                        if (parameters[i].registry.hasOwnProperty(j)) {\n                                            state.core.setRegistry(copyarr[i], j, parameters[i].registry[j]);\n                                        }\n                                    }\n                                }\n                            }\n                            saveRoot(msg);\n                        }\n                    });\n                }\n            } else {\n                state.logger.error('wrong parameters for copy operation - denied -');\n            }\n        }\n\n        function copyMoreNodesAsync(nodePaths, parentPath, callback) {\n            var i,\n                tempFrom,\n                tempTo,\n                helpArray,\n                subPathArray,\n                parent,\n                returnArray,\n                checkPaths = function () {\n                    var i,\n                        result = true;\n\n                    for (i = 0; i < nodePaths.length; i += 1) {\n                        result = result && (state.nodes[nodePaths[i]] &&\n                            typeof state.nodes[nodePaths[i]].node === 'object');\n                    }\n                    return result;\n                };\n\n            if (state.nodes[parentPath] &&\n                typeof state.nodes[parentPath].node === 'object' && checkPaths()) {\n                helpArray = {};\n                subPathArray = {};\n                parent = state.nodes[parentPath].node;\n                returnArray = {};\n\n                //creating the 'from' object\n                tempFrom = state.core.createNode({\n                    parent: parent,\n                    base: state.core.getTypeRoot(state.nodes[nodePaths[0]].node)\n                });\n                //and moving every node under it\n                for (i = 0; i < nodePaths.length; i += 1) {\n                    helpArray[nodePaths[i]] = {};\n                    helpArray[nodePaths[i]].origparent =\n                        state.core.getParent(state.nodes[nodePaths[i]].node);\n                    helpArray[nodePaths[i]].tempnode =\n                        state.core.moveNode(state.nodes[nodePaths[i]].node, tempFrom);\n                    subPathArray[state.core.getRelid(helpArray[nodePaths[i]].tempnode)] = nodePaths[i];\n                    delete state.nodes[nodePaths[i]];\n                }\n\n                //do the copy\n                tempTo = state.core.copyNode(tempFrom, parent);\n\n                //moving back the temporary source\n                for (i = 0; i < nodePaths.length; i += 1) {\n                    helpArray[nodePaths[i]].node = state.core.moveNode(helpArray[nodePaths[i]].tempnode,\n                        helpArray[nodePaths[i]].origparent);\n                    storeNode(helpArray[nodePaths[i]].node);\n                }\n\n                //gathering the destination nodes\n                state.core.loadChildren(tempTo, function (err, children) {\n                    var newNode;\n\n                    if (!err && children && children.length > 0) {\n                        for (i = 0; i < children.length; i += 1) {\n                            if (subPathArray[state.core.getRelid(children[i])]) {\n                                newNode = state.core.moveNode(children[i], parent);\n                                storeNode(newNode);\n                                returnArray[subPathArray[state.core.getRelid(children[i])]] = newNode;\n                            } else {\n                                state.logger.error('635 - should never happen!!!');\n                            }\n                        }\n                        state.core.deleteNode(tempFrom);\n                        state.core.deleteNode(tempTo);\n                        callback(null, returnArray);\n                    } else {\n                        //clean up the mess and return\n                        state.core.deleteNode(tempFrom);\n                        state.core.deleteNode(tempTo);\n                        callback(err, {});\n                    }\n                });\n            }\n        }\n\n        function moveMoreNodes(parameters) {\n            var pathsToMove = [],\n                returnParams = {},\n                i,\n                j,\n                newNode;\n\n            for (i in parameters) {\n                if (parameters.hasOwnProperty(i)) {\n                    if (i !== 'parentId') {\n                        pathsToMove.push(i);\n                    }\n                }\n            }\n\n            if (pathsToMove.length > 0 &&\n                typeof parameters.parentId === 'string' &&\n                state.nodes[parameters.parentId] &&\n                typeof state.nodes[parameters.parentId].node === 'object') {\n                for (i = 0; i < pathsToMove.length; i += 1) {\n                    if (state.nodes[pathsToMove[i]] &&\n                        typeof state.nodes[pathsToMove[i]].node === 'object') {\n                        newNode = state.core.moveNode(state.nodes[pathsToMove[i]].node,\n                            state.nodes[parameters.parentId].node);\n                        returnParams[pathsToMove[i]] = state.core.getPath(newNode);\n                        if (parameters[pathsToMove[i]].attributes) {\n                            for (j in parameters[pathsToMove[i]].attributes) {\n                                if (parameters[pathsToMove[i]].attributes.hasOwnProperty(j)) {\n                                    state.core.setAttribute(newNode,\n                                        j, parameters[pathsToMove[i]].attributes[j]);\n                                }\n                            }\n                        }\n                        if (parameters[pathsToMove[i]].registry) {\n                            for (j in parameters[pathsToMove[i]].registry) {\n                                if (parameters[pathsToMove[i]].registry.hasOwnProperty(j)) {\n                                    state.core.setRegistry(newNode,\n                                        j, parameters[pathsToMove[i]].registry[j]);\n                                }\n                            }\n                        }\n\n                        delete state.nodes[pathsToMove[i]];\n                        storeNode(newNode, true);\n                    }\n                }\n            }\n\n            return returnParams;\n        }\n\n        function createChildren(parameters, msg) {\n            //TODO we also have to check out what is happening with the sets!!!\n            var result = {},\n                paths = [],\n                nodes = [],\n                node,\n                parent = state.nodes[parameters.parentId].node,\n                names, i, j, index, pointer,\n                newChildren = [],\n                relations = [];\n\n            //to allow 'meaningfull' instantiation of multiple objects\n            // we have to recreate the internal relations - except the base\n            paths = Object.keys(parameters);\n            paths.splice(paths.indexOf('parentId'), 1);\n            for (i = 0; i < paths.length; i++) {\n                node = state.nodes[paths[i]].node;\n                nodes.push(node);\n                pointer = {};\n                names = state.core.getPointerNames(node);\n                index = names.indexOf('base');\n                if (index !== -1) {\n                    names.splice(index, 1);\n                }\n\n                for (j = 0; j < names.length; j++) {\n                    index = paths.indexOf(state.core.getPointerPath(node, names[j]));\n                    if (index !== -1) {\n                        pointer[names[j]] = index;\n                    }\n                }\n                relations.push(pointer);\n            }\n\n            //now the instantiation\n            for (i = 0; i < nodes.length; i++) {\n                newChildren.push(state.core.createNode({parent: parent, base: nodes[i]}));\n            }\n\n            //now for the storage and relation setting\n            for (i = 0; i < paths.length; i++) {\n                //attributes\n                names = Object.keys(parameters[paths[i]].attributes || {});\n                for (j = 0; j < names.length; j++) {\n                    state.core.setAttribute(newChildren[i],\n                        names[j], parameters[paths[i]].attributes[names[j]]);\n                }\n                //registry\n                names = Object.keys(parameters[paths[i]].registry || {});\n                for (j = 0; j < names.length; j++) {\n                    state.core.setRegistry(newChildren[i],\n                        names[j], parameters[paths[i]].registry[names[j]]);\n                }\n\n                //relations\n                names = Object.keys(relations[i]);\n                for (j = 0; j < names.length; j++) {\n                    state.core.setPointer(newChildren[i], names[j], newChildren[relations[i][names[j]]]);\n                }\n\n                //store\n                result[paths[i]] = storeNode(newChildren[i]);\n\n            }\n\n            msg = msg || 'createChildren(' + JSON.stringify(result) + ')';\n            saveRoot(msg);\n            return result;\n        }\n\n        //TODO should be removed as there is no user or public API related to this function\n        //function deleteNode(path, msg) {\n        //  if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n        //    state.core.deleteNode(state.nodes[path].node);\n        //    //delete state.nodes[path];\n        //    msg = msg || 'deleteNode(' + path + ')';\n        //    saveRoot(msg);\n        //  }\n        //}\n\n        function delMoreNodes(paths, msg) {\n            if (state.core) {\n                for (var i = 0; i < paths.length; i++) {\n                    if (state.nodes[paths[i]] && typeof state.nodes[paths[i]].node === 'object') {\n                        state.core.deleteNode(state.nodes[paths[i]].node);\n                        //delete state.nodes[paths[i]];\n                    }\n                }\n                msg = msg || 'delMoreNodes(' + paths + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function createChild(parameters, msg) {\n            var newID;\n\n            if (state.core) {\n                if (typeof parameters.parentId === 'string' && state.nodes[parameters.parentId] &&\n                    typeof state.nodes[parameters.parentId].node === 'object') {\n                    var baseNode = null;\n                    if (state.nodes[parameters.baseId]) {\n                        baseNode = state.nodes[parameters.baseId].node || baseNode;\n                    }\n                    var child = state.core.createNode({\n                        parent: state.nodes[parameters.parentId].node,\n                        base: baseNode,\n                        guid: parameters.guid,\n                        relid: parameters.relid\n                    });\n                    if (parameters.position) {\n                        state.core.setRegistry(child,\n                            'position',\n                            {\n                                x: parameters.position.x || 100,\n                                y: parameters.position.y || 100\n                            });\n                    } else {\n                        state.core.setRegistry(child, 'position', {x: 100, y: 100});\n                    }\n                    storeNode(child);\n                    newID = state.core.getPath(child);\n                    msg = msg || 'createChild(' + parameters.parentId + ',' + parameters.baseId + ',' + newID + ')';\n                    saveRoot(msg);\n                }\n            }\n\n            return newID;\n        }\n\n        function makePointer(id, name, to, msg) {\n            if (to === null) {\n                state.core.setPointer(state.nodes[id].node, name, to);\n            } else {\n\n\n                state.core.setPointer(state.nodes[id].node, name, state.nodes[to].node);\n            }\n\n            msg = msg || 'makePointer(' + id + ',' + name + ',' + to + ')';\n            saveRoot(msg);\n        }\n\n        function delPointer(path, name, msg) {\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.deletePointer(state.nodes[path].node, name);\n                msg = msg || 'delPointer(' + path + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n\n        //MGAlike - set functions\n        function addMember(path, memberpath, setid, msg) {\n            if (state.nodes[path] &&\n                state.nodes[memberpath] &&\n                typeof state.nodes[path].node === 'object' &&\n                typeof state.nodes[memberpath].node === 'object') {\n                state.core.addMember(state.nodes[path].node,\n                    setid, state.nodes[memberpath].node);\n                msg = msg || 'addMember(' + path + ',' + memberpath + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function removeMember(path, memberpath, setid, msg) {\n            if (state.nodes[path] &&\n                typeof state.nodes[path].node === 'object') {\n                state.core.delMember(state.nodes[path].node, setid, memberpath);\n                msg = msg || 'removeMember(' + path + ',' + memberpath + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setMemberAttribute(path, memberpath, setid, name, value, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setMemberAttribute(state.nodes[path].node, setid, memberpath, name, value);\n                msg = msg ||\n                    'setMemberAttribute(' + path + ',' + memberpath + ',' + setid + ',' + name + ',' + value +\n                    ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delMemberAttribute(path, memberpath, setid, name, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delMemberAttribute(state.nodes[path].node, setid, memberpath, name);\n                msg = msg || 'delMemberAttribute(' + path + ',' + memberpath + ',' + setid + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setMemberRegistry(path, memberpath, setid, name, value, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setMemberRegistry(state.nodes[path].node, setid, memberpath, name, value);\n                msg = msg ||\n                    'setMemberRegistry(' + path + ',' + memberpath + ',' + setid + ',' + name + ',' + value + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function delMemberRegistry(path, memberpath, setid, name, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.delMemberRegistry(state.nodes[path].node, setid, memberpath, name);\n                msg = msg || 'delMemberRegistry(' + path + ',' + memberpath + ',' + setid + ',' + name + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function createSet(path, setid, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.createSet(state.nodes[path].node, setid);\n                msg = msg || 'createSet(' + path + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function deleteSet(path, setid, msg) {\n            if (state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.deleteSet(state.nodes[path].node, setid);\n                msg = msg || 'deleteSet(' + path + ',' + setid + ')';\n                saveRoot(msg);\n            }\n        }\n\n        function setBase(path, basepath) {\n            /*if (state.core &&\n             state.nodes[path] && typeof state.nodes[path].node === 'object') {\n             state.core.setRegistry(state.nodes[path].node,'base',basepath);\n             saveRoot('setBase('+path+','+basepath+')');\n             }*/\n            if (state.core &&\n                state.nodes[path] &&\n                typeof state.nodes[path].node === 'object' &&\n                state.nodes[basepath] &&\n                typeof state.nodes[basepath].node === 'object') {\n                state.core.setBase(state.nodes[path].node, state.nodes[basepath].node);\n                saveRoot('setBase(' + path + ',' + basepath + ')');\n            }\n        }\n\n        function delBase(path) {\n            /*if (state.core &&\n             state.nodes[path] && typeof state.nodes[path].node === 'object') {\n             state.core.delRegistry(state.nodes[path].node,'base');\n             saveRoot('delBase('+path+')');\n             }*/\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\n                state.core.setBase(state.nodes[path].node, null);\n                saveRoot('delBase(' + path + ')');\n            }\n        }\n\n        return {\n            setAttributes: setAttributes,\n            delAttributes: delAttributes,\n            setRegistry: setRegistry,\n            delRegistry: delRegistry,\n            copyMoreNodes: copyMoreNodes,\n            moveMoreNodes: moveMoreNodes,\n            delMoreNodes: delMoreNodes,\n            createChild: createChild,\n            createChildren: createChildren,\n            makePointer: makePointer,\n            delPointer: delPointer,\n            addMember: addMember,\n            removeMember: removeMember,\n            setMemberAttribute: setMemberAttribute,\n            delMemberAttribute: delMemberAttribute,\n            setMemberRegistry: setMemberRegistry,\n            delMemberRegistry: delMemberRegistry,\n            createSet: createSet,\n            deleteSet: deleteSet,\n\n            setBase: setBase,\n            delBase: delBase,\n        };\n    }\n\n    return gmeNodeSetter;\n});\n",
    "/*globals define*/\n/*jshint node: true, browser: true*/\n\n/**\n * @author kecso / https://github.com/kecso\n */\n\ndefine('common/core/users/serialization',['common/util/assert'], function (ASSERT) {\n\n    'use strict';\n    var _nodes = {},\n        _core = null,\n        _pathToGuidMap = {},\n        _guidKeys = [], //ordered list of GUIDs\n        _extraBasePaths = {},\n        _export = {},\n        _import = {},\n        _newNodeGuids = [],\n        _removedNodeGuids = [],\n        _updatedNodeGuids = [],\n        _log = '';\n\n    function log(txt) {\n        if (_log) {\n            _log += '\\n' + txt;\n        } else {\n            _log = '' + txt;\n        }\n    }\n\n    function exportLibrary(core, libraryRoot, callback) {\n        //initialization\n        _core = core;\n        _nodes = {};\n        _pathToGuidMap = {};\n        _guidKeys = [];\n        _extraBasePaths = {};\n        _export = {};\n\n        //loading all library element\n        gatherNodesSlowly(libraryRoot, function (err) {\n            if (err) {\n                return callback(err);\n            }\n\n            _guidKeys = _guidKeys.sort();\n            gatherAncestors(); //collecting the 'external' base classes - probably we should avoid these\n\n            var keys = Object.keys(_extraBasePaths),\n                i;\n            _export.bases = {};\n            for (i = 0; i < keys.length; i++) {\n                _export.bases[_extraBasePaths[keys[i]]] = keys[i];\n            }\n\n            //_export.bases = _extraBasePaths;\n            // we save this info alongside with the library export, to be on the safe side\n\n            _export.root = getLibraryRootInfo(libraryRoot);\n            _export.relids = getRelIdInfo();\n            _export.containment = {};\n            fillContainmentTree(libraryRoot, _export.containment);\n            _export.nodes = getNodesData();\n\n            //we export MetaSheet info only if not the whole project is exported!!!\n            _export.metaSheets = core.getParent(libraryRoot) ? getMetaSheetInfo(_core.getRoot(libraryRoot)) : {};\n\n            callback(null, _export);\n\n        });\n    }\n\n    function getMetaSheetInfo(root) {\n        var getMemberRegistry = function (setname, memberpath) {\n                var names = _core.getMemberRegistryNames(root, setname, memberpath),\n                    i,\n                    registry = {};\n                for (i = 0; i < names.length; i++) {\n                    registry[names[i]] = _core.getMemberRegistry(root, setname, memberpath, names[i]);\n                }\n                return registry;\n            },\n            getMemberAttributes = function (setname, memberpath) {\n                var names = _core.getMemberAttributeNames(root, setname, memberpath),\n                    i,\n                    attributes = {};\n                for (i = 0; i < names.length; i++) {\n                    attributes[names[i]] = _core.getMemberAttribute(root, setname, memberpath, names[i]);\n                }\n                return attributes;\n            },\n            getRegistryEntry = function (setname) {\n                var index = registry.length;\n\n                while (--index >= 0) {\n                    if (registry[index].SetID === setname) {\n                        return registry[index];\n                    }\n                }\n                return {};\n            },\n            sheets = {},\n            registry = _core.getRegistry(root, 'MetaSheets'),\n            keys = _core.getSetNames(root),\n            elements, guid,\n            i,\n            j;\n\n        for (i = 0; i < keys.length; i++) {\n            if (keys[i].indexOf('MetaAspectSet') === 0) {\n                elements = _core.getMemberPaths(root, keys[i]);\n                for (j = 0; j < elements.length; j++) {\n                    guid = _pathToGuidMap[elements[j]] || _extraBasePaths[elements[j]];\n                    if (guid) {\n                        sheets[keys[i]] = sheets[keys[i]] || {};\n                        sheets[keys[i]][guid] = {\n                            registry: getMemberRegistry(keys[i], elements[j]),\n                            attributes: getMemberAttributes(keys[i], elements[j])\n                        };\n                    }\n                }\n\n                if (sheets[keys[i]] && keys[i] !== 'MetaAspectSet') {\n                    //we add the global registry values as well\n                    sheets[keys[i]].global = getRegistryEntry(keys[i]);\n                }\n            }\n        }\n        return sheets;\n    }\n\n    function importMetaSheetInfo(root) {\n        var setMemberAttributesAndRegistry = function (setname, memberguid) {\n                var attributes = oldSheets[setname][memberguid].attributes || {},\n                    registry = oldSheets[setname][memberguid].registry || {},\n                    keys = Object.keys(attributes),\n                    i;\n\n                for (i = 0; i < keys.length; i++) {\n                    _core.setMemberAttribute(root, setname, _core.getPath(_nodes[memberguid]), keys[i],\n                        attributes[keys[i]]);\n                }\n                keys = Object.keys(registry);\n                for (i = 0; i < keys.length; i++) {\n                    _core.setMemberRegistry(root, setname, _core.getPath(_nodes[memberguid]), keys[i],\n                        registry[keys[i]]);\n                }\n            },\n            updateSheet = function (name) {\n                //the removed object should be already removed...\n                //if some element is extra in the place of import, then it stays untouched\n                var oldMemberGuids = Object.keys(oldSheets[name]),\n                    i;\n                oldMemberGuids.splice(oldMemberGuids.indexOf('global'), 1);\n                for (i = 0; i < oldMemberGuids.length; i++) {\n                    _core.addMember(root, name, _nodes[oldMemberGuids[i]]);\n                    setMemberAttributesAndRegistry(name, oldMemberGuids[i]);\n                }\n            },\n            addSheet = function (name) {\n                var registry = JSON.parse(JSON.stringify(_core.getRegistry(root, 'MetaSheets')) || {}),\n                    i,\n                    memberpath,\n                    memberguids = Object.keys(oldSheets[name]);\n\n                memberguids.splice(memberguids.indexOf('global'), 1);\n\n                if (name !== 'MetaAspectSet') {\n                    registry.push(oldSheets[name].global);\n                    _core.setRegistry(root, 'MetaSheets', registry);\n                }\n\n                _core.createSet(root, name);\n                for (i = 0; i < memberguids.length; i++) {\n                    memberpath = _core.getPath(_nodes[memberguids[i]]);\n                    _core.addMember(root, name, _nodes[memberguids[i]]);\n                    setMemberAttributesAndRegistry(name, memberguids[i]);\n                }\n            },\n            oldSheets = _import.metaSheets || {},\n            newSheets = _export.metaSheets || {},\n            oldSheetNames = Object.keys(oldSheets),\n            newSheetNames = Object.keys(newSheets),\n            i;\n\n        for (i = 0; i < oldSheetNames.length; i++) {\n            if (newSheetNames.indexOf(oldSheetNames[i]) !== -1) {\n                updateSheet(oldSheetNames[i]);\n            } else {\n                addSheet(oldSheetNames[i]);\n            }\n        }\n    }\n\n    function getLibraryRootInfo(node) {\n        return {\n            path: _core.getPath(node),\n            guid: _core.getGuid(node)\n        };\n    }\n\n    function gatherNodesSlowly(node, callback) {\n        _core.loadSubTree(node, function (err, nodes) {\n            var guid, i;\n            if (!err && nodes) {\n                for (i = 0; i < nodes.length; i++) {\n                    guid = _core.getGuid(nodes[i]);\n                    _nodes[guid] = nodes[i];\n                    _guidKeys.push(guid);\n                    _pathToGuidMap[_core.getPath(nodes[i])] = guid;\n                }\n                callback(null);\n            } else {\n                callback(err);\n            }\n        });\n    }\n\n    function gatherAncestors() {\n        //this function inserts the needed base classes which were not included in the library\n        var i, base, guid;\n        for (i = 0; i < _guidKeys.length; i++) {\n            base = _nodes[_guidKeys[i]];\n            while (base !== null) {\n                guid = _core.getGuid(base);\n                if (!_nodes[guid]) {\n                    _nodes[guid] = base;\n                    _extraBasePaths[_core.getPath(base)] = guid;\n                } else if (_guidKeys.indexOf(guid) === -1) {\n                    _extraBasePaths[_core.getPath(base)] = guid;\n                }\n                base = _core.getBase(base);\n            }\n        }\n    }\n\n    function pathsToSortedGuidList(pathsList) { //it will also filter out not wanted elements\n        var i, guids = [];\n        for (i = 0; i < pathsList.length; i++) {\n            if (_pathToGuidMap[pathsList[i]]) {\n                guids.push(_pathToGuidMap[pathsList[i]]);\n            }\n        }\n        return guids.sort();\n    }\n\n    function fillContainmentTree(node, myTreeObject) {\n        var childrenGuids = pathsToSortedGuidList(_core.getChildrenPaths(node)),\n            i;\n        for (i = 0; i < childrenGuids.length; i++) {\n            myTreeObject[childrenGuids[i]] = {};\n            fillContainmentTree(_nodes[childrenGuids[i]], myTreeObject[childrenGuids[i]]);\n        }\n    }\n\n    function getRelIdInfo() {\n        var i,\n            relIdInfo = {};\n        for (i = 0; i < _guidKeys.length; i++) {\n            relIdInfo[_guidKeys[i]] = _core.getRelid(_nodes[_guidKeys[i]]);\n        }\n        return relIdInfo;\n    }\n\n    function getNodesData() {\n        var data = {},\n            i;\n        for (i = 0; i < _guidKeys.length; i++) {\n            data[_guidKeys[i]] = getNodeData(_nodes[_guidKeys[i]]);\n        }\n        return data;\n    }\n\n    function getNodeData(node) {\n        /*{\n         //only the ones defined on this level\n         attributes:{name:value},\n         base:GUID,\n         registry:{name:value},\n         parent:GUID,\n         pointers:{name:targetGuid},\n         sets:{name:[{guid:GUID,attributes:{name:value},registy:{name:value}}]}\n         meta:{}\n         }*/\n        return {\n            attributes: getAttributesOfNode(node),\n            base: _core.getBase(node) ? _core.getGuid(_core.getBase(node)) : null,\n            meta: pathsToGuids(JSON.parse(JSON.stringify(_core.getOwnJsonMeta(node)) || {})),\n            parent: _core.getParent(node) ? _core.getGuid(_core.getParent(node)) : null,\n            pointers: getPointersOfNode(node),\n            registry: getRegistryOfNode(node),\n            sets: getSetsOfNode(node),\n            constraints: getConstraintsOfNode(node)\n        };\n    }\n\n    function baseGuid(path) {\n        /*var keys = Object.keys(_extraBasePaths),\n         i;\n         for(i=0;i<keys.length;i++){\n         if(_extraBasePaths[keys[i]] === path){\n         return keys[i];\n         }\n         }\n         return null;*/\n        return _extraBasePaths[path];\n    }\n\n    var sortMultipleArrays = function () {\n        var index = getSortedIndex(arguments[0]);\n        for (var j = 0; j < arguments.length; j++) {\n            var _arr = arguments[j].slice();\n            for (var i = 0; i < _arr.length; i++) {\n                arguments[j][i] = _arr[index[i]];\n            }\n        }\n    };\n\n    var getSortedIndex = function (arr) {\n        var index = [];\n        for (var i = 0; i < arr.length; i++) {\n            index.push(i);\n        }\n        index = index.sort((function (arr) {\n            return function (a, b) {\n                return ((arr[a] > arr[b]) ? 1 : ((arr[a] < arr[b]) ? -1 : 0));\n            };\n        })(arr));\n        return index;\n    };\n\n    function pathsToGuids(jsonObject) {\n        if (jsonObject && typeof jsonObject === 'object') {\n            var keys = Object.keys(jsonObject),\n                i, j, k, toDelete, tArray;\n\n            for (i = 0; i < keys.length; i++) {\n                if (keys[i] === 'items') {\n                    //here comes the transformation itself\n                    toDelete = [];\n                    for (j = 0; j < jsonObject.items.length; j++) {\n                        if (_pathToGuidMap[jsonObject.items[j]]) {\n                            jsonObject.items[j] = _pathToGuidMap[jsonObject.items[j]];\n                        } else if (baseGuid(jsonObject.items[j])) {\n                            jsonObject.items[j] = baseGuid(jsonObject.items[j]);\n                        } else {\n                            toDelete.push(j);\n                        }\n                    }\n\n                    if (toDelete.length > 0) {\n                        toDelete = toDelete.sort();\n                        toDelete = toDelete.reverse();\n                        for (j = 0; j < toDelete.length; j++) {\n                            jsonObject.items.splice(toDelete[j], 1);\n                            jsonObject.minItems.splice(toDelete[j], 1);\n                            jsonObject.maxItems.splice(toDelete[j], 1);\n                        }\n                    }\n                    sortMultipleArrays(jsonObject.items, jsonObject.minItems, jsonObject.maxItems);\n                } else if (keys[i] === 'aspects') {\n                    //aspects are a bunch of named path list, so we have to handle them separately\n                    tArray = Object.keys(jsonObject[keys[i]]);\n                    for (j = 0; j < tArray.length; j++) {\n                        //here comes the transformation itself\n                        toDelete = [];\n                        for (k = 0; k < jsonObject.aspects[tArray[j]].length; k++) {\n                            if (_pathToGuidMap[jsonObject.aspects[tArray[j]][k]]) {\n                                jsonObject.aspects[tArray[j]][k] = _pathToGuidMap[jsonObject.aspects[tArray[j]][k]];\n                            } else if (baseGuid(jsonObject.aspects[tArray[j]][k])) {\n                                jsonObject.aspects[tArray[j]][k] = baseGuid(jsonObject.aspects[tArray[j]][k]);\n                            } else {\n                                toDelete.push(k);\n                            }\n                        }\n\n                        if (toDelete.length > 0) {\n                            toDelete = toDelete.sort();\n                            toDelete = toDelete.reverse();\n                            for (k = 0; k < toDelete.length; k++) {\n                                jsonObject.aspects[tArray[j]].splice(toDelete[k], 1);\n                            }\n                        }\n\n                        jsonObject.aspects[tArray[j]] = jsonObject.aspects[tArray[j]].sort();\n\n                    }\n                } else {\n                    if (typeof jsonObject[keys[i]] === 'object') {\n                        jsonObject[keys[i]] = pathsToGuids(jsonObject[keys[i]]);\n                    }\n                }\n            }\n\n        }\n        return jsonObject;\n    }\n\n    function getAttributesOfNode(node) {\n        var names = _core.getOwnAttributeNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getAttribute(node, names[i]);\n        }\n        return result;\n    }\n\n    function getRegistryOfNode(node) {\n        var names = _core.getOwnRegistryNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getRegistry(node, names[i]);\n        }\n        return result;\n    }\n\n    function getConstraintsOfNode(node) {\n        var names = _core.getOwnConstraintNames(node).sort(),\n            i,\n            result = {};\n        for (i = 0; i < names.length; i++) {\n            result[names[i]] = _core.getConstraint(node, names[i]);\n        }\n        return result;\n    }\n\n    function getPointersOfNode(node) {\n        var names = _core.getOwnPointerNames(node).sort(),\n            i,\n            result = {},\n            target;\n        for (i = 0; i < names.length; i++) {\n            target = _core.getPointerPath(node, names[i]);\n            if (_pathToGuidMap[target] || baseGuid(target) || target === null) {\n                result[names[i]] = _pathToGuidMap[target] || baseGuid(target) || null;\n            }\n        }\n        return result;\n    }\n\n    function getOwnMemberPaths(node, setName) {\n        var base = _core.getBase(node),\n            baseMembers = base === null ? [] : _core.getMemberPaths(base, setName),\n            members = _core.getMemberPaths(node, setName),\n            ownMembers = [],\n            i;\n        for (i = 0; i < members.length; i++) {\n            if (baseMembers.indexOf(members[i]) === -1) {\n                ownMembers.push(members[i]);\n            }\n        }\n        return ownMembers;\n    }\n\n    function getSetsOfNode(node) {\n        var names = _core.getSetNames(node).sort(),\n            i, j, k,\n            result = {},\n            targetGuids,\n            attributeNames,\n            registryNames,\n            memberInfo,\n            path;\n        for (i = 0; i < names.length; i++) {\n            targetGuids = pathsToSortedGuidList(getOwnMemberPaths(node, names[i]));\n            result[names[i]] = [];\n            for (j = 0; j < targetGuids.length; j++) {\n                path = _core.getPath(_nodes[targetGuids[j]]);\n                memberInfo = {\n                    attributes: {},\n                    guid: targetGuids[j],\n                    registry: {}\n                };\n\n                //attributes\n                attributeNames = _core.getMemberAttributeNames(node, names[i], path).sort();\n                for (k = 0; k < attributeNames.length; k++) {\n                    memberInfo.attributes[attributeNames[k]] =\n                        _core.getMemberAttribute(node, names[i], path, attributeNames[k]);\n                }\n\n                //registry\n                registryNames = _core.getMemberRegistryNames(node, names[i], path).sort();\n                for (k = 0; k < registryNames.length; k++) {\n                    memberInfo.registry[registryNames[k]] =\n                        _core.getMemberRegistry(node, names[i], path, registryNames[k]);\n                }\n\n                result[names[i]].push(memberInfo);\n            }\n        }\n        return result;\n    }\n\n    function logId(nodes, id) {\n        var txtId = id + '';\n        if (nodes[id] && nodes[id].attributes && nodes[id].attributes.name) {\n            txtId = nodes[id].attributes.name + '(' + id + ')';\n        }\n\n        return txtId;\n    }\n\n    function loadImportBases(guids, root, callback) {\n        var needed = [],\n            error = null,\n            stillToGo = 0,\n            i,\n            guidList = Object.keys(guids),\n            loadBase = function (guid, path, cb) {\n                _core.loadByPath(root, path, function (err, node) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    if (_core.getGuid(node) !== guid) {\n                        return cb('GUID mismatch');\n                    }\n\n                    _nodes[guid] = node;\n                    cb(null);\n                });\n            };\n\n        for (i = 0; i < guidList.length; i++) {\n            if (_nodes[guidList[i]] === undefined) {\n                needed.push(guidList[i]);\n            }\n        }\n\n        if (needed.length > 0) {\n            stillToGo = needed.length;\n            for (i = 0; i < needed.length; i++) {\n                loadBase(needed[i], guids[needed[i]], function (err) {\n                    error = error || err;\n                    if (--stillToGo === 0) {\n                        callback(error);\n                    }\n                });\n            }\n        } else {\n            return callback(null);\n        }\n\n    }\n\n    function importLibrary(core, originLibraryRoot, updatedLibraryJson, callback) {\n        _core = core;\n        _import = updatedLibraryJson;\n        _newNodeGuids = [];\n        _updatedNodeGuids = [];\n        _removedNodeGuids = [];\n        _log = '';\n\n        synchronizeRoots(originLibraryRoot, _import.root.guid);\n        exportLibrary(core, originLibraryRoot, function (err) {\n            //we do not need the returned json object as that is stored in our global _export variable\n            if (err) {\n                return callback(err);\n            }\n\n            //now we will search for the bases of the import and load them\n            loadImportBases(_import.bases, _core.getRoot(originLibraryRoot), function (err) {\n                if (err) {\n                    return callback(err);\n                }\n\n                //now we fill the insert/update/remove lists of GUIDs\n                var oldkeys = Object.keys(_export.nodes),\n                    newkeys = Object.keys(_import.nodes),\n                    i;\n\n                //TODO now we make three rounds although one would be sufficient on ordered lists\n                for (i = 0; i < oldkeys.length; i++) {\n                    if (newkeys.indexOf(oldkeys[i]) === -1) {\n                        log('node ' + logId(_export.nodes, oldkeys[i]) +\n                        ', all of its sub-types and its children will be removed');\n\n                        _removedNodeGuids.push(oldkeys[i]);\n                    }\n                }\n\n                for (i = 0; i < oldkeys.length; i++) {\n                    if (newkeys.indexOf(oldkeys[i]) !== -1) {\n                        log('node ' + logId(_export.nodes, oldkeys[i]) + ' will be updated');\n                        _updatedNodeGuids.push(oldkeys[i]);\n                    }\n                }\n\n                for (i = 0; i < newkeys.length; i++) {\n                    if (oldkeys.indexOf(newkeys[i]) === -1) {\n                        log('node ' + logId(_import.nodes, newkeys[i]) + ' will be added');\n                        _newNodeGuids.push(newkeys[i]);\n                    }\n                }\n\n                //Now we normalize the removedGUIDs by containment and remove them\n                var toDelete = [],\n                    parent;\n                for (i = 0; i < _removedNodeGuids.length; i++) {\n                    parent = _core.getParent(_nodes[_removedNodeGuids[i]]);\n                    if (parent && _removedNodeGuids.indexOf(_core.getGuid(parent)) === -1) {\n                        toDelete.push(_removedNodeGuids[i]);\n                    }\n                }\n                //and as a final step we remove all that is needed\n                for (i = 0; i < toDelete.length; i++) {\n                    _core.deleteNode(_nodes[toDelete[i]]);\n                }\n\n                //as a second step we should deal with the updated nodes\n                //we should go among containment hierarchy\n                updateNodes(_import.root.guid, null, _import.containment);\n\n                //now update inheritance chain\n                //we assume that our inheritance chain comes from the FCO and that it is identical everywhere\n                updateInheritance();\n\n                //now we can add or modify the relations of the nodes - we go along the hierarchy chain\n                updateRelations();\n\n                //finally we need to update the meta rules of each node - again along the containment hierarchy\n                updateMetaRules(_import.root.guid, _import.containment);\n\n                //after everything is done we try to synchronize the metaSheet info\n                importMetaSheetInfo(_core.getRoot(originLibraryRoot));\n\n                callback(null, _log);\n            });\n        });\n    }\n\n    function synchronizeRoots(oldRoot, newGuid) {\n        _core.setGuid(oldRoot, newGuid);\n    }\n\n    //it will update the modified nodes and create the new ones regarding their place in the hierarchy chain\n    function updateNodes(guid, parent, containmentTreeObject) {\n        if (_updatedNodeGuids.indexOf(guid) !== -1) {\n            updateNode(guid, parent);\n        }\n\n        var keys = Object.keys(containmentTreeObject),\n            i,\n            node = _nodes[guid],\n            relid;\n\n        for (i = 0; i < keys.length; i++) {\n            if (_updatedNodeGuids.indexOf(keys[i]) === -1) {\n                relid = _import.relids[keys[i]];\n                if (_core.getChildrenRelids(node).indexOf(relid) !== -1) {\n                    relid = undefined;\n                }\n                //this child is a new one so we should create\n                _nodes[keys[i]] = _core.createNode({parent: node, guid: keys[i], relid: relid});\n                addNode(keys[i]);\n            }\n            updateNodes(keys[i], node, containmentTreeObject[keys[i]]);\n        }\n    }\n\n    function updateRegistry(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n\n        keys = _core.getOwnRegistryNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delRegistry(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.registry);\n        for (i = 0; i < keys.length; i++) {\n            _core.setRegistry(node, keys[i], jsonNode.registry[keys[i]]);\n        }\n    }\n\n    function updateAttributes(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n\n        keys = _core.getOwnAttributeNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delAttribute(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.attributes);\n        for (i = 0; i < keys.length; i++) {\n            _core.setAttribute(node, keys[i], jsonNode.attributes[keys[i]]);\n        }\n    }\n\n    function updateConstraints(guid) {\n        var keys, i,\n            node = _nodes[guid],\n            jsonNode = _import.nodes[guid];\n        keys = _core.getOwnConstraintNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.delConstraint(node, keys[i]);\n        }\n\n        keys = Object.keys(jsonNode.constraints || {});\n        for (i = 0; i < keys.length; i++) {\n            _core.setConstraint(node, keys[i], jsonNode.constraints[keys[i]]);\n        }\n    }\n\n    //this function does not cover relations - it means only attributes and registry have been updated here\n    function updateNode(guid, parent) {\n        //first we check if the node have to be moved\n        var node = _nodes[guid];\n\n        if (parent && _core.getParent(node) && _core.getGuid(parent) !== _core.getGuid(_core.getParent(node))) {\n            //parent changed so it has to be moved...\n            _nodes[guid] = _core.moveNode(node, parent);\n        }\n\n        updateAttributes(guid);\n        updateRegistry(guid);\n        updateConstraints(guid);\n    }\n\n    //this function doesn't not cover relations - so only attributes and registry have been taken care of here\n    function addNode(guid) {\n        //at this point we assume that an empty vessel has been already created and part of the _nodes\n        updateAttributes(guid);\n        updateRegistry(guid);\n        updateConstraints(guid);\n    }\n\n    function getInheritanceBasedGuidOrder() {\n        var inheritanceOrdered = Object.keys(_import.nodes).sort(),\n            i = 0,\n            baseGuid,\n            baseIndex;\n\n        while (i < inheritanceOrdered.length) {\n            baseGuid = _import.nodes[inheritanceOrdered[i]].base;\n            if (baseGuid) {\n                baseIndex = inheritanceOrdered.indexOf(baseGuid);\n                if (baseIndex > i) {\n                    inheritanceOrdered.splice(baseIndex, 1);\n                    inheritanceOrdered.splice(i, 0, baseGuid);\n                } else {\n                    ++i;\n                }\n            } else {\n                ++i;\n            }\n        }\n        return inheritanceOrdered;\n    }\n\n    function updateRelations() {\n        var guids = getInheritanceBasedGuidOrder(),\n            i;\n        for (i = 0; i < guids.length; i++) {\n            updateNodeRelations(guids[i]);\n        }\n    }\n\n    function updateNodeRelations(guid) {\n        // Although it is possible that we set the base pointer at this point\n        // we should go through inheritance just to be sure.\n        var node = _nodes[guid],\n            jsonNode = _import.nodes[guid],\n            keys, i, j, k, target, memberGuid;\n\n        //pointers\n        keys = _core.getOwnPointerNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.deletePointer(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.pointers);\n        for (i = 0; i < keys.length; i++) {\n            target = jsonNode.pointers[keys[i]];\n            if (target === null) {\n                _core.setPointer(node, keys[i], null);\n            } else if (_nodes[target] && _removedNodeGuids.indexOf(target) === -1) {\n                _core.setPointer(node, keys[i], _nodes[target]);\n            } else {\n                console.log('error handling needed???!!!???');\n            }\n        }\n\n        //sets\n        keys = _core.getSetNames(node);\n        for (i = 0; i < keys.length; i++) {\n            _core.deleteSet(node, keys[i]);\n        }\n        keys = Object.keys(jsonNode.sets);\n        for (i = 0; i < keys.length; i++) {\n            //for every set we create it, go through its members...\n            _core.createSet(node, keys[i]);\n            for (j = 0; j < jsonNode.sets[keys[i]].length; j++) {\n                memberGuid = jsonNode.sets[keys[i]][j].guid;\n                if (_nodes[memberGuid]) {\n                    _core.addMember(node, keys[i], _nodes[memberGuid]);\n                    for (k in jsonNode.sets[keys[i]][j].attributes) {\n                        _core.setMemberAttribute(node, keys[i], _core.getPath(_nodes[memberGuid]), k,\n                            jsonNode.sets[keys[i]][j].attributes[k]);\n                    }\n                    for (k in jsonNode.sets[keys[i]][j].registry) {\n                        _core.setMemberRegistry(node, keys[i], _core.getPath(_nodes[memberGuid]), k,\n                            jsonNode.sets[keys[i]][j].registry[k]);\n                    }\n                }\n            }\n        }\n    }\n\n    function updateInheritance() {\n        var i,\n            guidList = Object.keys(_import.nodes),\n            base;\n        for (i = 0; i < guidList.length; i++) {\n            base = _core.getBase(_nodes[guidList[i]]);\n            if ((base && _core.getGuid(base) !== _import.nodes[guidList[i]].base) ||\n                (base === null && _import.nodes[guidList[i]].base !== null)) {\n\n                updateNodeInheritance(guidList[i]);\n            }\n        }\n    }\n\n    function updateNodeInheritance(guid) {\n        _core.setBase(_nodes[guid], _nodes[_import.nodes[guid].base]);\n    }\n\n    function updateMetaRules(guid, containmentTreeObject) {\n\n        var keys, i;\n\n        updateMeta(guid);\n\n        keys = Object.keys(containmentTreeObject);\n        for (i = 0; i < keys.length; i++) {\n            updateMetaRules(keys[i], containmentTreeObject[keys[i]]);\n        }\n    }\n\n    function updateMeta(guid) {\n        _core.clearMetaRules(_nodes[guid]);\n\n        updateAttributeMeta(guid);\n        updateChildrenMeta(guid);\n        updatePointerMeta(guid);\n        updateAspectMeta(guid);\n        updateConstraintMeta(guid);\n    }\n\n    function updateAttributeMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.attributes || {},\n            node = _nodes[guid],\n            keys, i;\n\n        keys = Object.keys(jsonMeta);\n        for (i = 0; i < keys.length; i++) {\n            _core.setAttributeMeta(node, keys[i], jsonMeta[keys[i]]);\n        }\n    }\n\n    function updateChildrenMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.children || {items: [], minItems: [], maxItems: []},\n            i;\n        ASSERT(jsonMeta.items.length === jsonMeta.minItems.length &&\n        jsonMeta.minItems.length === jsonMeta.maxItems.length);\n\n        _core.setChildrenMetaLimits(_nodes[guid], jsonMeta.min, jsonMeta.max);\n        for (i = 0; i < jsonMeta.items.length; i++) {\n            _core.setChildMeta(_nodes[guid], _nodes[jsonMeta.items[i]], jsonMeta.minItems[i], jsonMeta.maxItems[i]);\n        }\n    }\n\n    function updatePointerMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.pointers || {},\n            keys = Object.keys(jsonMeta),\n            i, j;\n\n        for (i = 0; i < keys.length; i++) {\n            ASSERT(jsonMeta[keys[i]].items.length === jsonMeta[keys[i]].minItems.length &&\n            jsonMeta[keys[i]].maxItems.length === jsonMeta[keys[i]].minItems.length);\n\n            for (j = 0; j < jsonMeta[keys[i]].items.length; j++) {\n                _core.setPointerMetaTarget(_nodes[guid], keys[i], _nodes[jsonMeta[keys[i]].items[j]],\n                    jsonMeta[keys[i]].minItems[j], jsonMeta[keys[i]].maxItems[j]);\n            }\n            _core.setPointerMetaLimits(_nodes[guid], keys[i], jsonMeta[keys[i]].min, jsonMeta[keys[i]].max);\n        }\n    }\n\n    function updateAspectMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.aspects || {},\n            keys = Object.keys(jsonMeta),\n            i, j;\n\n        for (i = 0; i < keys.length; i++) {\n            for (j = 0; j < jsonMeta[keys[i]].length; j++) {\n                _core.setAspectMetaTarget(_nodes[guid], keys[i], _nodes[jsonMeta[keys[i]][j]]);\n            }\n        }\n    }\n\n    function updateConstraintMeta(guid) {\n        var jsonMeta = _import.nodes[guid].meta.constraints || {},\n            keys = Object.keys(jsonMeta),\n            i;\n\n        for (i = 0; i < keys.length; i++) {\n            _core.setConstraint(_nodes[guid], keys[i], jsonMeta[keys[i]]);\n        }\n    }\n\n    return {\n        export: exportLibrary,\n        import: importLibrary\n    };\n});\n\n",
    "/*globals define*/\n/*jshint browser: true*/\n/**\n * @author kecso / https://github.com/kecso\n */\ndefine('js/client/addon',[], function () {\n    'use strict';\n\n    function AddOn(state, storage, logger__, gmeConfig) {\n        var _addOns = {},\n            logger = logger__.fork('addOn'),\n            _constraintCallback = function () {\n            };\n        //addOn functions\n        function startAddOn(name) {\n            if (_addOns[name] === undefined) {\n                _addOns[name] = 'loading';\n                logger.debug('loading addOn ' + name);\n                storage.simpleRequest({\n                        command: 'connectedWorkerStart',\n                        workerName: name,\n                        projectId: state.project.projectId,\n                        branch: state.branchName\n                    },\n                    function (err, id) {\n                        if (err) {\n                            logger.error('starting addon failed ' + err);\n                            delete _addOns[name];\n                            return logger.error(err);\n                        }\n\n                        logger.debug('started addon ' + name + ' ' + id);\n                        _addOns[name] = id;\n                    });\n            }\n\n        }\n\n        function queryAddOn(name, query, callback) {\n            if (!_addOns[name] || _addOns[name] === 'loading') {\n                return callback(new Error('no such addOn is ready for queries'));\n            }\n            storage.simpleQuery(_addOns[name], query, callback);\n        }\n\n        function stopAddOn(name, callback) {\n            if (_addOns[name] && _addOns[name] !== 'loading') {\n                storage.simpleResult(_addOns[name], callback);\n                delete _addOns[name];\n            } else {\n                callback(_addOns[name] ? new Error('addon loading') : null);\n            }\n        }\n\n        //generic project related addOn handling\n        function updateRunningAddOns(root) {\n            var i,\n                neededAddOns,\n                runningAddOns,\n                callback = function (err) {\n                    logger.error(err);\n                };\n\n            if (gmeConfig.addOn.enable === true) {\n                neededAddOns = state.core.getRegistry(root, 'usedAddOns');\n                runningAddOns = getRunningAddOnNames();\n                neededAddOns = neededAddOns ? neededAddOns.split(' ') : [];\n                for (i = 0; i < neededAddOns.length; i += 1) {\n                    if (!_addOns[neededAddOns[i]]) {\n                        startAddOn(neededAddOns[i]);\n                    }\n                }\n                for (i = 0; i < runningAddOns.length; i += 1) {\n                    if (neededAddOns.indexOf(runningAddOns[i]) === -1) {\n                        stopAddOn(runningAddOns[i], callback);\n                    }\n                }\n            }\n        }\n\n        function stopRunningAddOns() {\n            var i,\n                keys,\n                callback;\n\n            if (gmeConfig.addOn.enable === true) {\n                keys = Object.keys(_addOns);\n                callback = function (err) {\n                    if (err) {\n                        logger.error('stopAddOn' + err);\n                    }\n                };\n\n                for (i = 0; i < keys.length; i++) {\n                    stopAddOn(keys[i], callback);\n                }\n            }\n        }\n\n        function getRunningAddOnNames() {\n            var i,\n                names = [],\n                keys = Object.keys(_addOns);\n            for (i = 0; i < keys.length; i++) {\n                if (_addOns[keys[i]] !== 'loading') {\n                    names.push(keys[i]);\n                }\n            }\n            return names;\n        }\n\n        //core addOns\n        //history\n        function getDetailedHistoryAsync(callback) {\n            if (_addOns.hasOwnProperty('HistoryAddOn') && _addOns.HistoryAddOn !== 'loading') {\n                queryAddOn('HistoryAddOn', {}, callback);\n            } else {\n                callback(new Error('history information is not available'));\n            }\n        }\n\n        //constraint\n        function validateProjectAsync(callback) {\n            callback = callback || _constraintCallback || function (/*err, result*/) {\n                };\n            if (_addOns.hasOwnProperty('ConstraintAddOn') && _addOns.ConstraintAddOn !== 'loading') {\n                queryAddOn('ConstraintAddOn', {querytype: 'checkProject'}, callback);\n            } else {\n                callback(new Error('constraint checking is not available'));\n            }\n        }\n\n        function validateModelAsync(path, callback) {\n            callback = callback || _constraintCallback || function (/* err, result */) {\n                };\n            if (_addOns.hasOwnProperty('ConstraintAddOn') && _addOns.ConstraintAddOn !== 'loading') {\n                queryAddOn('ConstraintAddOn', {querytype: 'checkModel', path: path}, callback);\n            } else {\n                callback(new Error('constraint checking is not available'));\n            }\n        }\n\n        function validateNodeAsync(path, callback) {\n            callback = callback || _constraintCallback || function (/* err, result */) {\n                };\n            if (_addOns.hasOwnProperty('ConstraintAddOn') && _addOns.ConstraintAddOn !== 'loading') {\n                queryAddOn('ConstraintAddOn', {querytype: 'checkNode', path: path}, callback);\n            } else {\n                callback(new Error('constraint checking is not available'));\n            }\n        }\n\n        function setValidationCallback(cFunction) {\n            if (typeof cFunction === 'function' || cFunction === null) {\n                _constraintCallback = cFunction;\n            }\n        }\n\n        //core addOns end\n\n        return {\n            startAddOn: startAddOn,\n            queryAddOn: queryAddOn,\n            stopAddOn: stopAddOn,\n            updateRunningAddOns: updateRunningAddOns,\n            stopRunningAddOns: stopRunningAddOns,\n            getDetailedHistoryAsync: getDetailedHistoryAsync,\n            validateProjectAsync: validateProjectAsync,\n            validateModelAsync: validateModelAsync,\n            validateNodeAsync: validateNodeAsync,\n            setValidationCallback: setValidationCallback,\n            getRunningAddOnNames: getRunningAddOnNames\n        };\n    }\n\n    return AddOn;\n});\n",
    "/*globals define*/\r\n/*jshint browser: true*/\r\n/**\r\n * @author kecso / https://github.com/kecso\r\n * @author pmeijer / https://github.com/pmeijer\r\n */\r\ndefine('client/js/client',[\r\n    'js/logger',\r\n    'common/storage/browserstorage',\r\n    'common/EventDispatcher',\r\n    'common/core/core',\r\n    'js/client/constants',\r\n    'common/core/users/meta',\r\n    'common/util/assert',\r\n    'common/core/tasync',\r\n    'common/util/guid',\r\n    'common/util/url',\r\n    'js/client/gmeNodeGetter',\r\n    'js/client/gmeNodeSetter',\r\n    'common/core/users/serialization',\r\n    'js/client/addon'\r\n], function (Logger,\r\n             Storage,\r\n             EventDispatcher,\r\n             Core,\r\n             CONSTANTS,\r\n             META,\r\n             ASSERT,\r\n             TASYNC,\r\n             GUID,\r\n             URL,\r\n             getNode,\r\n             getNodeSetters,\r\n             Serialization,\r\n             AddOn) {\r\n    'use strict';\r\n\r\n    function Client(gmeConfig) {\r\n        var self = this,\r\n            logger = Logger.create('gme:client', gmeConfig.client.log),\r\n            storage = Storage.getStorage(logger, gmeConfig, true),\r\n            state = {\r\n                connection: null, // CONSTANTS.STORAGE. CONNECTED/DISCONNECTED/RECONNECTED\r\n                project: null, //CONSTANTS.BRANCH_STATUS. SYNCH/FORKED/AHEAD/PULLING\r\n                core: null,\r\n                branchName: null,\r\n                branchStatus: null,\r\n                inSync: true,\r\n                readOnlyProject: false,\r\n                viewer: false, // This means that a specific commit is selected w/o regards to any branch.\r\n\r\n                users: {},\r\n                nodes: {},\r\n                loadNodes: {},\r\n                // FIXME: This should be the same as nodes (need to make sure they are not modified in meta).\r\n                metaNodes: {},\r\n\r\n                root: {\r\n                    current: null,\r\n                    previous: null,\r\n                    object: null\r\n                },\r\n                commit: {\r\n                    current: null,\r\n                    previous: null\r\n                },\r\n                undoRedoChain: null, //{commit: '#hash', root: '#hash', previous: object, next: object}\r\n                inTransaction: false,\r\n                msg: '',\r\n                gHash: 0,\r\n                loadError: null\r\n            },\r\n            monkeyPatchKey,\r\n            nodeSetterFunctions,\r\n            addOnFunctions = new AddOn(state, storage, logger, gmeConfig);\r\n\r\n        EventDispatcher.call(this);\r\n\r\n        this.CONSTANTS = CONSTANTS;\r\n\r\n        function logState(level, msg) {\r\n            var lightState;\r\n\r\n            function replacer(key, value) {\r\n                var chainItem,\r\n                    prevChain,\r\n                    nextChain,\r\n                    chain;\r\n                if (key === 'project') {\r\n                    if (value) {\r\n                        return value.name;\r\n                    } else {\r\n                        return null;\r\n                    }\r\n\r\n                } else if (key === 'core') {\r\n                    if (value) {\r\n                        return 'instantiated';\r\n                    } else {\r\n                        return 'notInstantiated';\r\n                    }\r\n                } else if (key === 'metaNodes') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'nodes') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'loadNodes') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'users') {\r\n                    return Object.keys(value);\r\n                } else if (key === 'root') {\r\n                    return {\r\n                        current: value.current,\r\n                        previous: value.previous\r\n                    };\r\n                } else if (key === 'undoRedoChain') {\r\n                    if (value) {\r\n                        chain = {\r\n                            previous: null,\r\n                            next: null\r\n                        };\r\n                        if (value.previous) {\r\n                            prevChain = {};\r\n                            chain.previous = prevChain;\r\n                        }\r\n                        chainItem = value;\r\n                        while (chainItem.previous) {\r\n                            prevChain.previous = {\r\n                                commit: chainItem.commit,\r\n                                previous: null\r\n                            };\r\n                            prevChain = prevChain.previous;\r\n                            chainItem = chainItem.previous;\r\n                        }\r\n                        if (value.next) {\r\n                            nextChain = {};\r\n                            chain.next = nextChain;\r\n                        }\r\n                        chainItem = value;\r\n                        while (chainItem.next) {\r\n                            nextChain.next = {\r\n                                commit: chainItem.commit,\r\n                                next: null\r\n                            };\r\n                            nextChain = nextChain.next;\r\n                            chainItem = chainItem.next;\r\n                        }\r\n                        return chain;\r\n                    }\r\n                }\r\n\r\n                return value;\r\n            }\r\n\r\n            if (gmeConfig.debug) {\r\n                logger[level]('state at ' + msg, JSON.stringify(state, replacer, 2));\r\n            } else {\r\n                lightState = {\r\n                    connection: self.getNetworkStatus(),\r\n                    projectId: self.getActiveProjectId(),\r\n                    branchName: self.getActiveBranchName(),\r\n                    branchStatus: self.getBranchStatus(),\r\n                    commitHash: self.getActiveCommitHash(),\r\n                    rootHash: self.getActiveRootHash(),\r\n                    projectReadOnly: self.isProjectReadOnly(),\r\n                    commitReadOnly: self.isCommitReadOnly()\r\n                };\r\n                logger[level]('state at ' + msg, JSON.stringify(lightState));\r\n            }\r\n        }\r\n\r\n        // Forwarded functions\r\n        function saveRoot(msg, callback) {\r\n            var persisted,\r\n                numberOfPersistedObjects,\r\n                beforeLoading = true,\r\n                commitQueue,\r\n                newCommitObject;\r\n            logger.debug('saveRoot msg', msg);\r\n\r\n            callback = callback || function () {\r\n                };\r\n            if (!state.viewer && !state.readOnlyProject) {\r\n                if (state.msg) {\r\n                    state.msg += '\\n' + msg;\r\n                } else {\r\n                    state.msg += msg;\r\n                }\r\n                if (!state.inTransaction) {\r\n                    ASSERT(state.project && state.core && state.branchName);\r\n                    logger.debug('is NOT in transaction - will persist.');\r\n                    persisted = state.core.persist(state.nodes[ROOT_PATH].node);\r\n                    logger.debug('persisted', persisted);\r\n                    numberOfPersistedObjects = Object.keys(persisted.objects).length;\r\n                    if (numberOfPersistedObjects === 0) {\r\n                        logger.warn('No changes after persist will return from saveRoot.');\r\n                        callback(null);\r\n                        return;\r\n                    } else if (numberOfPersistedObjects > 200) {\r\n                        //This is just for debugging\r\n                        logger.warn('Lots of persisted objects', numberOfPersistedObjects);\r\n                    }\r\n\r\n                    // Calling event-listeners (users)\r\n                    // N.B. it is no longer waiting for the setBranchHash to return from server.\r\n                    // Which also was the case before:\r\n                    // https://github.com/webgme/webgme/commit/48547c33f638aedb60866772ca5638f9e447fa24\r\n\r\n                    loading(persisted.rootHash, function (err) {\r\n                        if (err) {\r\n                            logger.error('Saveroot - loading failed', err);\r\n                        }\r\n                        // TODO: Are local updates really guaranteed to be synchronous?\r\n                        if (beforeLoading === false) {\r\n                            logger.error('SaveRoot - was not synchronous!');\r\n                        }\r\n                    });\r\n\r\n                    beforeLoading = false;\r\n                    newCommitObject = storage.makeCommit(\r\n                        state.project.projectId,\r\n                        state.branchName,\r\n                        [state.commit.current],\r\n                        persisted.rootHash,\r\n                        persisted.objects,\r\n                        state.msg,\r\n                        callback\r\n                    );\r\n                    commitQueue = state.project.getBranch(state.branchName, true).getCommitQueue();\r\n                    if (state.inSync === true) {\r\n                        changeBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC, commitQueue);\r\n                    } else {\r\n                        changeBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC, commitQueue);\r\n                    }\r\n\r\n\r\n                    addCommit(newCommitObject[CONSTANTS.STORAGE.MONGO_ID]);\r\n                    //undo-redo\r\n                    addModification(newCommitObject, false);\r\n                    self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());\r\n                    self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());\r\n\r\n                    state.msg = '';\r\n                } else {\r\n                    logger.debug('is in transaction - will NOT persist.');\r\n                }\r\n            } else {\r\n                //TODO: Why is this set to empty here?\r\n                state.msg = '';\r\n                callback(null);\r\n            }\r\n        }\r\n\r\n        function storeNode(node /*, basic */) {\r\n            var path;\r\n            //basic = basic || true;\r\n            if (node) {\r\n                path = state.core.getPath(node);\r\n                state.metaNodes[path] = node;\r\n                if (state.nodes[path]) {\r\n                    //TODO we try to avoid this\r\n                } else {\r\n                    state.nodes[path] = {node: node, hash: ''/*,incomplete:true,basic:basic*/};\r\n                    //TODO this only needed when real eventing will be reintroduced\r\n                    //_inheritanceHash[path] = getInheritanceChain(node);\r\n                }\r\n                return path;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Monkey patching from other files..\r\n        this.meta = new META();\r\n\r\n        for (monkeyPatchKey in this.meta) {\r\n            //TODO: These should be accessed via this.meta.\r\n            //TODO: e.g. client.meta.getMetaAspectNames(id) instead of client.getMetaAspectNames(id)\r\n            //TODO: However that will break a lot since it's used all over the place...\r\n            if (this.meta.hasOwnProperty(monkeyPatchKey)) {\r\n                self[monkeyPatchKey] = this.meta[monkeyPatchKey];\r\n            }\r\n        }\r\n\r\n        nodeSetterFunctions = getNodeSetters(logger, state, saveRoot, storeNode);\r\n\r\n        for (monkeyPatchKey in nodeSetterFunctions) {\r\n            if (nodeSetterFunctions.hasOwnProperty(monkeyPatchKey)) {\r\n                self[monkeyPatchKey] = nodeSetterFunctions[monkeyPatchKey];\r\n            }\r\n        }\r\n\r\n        // Main API functions (with helpers) for connecting, selecting project and branches etc.\r\n        this.connectToDatabase = function (callback) {\r\n            if (isConnected()) {\r\n                logger.warn('connectToDatabase - already connected');\r\n                callback(null);\r\n                return;\r\n            }\r\n            storage.open(function (connectionState) {\r\n                state.connection = connectionState;\r\n                if (connectionState === CONSTANTS.STORAGE.CONNECTED) {\r\n                    //N.B. this event will only be triggered once.\r\n                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);\r\n                    reLaunchUsers();\r\n                    callback(null);\r\n                } else if (connectionState === CONSTANTS.STORAGE.DISCONNECTED) {\r\n                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);\r\n                } else if (connectionState === CONSTANTS.STORAGE.RECONNECTED) {\r\n                    self.dispatchEvent(CONSTANTS.NETWORK_STATUS_CHANGED, connectionState);\r\n                } else { //CONSTANTS.ERROR\r\n                    callback(Error('Connection failed!' + connectionState));\r\n                }\r\n            });\r\n        };\r\n\r\n        this.disconnectFromDatabase = function (callback) {\r\n\r\n            function closeStorage(err) {\r\n                storage.close(function (err2) {\r\n                    state.connection = CONSTANTS.STORAGE.DISCONNECTED;\r\n                    callback(err || err2);\r\n                });\r\n            }\r\n\r\n            if (isConnected()) {\r\n                if (state.project) {\r\n                    closeProject(state.project.projectId, closeStorage);\r\n                } else {\r\n                    closeStorage(null);\r\n                }\r\n            } else {\r\n                logger.warn('Trying to disconnect when already disconnected.');\r\n                callback(null);\r\n            }\r\n        };\r\n\r\n        this.selectProject = function (projectId, branchName, callback) {\r\n            if (callback === undefined && typeof branchName === 'function') {\r\n                callback = branchName;\r\n                branchName = undefined;\r\n            }\r\n            if (isConnected() === false) {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n            var prevProjectId,\r\n                branchToOpen = branchName || 'master';\r\n\r\n            logger.debug('selectProject', projectId, branchToOpen);\r\n\r\n            function projectOpened(err, project, branches, access) {\r\n                if (err) {\r\n                    callback(new Error(err));\r\n                    return;\r\n                }\r\n                state.project = project;\r\n                state.readOnlyProject = access.write === false;\r\n                state.core = new Core(project, {\r\n                    globConf: gmeConfig,\r\n                    logger: logger.fork('core')\r\n                });\r\n                self.meta.initialize(state.core, state.metaNodes, saveRoot);\r\n                logState('info', 'projectOpened');\r\n                logger.debug('projectOpened, branches: ', branches);\r\n                self.dispatchEvent(CONSTANTS.PROJECT_OPENED, projectId);\r\n\r\n                if (branches.hasOwnProperty(branchToOpen) === false) {\r\n                    if (branchName) {\r\n                        logger.error('Given branch does not exist \"' + branchName + '\"');\r\n                        closeProject(projectId, function (err) {\r\n                            if (err) {\r\n                                logger.error('closeProject after missing branch failed with err', err);\r\n                            }\r\n                            callback(new Error('Given branch does not exist \"' + branchName + '\"'));\r\n                        });\r\n                        return;\r\n                    }\r\n                    logger.warn('Project \"' + projectId + '\" did not have branch', branchToOpen);\r\n                    branchToOpen = Object.keys(branches)[0] || null;\r\n                    logger.debug('Picked \"' + branchToOpen + '\".');\r\n                }\r\n\r\n                ASSERT(branchToOpen, 'No branch avaliable in project');\r\n\r\n                self.selectBranch(branchToOpen, null, function (err) {\r\n                    if (err) {\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    logState('info', 'selectBranch');\r\n                    reLaunchUsers();\r\n                    callback(null);\r\n                });\r\n            }\r\n\r\n            if (state.project) {\r\n                prevProjectId = state.project.projectId;\r\n                logger.debug('A project was open, closing it', prevProjectId);\r\n\r\n                if (prevProjectId === projectId) {\r\n                    logger.warn('projectId is already opened', projectId);\r\n                    callback(null);\r\n                    return;\r\n                }\r\n                closeProject(prevProjectId, function (err) {\r\n                    if (err) {\r\n                        logger.error('problems closing previous project', err);\r\n                        callback(new Error(err));\r\n                        return;\r\n                    }\r\n                    storage.openProject(projectId, projectOpened);\r\n                });\r\n            } else {\r\n                storage.openProject(projectId, projectOpened);\r\n            }\r\n        };\r\n\r\n        function closeProject(projectId, callback) {\r\n            state.project = null;\r\n            //TODO what if for some reason we are in transaction?\r\n            storage.closeProject(projectId, function (err) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                state.core = null;\r\n                state.branchName = null;\r\n                changeBranchStatus(null);\r\n                state.patterns = {};\r\n                //state.gHash = 0;\r\n                state.nodes = {};\r\n                state.metaNodes = {};\r\n                state.loadNodes = {};\r\n                state.loadError = 0;\r\n                state.root.current = null;\r\n                state.root.previous = null;\r\n                //state.root.object = null;\r\n                state.inTransaction = false;\r\n                state.msg = '';\r\n\r\n                cleanUsersTerritories();\r\n                self.dispatchEvent(CONSTANTS.PROJECT_CLOSED, projectId);\r\n                callback(null);\r\n            });\r\n        }\r\n\r\n        /**\r\n         *\r\n         * @param {string} branchName - name of branch to open.\r\n         * @param {function} [commitHandler=getDefaultCommitHandler()] - Handles returned statuses after commits.\r\n         * @param callback\r\n         */\r\n        this.selectBranch = function (branchName, commitHandler, callback) {\r\n            logger.debug('selectBranch', branchName);\r\n            if (isConnected() === false) {\r\n                callback(new Error('There is no open database connection!'));\r\n                return;\r\n            }\r\n            if (!state.project) {\r\n                callback(new Error('selectBranch invoked without an opened project'));\r\n                return;\r\n            }\r\n\r\n            var prevBranchName = state.branchName;\r\n\r\n            function openBranch(err) {\r\n                if (err) {\r\n                    logger.error('Problems closing existing branch', err);\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                commitHandler = commitHandler || getDefaultCommitHandler();\r\n                storage.openBranch(state.project.projectId, branchName, getUpdateHandler(), commitHandler,\r\n                    function (err, latestCommit) {\r\n                        var commitObject;\r\n                        if (err) {\r\n                            logger.error('storage.openBranch returned with error', err);\r\n                            callback(new Error(err));\r\n                            return;\r\n                        }\r\n\r\n                        commitObject = latestCommit.commitObject;\r\n                        logger.debug('Branch opened latestCommit', latestCommit);\r\n\r\n                        //undo-redo\r\n                        logger.debug('changing branch - cleaning undo-redo chain');\r\n                        addModification(commitObject, true);\r\n                        self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());\r\n                        self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());\r\n\r\n                        state.viewer = false;\r\n                        state.branchName = branchName;\r\n                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, branchName);\r\n                        logState('info', 'openBranch');\r\n\r\n                        loading(commitObject.root, function (err) {\r\n                            if (err) {\r\n                                logger.error('loading failed after opening branch', branchName);\r\n                            } else {\r\n                                addCommit(commitObject[CONSTANTS.STORAGE.MONGO_ID]);\r\n                            }\r\n                            changeBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);\r\n                            // TODO: Make sure this is always the case.\r\n                            callback(err);\r\n                        });\r\n\r\n                    }\r\n                );\r\n            }\r\n\r\n            if (state.branchName !== null) {\r\n                logger.debug('Branch was open, closing it first', state.branchName);\r\n                prevBranchName = state.branchName;\r\n                storage.closeBranch(state.project.projectId, prevBranchName, openBranch);\r\n            } else {\r\n                openBranch(null);\r\n            }\r\n        };\r\n\r\n        this.selectCommit = function (commitHash, callback) {\r\n            logger.debug('selectCommit', commitHash);\r\n            if (isConnected() === false) {\r\n                callback(new Error('There is no open database connection!'));\r\n                return;\r\n            }\r\n            if (!state.project) {\r\n                callback(new Error('selectCommit invoked without open project'));\r\n                return;\r\n            }\r\n            var prevBranchName;\r\n\r\n            function openCommit(err) {\r\n                if (err) {\r\n                    logger.error('Problems closing existing branch', err);\r\n                    callback(err);\r\n                    return;\r\n                }\r\n\r\n                state.viewer = true;\r\n                changeBranchStatus(null);\r\n                state.project.loadObject(commitHash, function (err, commitObj) {\r\n                    if (!err && commitObj) {\r\n                        logState('info', 'selectCommit loaded commit');\r\n                        self.dispatchEvent(CONSTANTS.BRANCH_CHANGED, null);\r\n                        loading(commitObj.root, function (err, aborted) {\r\n                            if (err) {\r\n                                logger.error('loading returned error', commitObj.root, err);\r\n                                logState('error', 'selectCommit loading');\r\n                                callback(err);\r\n                            } else if (aborted === true) {\r\n                                logState('warn', 'selectCommit loading');\r\n                                callback('Loading selected commit was aborted');\r\n                            } else {\r\n                                addCommit(commitHash);\r\n                                logger.debug('loading complete for selectCommit rootHash', commitObj.root);\r\n                                logState('info', 'selectCommit loading');\r\n                                changeBranchStatus(null);\r\n                                callback(null);\r\n                            }\r\n                        });\r\n                    } else {\r\n                        logger.error('Cannot view given ' + commitHash + ' commit as it\\'s root cannot be loaded! [' +\r\n                            JSON.stringify(err) + ']');\r\n                        callback(err || new Error('commit object cannot be found!'));\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (state.branchName !== null) {\r\n                logger.debug('Branch was open, closing it first', state.branchName);\r\n                prevBranchName = state.branchName;\r\n                state.branchName = null;\r\n                //state.branchStatus = null;\r\n                storage.closeBranch(state.project.projectId, prevBranchName, openCommit);\r\n            } else {\r\n                openCommit(null);\r\n            }\r\n        };\r\n\r\n        function getDefaultCommitHandler() {\r\n            return function (commitQueue, result, callback) {\r\n                logger.debug('default commitHandler invoked, result: ', result);\r\n                logger.debug('commitQueue', commitQueue);\r\n\r\n                if (result.status === CONSTANTS.STORAGE.SYNCH) {\r\n                    logger.debug('You are in synch.');\r\n                    logState('info', 'commitHandler');\r\n                    if (commitQueue.length === 1) {\r\n                        logger.debug('No commits queued.');\r\n                        changeBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);\r\n                    } else {\r\n                        logger.debug('Will proceed with next queued commit...');\r\n                        changeBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_SYNC, commitQueue);\r\n                    }\r\n                    callback(true); // push:true\r\n                } else if (result.status === CONSTANTS.STORAGE.FORKED) {\r\n                    logger.debug('You got forked');\r\n                    logState('info', 'commitHandler');\r\n                    changeBranchStatus(CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC, commitQueue);\r\n                    callback(false); // push:false\r\n                } else {\r\n                    callback(false);\r\n                    changeBranchStatus(null);\r\n                    throw new Error('Unexpected result', result);\r\n                }\r\n            };\r\n        }\r\n\r\n        function getUpdateHandler() {\r\n            return function (updateQueue, eventData, callback) {\r\n                var commitHash = eventData.commitObject[CONSTANTS.STORAGE.MONGO_ID];\r\n                logger.debug('updateHandler invoked. project, branch', eventData.projectId, eventData.branchName);\r\n                if (state.inTransaction) {\r\n                    logger.warn('Is in transaction, will not load in changes');\r\n                    callback(true); // aborted: true\r\n                    return;\r\n                }\r\n                logger.debug('loading commitHash', commitHash);\r\n                //undo-redo\r\n                logger.debug('foreign modification clearing undo-redo chain');\r\n                addModification(eventData.commitObject, true);\r\n                self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());\r\n                self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());\r\n                changeBranchStatus(CONSTANTS.BRANCH_STATUS.PULLING, updateQueue.length);\r\n                loading(eventData.commitObject.root, function (err, aborted) {\r\n                    if (err) {\r\n                        logger.error('updateHandler invoked loading and it returned error',\r\n                            eventData.commitObject.root, err);\r\n                        logState('error', 'updateHandler');\r\n                        callback(true); // aborted: true\r\n                    } else if (aborted === true) {\r\n                        logState('warn', 'updateHandler');\r\n                        callback(true); // aborted: true\r\n                    } else {\r\n                        addCommit(commitHash);\r\n                        logger.debug('loading complete for incoming rootHash', eventData.commitObject.root);\r\n                        logState('debug', 'updateHandler');\r\n                        if (updateQueue.length === 1) {\r\n                            changeBranchStatus(CONSTANTS.BRANCH_STATUS.SYNC);\r\n                        }\r\n                        callback(false); // aborted: false\r\n                    }\r\n                });\r\n            };\r\n        }\r\n\r\n        function changeBranchStatus(branchStatus, details) {\r\n            logger.debug('changeBranchStatus, prev, new, details', state.branchStatus, branchStatus, details);\r\n            state.branchStatus = branchStatus;\r\n            if (branchStatus === CONSTANTS.BRANCH_STATUS.SYNC) {\r\n                state.inSync = true;\r\n            } else if (branchStatus === CONSTANTS.BRANCH_STATUS.AHEAD_NOT_SYNC) {\r\n                state.inSync = false;\r\n            }\r\n            self.dispatchEvent(CONSTANTS.BRANCH_STATUS_CHANGED, {status: branchStatus, details: details});\r\n        }\r\n\r\n        this.forkCurrentBranch = function (newName, commitHash, callback) {\r\n            var self = this,\r\n                activeBranchName = self.getActiveBranchName(),\r\n                activeProjectId = self.getActiveProjectId(),\r\n                forkName;\r\n\r\n            logger.debug('forkCurrentBranch', newName, commitHash);\r\n            if (!state.project) {\r\n                callback('Cannot fork without an open project!');\r\n                return;\r\n            }\r\n            if (activeBranchName === null) {\r\n                callback('Cannot fork without an open branch!');\r\n                return;\r\n            }\r\n            forkName = newName || activeBranchName + '_' + (new Date()).getTime();\r\n            storage.forkBranch(activeProjectId, activeBranchName, forkName, commitHash,\r\n                function (err, forkHash) {\r\n                    if (err) {\r\n                        logger.error('Could not fork branch:', newName, err);\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    callback(null, forkName, forkHash);\r\n                }\r\n            );\r\n        };\r\n\r\n        // State getters.\r\n        this.getNetworkStatus = function () {\r\n            return state.connection;\r\n        };\r\n\r\n        this.getBranchStatus = function () {\r\n            return state.branchStatus;\r\n        };\r\n\r\n        this.getActiveProjectId = function () {\r\n            return state.project && state.project.projectId;\r\n        };\r\n\r\n        this.getActiveBranchName = function () {\r\n            return state.branchName;\r\n        };\r\n\r\n        this.getActiveCommitHash = function () {\r\n            return state.commit.current;\r\n        };\r\n\r\n        this.getActiveRootHash = function () {\r\n            return state.root.current;\r\n        };\r\n\r\n        this.isProjectReadOnly = function () {\r\n            return state.readOnlyProject;\r\n        };\r\n\r\n        this.isCommitReadOnly = function () {\r\n            // This means that a specific commit is selected w/o regards to any branch.\r\n            return state.viewer;\r\n        };\r\n\r\n        this.getProjectObject = function () {\r\n            return state.project;\r\n        };\r\n\r\n        // Undo/Redo functionality\r\n        function addModification(commitObject, clear) {\r\n            var newItem;\r\n            if (clear) {\r\n                state.undoRedoChain = {\r\n                    commit: commitObject[CONSTANTS.STORAGE.MONGO_ID],\r\n                    root: commitObject.root,\r\n                    previous: null,\r\n                    next: null\r\n                };\r\n                return;\r\n            }\r\n\r\n            newItem = {\r\n                commit: commitObject[CONSTANTS.STORAGE.MONGO_ID],\r\n                root: commitObject.root,\r\n                previous: state.undoRedoChain,\r\n                next: null\r\n            };\r\n            state.undoRedoChain.next = newItem;\r\n            state.undoRedoChain = newItem;\r\n        }\r\n\r\n        function canUndo() {\r\n            var result = false;\r\n            if (state.undoRedoChain && state.undoRedoChain.previous) {\r\n                result = true;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function canRedo() {\r\n            var result = false;\r\n            if (state.undoRedoChain && state.undoRedoChain.next) {\r\n                result = true;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        this.undo = function (branchName, callback) {\r\n            if (canUndo() === false) {\r\n                callback(new Error('unable to make undo'));\r\n                return;\r\n            }\r\n\r\n            state.undoRedoChain = state.undoRedoChain.previous;\r\n\r\n            loading(state.undoRedoChain.root, function (err) {\r\n                //TODO do we need to handle this??\r\n                if (err) {\r\n                    logger.error(err);\r\n                }\r\n            });\r\n            self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());\r\n            self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());\r\n            logState('info', 'undo [before setBranchHash]');\r\n            storage.setBranchHash(state.project.projectId,\r\n                state.branchName, state.undoRedoChain.commit, state.commit.current, function (err) {\r\n                    if (err) {\r\n                        //TODO do we need to handle this? How?\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n\r\n                    state.commit.current = state.undoRedoChain.commit;\r\n                    logState('info', 'undo [after setBranchHash]');\r\n                    callback(null);\r\n                }\r\n            );\r\n\r\n        };\r\n\r\n        this.redo = function (branchName, callback) {\r\n            if (canRedo() === false) {\r\n                callback(new Error('unable to make redo'));\r\n                return;\r\n            }\r\n\r\n            state.undoRedoChain = state.undoRedoChain.next;\r\n\r\n            loading(state.undoRedoChain.root, function (err) {\r\n                //TODO do we need to handle this??\r\n                if (err) {\r\n                    logger.error(err);\r\n                }\r\n            });\r\n            self.dispatchEvent(CONSTANTS.UNDO_AVAILABLE, canUndo());\r\n            self.dispatchEvent(CONSTANTS.REDO_AVAILABLE, canRedo());\r\n            logState('info', 'redo [before setBranchHash]');\r\n            storage.setBranchHash(state.project.projectId,\r\n                state.branchName, state.undoRedoChain.commit, state.commit.current, function (err) {\r\n                    if (err) {\r\n                        //TODO do we need to handle this? How?\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    state.commit.current = state.undoRedoChain.commit;\r\n                    logState('info', 'redo [after setBranchHash]');\r\n                    callback(null);\r\n                }\r\n            );\r\n        };\r\n\r\n        // REST-like functions and forwarded to storage TODO: add these to separate base class\r\n\r\n        //  Getters\r\n        this.getProjects = function (options, callback) {\r\n            var asObject;\r\n            if (isConnected()) {\r\n                if (options.asObject) {\r\n                    asObject = true;\r\n                    delete options.asObject;\r\n                }\r\n                storage.getProjects(options, function (err, result) {\r\n                    var i,\r\n                        resultObj = {};\r\n                    if (err) {\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    if (asObject === true) {\r\n                        for (i = 0; i < result.length; i += 1) {\r\n                            resultObj[result[i]._id] = result[i];\r\n                        }\r\n                        callback(null, resultObj);\r\n                    } else {\r\n                        callback(null, result);\r\n                    }\r\n                });\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.getProjectsAndBranches = function (asObject, callback) {\r\n            //This is kept for the tests.\r\n            self.getProjects({rights: true, branches: true, asObject: asObject}, callback);\r\n        };\r\n\r\n        this.getBranches = function (projectId, callback) {\r\n            if (isConnected()) {\r\n                storage.getBranches(projectId, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.getCommits = function (projectId, before, number, callback) {\r\n            if (isConnected()) {\r\n                storage.getCommits(projectId, before, number, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.getLatestCommitData = function (projectId, branchName, callback) {\r\n            if (isConnected()) {\r\n                storage.getLatestCommitData(projectId, branchName, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        //  Setters\r\n        this.createProject = function (projectName, parameters, callback) {\r\n            if (isConnected()) {\r\n                storage.createProject(projectName, parameters, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.deleteProject = function (projectId, callback) {\r\n            if (isConnected()) {\r\n                storage.deleteProject(projectId, function (err, didExist) {\r\n                    if (err) {\r\n                        callback(new Error(err));\r\n                        return;\r\n                    }\r\n                    callback(null, didExist);\r\n                });\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.createBranch = function (projectId, branchName, newHash, callback) {\r\n            if (isConnected()) {\r\n                storage.createBranch(projectId, branchName, newHash, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        this.deleteBranch = function (projectId, branchName, oldHash, callback) {\r\n            if (isConnected()) {\r\n                storage.deleteBranch(projectId, branchName, oldHash, callback);\r\n            } else {\r\n                callback(new Error('There is no open database connection!'));\r\n            }\r\n        };\r\n\r\n        // Watchers (used in e.g. ProjectNavigator).\r\n        /**\r\n         * Triggers eventHandler(storage, eventData) on PROJECT_CREATED and PROJECT_DELETED.\r\n         *\r\n         * eventData = {\r\n         *    etype: PROJECT_CREATED||DELETED,\r\n         *    projectId: %id of project%\r\n         * }\r\n         *\r\n         * @param {function} eventHandler\r\n         * @param {function} [callback]\r\n         */\r\n        this.watchDatabase = function (eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems watching database room');\r\n                    }\r\n                };\r\n            storage.watchDatabase(eventHandler, callback);\r\n        };\r\n\r\n        this.unwatchDatabase = function (eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems unwatching database room');\r\n                    }\r\n                };\r\n            storage.unwatchDatabase(eventHandler, callback);\r\n        };\r\n\r\n        /**\r\n         * Triggers eventHandler(storage, eventData) on BRANCH_CREATED, BRANCH_DELETED and BRANCH_HASH_UPDATED\r\n         * for the given projectId.\r\n         *\r\n         *\r\n         * eventData = {\r\n         *    etype: BRANCH_CREATED||DELETED||HASH_UPDATED,\r\n         *    projectId: %id of project%,\r\n         *    branchName: %name of branch%,\r\n         *    newHash: %new commitHash (='' when DELETED)%\r\n         *    oldHash: %previous commitHash (='' when CREATED)%\r\n         * }\r\n         *\r\n         * @param {string} projectId\r\n         * @param {function} eventHandler\r\n         * @param {function} [callback]\r\n         */\r\n        this.watchProject = function (projectId, eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems watching project room', projectId);\r\n                    }\r\n                };\r\n            storage.watchProject(projectId, eventHandler, callback);\r\n        };\r\n\r\n        this.unwatchProject = function (projectId, eventHandler, callback) {\r\n            callback = callback || function (err) {\r\n                    if (err) {\r\n                        logger.error('Problems unwatching project room', projectId);\r\n                    }\r\n                };\r\n            storage.unwatchProject(projectId, eventHandler, callback);\r\n        };\r\n\r\n        // Internal functions\r\n        function isConnected() {\r\n            return state.connection === CONSTANTS.STORAGE.CONNECTED ||\r\n                state.connection === CONSTANTS.STORAGE.RECONNECTED;\r\n        }\r\n\r\n        var ROOT_PATH = ''; //FIXME: This should come from constants..\r\n\r\n        function COPY(object) {\r\n            if (object) {\r\n                return JSON.parse(JSON.stringify(object));\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Node handling\r\n        this.getNode = function (nodePath) {\r\n            return getNode(nodePath, logger, state, self.meta, storeNode);\r\n        };\r\n\r\n        function getStringHash(/* node */) {\r\n            //TODO there is a memory issue with the huge strings so we have to replace it with something\r\n            state.gHash += 1;\r\n            return state.gHash;\r\n        }\r\n\r\n        function getModifiedNodes(newerNodes) {\r\n            var modifiedNodes = [],\r\n                i;\r\n\r\n            for (i in state.nodes) {\r\n                if (state.nodes.hasOwnProperty(i)) {\r\n                    if (newerNodes[i]) {\r\n                        if (newerNodes[i].hash !== state.nodes[i].hash && state.nodes[i].hash !== '') {\r\n                            modifiedNodes.push(i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return modifiedNodes;\r\n        }\r\n\r\n        //this is just a first brute implementation it needs serious optimization!!!\r\n        function fitsInPatternTypes(path, pattern) {\r\n            var i;\r\n\r\n            if (pattern.items && pattern.items.length > 0) {\r\n                for (i = 0; i < pattern.items.length; i += 1) {\r\n                    if (self.meta.isTypeOf(path, pattern.items[i])) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function patternToPaths(patternId, pattern, pathsSoFar) {\r\n            var children,\r\n                subPattern,\r\n                i;\r\n\r\n            if (state.nodes[patternId]) {\r\n                pathsSoFar[patternId] = true;\r\n                if (pattern.children && pattern.children > 0) {\r\n                    children = state.core.getChildrenPaths(state.nodes[patternId].node);\r\n                    subPattern = COPY(pattern);\r\n                    subPattern.children -= 1;\r\n                    for (i = 0; i < children.length; i += 1) {\r\n                        if (fitsInPatternTypes(children[i], pattern)) {\r\n                            patternToPaths(children[i], subPattern, pathsSoFar);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                state.loadError++;\r\n            }\r\n        }\r\n\r\n        function userEvents(userId, modifiedNodes) {\r\n            var newPaths = {},\r\n                startErrorLevel = state.loadError,\r\n                i,\r\n                events = [];\r\n\r\n            for (i in state.users[userId].PATTERNS) {\r\n                if (state.users[userId].PATTERNS.hasOwnProperty(i)) {\r\n                    if (state.nodes[i]) { //TODO we only check pattern if its root is there...\r\n                        patternToPaths(i, state.users[userId].PATTERNS[i], newPaths);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (startErrorLevel !== state.loadError) {\r\n                return; //we send events only when everything is there correctly\r\n            }\r\n\r\n            //deleted items\r\n            for (i in state.users[userId].PATHS) {\r\n                if (!newPaths[i]) {\r\n                    events.push({etype: 'unload', eid: i});\r\n                }\r\n            }\r\n\r\n            //added items\r\n            for (i in newPaths) {\r\n                if (!state.users[userId].PATHS[i]) {\r\n                    events.push({etype: 'load', eid: i});\r\n                }\r\n            }\r\n\r\n            //updated items\r\n            for (i = 0; i < modifiedNodes.length; i++) {\r\n                if (newPaths[modifiedNodes[i]]) {\r\n                    events.push({etype: 'update', eid: modifiedNodes[i]});\r\n                }\r\n            }\r\n\r\n            state.users[userId].PATHS = newPaths;\r\n\r\n            //this is how the events should go\r\n            if (events.length > 0) {\r\n                if (state.loadError > startErrorLevel) {\r\n                    events.unshift({etype: 'incomplete', eid: null});\r\n                } else {\r\n                    events.unshift({etype: 'complete', eid: null});\r\n                }\r\n            } else {\r\n                events.unshift({etype: 'complete', eid: null});\r\n            }\r\n            state.users[userId].FN(events);\r\n        }\r\n\r\n        function loadChildrenPattern(core, nodesSoFar, node, level, callback) {\r\n            var path = core.getPath(node),\r\n                childrenPaths = core.getChildrenPaths(node),\r\n                childrenRelids = core.getChildrenRelids(node),\r\n                missing = childrenPaths.length,\r\n                error = null,\r\n                i,\r\n                childLoaded = function (err, child) {\r\n                    if (err || child === null) {\r\n                        error = error || err;\r\n                        missing -= 1;\r\n                        if (missing === 0) {\r\n                            callback(error);\r\n                        }\r\n                    } else {\r\n                        loadChildrenPattern(core, nodesSoFar, child, level - 1, childrenPatternLoaded);\r\n                    }\r\n                },\r\n                childrenPatternLoaded = function (err) {\r\n                    error = error || err;\r\n                    missing -= 1;\r\n                    if (missing === 0) {\r\n                        callback(error);\r\n                    }\r\n                };\r\n            state.metaNodes[path] = node;\r\n            if (!nodesSoFar[path]) {\r\n                nodesSoFar[path] = {node: node, incomplete: true, basic: true, hash: getStringHash(node)};\r\n            }\r\n            if (level > 0) {\r\n                if (missing > 0) {\r\n                    for (i = 0; i < childrenPaths.length; i++) {\r\n                        if (nodesSoFar[childrenPaths[i]]) {\r\n                            loadChildrenPattern(core,\r\n                                nodesSoFar,\r\n                                nodesSoFar[childrenPaths[i]].node,\r\n                                level - 1, childrenPatternLoaded);\r\n                        } else {\r\n                            core.loadChild(node, childrenRelids[i], childLoaded);\r\n                        }\r\n                    }\r\n                } else {\r\n                    callback(error);\r\n                }\r\n            } else {\r\n                callback(error);\r\n            }\r\n        }\r\n\r\n        function loadPattern(core, id, pattern, nodesSoFar, callback) {\r\n            var base = null,\r\n                baseLoaded = function () {\r\n                    if (pattern.children && pattern.children > 0) {\r\n                        var level = pattern.children;\r\n                        loadChildrenPattern(core, nodesSoFar, base, level, callback);\r\n                    } else {\r\n                        callback(null);\r\n                    }\r\n                };\r\n\r\n            if (nodesSoFar[id]) {\r\n                base = nodesSoFar[id].node;\r\n                baseLoaded();\r\n            } else {\r\n                base = null;\r\n                if (state.loadNodes[ROOT_PATH]) {\r\n                    base = state.loadNodes[ROOT_PATH].node;\r\n                } else if (state.nodes[ROOT_PATH]) {\r\n                    base = state.nodes[ROOT_PATH].node;\r\n                }\r\n                core.loadByPath(base, id, function (err, node) {\r\n                    var path;\r\n                    if (!err && node && !core.isEmpty(node)) {\r\n                        path = core.getPath(node);\r\n                        state.metaNodes[path] = node;\r\n                        if (!nodesSoFar[path]) {\r\n                            nodesSoFar[path] = {\r\n                                node: node,\r\n                                incomplete: false,\r\n                                basic: true,\r\n                                hash: getStringHash(node)\r\n                            };\r\n                        }\r\n                        base = node;\r\n                        baseLoaded();\r\n                    } else {\r\n                        callback(err);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        function orderStringArrayByElementLength(strArray) {\r\n            var ordered = [],\r\n                i, j, index;\r\n\r\n            for (i = 0; i < strArray.length; i++) {\r\n                index = -1;\r\n                j = 0;\r\n                while (index === -1 && j < ordered.length) {\r\n                    if (ordered[j].length > strArray[i].length) {\r\n                        index = j;\r\n                    }\r\n                    j++;\r\n                }\r\n\r\n                if (index === -1) {\r\n                    ordered.push(strArray[i]);\r\n                } else {\r\n                    ordered.splice(index, 0, strArray[i]);\r\n                }\r\n            }\r\n            return ordered;\r\n        }\r\n\r\n        function loadRoot(newRootHash, callback) {\r\n            //with the newer approach we try to optimize a bit the mechanism of the loading and\r\n            // try to get rid of the parallelism behind it\r\n            var patterns = {},\r\n                orderedPatternIds = [],\r\n                error = null,\r\n                i,\r\n                j,\r\n                keysi,\r\n                keysj;\r\n\r\n            state.loadNodes = {};\r\n            state.loadError = 0;\r\n\r\n            //gathering the patterns\r\n            keysi = Object.keys(state.users);\r\n            for (i = 0; i < keysi.length; i++) {\r\n                keysj = Object.keys(state.users[keysi[i]].PATTERNS);\r\n                for (j = 0; j < keysj.length; j++) {\r\n                    if (patterns[keysj[j]]) {\r\n                        //we check if the range is bigger for the new definition\r\n                        if (patterns[keysj[j]].children < state.users[keysi[i]].PATTERNS[keysj[j]].children) {\r\n                            patterns[keysj[j]].children = state.users[keysi[i]].PATTERNS[keysj[j]].children;\r\n                        }\r\n                    } else {\r\n                        patterns[keysj[j]] = state.users[keysi[i]].PATTERNS[keysj[j]];\r\n                    }\r\n                }\r\n            }\r\n            //getting an ordered key list\r\n            orderedPatternIds = Object.keys(patterns);\r\n            orderedPatternIds = orderStringArrayByElementLength(orderedPatternIds);\r\n\r\n\r\n            //and now the one-by-one loading\r\n            state.core.loadRoot(newRootHash, function (err, root) {\r\n                var fut,\r\n                    _loadPattern;\r\n\r\n                ASSERT(err || root);\r\n\r\n                state.root.object = root;\r\n                addOnFunctions.updateRunningAddOns(root);\r\n                error = error || err;\r\n                if (!err) {\r\n                    //_clientGlobal.addOn.updateRunningAddOns(root); //FIXME: ADD ME BACK!!\r\n                    state.loadNodes[state.core.getPath(root)] = {\r\n                        node: root,\r\n                        incomplete: true,\r\n                        basic: true,\r\n                        hash: getStringHash(root)\r\n                    };\r\n                    state.metaNodes[state.core.getPath(root)] = root;\r\n                    if (orderedPatternIds.length === 0 && Object.keys(state.users) > 0) {\r\n                        //we have user, but they do not interested in any object -> let's relaunch them :D\r\n                        callback(null);\r\n                        reLaunchUsers();\r\n                    } else {\r\n                        _loadPattern = TASYNC.throttle(TASYNC.wrap(loadPattern), 1);\r\n                        fut = TASYNC.lift(\r\n                            orderedPatternIds.map(function (pattern /*, index */) {\r\n                                return TASYNC.apply(_loadPattern,\r\n                                    [state.core, pattern, patterns[pattern], state.loadNodes],\r\n                                    this);\r\n                            }));\r\n                        TASYNC.unwrap(function () {\r\n                            return fut;\r\n                        })(callback);\r\n                    }\r\n                } else {\r\n                    callback(err);\r\n                }\r\n            });\r\n        }\r\n\r\n        //this is just a first brute implementation it needs serious optimization!!!\r\n        function loading(newRootHash, callback) {\r\n            var firstRoot = !state.nodes[ROOT_PATH],\r\n                originatingRootHash = state.nodes[ROOT_PATH] ? state.core.getHash(state.nodes[ROOT_PATH].node) : null,\r\n                finalEvents = function () {\r\n                    var modifiedPaths,\r\n                        i;\r\n\r\n                    modifiedPaths = getModifiedNodes(state.loadNodes);\r\n                    state.nodes = state.loadNodes;\r\n                    state.loadNodes = {};\r\n                    state.root.previous = state.root.current;\r\n                    state.root.current = newRootHash;\r\n                    for (i in state.users) {\r\n                        if (state.users.hasOwnProperty(i)) {\r\n                            userEvents(i, modifiedPaths);\r\n                        }\r\n                    }\r\n                    callback(null);\r\n                };\r\n            logger.debug('loading newRootHash', newRootHash);\r\n\r\n            callback = callback || function (/*err*/) {\r\n                };\r\n\r\n\r\n            loadRoot(newRootHash, function (err) {\r\n                if (err) {\r\n                    state.root.current = null;\r\n                    callback(err);\r\n                } else {\r\n                    if (firstRoot ||\r\n                        state.core.getHash(state.nodes[ROOT_PATH].node) === originatingRootHash) {\r\n                        finalEvents();\r\n                    } else {\r\n                        // This relies on the fact that loading is synchronous for local updates.\r\n                        logger.warn('Modifications were done during loading - load aborted.');\r\n                        callback(null, true);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        this.startTransaction = function (msg) {\r\n            if (state.inTransaction) {\r\n                logger.error('Already in transaction, will proceed though..');\r\n            }\r\n            if (state.core) {\r\n                state.inTransaction = true;\r\n                msg = msg || 'startTransaction()';\r\n                saveRoot(msg);\r\n            } else {\r\n                logger.error('Can not start transaction with no core avaliable.');\r\n            }\r\n        };\r\n\r\n        this.completeTransaction = function (msg, callback) {\r\n            state.inTransaction = false;\r\n            if (state.core) {\r\n                msg = msg || 'completeTransaction()';\r\n                saveRoot(msg, callback);\r\n            }\r\n        };\r\n\r\n        function addCommit(commitHash) {\r\n            state.commit.previous = state.commit.current;\r\n            state.commit.current = commitHash;\r\n        }\r\n\r\n        //territory functions\r\n        this.addUI = function (ui, fn, guid) {\r\n            ASSERT(fn);\r\n            ASSERT(typeof fn === 'function');\r\n            guid = guid || GUID();\r\n            state.users[guid] = {type: 'notused', UI: ui, PATTERNS: {}, PATHS: {}, SENDEVENTS: true, FN: fn};\r\n            return guid;\r\n        };\r\n\r\n        this.removeUI = function (guid) {\r\n            logger.debug('removeUI', guid);\r\n            delete state.users[guid];\r\n        };\r\n\r\n        function reLaunchUsers() {\r\n            var i;\r\n            for (i in state.users) {\r\n                if (state.users.hasOwnProperty(i)) {\r\n                    if (state.users[i].UI.reLaunch) {\r\n                        state.users[i].UI.reLaunch();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function _updateTerritoryAllDone(guid, patterns, error) {\r\n            if (state.users[guid]) {\r\n                state.users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n                if (!error) {\r\n                    userEvents(guid, []);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.updateTerritory = function (guid, patterns) {\r\n            var missing,\r\n                error,\r\n                patternLoaded,\r\n                i;\r\n\r\n            if (state.users[guid]) {\r\n                if (state.project) {\r\n                    if (state.nodes[ROOT_PATH]) {\r\n                        //TODO: this has to be optimized\r\n                        missing = 0;\r\n                        error = null;\r\n\r\n                        patternLoaded = function (err) {\r\n                            error = error || err;\r\n                            missing -= 1;\r\n                            if (missing === 0) {\r\n                                //allDone();\r\n                                _updateTerritoryAllDone(guid, patterns, error);\r\n                            }\r\n                        };\r\n\r\n                        for (i in patterns) {\r\n                            missing += 1;\r\n                        }\r\n                        if (missing > 0) {\r\n                            for (i in patterns) {\r\n                                if (patterns.hasOwnProperty(i)) {\r\n                                    loadPattern(state.core, i, patterns[i], state.nodes, patternLoaded);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            //allDone();\r\n                            _updateTerritoryAllDone(guid, patterns, error);\r\n                        }\r\n                    } else {\r\n                        //something funny is going on\r\n                        if (state.loadNodes[ROOT_PATH]) {\r\n                            //probably we are in the loading process,\r\n                            // so we should redo this update when the loading finishes\r\n                            //setTimeout(updateTerritory, 100, guid, patterns);\r\n                        } else {\r\n                            //root is not in nodes and has not even started to load it yet...\r\n                            state.users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n                        }\r\n                    }\r\n                } else {\r\n                    //we should update the patterns, but that is all\r\n                    state.users[guid].PATTERNS = JSON.parse(JSON.stringify(patterns));\r\n                }\r\n            }\r\n        };\r\n\r\n        function cleanUsersTerritories() {\r\n            //look out as the user can remove itself at any time!!!\r\n            var userIds = Object.keys(state.users),\r\n                i,\r\n                j,\r\n                events;\r\n\r\n            for (i = 0; i < userIds.length; i++) {\r\n                if (state.users[userIds[i]]) {\r\n                    events = [{eid: null, etype: 'complete'}];\r\n                    for (j in state.users[userIds[i]].PATHS\r\n                        ) {\r\n                        events.push({etype: 'unload', eid: j});\r\n                    }\r\n                    state.users[userIds[i]].PATTERNS = {};\r\n                    state.users[userIds[i]].PATHS = {};\r\n                    state.users[userIds[i]].SENDEVENTS = true;\r\n                    state.users[userIds[i]].FN(events);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.getUserId = function () {\r\n            var cookies = URL.parseCookie(document.cookie);\r\n            if (cookies.webgme) {\r\n                return cookies.webgme;\r\n            } else {\r\n                return 'n/a';\r\n            }\r\n        };\r\n\r\n        //create from file\r\n        this.createProjectFromFile = function (projectName, jProject, callback) {\r\n            storage.createProject(projectName, function (err, projectId) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                storage.openProject(projectId, function (err, project) {\r\n                    var core,\r\n                        rootNode,\r\n                        persisted;\r\n                    if (err) {\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n\r\n                    core = new Core(project, {\r\n                        globConf: gmeConfig,\r\n                        logger: logger.fork('core')\r\n                    });\r\n                    rootNode = core.createNode({parent: null, base: null});\r\n                    persisted = core.persist(rootNode);\r\n\r\n                    storage.makeCommit(projectId,\r\n                        null,\r\n                        [],\r\n                        persisted.rootHash,\r\n                        persisted.objects,\r\n                        'creating project from a file',\r\n                        function (err, commitResult) {\r\n                            if (err) {\r\n                                logger.error('cannot make initial commit for project creation from file');\r\n                                callback(err);\r\n                                return;\r\n                            }\r\n\r\n                            project.createBranch('master', commitResult.hash, function (err) {\r\n                                if (err) {\r\n                                    logger.error('cannot set branch \\'master\\' for project creation from file');\r\n                                    callback(err);\r\n                                    return;\r\n                                }\r\n                                storage.closeProject(projectId, function (err) {\r\n                                    if (err) {\r\n                                        logger.error('Closing temporary project failed in project creation from file',\r\n                                            err);\r\n                                        callback(err);\r\n                                        return;\r\n                                    }\r\n\r\n                                    self.selectProject(projectId, null, function (err) {\r\n                                        if (err) {\r\n                                            callback(err);\r\n                                            return;\r\n                                        }\r\n\r\n                                        Serialization.import(state.core, state.root.object, jProject, function (err) {\r\n                                            if (err) {\r\n                                                return callback(err);\r\n                                            }\r\n                                            saveRoot('project created from file', callback);\r\n                                        });\r\n                                    });\r\n                                });\r\n                            });\r\n                        }\r\n                    );\r\n                });\r\n            });\r\n        };\r\n\r\n        //seed\r\n        this.seedProject = function (parameters, callback) {\r\n            logger.debug('seeding project', parameters);\r\n            parameters.command = 'seedProject';\r\n            storage.simpleRequest(parameters, function (err, id) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n\r\n                storage.simpleResult(id, callback);\r\n            });\r\n        };\r\n\r\n        //export branch\r\n        this.getExportProjectBranchUrl = function (projectId, branchName, fileName, callback) {\r\n            var command = {};\r\n            command.command = 'exportLibrary';\r\n            command.projectId = projectId;\r\n            command.branchName = branchName;\r\n            command.path = ROOT_PATH;\r\n            logger.debug('getExportProjectBranchUrl, command', command);\r\n            if (command.projectId && command.branchName) {\r\n                storage.simpleRequest(command, function (err, resId) {\r\n                    var resultUrl = window.location.origin + '/worker/simpleResult/' + resId + '/' + fileName;\r\n                    logger.debug('getExportProjectBranchUrl', resultUrl);\r\n                    if (err) {\r\n                        logger.error('getExportProjectBranchUrl failed with error', err);\r\n                        callback(err);\r\n                    } else {\r\n                        callback(null, resultUrl);\r\n                    }\r\n                });\r\n            } else {\r\n                callback(new Error('invalid parameters!'));\r\n            }\r\n        };\r\n\r\n        //dump nodes\r\n        this.getExportItemsUrl = function (paths, filename, callback) {\r\n            storage.simpleRequest({\r\n                    command: 'dumpMoreNodes',\r\n                    projectId: state.project.projectId,\r\n                    hash: state.root.current,\r\n                    nodes: paths\r\n                },\r\n                function (err, resId) {\r\n                    if (err) {\r\n                        callback(err);\r\n                    } else {\r\n                        callback(null,\r\n                            window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' +\r\n                            resId + '/' + filename);\r\n                    }\r\n                });\r\n        };\r\n\r\n        //library functions\r\n        this.getExportLibraryUrl = function (libraryRootPath, filename, callback) {\r\n            var command = {};\r\n            command.command = 'exportLibrary';\r\n            command.projectId = state.project.projectId;\r\n            command.hash = state.root.current;\r\n            command.path = libraryRootPath;\r\n            if (command.projectId && command.hash) {\r\n                storage.simpleRequest(command, function (err, resId) {\r\n                    if (err) {\r\n                        logger.error('getExportLibraryUrl failed with error', err);\r\n                        callback(err);\r\n                    } else {\r\n                        callback(null,\r\n                            window.location.protocol + '//' + window.location.host + '/worker/simpleResult/' +\r\n                            resId + '/' + filename);\r\n                    }\r\n                });\r\n            } else {\r\n                callback(new Error('there is no open project!'));\r\n            }\r\n        };\r\n\r\n        this.updateLibrary = function (libraryRootPath, newLibrary, callback) {\r\n            Serialization.import(state.core, state.nodes[libraryRootPath].node, newLibrary, function (err, log) {\r\n                if (err) {\r\n                    return callback(err);\r\n                }\r\n\r\n                saveRoot('library update done\\nlogs:\\n' + log, callback);\r\n            });\r\n        };\r\n\r\n        this.addLibrary = function (libraryParentPath, newLibrary, callback) {\r\n            self.startTransaction('creating library as a child of ' + libraryParentPath);\r\n            var libraryRoot = self.createChild({\r\n                parentId: libraryParentPath,\r\n                baseId: null\r\n            }, 'library placeholder');\r\n            Serialization.import(state.core,\r\n                state.nodes[libraryRoot].node, newLibrary, function (err, log) {\r\n                    if (err) {\r\n                        return callback(err);\r\n                    }\r\n\r\n                    self.completeTransaction('library update done\\nlogs:\\n' + log, callback);\r\n                }\r\n            );\r\n        };\r\n\r\n        /**\r\n         * Run the plugin on the server inside a worker process.\r\n         * @param {string} name - name of plugin.\r\n         * @param {object} context\r\n         * @param {object} context.managerConfig - where the plugin should execute.\r\n         * @param {string} context.managerConfig.project - id of project.\r\n         * @param {string} context.managerConfig.activeNode - path to activeNode.\r\n         * @param {string} [context.managerConfig.activeSelection=[]] - paths to selected nodes.\r\n         * @param {string} context.managerConfig.commit - commit hash to start the plugin from.\r\n         * @param {string} context.managerConfig.branchName - branch which to save to.\r\n         * @param {object} [context.pluginConfig=%defaultForPlugin%] - specific configuration for the plugin.\r\n         * @param {function} callback\r\n         */\r\n        this.runServerPlugin = function (name, context, callback) {\r\n            storage.simpleRequest({command: 'executePlugin', name: name, context: context}, callback);\r\n        };\r\n\r\n        /**\r\n         * @param {string[]} pluginNames - All avaliable plugins from server.\r\n         * @param {string} [nodePath=''] - Node to get the validPlugins from.\r\n         * @returns {string[]} - Filtered plugin names.\r\n         */\r\n        this.filterPlugins = function (pluginNames, nodePath) {\r\n            var filteredNames = [],\r\n                validPlugins,\r\n                i,\r\n                node;\r\n\r\n            logger.debug('filterPluginsBasedOnNode allPlugins, given nodePath', pluginNames, nodePath);\r\n            if (!nodePath) {\r\n                logger.debug('filterPluginsBasedOnNode nodePath not given - will fall back on root-node.');\r\n                nodePath = ROOT_PATH;\r\n            }\r\n\r\n            node = state.nodes[nodePath];\r\n\r\n            if (!node) {\r\n                logger.warn('filterPluginsBasedOnNode node not loaded - will fall back on root-node.', nodePath);\r\n                nodePath = ROOT_PATH;\r\n                node = state.nodes[nodePath];\r\n            }\r\n\r\n            if (!node) {\r\n                logger.warn('filterPluginsBasedOnNode root node not loaded - will return full list.');\r\n                return pluginNames;\r\n            }\r\n\r\n            validPlugins = (state.core.getRegistry(node.node, 'validPlugins') || '').split(' ');\r\n            for (i = 0; i < validPlugins.length; i += 1) {\r\n                if (pluginNames.indexOf(validPlugins[i]) > -1) {\r\n                    filteredNames.push(validPlugins[i]);\r\n                } else {\r\n                    logger.warn('Registered plugin for node at path \"' + nodePath +\r\n                        '\" is not amongst avaliable plugins', pluginNames);\r\n                }\r\n            }\r\n\r\n            return filteredNames;\r\n        };\r\n\r\n        //addOn\r\n        this.validateProjectAsync = addOnFunctions.validateProjectAsync;\r\n        this.validateModelAsync = addOnFunctions.validateModelAsync;\r\n        this.validateNodeAsync = addOnFunctions.validateNodeAsync;\r\n        this.setValidationCallback = addOnFunctions.setValidationCallback;\r\n        this.getDetailedHistoryAsync = addOnFunctions.getDetailedHistoryAsync;\r\n        this.getRunningAddOnNames = addOnFunctions.getRunningAddOnNames;\r\n        this.addOnsAllowed = gmeConfig.addOn.enable === true;\r\n\r\n        //constraint\r\n        this.setConstraint = function (path, name, constraintObj) {\r\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\r\n                state.core.setConstraint(state.nodes[path].node, name, constraintObj);\r\n                saveRoot('setConstraint(' + path + ',' + name + ')');\r\n            }\r\n        };\r\n\r\n        this.delConstraint = function (path, name) {\r\n            if (state.core && state.nodes[path] && typeof state.nodes[path].node === 'object') {\r\n                state.core.delConstraint(state.nodes[path].node, name);\r\n                saveRoot('delConstraint(' + path + 'name' + ')');\r\n            }\r\n        };\r\n\r\n        //automerge\r\n        this.autoMerge = function (projectId, mine, theirs, callback) {\r\n            var command = {\r\n                command: 'autoMerge',\r\n                projectId: projectId,\r\n                mine: mine,\r\n                theirs: theirs\r\n            };\r\n            storage.simpleRequest(command, function (err, resId) {\r\n                if (err) {\r\n                    callback(err);\r\n                } else {\r\n                    storage.simpleResult(resId, callback);\r\n                }\r\n            });\r\n        };\r\n\r\n        this.resolve = function (mergeResult, callback) {\r\n            var command = {\r\n                command: 'resolve',\r\n                partial: mergeResult\r\n            };\r\n            storage.simpleRequest(command, function (err, resId) {\r\n                if (err) {\r\n                    callback(err);\r\n                } else {\r\n                    storage.simpleResult(resId, callback);\r\n                }\r\n            });\r\n        };\r\n    }\r\n\r\n\r\n    // Inherit from the EventDispatcher\r\n    Client.prototype = Object.create(EventDispatcher.prototype);\r\n    Client.prototype.constructor = Client;\r\n\r\n    return Client;\r\n  });\r\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/BlobConfig',[], function () {\n    'use strict';\n    var BlobConfig = {\n        hashMethod: 'sha1', // TODO: in the future we may switch to sha512\n        hashRegex: new RegExp('^[0-9a-f]{40}$')\n    };\n\n    return BlobConfig;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/BlobMetadata',['blob/BlobConfig'], function (BlobConfig) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of BlobMetadata\n     * @param {object} metadata - A serialized metadata object.\n     * @param {string} metadata.name\n     * @param {string|Object} metadata.content\n     * @param {number} [metadata.size=0]\n     * @param {BlobMetadata.CONTENT_TYPES} [metadata.contentType=BlobMetadata.CONTENT_TYPES.OBJECT]\n     * @param {string} [metadata.mime='']\n     * @param {boolean} [metadata.isPublic=false]\n     * @param {string[]} [metadata.tags=[]]\n     * @constructor\n     */\n    var BlobMetadata = function (metadata) {\n        var key;\n        if (metadata) {\n            this.name = metadata.name;\n            this.size = metadata.size || 0;\n            this.mime = metadata.mime || '';\n            this.isPublic = metadata.isPublic || false;\n            this.tags = metadata.tags || [];\n            this.content = metadata.content;\n            this.contentType = metadata.contentType || BlobMetadata.CONTENT_TYPES.OBJECT;\n            if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n                for (key in this.content) {\n                    if (this.content.hasOwnProperty(key)) {\n                        if (BlobConfig.hashRegex.test(this.content[key].content) === false) {\n                            throw Error('BlobMetadata is malformed: hash \\'' + this.content[key].content + '\\'is invalid');\n                        }\n                    }\n                }\n            }\n        } else {\n            throw new Error('metadata parameter is not defined');\n        }\n    };\n\n    /**\n     * Type of the metadata\n     * @type {{OBJECT: string, COMPLEX: string, SOFT_LINK: string}}\n     */\n    BlobMetadata.CONTENT_TYPES = {\n        OBJECT: 'object',\n        COMPLEX: 'complex',\n        SOFT_LINK: 'softLink'\n    };\n\n    /**\n     * Serializes the metadata to a JSON object.\n     * @returns {{\n     *  name: string,\n     *  size: number,\n     *  mime: string,\n     *  tags: Array.<string>,\n     *  content: (string|Object},\n     *  contentType: string}}\n     */\n    BlobMetadata.prototype.serialize = function () {\n        var metadata = {\n            name: this.name,\n            size: this.size,\n            mime: this.mime,\n            isPublic: this.isPublic,\n            tags: this.tags,\n            content: this.content,\n            contentType: this.contentType\n        };\n\n        metadata.tags.sort();\n\n        if (this.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n            // override on  purpose to normalize content\n            metadata.content = {};\n            var fnames = Object.keys(this.content);\n            fnames.sort();\n\n            for (var j = 0; j < fnames.length; j += 1) {\n                metadata.content[fnames[j]] = this.content[fnames[j]];\n            }\n        }\n\n        return metadata;\n    };\n\n    return BlobMetadata;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/*\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('blob/Artifact',['blob/BlobMetadata', 'blob/BlobConfig', 'common/core/tasync'], function (BlobMetadata, BlobConfig, tasync) {\n    'use strict';\n    /**\n     * Creates a new instance of artifact, i.e. complex object, in memory. This object can be saved in the storage.\n     * @param {string} name Artifact's name without extension\n     * @param {blob.BlobClient} blobClient\n     * @param {blob.BlobMetadata} descriptor\n     * @constructor\n     */\n    var Artifact = function (name, blobClient, descriptor) {\n        this.name = name;\n        this.blobClient = blobClient;\n        this.blobClientPutFile = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.putFile), 5));\n        this.blobClientGetMetadata = tasync.unwrap(tasync.throttle(tasync.wrap(blobClient.getMetadata), 5));\n        // TODO: use BlobMetadata class here\n        this.descriptor = descriptor || {\n            name: name + '.zip',\n            size: 0,\n            mime: 'application/zip',\n            content: {},\n            contentType: 'complex'\n        }; // name and hash pairs\n    };\n\n    /**\n     * Adds content to the artifact as a file.\n     * @param {string} name filename\n     * @param {Blob} content File object or Blob\n     * @param callback\n     */\n    Artifact.prototype.addFile = function (name, content, callback) {\n        var self = this;\n        var filename = name.substring(name.lastIndexOf('/') + 1);\n\n        self.blobClientPutFile.call(self.blobClient, filename, content, function (err, hash) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            self.addObjectHash(name, hash, function (err, hash) {\n                callback(err, hash);\n            });\n        });\n    };\n\n    Artifact.prototype.addFileAsSoftLink = function (name, content, callback) {\n        var self = this;\n        var filename = name.substring(name.lastIndexOf('/') + 1);\n\n        self.blobClientPutFile.call(self.blobClient, filename, content,\n            function (err, hash) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                var size;\n                if (content.size !== undefined) {\n                    size = content.size;\n                }\n                if (content.length !== undefined) {\n                    size = content.length;\n                }\n\n                self.addMetadataHash(name, hash, size, function (err, hash) {\n                    callback(err, hash);\n                });\n            });\n    };\n\n    /**\n     * Adds a hash to the artifact using the given file path.\n     * @param {string} name Path to the file in the artifact. Note: 'a/b/c.txt'\n     * @param {string} hash Metadata hash that has to be added.\n     * @param callback\n     */\n    Artifact.prototype.addObjectHash = function (name, hash, callback) {\n        var self = this;\n\n        if (BlobConfig.hashRegex.test(hash) === false) {\n            callback('Blob hash is invalid');\n            return;\n        }\n\n        self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            if (self.descriptor.content.hasOwnProperty(name)) {\n                callback('Another content with the same name was already added. ' +\n                JSON.stringify(self.descriptor.content[name]));\n\n            } else {\n                self.descriptor.size += metadata.size;\n\n                self.descriptor.content[name] = {\n                    content: metadata.content,\n                    contentType: BlobMetadata.CONTENT_TYPES.OBJECT\n                };\n                callback(null, hash);\n            }\n        });\n    };\n\n    Artifact.prototype.addMetadataHash = function (name, hash, size, callback) {\n        var self = this,\n            addMetadata = function (size) {\n                if (self.descriptor.content.hasOwnProperty(name)) {\n                    callback('Another content with the same name was already added. ' +\n                    JSON.stringify(self.descriptor.content[name]));\n\n                } else {\n                    self.descriptor.size += size;\n\n                    self.descriptor.content[name] = {\n                        content: hash,\n                        contentType: BlobMetadata.CONTENT_TYPES.SOFT_LINK\n                    };\n                    callback(null, hash);\n                }\n            };\n\n        if (typeof size === 'function') {\n            callback = size;\n            size = undefined;\n        }\n\n        if (BlobConfig.hashRegex.test(hash) === false) {\n            callback('Blob hash is invalid');\n            return;\n        }\n        if (size === undefined) {\n            self.blobClientGetMetadata.call(self.blobClient, hash, function (err, metadata) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                addMetadata(metadata.size);\n            });\n        } else {\n            addMetadata(size);\n        }\n    };\n\n    /**\n     * Adds multiple files.\n     * @param {Object.<string, Blob>} files files to add\n     * @param callback\n     */\n    Artifact.prototype.addFiles = function (files, callback) {\n        var self = this,\n            fileNames = Object.keys(files),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding files: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addFile(fileNames[i], files[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds multiple files as soft-links.\n     * @param {Object.<string, Blob>} files files to add\n     * @param callback\n     */\n    Artifact.prototype.addFilesAsSoftLinks = function (files, callback) {\n        var self = this,\n            fileNames = Object.keys(files),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding files as soft-links: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addFileAsSoftLink(fileNames[i], files[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds hashes to the artifact using the given file paths.\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\n     * @param callback\n     */\n    Artifact.prototype.addObjectHashes = function (objectHashes, callback) {\n        var self = this,\n            fileNames = Object.keys(objectHashes),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding objectHashes: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addObjectHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Adds hashes to the artifact using the given file paths.\n     * @param {object.<string, string>} objectHashes - Keys are file paths and values object hashes.\n     * @param callback\n     */\n    Artifact.prototype.addMetadataHashes = function (objectHashes, callback) {\n        var self = this,\n            fileNames = Object.keys(objectHashes),\n            nbrOfFiles = fileNames.length,\n            hashes = [],\n            error = '',\n            i,\n            counterCallback = function (err, hash) {\n                error = err ? error + err : error;\n                nbrOfFiles -= 1;\n                hashes.push(hash);\n                if (nbrOfFiles === 0) {\n                    if (error) {\n                        return callback('Failed adding objectHashes: ' + error, hashes);\n                    }\n                    callback(null, hashes);\n                }\n            };\n\n        if (nbrOfFiles === 0) {\n            callback(null, hashes);\n            return;\n        }\n\n        for (i = 0; i < fileNames.length; i += 1) {\n            self.addMetadataHash(fileNames[i], objectHashes[fileNames[i]], counterCallback);\n        }\n    };\n\n    /**\n     * Saves this artifact and uploads the metadata to the server's storage.\n     * @param callback\n     */\n    Artifact.prototype.save = function (callback) {\n        this.blobClient.putMetadata(this.descriptor, callback);\n    };\n\n    return Artifact;\n});\n\n",
    "!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define('lib/superagent/superagent-1.2.0',[],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.superagent=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root = 'undefined' == typeof window\n  ? (this || self)\n  : window;\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(err || new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"})\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n  err.crossDomain = true;\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var serialize = request.serialize[this.getHeader('Content-Type')];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n  xhr.send(data);\n  return this;\n};\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.del = function(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n},{\"emitter\":2,\"reduce\":3}],2:[function(require,module,exports){\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n},{}],3:[function(require,module,exports){\n\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n},{}]},{},[1])(1)\n});\n",
    "/*globals define, escape*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for accessing the blob.\n *\n * @author lattmann / https://github.com/lattmann\n * @author ksmyth / https://github.com/ksmyth\n */\n\ndefine('blob/BlobClient',['blob/Artifact', 'blob/BlobMetadata', 'superagent'], function (Artifact, BlobMetadata, superagent) {\n    'use strict';\n\n    var BlobClient = function (parameters) {\n        this.artifacts = [];\n\n        if (parameters) {\n            this.server = parameters.server || this.server;\n            this.serverPort = parameters.serverPort || this.serverPort;\n            this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\n            this.webgmeclientsession = parameters.webgmeclientsession;\n            this.keepaliveAgentOptions = parameters.keepaliveAgentOptions || { /* use defaults */ };\n        } else {\n            this.keepaliveAgentOptions = { /* use defaults */ };\n        }\n        this.blobUrl = '';\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\n            this.blobUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\n        }\n\n        // TODO: TOKEN???\n        this.blobUrl = this.blobUrl + '/rest/blob/'; // TODO: any ways to ask for this or get it from the configuration?\n\n        this.isNodeOrNodeWebKit = typeof process !== 'undefined';\n        if (this.isNodeOrNodeWebKit) {\n            // node or node-webkit\n            if (this.httpsecure) {\n                this.Agent = require('agentkeepalive').HttpsAgent;\n            } else {\n                this.Agent = require('agentkeepalive');\n            }\n            if (this.keepaliveAgentOptions.hasOwnProperty('ca') === false) {\n                this.keepaliveAgentOptions.ca = require('https').globalAgent.options.ca;\n            }\n            this.keepaliveAgent = new this.Agent(this.keepaliveAgentOptions);\n        }\n    };\n\n    BlobClient.prototype.getMetadataURL = function (hash) {\n        var metadataBase = this.blobUrl + 'metadata';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n    BlobClient.prototype._getURL = function (base, hash, subpath) {\n        var subpathURL = '';\n        if (subpath) {\n            subpathURL = subpath;\n        }\n        return this.blobUrl + base + '/' + hash + '/' + encodeURIComponent(subpathURL);\n    };\n\n    BlobClient.prototype.getViewURL = function (hash, subpath) {\n        return this._getURL('view', hash, subpath);\n    };\n\n    BlobClient.prototype.getDownloadURL = function (hash, subpath) {\n        return this._getURL('download', hash, subpath);\n    };\n\n    BlobClient.prototype.getCreateURL = function (filename, isMetadata) {\n        if (isMetadata) {\n            return this.blobUrl + 'createMetadata/';\n        } else {\n            return this.blobUrl + 'createFile/' + encodeURIComponent(filename);\n        }\n    };\n\n    BlobClient.prototype.putFile = function (name, data, callback) {\n        var contentLength,\n            req;\n\n        function toArrayBuffer(buffer) {\n            var ab = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(ab);\n            for (var i = 0; i < buffer.length; ++i) {\n                view[i] = buffer[i];\n            }\n            return ab;\n        }\n\n        // On node-webkit, we use XMLHttpRequest, but xhr.send thinks a Buffer is a string and encodes it in utf-8 -\n        // send an ArrayBuffer instead.\n        if (typeof window !== 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\n            data = toArrayBuffer(data); // FIXME will this have performance problems\n        }\n        // on node, empty Buffers will cause a crash in superagent\n        if (typeof window === 'undefined' && typeof Buffer !== 'undefined' && data instanceof Buffer) {\n            if (data.length === 0) {\n                data = '';\n            }\n        }\n        contentLength = data.hasOwnProperty('length') ? data.length : data.byteLength;\n        req = superagent.post(this.getCreateURL(name));\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n        if (typeof data !== 'string' && !(data instanceof String)) {\n            req.set('Content-Length', contentLength)\n        }\n        req.set('Content-Type', 'application/octet-stream')\n            .send(data)\n            .end(function (err, res) {\n                if (err || res.status > 399) {\n                    callback(err || res.status);\n                    return;\n                }\n                var response = res.body;\n                // Get the first one\n                var hash = Object.keys(response)[0];\n                callback(null, hash);\n            });\n    };\n\n    BlobClient.prototype.putMetadata = function (metadataDescriptor, callback) {\n        var metadata = new BlobMetadata(metadataDescriptor),\n            blob,\n            contentLength,\n            req;\n        // FIXME: in production mode do not indent the json file.\n        if (typeof Blob !== 'undefined') {\n            blob = new Blob([JSON.stringify(metadata.serialize(), null, 4)], {type: 'text/plain'});\n            contentLength = blob.size;\n        } else {\n            blob = new Buffer(JSON.stringify(metadata.serialize(), null, 4), 'utf8');\n            contentLength = blob.length;\n        }\n\n        req = superagent.post(this.getCreateURL(metadataDescriptor.name, true));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        req.set('Content-Type', 'application/octet-stream')\n            .set('Content-Length', contentLength)\n            .send(blob)\n            .end(function (err, res) {\n                if (err || res.status > 399) {\n                    callback(err || res.status);\n                    return;\n                }\n                // Uploaded.\n                var response = JSON.parse(res.text);\n                // Get the first one\n                var hash = Object.keys(response)[0];\n                callback(null, hash);\n            });\n    };\n\n    BlobClient.prototype.putFiles = function (o, callback) {\n        var self = this,\n            error = '',\n            filenames = Object.keys(o),\n            remaining = filenames.length,\n            hashes = {},\n            putFile;\n        if (remaining === 0) {\n            callback(null, hashes);\n        }\n        putFile = function (filename, data) {\n            self.putFile(filename, data, function (err, hash) {\n                remaining -= 1;\n\n                hashes[filename] = hash;\n\n                if (err) {\n                    error += 'putFile error: ' + err.toString();\n                }\n\n                if (remaining === 0) {\n                    callback(error, hashes);\n                }\n            });\n        };\n\n        for (var j = 0; j < filenames.length; j += 1) {\n            putFile(filenames[j], o[filenames[j]]);\n        }\n    };\n\n    BlobClient.prototype.getSubObject = function (hash, subpath, callback) {\n        return this.getObject(hash, callback, subpath);\n    };\n\n    BlobClient.prototype.getObject = function (hash, callback, subpath) {\n        superagent.parse['application/zip'] = function (obj, parseCallback) {\n            if (parseCallback) {\n                // Running on node; this should be unreachable due to req.pipe() below\n            } else {\n                return obj;\n            }\n        };\n        //superagent.parse['application/json'] = superagent.parse['application/zip'];\n\n        var req = superagent.get(this.getViewURL(hash, subpath));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        if (req.pipe) {\n            // running on node\n            var Writable = require('stream').Writable;\n            var BuffersWritable = function (options) {\n                Writable.call(this, options);\n\n                var self = this;\n                self.buffers = [];\n            };\n            require('util').inherits(BuffersWritable, Writable);\n\n            BuffersWritable.prototype._write = function (chunk, encoding, callback) {\n                this.buffers.push(chunk);\n                callback();\n            };\n\n            var buffers = new BuffersWritable();\n            buffers.on('finish', function () {\n                if (req.req.res.statusCode > 399) {\n                    return callback(req.req.res.statusCode);\n                }\n                callback(null, Buffer.concat(buffers.buffers));\n            });\n            buffers.on('error', function (err) {\n                callback(err);\n            });\n            req.pipe(buffers);\n        } else {\n            req.removeAllListeners('end');\n            req.on('request', function () {\n                if (typeof this.xhr !== 'undefined') {\n                    this.xhr.responseType = 'arraybuffer';\n                }\n            });\n            // req.on('error', callback);\n            req.on('end', function () {\n                if (req.xhr.status > 399) {\n                    callback(req.xhr.status);\n                } else {\n                    var contentType = req.xhr.getResponseHeader('content-type');\n                    var response = req.xhr.response; // response is an arraybuffer\n                    if (contentType === 'application/json') {\n                        var utf8ArrayToString = function (uintArray) {\n                            var inputString = '',\n                                i;\n                            for (i = 0; i < uintArray.byteLength; i++) {\n                                inputString += String.fromCharCode(uintArray[i]);\n                            }\n                            return decodeURIComponent(escape(inputString));\n                        };\n                        response = JSON.parse(utf8ArrayToString(new Uint8Array(response)));\n                    }\n                    callback(null, response);\n                }\n            });\n            req.end(callback);\n        }\n    };\n\n    BlobClient.prototype.getMetadata = function (hash, callback) {\n        var req = superagent.get(this.getMetadataURL(hash));\n        if (this.webgmeclientsession) {\n            req.set('webgmeclientsession', this.webgmeclientsession);\n        }\n\n        if (typeof window === 'undefined') {\n            req.agent(this.keepaliveAgent);\n        }\n\n        req.end(function (err, res) {\n            if (err || res.status > 399) {\n                callback(err || res.status);\n            } else {\n                callback(null, JSON.parse(res.text));\n            }\n        });\n    };\n\n    BlobClient.prototype.createArtifact = function (name) {\n        var artifact = new Artifact(name, this);\n        this.artifacts.push(artifact);\n        return artifact;\n    };\n\n    BlobClient.prototype.getArtifact = function (metadataHash, callback) {\n        // TODO: get info check if complex flag is set to true.\n        // TODO: get info get name.\n        var self = this;\n        this.getMetadata(metadataHash, function (err, info) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            if (info.contentType === BlobMetadata.CONTENT_TYPES.COMPLEX) {\n                var artifact = new Artifact(info.name, self, info);\n                self.artifacts.push(artifact);\n                callback(null, artifact);\n            } else {\n                callback('not supported contentType ' + JSON.stringify(info, null, 4));\n            }\n\n        });\n    };\n\n    BlobClient.prototype.saveAllArtifacts = function (callback) {\n        var remaining = this.artifacts.length,\n            hashes = [],\n            error = '',\n            saveCallback;\n\n        if (remaining === 0) {\n            callback(null, hashes);\n        }\n\n        saveCallback = function (err, hash) {\n            remaining -= 1;\n\n            hashes.push(hash);\n\n            if (err) {\n                error += 'artifact.save err: ' + err.toString();\n            }\n            if (remaining === 0) {\n                callback(error, hashes);\n            }\n        };\n\n        for (var i = 0; i < this.artifacts.length; i += 1) {\n\n            this.artifacts[i].save(saveCallback);\n        }\n    };\n\n    return BlobClient;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * Client module for creating, monitoring executor jobs.\n *\n * @author lattmann / https://github.com/lattmann\n * @author ksmyth / https://github.com/ksmyth\n */\n\n\ndefine('executor/ExecutorClient',['superagent'], function (superagent) {\n    'use strict';\n\n    var ExecutorClient = function (parameters) {\n        parameters = parameters || {};\n        this.isNodeJS = (typeof window === 'undefined') && (typeof process === 'object');\n        this.isNodeWebkit = (typeof window === 'object') && (typeof process === 'object');\n        //console.log(isNode);\n        if (this.isNodeJS) {\n            this.server = '127.0.0.1';\n            this._clientSession = null; // parameters.sessionId;;\n        }\n        this.server = parameters.server || this.server;\n        this.serverPort = parameters.serverPort || this.serverPort;\n        this.httpsecure = (parameters.httpsecure !== undefined) ? parameters.httpsecure : this.httpsecure;\n        if (this.isNodeJS) {\n            this.http = this.httpsecure ? require('https') : require('http');\n        }\n        this.executorUrl = '';\n        if (this.httpsecure !== undefined && this.server && this.serverPort) {\n            this.executorUrl = (this.httpsecure ? 'https://' : 'http://') + this.server + ':' + this.serverPort;\n        }\n        // TODO: TOKEN???\n        // TODO: any ways to ask for this or get it from the configuration?\n        this.executorUrl = this.executorUrl + '/rest/executor/';\n        if (parameters.executorNonce) {\n            this.executorNonce = parameters.executorNonce;\n        }\n    };\n\n    ExecutorClient.prototype.getInfoURL = function (hash) {\n        var metadataBase = this.executorUrl + 'info';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n\n    ExecutorClient.prototype.getCreateURL = function (hash) {\n        var metadataBase = this.executorUrl + 'create';\n        if (hash) {\n            return metadataBase + '/' + hash;\n        } else {\n            return metadataBase;\n        }\n    };\n\n    ExecutorClient.prototype.createJob = function (jobInfo, callback) {\n        if (typeof jobInfo === 'string') {\n            jobInfo = { hash: jobInfo }; // old API\n        }\n        this.sendHttpRequestWithData('POST', this.getCreateURL(jobInfo.hash), jobInfo, function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.updateJob = function (jobInfo, callback) {\n        this.sendHttpRequestWithData('POST', this.executorUrl + 'update/' + jobInfo.hash, jobInfo,\n            function (err, response) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                callback(null, response);\n            }\n        );\n    };\n\n    ExecutorClient.prototype.getInfo = function (hash, callback) {\n        this.sendHttpRequest('GET', this.getInfoURL(hash), function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getAllInfo = function (callback) {\n\n        this.sendHttpRequest('GET', this.getInfoURL(), function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getInfoByStatus = function (status, callback) {\n\n        this.sendHttpRequest('GET', this.executorUrl + '?status=' + status, function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.getWorkersInfo = function (callback) {\n\n        this.sendHttpRequest('GET', this.executorUrl + 'worker', function (err, response) {\n            if (err) {\n                callback(err);\n                return;\n            }\n\n            callback(null, JSON.parse(response));\n        });\n    };\n\n    ExecutorClient.prototype.sendHttpRequest = function (method, url, callback) {\n        return this.sendHttpRequestWithData(method, url, null, callback);\n    };\n\n    ExecutorClient.prototype.sendHttpRequestWithData = function (method, url, data, callback) {\n        var req = new superagent.Request(method, url);\n        if (this.executorNonce) {\n            req.set('x-executor-nonce', this.executorNonce);\n        }\n        if (data) {\n            req.send(data);\n        }\n        req.end(function (err, res) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (res.status > 399) {\n                callback(res.status, res.text);\n            } else {\n                callback(null, res.text);\n            }\n        });\n    };\n\n    ExecutorClient.prototype._ensureAuthenticated = function (options, callback) {\n        //this function enables the session of the client to be authenticated\n        //TODO currently this user does not have a session, so it has to upgrade the options always!!!\n//        if (options.headers) {\n//            options.headers.webgmeclientsession = this._clientSession;\n//        } else {\n//            options.headers = {\n//                'webgmeclientsession': this._clientSession\n//            }\n//        }\n        callback(null, options);\n    };\n\n    return ExecutorClient;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginConfig',[], function () {\n    'use strict';\n    /**\n     * Initializes a new instance of plugin configuration.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginConfig = function (config) {\n        if (config) {\n            var keys = Object.keys(config);\n            for (var i = 0; i < keys.length; i += 1) {\n                // TODO: check for type on deserialization\n                this[keys[i]] = config[keys[i]];\n            }\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginConfig.prototype.serialize = function () {\n        var keys = Object.keys(this);\n        var result = {};\n\n        for (var i = 0; i < keys.length; i += 1) {\n            // TODO: check for type on serialization\n            result[keys[i]] = this[keys[i]];\n        }\n\n        return result;\n    };\n\n\n    return PluginConfig;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginNodeDescription',[], function () {\n    'use strict';\n    /**\n     * Initializes a new instance of plugin node description object.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginNodeDescription = function (config) {\n        if (config) {\n            this.name = config.name;\n            this.id = config.id;\n        } else {\n            this.name = '';\n            this.id = '';\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginNodeDescription.prototype.serialize = function () {\n        var keys = Object.keys(this),\n            result = {},\n            i;\n\n        for (i = 0; i < keys.length; i += 1) {\n            // TODO: check for type on serialization\n            result[keys[i]] = this[keys[i]];\n        }\n\n        return result;\n    };\n\n    return PluginNodeDescription;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginMessage',['plugin/PluginNodeDescription'], function (PluginNodeDescription) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of plugin message.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginMessage = function (config) {\n        if (config) {\n            this.commitHash = config.commitHash;\n            if (config.activeNode instanceof PluginNodeDescription) {\n                this.activeNode = config.activeNode;\n            } else {\n                this.activeNode = new PluginNodeDescription(config.activeNode);\n            }\n\n            this.message = config.message;\n            if (config.severity) {\n                this.severity = config.severity;\n            } else {\n                this.severity = 'info';\n            }\n        } else {\n            this.commitHash = '';\n            this.activeNode = new PluginNodeDescription();\n            this.message = '';\n            this.severity = 'info';\n        }\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{}}\n     */\n    PluginMessage.prototype.serialize = function () {\n        var result = {\n            commitHash: this.commitHash,\n            activeNode: this.activeNode.serialize(),\n            message: this.message,\n            severity: this.severity\n        };\n\n        return result;\n    };\n\n    return PluginMessage;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n\ndefine('plugin/PluginResult',['plugin/PluginMessage'], function (PluginMessage) {\n    'use strict';\n    /**\n     * Initializes a new instance of a plugin result object.\n     *\n     * Note: this object is JSON serializable see serialize method.\n     *\n     * @param config - deserializes an existing configuration to this object.\n     * @constructor\n     */\n    var PluginResult = function (config) {\n        var pluginMessage,\n            i;\n        if (config) {\n            this.success = config.success;\n            this.pluginName = config.pluginName;\n            this.startTime = config.startTime;\n            this.finishTime = config.finishTime;\n            this.messages = [];\n            this.artifacts = config.artifacts;\n            this.error = config.error;\n            this.commits = config.commits;\n\n            for (i = 0; i < config.messages.length; i += 1) {\n                if (config.messages[i] instanceof PluginMessage) {\n                    pluginMessage = config.messages[i];\n                } else {\n                    pluginMessage = new PluginMessage(config.messages[i]);\n                }\n                this.messages.push(pluginMessage);\n            }\n        } else {\n            this.success = false;\n            this.messages = []; // array of PluginMessages\n            this.artifacts = []; // array of hashes\n            this.pluginName = 'PluginName N/A';\n            this.startTime = null;\n            this.finishTime = null;\n            this.error = null;\n            this.commits = [];\n        }\n    };\n\n    /**\n     * Gets the success flag of this result object\n     *\n     * @returns {boolean}\n     */\n    PluginResult.prototype.getSuccess = function () {\n        return this.success;\n    };\n\n    /**\n     * Sets the success flag of this result.\n     *\n     * @param {boolean} value\n     */\n    PluginResult.prototype.setSuccess = function (value) {\n        this.success = value;\n    };\n\n    /**\n     * Returns with the plugin messages.\n     *\n     * @returns {plugin.PluginMessage[]}\n     */\n    PluginResult.prototype.getMessages = function () {\n        return this.messages;\n    };\n\n    /**\n     * Adds a new plugin message to the messages list.\n     *\n     * @param {plugin.PluginMessage} pluginMessage\n     */\n    PluginResult.prototype.addMessage = function (pluginMessage) {\n        this.messages.push(pluginMessage);\n    };\n\n    PluginResult.prototype.getArtifacts = function () {\n        return this.artifacts;\n    };\n\n    PluginResult.prototype.addArtifact = function (hash) {\n        this.artifacts.push(hash);\n    };\n\n    /**\n     *\n     * @param {object} commitData\n     * @param {string} commitData.commitHash - hash of the commit.\n     * @param {string} commitData.status - storage.constants./SYNCH/FORKED.\n     * @param {string} commitData.branchName - name of branch that got updated with the commitHash.\n     */\n    PluginResult.prototype.addCommit = function (commitData) {\n        this.commits.push(commitData);\n    };\n\n    /**\n     * Gets the name of the plugin to which the result object belongs to.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getPluginName = function () {\n        return this.pluginName;\n    };\n\n    //------------------------------------------------------------------------------------------------------------------\n    //--------------- Methods used by the plugin manager\n\n    /**\n     * Sets the name of the plugin to which the result object belongs to.\n     *\n     * @param pluginName - name of the plugin\n     */\n    PluginResult.prototype.setPluginName = function (pluginName) {\n        this.pluginName = pluginName;\n    };\n\n    /**\n     * Gets the ISO 8601 representation of the time when the plugin started its execution.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getStartTime = function () {\n        return this.startTime;\n    };\n\n    /**\n     * Sets the ISO 8601 representation of the time when the plugin started its execution.\n     *\n     * @param {string} time\n     */\n    PluginResult.prototype.setStartTime = function (time) {\n        this.startTime = time;\n    };\n\n    /**\n     * Gets the ISO 8601 representation of the time when the plugin finished its execution.\n     *\n     * @returns {string}\n     */\n    PluginResult.prototype.getFinishTime = function () {\n        return this.finishTime;\n    };\n\n    /**\n     * Sets the ISO 8601 representation of the time when the plugin finished its execution.\n     *\n     * @param {string} time\n     */\n    PluginResult.prototype.setFinishTime = function (time) {\n        this.finishTime = time;\n    };\n\n    /**\n     * Gets error if any error occured during execution.\n     * FIXME: should this be an Error object?\n     * @returns {string}\n     */\n    PluginResult.prototype.getError = function () {\n        return this.error;\n    };\n\n    /**\n     * Sets the error string if any error occured during execution.\n     * FIXME: should this be an Error object?\n     * @param {string} time\n     */\n    PluginResult.prototype.setError = function (error) {\n        this.error = error;\n    };\n\n    /**\n     * Serializes this object to a JSON representation.\n     *\n     * @returns {{success: boolean, messages: plugin.PluginMessage[], pluginName: string, finishTime: stirng}}\n     */\n    PluginResult.prototype.serialize = function () {\n        var result = {\n            success: this.success,\n            messages: [],\n            commits: this.commits,\n            artifacts: this.artifacts,\n            pluginName: this.pluginName,\n            startTime: this.startTime,\n            finishTime: this.finishTime,\n            error: this.error\n        },\n            i;\n\n        for (i = 0; i < this.messages.length; i += 1) {\n            result.messages.push(this.messages[i].serialize());\n        }\n\n        return result;\n    };\n\n    return PluginResult;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * This is the base class that plugins should inherit from.\n * (Using the plugin-generator - the generated plugin will do that.)\n *\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginBase',[\n    'plugin/PluginConfig',\n    'plugin/PluginResult',\n    'plugin/PluginMessage',\n    'plugin/PluginNodeDescription',\n    'common/storage/constants',\n], function (PluginConfig, PluginResult, PluginMessage, PluginNodeDescription, STORAGE_CONSTANTS) {\n    'use strict';\n\n    /**\n     * Initializes a new instance of a plugin object, which should be a derived class.\n     *\n     * @constructor\n     */\n    var PluginBase = function () {\n        // set by initialize\n        this.logger = null;\n        this.blobClient = null;\n        this._currentConfig = null;\n\n        // set by configure\n        this.core = null;\n        this.project = null;\n        this.projectName = null;\n        this.branchName = null;\n        this.branchHash = null;\n        this.commitHash = null;\n        this.currentHash = null;\n        this.rootNode = null;\n        this.activeNode = null;\n        this.activeSelection = [];\n        this.META = null;\n\n        this.result = null;\n        this.isConfigured = false;\n        this.gmeConfig = null;\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods must be overridden by the derived classes\n\n    /**\n     * Main function for the plugin to execute. This will perform the execution.\n     * Notes:\n     * - do NOT use console.log use this.logger.[error,warning,info,debug] instead\n     * - do NOT put any user interaction logic UI, etc. inside this function\n     * - callback always have to be called even if error happened\n     *\n     * @param {function(string, plugin.PluginResult)} callback - the result callback\n     */\n    PluginBase.prototype.main = function (/*callback*/) {\n        throw new Error('implement this function in the derived class');\n    };\n\n    /**\n     * Readable name of this plugin that can contain spaces.\n     *\n     * @returns {string}\n     */\n    PluginBase.prototype.getName = function () {\n        throw new Error('implement this function in the derived class - getting type automatically is a bad idea,' +\n            'when the js scripts are minified names are useless.');\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods could be overridden by the derived classes\n\n    /**\n     * Current version of this plugin using semantic versioning.\n     * @returns {string}\n     */\n    PluginBase.prototype.getVersion = function () {\n        return '0.1.0';\n    };\n\n    /**\n     * A detailed description of this plugin and its purpose. It can be one or more sentences.\n     *\n     * @returns {string}\n     */\n    PluginBase.prototype.getDescription = function () {\n        return '';\n    };\n\n    /**\n     * Configuration structure with names, descriptions, minimum, maximum values, default values and\n     * type definitions.\n     *\n     * Example:\n     *\n     * [{\n         *    \"name\": \"logChildrenNames\",\n         *    \"displayName\": \"Log Children Names\",\n         *    \"description\": '',\n         *    \"value\": true, // this is the 'default config'\n         *    \"valueType\": \"boolean\",\n         *    \"readOnly\": false\n         * },{\n         *    \"name\": \"logLevel\",\n         *    \"displayName\": \"Logger level\",\n         *    \"description\": '',\n         *    \"value\": \"info\",\n         *    \"valueType\": \"string\",\n         *    \"valueItems\": [\n         *          \"debug\",\n         *          \"info\",\n         *          \"warn\",\n         *          \"error\"\n         *      ],\n         *    \"readOnly\": false\n         * },{\n         *    \"name\": \"maxChildrenToLog\",\n         *    \"displayName\": \"Maximum children to log\",\n         *    \"description\": 'Set this parameter to blabla',\n         *    \"value\": 4,\n         *    \"minValue\": 1,\n         *    \"valueType\": \"number\",\n         *    \"readOnly\": false\n         * }]\n     *\n     * @returns {object[]}\n     */\n    PluginBase.prototype.getConfigStructure = function () {\n        return [];\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods that can be used by the derived classes\n\n    /**\n     * Updates the current success flag with a new value.\n     *\n     * NewValue = OldValue && Value\n     *\n     * @param {boolean} value - apply this flag on current success value\n     * @param {string|null} message - optional detailed message\n     */\n    PluginBase.prototype.updateSuccess = function (value, message) {\n        var prevSuccess = this.result.getSuccess();\n        var newSuccessValue = prevSuccess && value;\n\n        this.result.setSuccess(newSuccessValue);\n        var msg = '';\n        if (message) {\n            msg = ' - ' + message;\n        }\n\n        this.logger.debug('Success was updated from ' + prevSuccess + ' to ' + newSuccessValue + msg);\n    };\n\n    /**\n     * WebGME can export the META types as path and this method updates the generated domain specific types with\n     * webgme node objects. These can be used to define the base class of new objects created through the webgme API.\n     *\n     * @param {object} generatedMETA\n     */\n    PluginBase.prototype.updateMETA = function (generatedMETA) {\n        var name;\n        for (name in this.META) {\n            if (this.META.hasOwnProperty(name)) {\n                generatedMETA[name] = this.META[name];\n            }\n        }\n\n        // TODO: check if names are not the same\n        // TODO: log if META is out of date\n    };\n\n    /**\n     * Checks if the given node is of the given meta-type.\n     * Usage: <tt>self.isMetaTypeOf(aNode, self.META['FCO']);</tt>\n     * @param node - Node to be checked for type.\n     * @param metaNode - Node object defining the meta type.\n     * @returns {boolean} - True if the given object was of the META type.\n     */\n    PluginBase.prototype.isMetaTypeOf = function (node, metaNode) {\n        var self = this;\n        while (node) {\n            if (self.core.getGuid(node) === self.core.getGuid(metaNode)) {\n                return true;\n            }\n            node = self.core.getBase(node);\n        }\n        return false;\n    };\n\n    /**\n     * Finds and returns the node object defining the meta type for the given node.\n     * @param node - Node to be checked for type.\n     * @returns {Object} - Node object defining the meta type of node.\n     */\n    PluginBase.prototype.getMetaType = function (node) {\n        var self = this,\n            name;\n        while (node) {\n            name = self.core.getAttribute(node, 'name');\n            if (self.META.hasOwnProperty(name) && self.core.getGuid(node) === self.core.getGuid(self.META[name])) {\n                break;\n            }\n            node = self.core.getBase(node);\n        }\n        return node;\n    };\n\n    /**\n     * Returns true if node is a direct instance of a meta-type node (or a meta-type node itself).\n     * @param node - Node to be checked.\n     * @returns {boolean}\n     */\n    PluginBase.prototype.baseIsMeta = function (node) {\n        var self = this,\n            baseName,\n            baseNode = self.core.getBase(node);\n        if (!baseNode) {\n            // FCO does not have a base node, by definition function returns true.\n            return true;\n        }\n        baseName = self.core.getAttribute(baseNode, 'name');\n        return self.META.hasOwnProperty(baseName) &&\n            self.core.getGuid(self.META[baseName]) === self.core.getGuid(baseNode);\n    };\n\n    /**\n     * Gets the current configuration of the plugin that was set by the user and plugin manager.\n     *\n     * @returns {object}\n     */\n    PluginBase.prototype.getCurrentConfig = function () {\n        return this._currentConfig;\n    };\n\n    /**\n     * Creates a new message for the user and adds it to the result.\n     *\n     * @param {object} node - webgme object which is related to the message\n     * @param {string} message - feedback to the user\n     * @param {string} severity - severity level of the message: 'debug', 'info' (default), 'warning', 'error'.\n     */\n    PluginBase.prototype.createMessage = function (node, message, severity) {\n        var severityLevel = severity || 'info';\n        //this occurence of the function will always handle a single node\n\n        var descriptor = new PluginNodeDescription({\n            name: node ? this.core.getAttribute(node, 'name') : '',\n            id: node ? this.core.getPath(node) : ''\n        });\n        var pluginMessage = new PluginMessage({\n            commitHash: this.currentHash,\n            activeNode: descriptor,\n            message: message,\n            severity: severityLevel\n        });\n\n        this.result.addMessage(pluginMessage);\n    };\n\n    /**\n     * Saves all current changes if there is any to a new commit.\n     * If the changes were started from a branch, then tries to fast forward the branch to the new commit.\n     * Note: Does NOT handle any merges at this point.\n     *\n     * @param {string|null} message - commit message\n     * @param callback\n     */\n    PluginBase.prototype.save = function (message, callback) {\n        var self = this,\n            persisted,\n            commitMessage = '[Plugin] ' + self.getName() + ' (v' + self.getVersion() + ') updated the model.';\n\n        commitMessage = message ? commitMessage + ' - ' + message : commitMessage;\n\n        self.logger.debug('Saving project');\n        persisted = self.core.persist(self.rootNode);\n        if (Object.keys(persisted.objects).length === 0) {\n            self.logger.warn('save invoked with no changes, will still proceed');\n        }\n        if (self.branch) {\n            self._commitWithClient(persisted, commitMessage, callback);\n        } else {\n            // Make commit w/o depending on a client.\n            self._makeCommit(persisted, commitMessage, callback);\n        }\n    };\n\n    PluginBase.prototype._commitWithClient = function (persisted, commitMessage, callback) {\n        var self = this,\n            forkName;\n        if (self.currentHash !== self.branch.getLocalHash()) {\n            // If the client has made local changes  since the plugin started - create a new branch.\n            forkName = self.forkName || self.branchName + '_' + (new Date()).getTime();\n            self.logger.warn('Client has made local change since the plugin started in \"' + self.branchName + '\". ' +\n                'Trying to create a new branch \"' + forkName + '\".');\n            self.branch = null; // Set the branch to null - from now on the plugin is detached from the client branch.\n            self.project.makeCommit(null,\n                [self.currentHash],\n                persisted.rootHash,\n                persisted.objects,\n                commitMessage,\n                function (err, commitResult) {\n                    var originalBranchName;\n                    if (err) {\n                        self.logger.error('project.makeCommit failed.');\n                        callback(err);\n                        return;\n                    }\n                    self.commitHash = commitResult.hash;\n                    self.project.setBranchHash(forkName, commitResult.hash, '',\n                        function (err, updateResult) {\n                            if (err) {\n                                self.logger.error('setBranchHash failed with error.');\n                                callback(err);\n                                return;\n                            }\n                            self.currentHash = commitResult.hash;\n                            if (updateResult.status === STORAGE_CONSTANTS.SYNCH) {\n                                self.logger.info('\"' + self.branchName + '\" was updated to the new commit.' +\n                                    '(Successive saves will try to save to this new branch.)');\n                                self.branchName = forkName;\n                                self.addCommitToResult(STORAGE_CONSTANTS.FORKED);\n\n                                callback(null, {status: STORAGE_CONSTANTS.FORKED, forkName: forkName});\n\n                            } else if (updateResult.status === STORAGE_CONSTANTS.FORKED) {\n                                originalBranchName = self.branchName;\n                                self.branchName = null;\n                                self.addCommitToResult(STORAGE_CONSTANTS.FORKED);\n                                callback('Plugin got forked from \"' + originalBranchName + '\". ' +\n                                    'And got forked from name \"' + forkName + '\" too.');\n                            }\n                        }\n                    );\n\n                }\n            );\n        } else {\n            var commitObject,\n                updateData;\n\n            commitObject = self.project.makeCommit(self.branch.name,\n                [self.currentHash],\n                persisted.rootHash,\n                persisted.objects,\n                commitMessage,\n                function (err, commmitResult) {\n                    if (err) {\n                        self.logger.error('project.makeCommit failed in _commitWithClient.');\n                        callback(err);\n                        return;\n                    }\n                    self.currentHash = commmitResult.hash;\n\n                    if (commmitResult.status === STORAGE_CONSTANTS.SYNCH) {\n                        self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\n\n                        self.addCommitToResult(STORAGE_CONSTANTS.SYNCH);\n\n                        callback(null, {status: STORAGE_CONSTANTS.SYNCH});\n                    } else if (commmitResult.status === STORAGE_CONSTANTS.FORKED) {\n                        self.logger.warn('Plugin and client are forked from \"' + self.branchName + '\". ');\n                        // Set the branch to null - from now on the plugin is detached from the client branch.\n                        self.branch = null;\n                        self._createFork(callback);\n                    } else {\n                        callback('makeCommit returned unexpected status, ' + commmitResult.status);\n                    }\n                }\n            );\n\n            // Locally update the client with the new data.\n            updateData = {\n                projectName: self.projectName,\n                branchName: self.branchName,\n                commitObject: commitObject,\n                coreObjects: persisted.objects\n            };\n\n            self.branch.localUpdateHandler(self.branch.getUpdateQueue(), updateData, function (aborted) {\n                if (aborted) {\n                    self.logger.warn('Updates were not loaded in client. Expect a fork..');\n                }\n            });\n        }\n    };\n\n    PluginBase.prototype._makeCommit = function (persisted, commitMessage, callback) {\n        var self = this;\n        self.project.makeCommit(null,\n            [self.currentHash],\n            persisted.rootHash,\n            persisted.objects,\n            commitMessage,\n            function (err, commitResult) {\n                if (err) {\n                    self.logger.error('project.makeCommit failed.');\n                    callback(err);\n                    return;\n                }\n                self.project.setBranchHash(self.branchName, commitResult.hash, self.currentHash,\n                    function (err, updateResult) {\n                        if (err) {\n                            self.logger.error('setBranchHash failed with error.');\n                            callback(err);\n                            return;\n                        }\n                        self.currentHash = commitResult.hash;\n                        if (updateResult.status === STORAGE_CONSTANTS.SYNCH) {\n                            self.logger.info('\"' + self.branchName + '\" was updated to the new commit.');\n\n                            self.addCommitToResult(STORAGE_CONSTANTS.SYNCH);\n\n                            callback(null, {status: STORAGE_CONSTANTS.SYNCH});\n                        } else if (updateResult.status === STORAGE_CONSTANTS.FORKED) {\n                            self._createFork(callback);\n                        } else {\n                            callback('setBranchHash returned unexpected status' + updateResult.status);\n                        }\n                    }\n                );\n            }\n        );\n    };\n\n    PluginBase.prototype._createFork = function (callback) {\n        // User can set self.forkName, but must make sure it is unique.\n        var self = this,\n            oldBranchName = self.branchName,\n            forkName = self.forkName || self.branchName + '_' + (new Date()).getTime();\n        self.logger.warn('Plugin got forked from \"' + self.branchName + '\". ' +\n            'Trying to create a new branch \"' + forkName + '\".');\n        self.project.createBranch(forkName, self.currentHash, function (err, forkResult) {\n            if (err) {\n                self.logger.error('createBranch failed with error.');\n                callback(err);\n                return;\n            }\n            if (forkResult.status === STORAGE_CONSTANTS.SYNCH) {\n                self.branchName = forkName;\n                self.logger.info('\"' + self.branchName + '\" was updated to the new commit.' +\n                    '(Successive saves will try to save to this new branch.)');\n                self.addCommitToResult(STORAGE_CONSTANTS.FORKED);\n\n                callback(null, {status: STORAGE_CONSTANTS.FORKED, forkName: forkName});\n\n            } else if (forkResult.status === STORAGE_CONSTANTS.FORKED) {\n                self.branchName = null;\n                self.addCommitToResult(STORAGE_CONSTANTS.FORKED);\n\n                callback('Plugin got forked from \"' + oldBranchName + '\". ' +\n                    'And got forked from \"' + forkName + '\" too.');\n            } else {\n                callback('createBranch returned unexpected status' + forkResult.status);\n            }\n        });\n    };\n\n    PluginBase.prototype.addCommitToResult = function (status) {\n        var newCommit = {\n            commitHash: this.currentHash,\n            branchName: this.branchName,\n            status: status\n        };\n        this.result.addCommit(newCommit);\n        this.logger.debug('newCommit added', newCommit);\n    };\n\n    //--------------------------------------------------------------------------------------------------------------\n    //---------- Methods that are used by the Plugin Manager. Derived classes should not use these methods\n\n    /**\n     * Initializes the plugin with objects that can be reused within the same plugin instance.\n     *\n     * @param {logManager} logger - logging capability to console (or file) based on PluginManager configuration\n     * @param {blob.BlobClient} blobClient - virtual file system where files can be generated then saved as a zip file.\n     * @param {object} gmeConfig - global configuration for webGME.\n     */\n    PluginBase.prototype.initialize = function (logger, blobClient, gmeConfig) {\n        if (logger) {\n            this.logger = logger;\n        } else {\n            this.logger = console;\n        }\n        if (!gmeConfig) {\n            // TODO: Remove this check at some point\n            throw new Error('gmeConfig was not provided to Plugin.initialize!');\n        }\n        this.blobClient = blobClient;\n        this.gmeConfig = gmeConfig;\n\n        this._currentConfig = null;\n        // initialize default configuration\n        this.setCurrentConfig(this.getDefaultConfig());\n\n        this.isConfigured = false;\n    };\n\n    /**\n     * Configures this instance of the plugin for a specific execution. This function is called before the main by\n     * the PluginManager.\n     * Initializes the result with a new object.\n     *\n     * @param {PluginContext} config - specific context: project, branch, core, active object and active selection.\n     */\n    PluginBase.prototype.configure = function (config) {\n        this.core = config.core;\n        this.project = config.project;\n        this.branch = config.branch;  // This is only for client side.\n        this.projectName = config.projectName;\n        this.branchName = config.branchName;\n        this.branchHash = config.branchName ? config.commitHash : null;\n\n        this.commitHash = config.commitHash;\n        this.currentHash = config.commitHash;\n\n        this.rootNode = config.rootNode;\n        this.activeNode = config.activeNode;\n        this.activeSelection = config.activeSelection;\n        this.META = config.META;\n\n        this.result = new PluginResult();\n\n        this.addCommitToResult(STORAGE_CONSTANTS.SYNCH);\n\n        this.isConfigured = true;\n    };\n\n    /**\n     * Gets the default configuration based on the configuration structure for this plugin.\n     *\n     * @returns {plugin.PluginConfig}\n     */\n    PluginBase.prototype.getDefaultConfig = function () {\n        var configStructure = this.getConfigStructure();\n\n        var defaultConfig = new PluginConfig();\n\n        for (var i = 0; i < configStructure.length; i += 1) {\n            defaultConfig[configStructure[i].name] = configStructure[i].value;\n        }\n\n        return defaultConfig;\n    };\n\n    /**\n     * Sets the current configuration of the plugin.\n     *\n     * @param {object} newConfig - this is the actual configuration and NOT the configuration structure.\n     */\n    PluginBase.prototype.setCurrentConfig = function (newConfig) {\n        this._currentConfig = newConfig;\n    };\n\n    return PluginBase;\n});\n\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\ndefine('plugin/PluginContext',[], function () {\n    'use strict';\n\n    /**\n     * Initializes a new instance of PluginContext. This context is set through PluginBase.configure method for a given\n     * plugin instance and execution.\n     *\n     * @constructor\n     */\n    var PluginContext = function () {\n\n        // TODO: something like this\n//        context.project = project;\n//        context.projectName = config.project;\n//        context.core = new Core(context.project);\n//        context.commitHash = config.commit;\n//        context.selected = config.selected;\n//        context.storage = null;\n\n    };\n\n\n    return PluginContext;\n});\n",
    "/*globals define*/\n/*jshint browser: true, node:true*/\n\n/**\n * @author lattmann / https://github.com/lattmann\n */\n\n// TODO: Use PluginManagerConfiguration\n// TODO: Load ActiveSelection objects and pass it correctly\n// TODO: Add more statistics to the result object\n// TODO: Result object rename name -> pluginName, time -> finishTime)\n// TODO: Make this class testable\n// TODO: PluginManager should download the plugins\n\n\ndefine('plugin/PluginManagerBase',['plugin/PluginBase', 'plugin/PluginContext'], function (PluginBase, PluginContext) {\n'use strict';\n\n        var PluginManagerBase = function (storage, Core, logger, plugins, gmeConfig) {\n            this.gmeConfig = gmeConfig; // global configuration of webgme\n            this.logger = logger.fork('PluginManager');\n            this._Core = Core;       // webgme core class is used to operate on objects\n            this._storage = storage; // webgme storage (project)\n            this._plugins = plugins; // key value pair of pluginName: pluginType - plugins are already loaded/downloaded\n            this._pluginConfigs = {}; // keeps track of the current configuration for each plugins by name\n\n            if (!this.gmeConfig) {\n                // TODO: this error check is temporary\n                throw new Error('PluginManagerBase takes gmeConfig as parameter!');\n            }\n\n            var pluginNames = Object.keys(this._plugins);\n            for (var i = 0; i < pluginNames.length; i += 1) {\n                var p = new this._plugins[pluginNames[i]]();\n                this._pluginConfigs[pluginNames[i]] = p.getDefaultConfig();\n            }\n        };\n\n        PluginManagerBase.prototype.initialize = function (managerConfiguration, configCallback, callbackContext) {\n            var self = this,\n                pluginName,\n                plugins = this._plugins;\n\n            //#1: PluginManagerBase should load the plugins\n\n            //#2: PluginManagerBase iterates through each plugin and collects the config data\n            var pluginConfigs = {};\n\n            for (pluginName in plugins) {\n                if (plugins.hasOwnProperty(pluginName)) {\n                    var plugin = new plugins[pluginName]();\n                    pluginConfigs[pluginName] = plugin.getConfigStructure();\n                }\n            }\n\n            if (configCallback) {\n                configCallback.call(callbackContext, pluginConfigs, function (updatedPluginConfig) {\n                    for (pluginName in updatedPluginConfig) {\n                        if (updatedPluginConfig.hasOwnProperty(pluginName)) {\n                            //save it back to the plugin\n                            self._pluginConfigs[pluginName] = updatedPluginConfig[pluginName];\n                        }\n                    }\n                });\n            }\n        };\n\n        /**\n         * Gets a new instance of a plugin by name.\n         *\n         * @param {string} name\n         * @returns {plugin.PluginBase}\n         */\n        PluginManagerBase.prototype.getPluginByName = function (name) {\n            return this._plugins[name];\n        };\n\n        PluginManagerBase.prototype.loadMetaNodes = function (pluginContext, callback) {\n            var self = this;\n\n            this.logger.debug('Loading meta nodes');\n\n            // get meta members\n            var metaIDs = pluginContext.core.getMemberPaths(pluginContext.rootNode, 'MetaAspectSet');\n\n            var len = metaIDs.length;\n\n            var nodeObjs = [];\n\n\n            var allObjectsLoadedHandler = function () {\n                var len2 = nodeObjs.length;\n\n                var nameObjMap = {};\n\n                while (len2--) {\n                    var nodeObj = nodeObjs[len2];\n\n                    nameObjMap[pluginContext.core.getAttribute(nodeObj, 'name')] = nodeObj;\n                }\n\n                pluginContext.META = nameObjMap;\n\n                self.logger.debug('Meta nodes are loaded');\n\n                callback(null, pluginContext);\n            };\n\n            var loadedMetaObjectHandler = function (err, nodeObj) {\n                nodeObjs.push(nodeObj);\n\n                if (nodeObjs.length === metaIDs.length) {\n                    allObjectsLoadedHandler();\n                }\n            };\n\n            while (len--) {\n                pluginContext.core.loadByPath(pluginContext.rootNode, metaIDs[len], loadedMetaObjectHandler);\n            }\n        };\n\n        /**\n         *\n         * @param {plugin.PluginManagerConfiguration} managerConfiguration\n         * @param {function} callback\n         */\n        PluginManagerBase.prototype.getPluginContext = function (managerConfiguration, callback) {\n            var self = this,\n                pluginContext = new PluginContext();\n\n            // TODO: check if callback is a function\n            // based on the string values get the node objects\n            // 1) Open project\n            // 2) Load branch OR commit hash\n            // 3) Load rootNode\n            // 4) Load active object\n            // 5) Load active selection\n            // 6) Update context\n            // 7) return\n\n            pluginContext.project = this._storage;\n            pluginContext.projectName = managerConfiguration.project;\n            pluginContext.branchName = managerConfiguration.branchName;\n            pluginContext.branch = pluginContext.project.getBranch(pluginContext.branchName, true);\n            pluginContext.core = new self._Core(pluginContext.project, {\n                globConf: self.gmeConfig,\n                logger: self.logger.fork('core') //TODO: This logger should probably fork from the plugin logger\n            });\n            pluginContext.commitHash = managerConfiguration.commit;\n            pluginContext.activeNode = null;    // active object\n            pluginContext.activeSelection = []; // selected objects\n\n\n            // add activeSelection\n            function loadActiveSelectionAndMetaNodes() {\n                var remaining = managerConfiguration.activeSelection.length,\n                    i;\n                function loadNodeByNode(selectedNodePath) {\n                    pluginContext.core.loadByPath(pluginContext.rootNode, selectedNodePath,\n                        function (err, selectedNode) {\n                                remaining -= 1;\n\n                                if (err) {\n                                self.logger.warn('unable to load active selection: ' + selectedNodePath);\n                                } else {\n                                pluginContext.activeSelection.push(selectedNode);\n                                }\n\n                                if (remaining === 0) {\n                                    // all nodes from active selection are loaded\n                                    self.loadMetaNodes(pluginContext, callback);\n                                }\n                        }\n                    );\n                }\n                if (managerConfiguration.activeSelection.length === 0) {\n                    self.loadMetaNodes(pluginContext, callback);\n                } else {\n                    for (i = 0; i < managerConfiguration.activeSelection.length; i += 1) {\n                        loadNodeByNode(managerConfiguration.activeSelection[i]);\n                    }\n                    }\n                }\n\n            // add activeNode\n            function loadCommitHashAndRun(commitHash) {\n                self.logger.info('Loading commit ' + commitHash);\n                pluginContext.project.getCommits(commitHash, 1, function (err, commitObjects) {\n                    var commitObj;\n                    if (err || commitObjects.length !== 1) {\n                        if (err) {\n                            callback(err, pluginContext);\n                        } else {\n                            self.logger.error('commitObjects', commitObjects);\n                            callback('getCommits did not return with one commit', pluginContext);\n                        }\n                        return;\n                    }\n\n                    commitObj = commitObjects[0];\n\n                    if (typeof commitObj === 'undefined' || commitObj === null) {\n                        callback('cannot find commit', pluginContext);\n                        return;\n                    }\n\n                    if (managerConfiguration.rootHash && commitObj.root !== managerConfiguration.rootHash) {\n                        // This is a sanity check for the client state handling..\n                        self.logger.error('Root hash for commit-object, is not the same as passed from the client.' +\n                        'commitHash, rootHash, given rootHash:',\n                            commitHash, commitObj.root, managerConfiguration.rootHash);\n                    }\n\n                    pluginContext.core.loadRoot(commitObj.root, function (err, rootNode) {\n                        if (err) {\n                            callback('unable to load root', pluginContext);\n                            return;\n                        }\n\n                        pluginContext.rootNode = rootNode;\n                        if (typeof managerConfiguration.activeNode === 'string') {\n                            pluginContext.core.loadByPath(pluginContext.rootNode, managerConfiguration.activeNode,\n                                function (err, activeNode) {\n                                if (err) {\n                                        callback('unable to load selected object', pluginContext);\n                                    return;\n                                }\n\n                                pluginContext.activeNode = activeNode;\n                                loadActiveSelectionAndMetaNodes();\n                                }\n                            );\n                        } else {\n                            pluginContext.activeNode = null;\n                            loadActiveSelectionAndMetaNodes();\n                        }\n                    });\n                });\n            }\n\n            // load commit hash and run based on branch name or commit hash\n            if (managerConfiguration.branchName) {\n                pluginContext.project.getBranches(function (err, branchNames) {\n                    //self.logger.debug(branchNames);\n\n                        pluginContext.commitHash = branchNames[managerConfiguration.branchName] || pluginContext.commitHash;\n                        pluginContext.branchName = managerConfiguration.branchName;\n                        loadCommitHashAndRun(pluginContext.commitHash);\n                });\n            } else {\n                loadCommitHashAndRun(pluginContext.commitHash);\n            }\n\n        };\n\n        PluginManagerBase.prototype.executePlugin = function (name, managerConfiguration, callback) {\n            // TODO: check if name is a string\n            // TODO: check if managerConfiguration is an instance of PluginManagerConfiguration\n            // TODO: check if callback is a function\n            var self = this,\n                mainCallbackCalls = 0,\n                multiCallbackHandled = false;\n\n            var PluginClass = this.getPluginByName(name);\n\n            var plugin = new PluginClass();\n\n            var pluginLogger = this.logger.fork('gme:plugin:' + name, true);\n\n            plugin.initialize(pluginLogger, managerConfiguration.blobClient, self.gmeConfig);\n\n            plugin.setCurrentConfig(this._pluginConfigs[name]);\n            for (var key in managerConfiguration.pluginConfig) {\n                if (managerConfiguration.pluginConfig.hasOwnProperty(key) &&\n                    plugin._currentConfig.hasOwnProperty(key)) {\n\n                    plugin._currentConfig[key] = managerConfiguration.pluginConfig[key];\n                }\n            }\n            self.getPluginContext(managerConfiguration, function (err, pluginContext) {\n                if (err) {\n                    // TODO: this has to return with an empty PluginResult object and NOT with null.\n                    callback(err, null);\n                    return;\n\n                }\n\n                plugin.configure(pluginContext);\n\n                var startTime = (new Date()).toISOString();\n\n                plugin.main(function (err, result) {\n                    var stackTrace;\n                    mainCallbackCalls += 1;\n                    // set common information (meta info) about the plugin and measured execution times\n                    result.setFinishTime((new Date()).toISOString());\n                    result.setStartTime(startTime);\n\n                    result.setPluginName(plugin.getName());\n\n                    if (mainCallbackCalls > 1) {\n                        stackTrace = new Error().stack;\n                        self.logger.error('The main callback is being called more than once!', {metadata: stackTrace});\n                        result.setError('The main callback is being called more than once!');\n                        if (multiCallbackHandled === true) {\n                            plugin.createMessage(null, stackTrace);\n                            return;\n                        }\n                        multiCallbackHandled = true;\n                        result.setSuccess(false);\n                        plugin.createMessage(null, 'The main callback is being called more than once.');\n                        plugin.createMessage(null, stackTrace);\n                        callback('The main callback is being called more than once!', result);\n                    } else {\n                        result.setError(err);\n                        callback(err, result);\n                    }\n                });\n\n            });\n\n        };\n\n\n        return PluginManagerBase;\n    });\n",
    "define('js/Dialogs/PluginConfig/PluginConfigDialog',[], function () {\n   return;\n});\n\n",
    "/*globals define, WebGMEGlobal, requirejs*/\n/*jshint browser: true*/\n\n/**\n * @author rkereskenyi / https://github.com/rkereskenyi\n * @author lattmann / https://github.com/lattmann\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('js/Utils/InterpreterManager',[\n    'common/core/core',\n    'plugin/PluginManagerBase',\n    'plugin/PluginResult',\n    'blob/BlobClient',\n    'js/Dialogs/PluginConfig/PluginConfigDialog',\n    'js/logger'\n], function (Core, PluginManagerBase, PluginResult, BlobClient, PluginConfigDialog, Logger) {\n\n    'use strict';\n\n    var InterpreterManager = function (client, gmeConfig) {\n        this._client = client;\n        //this._manager = new PluginManagerBase();\n        this.gmeConfig = gmeConfig;\n        this._savedConfigs = {};\n        this.logger = Logger.create('gme:InterpreterManager', gmeConfig.client.log);\n        this.logger.debug('InterpreterManager ctor');\n    };\n\n    var getPlugin = function (name, callback) {\n        if (WebGMEGlobal && WebGMEGlobal.plugins && WebGMEGlobal.plugins.hasOwnProperty(name)) {\n            callback(null, WebGMEGlobal.plugins[name]);\n        } else {\n            requirejs(['/plugin/' + name + '/' + name + '/' + name],\n                function (InterpreterClass) {\n                    callback(null, InterpreterClass);\n                },\n                function (err) {\n                    callback(err, null);\n                }\n            );\n        }\n    };\n\n    /**\n     *\n     * @param {string} name - name of plugin to be executed.\n     * @param {object} silentPluginCfg - if falsy dialog window will be shown.\n     * @param {object.string} silentPluginCfg.activeNode - Path to activeNode.\n     * @param {object.Array.<string>} silentPluginCfg.activeSelection - Paths to nodes in activeSelection.\n     * @param {object.boolean} silentPluginCfg.runOnServer - Whether to run the plugin on the server or not.\n     * @param {object.object} silentPluginCfg.pluginConfig - Plugin specific options.\n     * @param callback\n     */\n    InterpreterManager.prototype.run = function (name, silentPluginCfg, callback) {\n        var self = this;\n        getPlugin(name, function (err, plugin) {\n            self.logger.debug('Getting getPlugin in run.');\n            if (!err && plugin) {\n                var plugins = {},\n                    runWithConfiguration;\n                plugins[name] = plugin;\n                var pluginManager = new PluginManagerBase(self._client.getProjectObject(), Core, self.logger, plugins,\n                    self.gmeConfig);\n                pluginManager.initialize(null, function (pluginConfigs, configSaveCallback) {\n                    //#1: display config to user\n                    var noServerExecution = self.gmeConfig.plugin.allowServerExecution === false,\n                        hackedConfig = {\n                            'Global Options': [\n                                {\n                                    name: 'runOnServer',\n                                    displayName: 'Execute on Server',\n                                    description: noServerExecution ? 'Server side execution is disabled.' : '',\n                                    value: false, // this is the 'default config'\n                                    valueType: 'boolean',\n                                    readOnly: noServerExecution\n                                }\n                            ]\n                        },\n                        i, j, d, len;\n\n                    for (i in pluginConfigs) {\n                        if (pluginConfigs.hasOwnProperty(i)) {\n                            hackedConfig[i] = pluginConfigs[i];\n\n                            // retrieve user settings from previous run\n                            if (self._savedConfigs.hasOwnProperty(i)) {\n                                var iConfig = self._savedConfigs[i];\n                                len = hackedConfig[i].length;\n\n                                while (len--) {\n                                    if (iConfig.hasOwnProperty(hackedConfig[i][len].name)) {\n                                        hackedConfig[i][len].value = iConfig[hackedConfig[i][len].name];\n                                    }\n                                }\n\n                            }\n                        }\n                    }\n\n                    runWithConfiguration = function (updatedConfig) {\n                        //when Save&Run is clicked in the dialog (or silentPluginCfg was passed)\n                        var globalconfig = updatedConfig['Global Options'],\n                            activeNode,\n                            activeSelection;\n                        delete updatedConfig['Global Options'];\n\n                        activeNode = silentPluginCfg.activeNode;\n                        if (!activeNode && WebGMEGlobal && WebGMEGlobal.State) {\n                            activeNode = WebGMEGlobal.State.getActiveObject();\n                        }\n                        activeSelection = silentPluginCfg.activeSelection;\n                        if (!activeSelection && WebGMEGlobal && WebGMEGlobal.State) {\n                            activeSelection = WebGMEGlobal.State.getActiveSelection();\n                        }\n                        // save config from user\n                        for (i in updatedConfig) {\n                            self._savedConfigs[i] = updatedConfig[i];\n                        }\n\n                        //#2: save it back and run the plugin\n                        if (configSaveCallback) {\n                            configSaveCallback(updatedConfig);\n\n                            // TODO: If global config says try to merge branch then we\n                            // TODO: should pass the name of the branch.\n                            var config = {\n                                project: self._client.getActiveProjectId(),\n                                token: '',\n                                activeNode: activeNode, // active object in the editor\n                                activeSelection: activeSelection || [],\n                                commit: self._client.getActiveCommitHash(), //#668b3babcdf2ddcd7ba38b51acb62d63da859d90,\n                                // This will get loaded too which will provide a sanity check on the client state.\n                                rootHash: self._client.getActiveRootHash(),\n                                branchName: self._client.getActiveBranchName()\n                            };\n\n                            if (globalconfig.runOnServer === true || silentPluginCfg.runOnServer === true) {\n                                var context = {\n                                    managerConfig: config,\n                                    pluginConfig: updatedConfig[name]\n                                };\n                                self._client.runServerPlugin(name, context, function (err, result) {\n                                    if (err) {\n                                        self.logger.error(err);\n                                        callback(new PluginResult()); //TODO return proper error result\n                                    } else {\n                                        var resultObject = new PluginResult(result);\n                                        callback(resultObject);\n                                    }\n                                });\n                            } else {\n                                config.blobClient = new BlobClient();\n\n                                pluginManager.executePlugin(name, config, function (err, result) {\n                                    if (err) {\n                                        self.logger.error(err);\n                                    }\n                                    callback(result);\n                                });\n                            }\n                        }\n                    };\n\n                    if (silentPluginCfg) {\n                        var updatedConfig = {};\n                        for (i in hackedConfig) {\n                            updatedConfig[i] = {};\n                            len = hackedConfig[i].length;\n                            while (len--) {\n                                updatedConfig[i][hackedConfig[i][len].name] = hackedConfig[i][len].value;\n                            }\n\n                            if (silentPluginCfg && silentPluginCfg.pluginConfig) {\n                                for (j in silentPluginCfg.pluginConfig) {\n                                    updatedConfig[i][j] = silentPluginCfg.pluginConfig[j];\n                                }\n                            }\n                        }\n                        runWithConfiguration(updatedConfig);\n                    } else {\n                        d = new PluginConfigDialog();\n                        silentPluginCfg = {};\n                        d.show(hackedConfig, runWithConfiguration);\n                    }\n                });\n            } else {\n                self.logger.error(err);\n                self.logger.error('unable to load plugin');\n                callback(null); //TODO proper result\n            }\n        });\n    };\n\n    //TODO: Somehow it would feel more right if we do run in async mode, but if not then we should provide getState and\n    //TODO: getResult synchronous functions as well.\n\n    return InterpreterManager;\n});\n\n",
    "/*globals define, alert*/\n/*jshint browser: true*/\n/**\n * @author pmeijer / https://github.com/pmeijer\n */\nvar CREATE_BRANCH = false;\n//PROJECT_NAME = 'IBug',\n//BRANCH_NAME = 'master',\n//NEW_BRANCH_HASH = '#d2d00cdd50a1ca144666a52a471af59d280ac751';\n\ndefine('teststorage/teststorage',[\n    'js/logger',\n    'common/storage/browserstorage',\n    'common/core/core',\n    'common/storage/constants'\n], function (Logger, Storage, Core, CONSTANTS) {\n    'use strict';\n    function Client(gmeConfig, projectName, branchName) {\n        var logger = Logger.create('gme:client', gmeConfig.client.log),\n            storage = Storage.getStorage(logger, gmeConfig),\n            currRootNode,\n            currCommitObject,\n            intervalId,\n            core,\n            PROJECT_NAME = projectName,\n            BRANCH_NAME = branchName;\n\n        logger.debug('ctor');\n        function loadChildrenAndSetAttribute(rootNode, commitObject) {\n            core.loadChildren(rootNode, function (err, children) {\n                if (err) {\n                    throw new Error(err);\n                }\n                logger.debug('children loaded', children);\n                //children.map(function (child) {\n                var newPos;\n                logger.debug('child name', core.getAttribute(children[0], 'name'));\n                //if (core.getAttribute(children[0], 'name') === 'newName') {\n                newPos = {x: 70 + getRandomInt(0, 100), y: 70 + getRandomInt(0, 100)};\n                core.setRegistry(children[0], 'position', newPos);\n                logger.debug('setting new position', newPos);\n                //}\n                //});\n                currRootNode = rootNode;\n                core.persist(rootNode, function (err, persisted) {\n                    if (err) {\n                        throw new Error(err);\n                    }\n                    logger.debug('cb persist data', persisted);\n                    currCommitObject = storage.makeCommit(PROJECT_NAME, BRANCH_NAME,\n                        [commitObject._id],\n                        persisted.rootHash,\n                        persisted.objects,\n                        'First commit from new storage'\n                    );\n\n                });\n                //logger.debug('persistData', persistData);\n                //core.loadChildren(rootNode, function (err, children) {\n                //    if (err) {\n                //        throw new Error(err);\n                //    }\n                //    logger.debug('children loaded again (should come from cache)', children);\n                //});\n            });\n        }\n\n        storage.open(function (status) {\n            logger.debug('storage is open');\n            if (status === CONSTANTS.CONNECTED) {\n                storage.getProjectNames({}, function (err, projectNames) {\n                    if (err) {\n                        throw new Error(err);\n                    }\n                    if (projectNames.indexOf(projectName) < 0) {\n                        throw new Error('Project does not exist');\n                    }\n                    logger.debug(projectNames);\n                    storage.watchProject(PROJECT_NAME, function (_ws, data) {\n                        logger.debug('watchProject event', data);\n                    });\n                    storage.openProject(PROJECT_NAME, function (err, project, branches) {\n                        if (err) {\n                            throw new Error(err);\n                        }\n                        var updateHandler = function (newCommitData) {\n                            logger.debug('updateHandler invoked', newCommitData);\n                            logger.debug('would call loadNodes...');\n                            currCommitObject = newCommitData.commitObject;\n                            core.loadRoot(newCommitData.commitObject.root, function (err, rootNode) {\n                                if (err) {\n                                    throw new Error(err);\n                                }\n                                logger.debug('rootNode loaded', rootNode);\n                                currRootNode = rootNode;\n                                core.loadChildren(rootNode, function (err, children) {\n                                    if (err) {\n                                        throw new Error(err);\n                                    }\n                                    logger.debug('children loaded', children);\n                                    children.map(function (child) {\n                                        logger.debug('child name', core.getAttribute(child, 'name'));\n                                        if (core.getAttribute(child, 'name') === 'newName') {\n                                            logger.debug('Got new position', core.getRegistry(child, 'position'));\n                                        }\n                                    });\n                                });\n                            });\n                        };\n                        var commitHandler = function (commitQueue, result, callback) {\n                            logger.debug('commitHandler', result);\n                            if (result.status === CONSTANTS.SYNCH) {\n                                callback(true); // All is fine, continue with the commitQueue..\n                            } else if (result.status === CONSTANTS.FORKED) {\n                                logger.debug('You got forked, queued commits', commitQueue);\n                                callback(false);\n                            } else {\n                                throw new Error('Unexpected result', result);\n                            }\n                        };\n                        logger.debug('openProject project', project);\n                        logger.debug('openProject returned branches', branches);\n                        storage.openBranch(PROJECT_NAME, BRANCH_NAME, updateHandler, commitHandler,\n                            function (err, latestCommit) {\n                                if (err) {\n                                    throw new Error(err);\n                                }\n                                logger.debug('latestCommit', latestCommit);\n                                currCommitObject = latestCommit.commitObject;\n                                core = new Core(project, {\n                                    globConf: gmeConfig,\n                                    logger: logger.fork('core')\n                                });\n                                logger.debug('core instantiated');\n                                core.loadRoot(latestCommit.commitObject.root, function (err, rootNode) {\n                                    if (err) {\n                                        throw new Error(err);\n                                    }\n                                    logger.debug('rootNode loaded', rootNode);\n                                    loadChildrenAndSetAttribute(rootNode, latestCommit.commitObject);\n                                });\n                            }\n                        );\n                        //storage.deleteBranch(PROJECT_NAME, 'b535', branches['b535'], function () {\n                        //    logger.debug('branch deleted', arguments);\n                        //});\n                    });\n                    if (CREATE_BRANCH) {\n                        storage.getBranches(PROJECT_NAME, {}, function (err, data) {\n                            if (err) {\n                                throw new Error(err);\n                            }\n                            logger.debug('getBranches return', data);\n                        });\n                        var newBranchName = 'br' + getRandomInt(2, 9999);\n                        logger.debug('will create', newBranchName);\n                        setTimeout(function () {\n                            storage.createBranch(PROJECT_NAME,\n                                newBranchName,\n                                NEW_BRANCH_HASH,\n                                function (err) {\n                                    if (err) {\n                                        throw new Error(err);\n                                    }\n                                    storage.getBranches(PROJECT_NAME, {}, function (err, data) {\n                                        if (err) {\n                                            throw new Error(err);\n                                        }\n                                        logger.debug('getBranches after create returned', data);\n                                    });\n                                });\n                        }, 2000);\n                    }\n                });\n            } else if (status === CONSTANTS.RECONNECTED) {\n                logger.debug('Reconnected!');\n                clearInterval(intervalId);\n            } else if (status === CONSTANTS.DISCONNECTED) {\n                logger.debug('Got disconnect, waiting for reconnect...');\n                intervalId = setInterval(function () {\n                    loadChildrenAndSetAttribute(currRootNode, currCommitObject);\n                }, 2000);\n            } else if (status === CONSTANTS.ERROR) {\n                throw new Error('Could not connect');\n            }\n        });\n\n        function getRandomInt(min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        }\n    }\n\n    return Client;\n});\n",
    "/*globals define, document, console, window, GME, docReady, setTimeout*/\n/*jshint browser:true, evil:true*/\n\n/**\n * @author kecso / https://github.com/kecso\n * @author lattmann / https://github.com/lattmann\n * @author nabana / https://github.com/nabana\n * @author ksmyth / https://github.com/ksmyth\n * @author pmeijer / https://github.com/pmeijer\n */\n\ndefine('webgme.classes', [\n    'client/js/client',\n    'blob/BlobClient',\n    'executor/ExecutorClient',\n    'js/Utils/InterpreterManager',\n    'common/core/core',\n    'common/storage/browserstorage',\n    'js/logger',\n    'lib/superagent/superagent-1.2.0',\n    'teststorage/teststorage'\n], function (Client,\n             BlobClient,\n             ExecutorClient,\n             InterpreterManager,\n             Core,\n             Storage,\n             Logger,\n             superagent,\n             TestStorage) {\n\n    'use strict';\n    // Setting global classes\n\n    GME.classes.Client = Client;\n    GME.classes.BlobClient = BlobClient;\n    GME.classes.ExecutorClient = ExecutorClient;\n    GME.classes.InterpreterManager = InterpreterManager;\n    GME.classes.Core = Core;\n    GME.classes.Storage = Storage;\n    GME.classes.Logger = Logger;\n    GME.classes.TestStorage = TestStorage;\n\n    // Exposing built in libraries\n    GME.utils.superagent = superagent;\n\n    // Pure JavaScript equivalent to jQuery's $.ready() from https://github.com/jfriend00/docReady\n\n    (function (funcName, baseObj) {\n        // The public function name defaults to window.docReady\n        // but you can pass in your own object and own function name and those will be used\n        // if you want to put them in a different namespace\n        funcName = funcName || 'docReady';\n        baseObj = baseObj || window;\n        var readyList = [];\n        var readyFired = false;\n        var readyEventHandlersInstalled = false;\n\n        // call this when the document is ready\n        // this function protects itself against being called more than once\n        function ready() {\n            if (!readyFired) {\n                // this must be set to true before we start calling callbacks\n                readyFired = true;\n                for (var i = 0; i < readyList.length; i++) {\n                    // if a callback here happens to add new ready handlers,\n                    // the docReady() function will see that it already fired\n                    // and will schedule the callback to run right after\n                    // this event loop finishes so all handlers will still execute\n                    // in order and no new ones will be added to the readyList\n                    // while we are processing the list\n                    readyList[i].fn.call(window, readyList[i].ctx);\n                }\n                // allow any closures held by these functions to free\n                readyList = [];\n            }\n        }\n\n        function readyStateChange() {\n            if (document.readyState === 'complete') {\n                ready();\n            }\n        }\n\n        // This is the one public interface\n        // docReady(fn, context);\n        // the context argument is optional - if present, it will be passed\n        // as an argument to the callback\n        baseObj[funcName] = function (callback, context) {\n            // if ready has already fired, then just schedule the callback\n            // to fire asynchronously, but right away\n            if (readyFired) {\n                setTimeout(function () {\n                    callback(context);\n                }, 1);\n                return;\n            } else {\n                // add the function and context to the list\n                readyList.push({fn: callback, ctx: context});\n            }\n            // if document already ready to go, schedule the ready function to run\n            if (document.readyState === 'complete') {\n                setTimeout(ready, 1);\n            } else if (!readyEventHandlersInstalled) {\n                // otherwise if we don't have event handlers installed, install them\n                if (document.addEventListener) {\n                    // first choice is DOMContentLoaded event\n                    document.addEventListener('DOMContentLoaded', ready, false);\n                    // backup is window load event\n                    window.addEventListener('load', ready, false);\n                } else {\n                    // must be IE\n                    document.attachEvent('onreadystatechange', readyStateChange);\n                    window.attachEvent('onload', ready);\n                }\n                readyEventHandlersInstalled = true;\n            }\n        };\n    })('docReady', window);\n\n    // See if there is handler attached to body tag when ready\n\n    var evalOnGmeInit = function () {\n        if (document.body.getAttribute('on-gme-init')) {\n            eval(document.body.getAttribute('on-gme-init'));\n        } else {\n            console.warn('To use GME, define a javascript function and set the body ' +\n            'element\\'s on-gme-init property.');\n        }\n    };\n\n    // wait for document.readyState !== 'loading' and getGmeConfig\n    var stillLoading = 2;\n    var somethingFinishedLoading = function () {\n        if (--stillLoading === 0) {\n            evalOnGmeInit();\n        }\n    };\n\n    if (document.readyState === 'loading') {\n        docReady(function () {\n            somethingFinishedLoading();\n        });\n    } else {\n        somethingFinishedLoading();\n    }\n\n\n    (function getGmeConfig() {\n        var http = new XMLHttpRequest(),\n            configUrl = window.location.origin + '/gmeConfig.json';\n        http.onreadystatechange = function () {\n            if (http.readyState === 4 && http.status === 200) {\n                GME.gmeConfig = JSON.parse(http.responseText);\n                somethingFinishedLoading();\n            } else if (http.readyState === 4 && http.status !== 200) {\n                console.warn('Could not load gmeConfig at', configUrl);\n                somethingFinishedLoading();\n            }\n        };\n        http.open('GET', configUrl, true);\n        http.send();\n    })();\n});\n\n"
  ]
}